--- public/minekhan/_mksrc10.html	2025-03-26 21:44:58.800840225 +0000
+++ public/minekhan/beta/allupdate/_mksrc10test.html	2025-03-26 21:46:19.844781283 +0000
@@ -1,7 +1,8 @@
 <!DOCTYPE html>
 <html lang="en-us">
+<script>alert('this version is glitchy because many thing changed to make it work (including block states, entities)\nworlds from the other versions may be corrupted when loaded in this version')</script>
 <pre id="topCredits" class='hidden'>
-@MineKhan-thingmaker version Beta 1.1.2
+@MineKhan-thingmaker version Beta 1.1.2.test-allupdate
 
 If you make a spin-off/fork of this, please keep the current credits and don't change them.
 
@@ -2151,7 +2152,7 @@
 
 const preVersion = false //preview version
 function MineKhan() {
-	// The math function things are in world.js
+	const { cos, sin, round, floor, ceil, min, max, abs, sqrt, atan, atan2, tan } = Math;
 	
   let tickSpeed = 20
   let tickTime = 1000/tickSpeed
@@ -2265,7 +2266,7 @@
     }
     return textures
   }
-  const semiTransTextures = []
+  const semiTransTextures = []//todo n
   window.semiTransTextures = semiTransTextures
 /*
 Each value in textures is a string, function, or array
@@ -2273,7 +2274,7 @@
 functions set the texture dynamically
 arrays are texture that will be connected, useful for shapes used for different blocks that all have multiple textures
 */
-	const textures = {
+	let textures = {//todo n: move to world.js
 		grassTop: n => {
       const pix = getPixels("0g0glþÇHĪcWJPWðoH÷-ZéŞZĆåZóEYĎĂHÞĮWĊóWĂÖYí8WĒĒYĖĢZâľHĞłHĢŒYåŎYĚĲWĦŢZ0QMùČ(eOĉA1k5ęÙ#ÀwùÔÁaOĄR1Ăňĥùäĵ1$Ċ#82t5ÃsĮ-ŕôĿðüŋÈŋð0boeİsëFùx(ŌoŇňw4wĳÞl33ðĩEĕRŇľMĭăÆxIĬ3wR%ĔoXĹ{õÇëðSícùĩs4rðĈc[0òFüďIoâIß-÷ÃySÐÌyĕìÀĂĝtĖÂîFĜ2E0+Āřoeá$2BaĸIō");
       //const c = grassColor
@@ -5005,6 +5006,47 @@
 		corn: "0g0gf000ĦúZĺMZĽňYĆxHĢŊYņùYêŊZÂTWÓíHÌħWĦŋZÂxY?ĸH.ĈZ00000000000001h000001iMS0000iMBS0001ÐiNS007ìÐi)007ĀjzzS007ĐÐØ)000åïOjk000ıôÁl]000ĂāhåĐ000ŅĄGİë00eńđĄIħ00eŅŃë0000dŕ00000000000000",
 		popcornBowl: "0g0gc000ĒÎHŊ1HŚÏWìĨWĭĨY;ĈY-ùHsÀWÞ(ZÀŇY(ëY0000000000000000000000000001g000001i)S0000jzzU0001OO*lS00lzBNÃk00ÔàNÃÅä00ÖďGGæĐ00bāāāĂë000IđĂI00000II000000000000000000000000000",
 		
+	dirt: "0g0g7ĢlZýĜYåÃYÆřYðoHÚĞZâÑH4Č9PČg?ČÐSĈÉ9(J9Cĩ)yķBkaEðÂ%UÈ{üÉÖ)ù9Eù84Á]2Â$üòFkÃQČĂ?ČŁPwh?0ìKNÏFihČĎÃ{ĊRPAë?$ò{)9FXĺ1kòEiĊByÃ",
+	hitbox: "0g0g100W",
+	netherrack: "0g0g7ÀÁHUíWÀÎYÑĊYÝĪWSÁHï4W4CČÛğp%ýÃIÄķ÷ORÒ6ĄĸĭõßgĺĂ)ōĵ?phú+úĎŊe#sö7)XUŊ2)ŝÖĭùÛ@s}ÕőÞį2MįőĂ?×Ö@ïÁóóe*o][oMİĈ]ġĈ}{ĸVĮrPįĄ*.r",
+	endStone: "0g0g6ņĂHľÖHŖłHĭşYĶoYŞŒZ4XI}iĉAEÂùíg9n8?wRÝĊňa^üXĻTÁûÉ(!IÀħĉxoV]XIPİaĉnhČĠTÏNR]Rjïo]&wÁA2RÑüĐ9ħhB4Ï}gSS#zwíýòÂŀwAb(yT5ħĄ",
+	error: "0g0g2ŗf=00=0Z0Z0Z0Z0Z0Z0Z0ZZ0Z0Z0Z0Z0Z0Z0Z0",
+	crack1: "0g0g3ZZħ;ŚZĂÖY0000000000000000000000000000010002S000ë0000000000000000000000000",
+	crack2: "0g0g3ZZħ;ŚZĂÖY000000000000000000000400040009g002K000S000ë000000000000000000000",
+	crack3: "0g0g3ZZħ;ŚZĂÖY000000000000000004000400045009q002K000S000S001ë00200000000000000",
+	crack4: "0g0g3ZZħ;ŚZĂÖY0000000000000100060004gS0kBë0Fq002K000S000S005ë00a00000000000000",
+	crack5: "0g0g3ZZħ;ŚZĂÖY0000000000S001ë006gg04gK0UBë1đq022K000S000S00lë00!S000ë000000000",
+	crack6: "0g0g3ZZħ;ŚZĂÖY0000000004À009Ĉ006gk0QgÕ0UBë1đq062K080S00gS00lë00×S00ëù000w00000",
+	crack7: "0g0g3ZZħ;ŚZĂÖY00000g000AÀ009Ĉ00@gk0QgÕ0UBë1đp062Ï04SS08ùÀ00lĈ00×S01ëý020!00000",
+	crack8: "0g0g3ZZħ;ŚZĂÖY00000À000ČÀ059Ĉga@kk0QoÖ0UBí1đp06iÎ04KRS8ùÀë0lč0g×^0Bëý0aS×S0ëëë",
+	crack9: "0g0g3ZZħ;ŚZĂÖY04ë81Æ4SiČÆùB9Ĉgq@kkwQoÖ0UBí1đp06iÎ04KRQ]ùÀĀùlčgg×^wBëý06À×À8ĈSČ",
+	crack10: "0g0g3ZZħ;ŚZĂÖY44X]9Æ4SiČÆùB9ĈgÈ@kkĈQoÖ0UBíÁđp0ĎiÎ14KR@]ùÀĀùlčgg×^BBëýa6À×À4ĈSČ",
+	fire: "0g0g2ŗf=00=0Z0Z0Z0Z0Z0Z0Z0ZZ0Z0Z0Z0Z0Z0Z0Z0",
+	"onceFreezeHalfHeart": "09099000Äėħ}ŔY×ÇZîĆZÓoZēņZ2ZWŊZZ00000iw002NS00B+006?w007]0007S00070000000",
+	"onceFreezeHeart": "09099000Äėħ}ŔY×ÇZîĆZÓoZēņZ2ZWŊZZ00000iwy02NRÂ0B+*w6?B@07][007[00070000000",
+	"onceHalfHeart": "09094000ţTWKgHĠTW001S1ü0Ö0+S3À0)030000",
+	"onceHeart": "09094000ţTWKgHĠTW001?1ýùÖČ+Ô3Å0,030000",
+	"onceWitherHalfHeart": "09099000-TWĲ$YEĊY$(ZĆåZĞłHE(ZwíW000001g001zg00?Ð007ï(007î0007ë00070000000",
+	"onceWitherHeart": "09099000-TWĲ$YEĊYĆåZ$(ZĞłHE(ZwíW000001gh01zjT0UÐÑÀ7X)ñ07îñ007ñ00070000000",
+	"xbubble": "0909500000W2ÍZĺėZÄŖZ0iS0kú0k0Qkr2iî0RÀ08TS8S6]S0iS0",
+	"xbubblePop": "090930002ÍZ00W0SggP8Këw00g0ÆSEKgw80",
+	"freezeHalfHeart": "09098000Äėħ}ŔYďņZîĆZēņZŊZZ2ZW0000Č00CĈ04č01ÓS07Ā00u000Ý00000",
+	"freezeHeart": "09098000Äėħ}ŔYďņZîĆZēņZŊZZ2ZW0000Či0CĊĐ4čò1ÓÄÀ7ĂÝ0uÝ00Ý00000",
+	"halfHeart": "09094000ţTWZ$YĠTW001S1ü0V0*S3À0)030000",
+	"heartBackground": "0909300000WEĊY5k6Ă@ĒčĒđ×Ē@ĒS×S6S0S0",
+	"heartBlink": "09093000ZZZEĊY5k6Ă@ĒčĒđ×Ē@ĒS×S6S0S0",
+	"heart": "09094000ţTWZ$YĠTW001?1ýÀVU*Å3Å0,030000",
+	"foodBackground": "0909300000WEĊY506ù6đ1ĒùqČ1đ0lü0p050",
+	"foodFull": "0909a000ĻĊYĘÎYŅįZĢlYąĜWKŘYåRZŊÈYZńZ000001w001MS00x?S00ÔV000ÔÝ0000ë0000ù00000",
+	"foodHalf": "0909b000ĘÎYŒqHĻĊYĽÅYĢlYąĜWKŘYåRZŊÈYZńZ000000g000zg000>À001m0007ë0000ù0000Ĉ00000",
+	"witherHalfHeart": "09098000-TWĲ$YEĊY$(ZE(ZwíWAJH0000i00kį08ł01GK05ĳ00n000À00000",
+	"witherHeart": "0909b000-TWĲ$YEĊY$(ZAJHsÞZE(ZwíW-ÞZQÞZ000001gh01zjM0>OÃK7ïOò07îò007ó000a0000000",
+	
+	flame: "08085000ţ0WŤĈWZKWZŃH0g00y00)00)01+01ĭë1įħ1+ë",
+	glint: "080850002ÁW2ĩY3AZ3āH0g00w00Ě0FĭI0Ě00w00g0000",
+	lavaParticle: "08085000ŤĈWZKWţ0WZŃH0000000Čħ1QS1]ë0ČS000000",
+	soulFireFlame: "080850002.W2ĂZÐņYZZZ0g00y00)00)01+01ĭë1įħ1+ë",
+
 		//pretty: "0g0g40001blc009d4hc009efw01ulak1c3300022112200033333022111122033303332112211233300033312222133300022333222233322022113330033311222112233333322112112220333302221111222033330222112112233333322112221133300333112202233322223332200033312222133300033321122112333033302211112203333300222112200033",
     error:function(n){
       for (let x = 0; x < 16; ++x) {
@@ -5018,7 +5060,8 @@
 			}
     }//"0g0g2000006w1ulbvg81111111100000000111111110000000011111111000000001111111100000000111111110000000011111111000000001111111100000000111111110000000000000000111111110000000011111111000000001111111100000000111111110000000011111111000000001111111100000000111111110000000011111111",
 	}
-  window.textures = textures
+  //window.textures = textures
+	Object.assign(textures, window.serverTextures)
   
 	window.emptyFunc = function(){}
 	
@@ -5506,7 +5549,7 @@
 				if(block.rarity === "epic") txt += "\n§dEpic"
 			}
 			if(block.category) txt += "\n§9"+blockCategories[block.category]
-			if(block.type) txt += "\n§c"+blockCategories[block.type]
+			//if(block.type) txt += "\n§c"+blockCategories[block.type]
 			if(blockInfoIds[block.id]){
 				txt += "\n§r"+blockInfo[blockInfoIds[block.id]].data
 			}
@@ -5735,7 +5778,6 @@
 			}
 		})
 	}
-
 	let backupWorldsDir
 	loadFromDB("backupWorldsDir").then(r => r && (backupWorldsDir = r.data))
 	async function backupWorlds(){
@@ -5775,7 +5817,7 @@
 		if(value instanceof Uint8Array) return value.toString()
 		else return value
 	}
-
+	
 	async function save(getObj) {
     let obj = {
 			id: serverWorld.id,
@@ -5790,20 +5832,24 @@
 			activeResourcePacks:serverWorld.activeResourcePacks
 		}
 		if(!getObj) await saveToDB(serverWorld.id, obj)
+		obj.code += ""
+		let playersInvString = {}
+		for(let i in serverWorld.playersInv){
+			playersInvString[i] = {}
+			if(serverWorld.playersInv[i].inv) playersInvString[i].inv = serverWorld.playersInv[i].inv.toString()
+			if(serverWorld.playersInv[i].survivStr) playersInvString[i].survivStr = serverWorld.playersInv[i].survivStr.toString()
+		}
+		obj.playersInv = playersInvString
 		if(!getObj){
-			let str = JSON.stringify(obj, saveJSONReplacer)
-			await Promise.all([
-				fetch('saves', {
-					method: "POST",
-					headers:{Authorization:userSessionString},
-					body: str
-				}).then(r => r.json()).then(r => {
-					if(!r.success){
-						console.log(r.message)
-					}
-				}).catch(console.error),
-				saveBackupWorld(obj, str)
-			])
+			await fetch('saves', {
+				method: "POST",
+				headers:{Authorization:userSessionString},
+				body: JSON.stringify(obj)
+			}).then(r => r.json()).then(r => {
+				if(!r.success){
+					console.log(r.message)
+				}
+			}).catch(console.error)
 			serverWorld.edited = Date.now()
     }else{
       return obj
@@ -5816,7 +5862,7 @@
     delete obj.thumbnail
     delete obj.banned
     delete obj.whitelist
-    return JSON.stringify(obj, saveJSONReplacer)
+    return JSON.stringify(obj)
   }
   
   let sixtyfourCnv = document.createElement("canvas")
@@ -5883,7 +5929,7 @@
     narratorVoice: null, // defined later
 		joystick: true,
 		language: null,
-		adjustBrightness: true,
+		adjustBrightness: false,
 		reach: 5, // Max distance player can place or break blocks
 		graphics: null, //Null means not changed yet (same as normal)
 		resolution: true,
@@ -5943,7 +5989,7 @@
       glExtensions.vertex_array_object.bindVertexArrayOES(null)
       this.faces = size
       
-      let tex = textureCoords[textureMap.sun]
+      let tex = textureCoords[textureMap.sun] || [0,0,0,0]
       this.sun = generateVAO(shapes.sun, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
       
       this.moonPhase = null
@@ -5972,7 +6018,7 @@
       let moonPhase = round(worldTime/1000) % 8
       if(this.moonPhase !== moonPhase){
         this.moonPhase = moonPhase
-        let tex = textureCoords[textureMap["moonPhases"+moonPhase]]
+        let tex = textureCoords[textureMap["moonPhases"+moonPhase]] || [0,0,0,0]
         this.moon = generateVAO(shapes.sun, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
       }
       
@@ -8326,6 +8372,7 @@
     return true
   }
 
+	const {setBlockState,getBlockState} = win
 	function initBlockEntities(){
 		crack.entity = new crackEntity("crack1",0,0,0)
     for(var i=0; i<crack.length; i++) crack.entity.cacheTexture(crack[i])
@@ -8345,31 +8392,14 @@
 		}
 		win.initServerBlockData()
 const blockDataAdditional = {
-	grass:{
-		/*customTexture:function(x,y,z,dimension,block,side){
-			if(block !== this.id || side === "bottom" || side === "top") return //Skip snow variant
-			if(side === "north" && world.getBlock(x,y-1,z+1,dimension) !== this.id) return
-			if(side === "south" && world.getBlock(x,y-1,z-1,dimension) !== this.id) return
-			if(side === "east" && world.getBlock(x+1,y-1,z,dimension) !== this.id) return
-			if(side === "west" && world.getBlock(x-1,y-1,z,dimension) !== this.id) return
-			return "grassSideGrass"
-		}*/
-	},
 	redstoneDust:{
 		clientTick:function(block,x,y,z,dimension,world){
-			if(!performFast && world.getPower(x,y,z,dimension)) world.addParticle(new entities[entityIds.RedstoneParticle](x,y-0.49,z,null,(block&FLIP)===FLIP),dimension)
-		},
-		alwaysCustomTexture:true,
-		customTexture:function(x,y,z,dimension,block,side,originalShapeVerts,tags){
-			const up = getTagBits(tags,"up",this.id), down = getTagBits(tags,"down",this.id)
-			if(originalShapeVerts.t) side = originalShapeVerts.t
-			else return (side === "top" || side === "bottom") && up && down && false
-			let tex
-			if(side === "west") tex = tags && (getTagBits(tags,"westUp",this.id) || up)
-			else if(side === "east") tex = tags && (getTagBits(tags,"eastUp",this.id) || up)
-			else if(side === "south") tex = tags && (getTagBits(tags,"northUp",this.id) || up)
-			else if(side === "north") tex = tags && (getTagBits(tags,"southUp",this.id) || up)
-			return tex ? "redstoneDustLine" : false
+			if(!performFast && world.getPower(x,y,z,dimension)) world.addParticle(new RedstoneParticle(x,y-0.49,z,null,false),dimension)
+		}
+	},
+	blueRedstoneDust:{
+		clientTick:function(block,x,y,z,dimension,world){
+			if(!performFast && world.getPower(x,y,z,dimension)) world.addParticle(new RedstoneParticle(x,y-0.49,z,null,true),dimension)
 		}
 	},
 	torch:{
@@ -8377,70 +8407,72 @@
 			if(performFast) return
 			let wall = this.id | SLAB
 			let pix = 1/16
-			switch(block){
-				case wall | NORTH:
+			y += pix*2
+			world.addParticle(new FlameParticle(x,y,z),dimension)
+		},
+	},
+	wallTorch:{
+		clientTick:function(block,x,y,z,dimension){
+			if(performFast) return
+			let wall = this.id | SLAB
+			let pix = 1/16
+			switch(getBlockState(block,this.blockStatesMap.facing)){
+				case "north":
 					z += pix*5
 					y += pix*6
 					break
-				case wall | SOUTH:
+				case "south":
 					z -= pix*5
 					y += pix*6
 					break
-				case wall | EAST:
+				case "east":
 					x += pix*5
 					y += pix*6
 					break
-				case wall | WEST:
+				case "west":
 					x -= pix*5
 					y += pix*6
 					break
-				default:
-					y += pix*2
 			}
-			world.addParticle(new entities[entityIds.FlameParticle](x,y,z),dimension)
+			world.addParticle(new FlameParticle(x,y,z),dimension)
 		},
 	},
 	soulTorch:{
-		 clientTick:function(block,x,y,z,dimension){
+		clientTick:function(block,x,y,z,dimension){
+			if(performFast) return
+			let wall = this.id | SLAB
+			let pix = 1/16
+			y += pix*2
+			world.addParticle(new FlameParticle(x,y,z,"soul"),dimension)
+		},
+	},
+	soulWallTorch:{
+		clientTick:function(block,x,y,z,dimension){
 			if(performFast) return
 			let wall = this.id | SLAB
 			let pix = 1/16
-			switch(block){
-				case wall | NORTH:
+			switch(getBlockState(block,this.blockStatesMap.facing)){
+				case "north":
 					z += pix*5
 					y += pix*6
 					break
-				case wall | SOUTH:
+				case "south":
 					z -= pix*5
 					y += pix*6
 					break
-				case wall | EAST:
+				case "east":
 					x += pix*5
 					y += pix*6
 					break
-				case wall | WEST:
+				case "west":
 					x -= pix*5
 					y += pix*6
 					break
-				default:
-					y += pix*2
 			}
-			world.addParticle(new entities[entityIds.FlameParticle](x,y,z,"soul"),dimension)
+			world.addParticle(new FlameParticle(x,y,z,"soul"),dimension)
 		},
 	},
-	sandstone:{
-		customTexture:function(x,y,z,dimension,block,side){
-			if(world.getBlock(x,y+1,z,dimension) === block) return "sandstoneBottom"
-		},
-	},
-	redSandstone:{
-		customTexture:function(x,y,z,dimension,block,side){
-			if(world.getBlock(x,y+1,z,dimension) === block) return "redSandstoneBottom"
-		}
-	},
 	dropper:{
-		upTextures:fillTextureArray(["furnaceTop","dropperFrontVertical","furnaceTop"]),
-		downTextures:fillTextureArray(["dropperFrontVertical","furnaceTop","furnaceTop"]),
 		onclientclick:function(x,y,z,dimension){
 			containerData.x = x
 			containerData.y = y
@@ -8451,8 +8483,6 @@
 		},
 	},
 	dispenser:{
-		upTextures:fillTextureArray(["furnaceTop","dispenserFrontVertical","furnaceTop"]),
-		downTextures:fillTextureArray(["dispenserFrontVertical","furnaceTop","furnaceTop"]),
 		onclientclick:function(x,y,z,dimension){
 			containerData.x = x
 			containerData.y = y
@@ -8476,7 +8506,7 @@
 		clientTick:function(block,x,y,z,dimension,world){
 			let b = world.getBlock(x,y+1,z,dimension)
 			if(!b && !b.liquid && !performFast && rand() < 0.05){
-				world.addParticle(new entities[entityIds.LavaParticle](x,y+0.5,z),dimension)
+				world.addParticle(new LavaParticle(x,y+0.5,z),dimension)
 				playSound("liquid.lavapop",0,1,1,posSound(x,y+0.5,z))
 			}
 		},
@@ -8497,7 +8527,7 @@
 				let ent = chunkEntities[i]
 				if(ent.type === "BeaconBeam" && ent.x === x && ent.actualY === y && ent.z === z && ent.dimension === dimension) return
 			}
-			world.addEntity(new entities[entityIds.BeaconBeam](x,y,z),false,dimension)
+			world.addEntity(new BeaconBeam(x,y,z),false,dimension)
 		},
 	},
 	craftingTable:{
@@ -8520,31 +8550,28 @@
 		},
 		clientTick:function(block,x,y,z,dimension,world){
 			if(performFast) return
-			let tags = world.getTags(x,y,z,dimension)
+			if(!getBlockState(block,this.blockStatesMap.lit)) return
 			let pix = 1/16
-			let on = this.id | SLAB
 			y -= rand(4,8)*pix
-			switch(block){
-				case on | NORTH:
+			switch(getBlockState(block,this.blockStatesMap.facing)){
+				case "north":
 					z -= 0.51
 					x += rand(-5,5)*pix
 					break
-				case on | SOUTH:
+				case "south":
 					z += 0.51
 					x += rand(-5,5)*pix
 					break
-				case on | EAST:
+				case "east":
 					x -= 0.51
 					z += rand(-5,5)*pix
 					break
-				case on | WEST:
+				case "west":
 					x += 0.51
 					z += rand(-5,5)*pix
 					break
-				default:
-					return
 			}
-			world.addParticle(new entities[entityIds.FlameParticle](x,y,z),dimension)
+			world.addParticle(new FlameParticle(x,y,z),dimension)
 		}
 	},
 	barrel:{
@@ -8598,31 +8625,38 @@
 			if(performFast || !world.getPower(x,y,z,dimension)) return
 			let wall = this.id | SLAB
 			let pix = 1/16
-			switch(block){
-				case wall | NORTH:
+			y += pix*2
+			world.addParticle(new RedstoneParticle(x,y,z),dimension)
+		},
+	},
+	redstoneWallTorch:{
+		clientTick:function(block,x,y,z,dimension,world){
+			if(performFast || !world.getPower(x,y,z,dimension)) return
+			let wall = this.id | SLAB
+			let pix = 1/16
+			switch(getBlockState(block,this.blockStatesMap.facing)){
+				case "north":
 					z += pix*5
 					y += pix*6
 					break
-				case wall | SOUTH:
+				case "south":
 					z -= pix*5
 					y += pix*6
 					break
-				case wall | EAST:
+				case "east":
 					x += pix*5
 					y += pix*6
 					break
-				case wall | WEST:
+				case "west":
 					x -= pix*5
 					y += pix*6
 					break
-				default:
-					y += pix*2
 			}
-			world.addParticle(new entities[entityIds.RedstoneParticle](x,y,z),dimension)
+			world.addParticle(new RedstoneParticle(x,y,z),dimension)
 		},
 	},
 	debugStick:{
-		Name:function(){
+		Name:function(){//todo n
 			let str
 			if(blockMode === CUBE) str = "Get Tags"
 			else if(blockMode === SLAB) str = "Change Block State"
@@ -8693,12 +8727,12 @@
 				Object.assign(data, blockDataAdditional[data.name])
 			}
 			
-			for(let t = 0; t<data.textures.length; t++){
+			/*for(let t = 0; t<data.textures.length; t++){
 				if(!textures[data.textures[t]]){
 					window.console.log("Missing texture for "+data.textures[t])
 					data.textures[t] = "error"
 				}
-			}
+			}*/
 		}
 		
 		blockInfoIds = {}
@@ -8888,18 +8922,6 @@
 			},
 		}
 
-		var itemFrameSet = function(x,y,z,dimension,block,itemFrameBlock,world){
-			let chunkEntities = world.getChunk(x,z,dimension).entities
-			for(var i in chunkEntities){
-				let ent = chunkEntities[i]
-				if(ent.type === "ItemFrame" && ent.x === x && ent.y === y && ent.z === z && ent.dimension === dimension) return
-			}
-			world.addEntity(new entities[entityIds.ItemFrame](x,y,z,block,itemFrameBlock),true,dimension)
-		}
-		var itemFrameOnset = function(x,y,z, dimension,world){
-			var block = world.getBlock(x,y,z,dimension)
-			this.set(x,y,z,dimension,0,block,world)
-		}
 		var signSet = function(x,y,z,dimension,block,world){
 			let chunkEntities = world.getChunk(x,z,dimension).entities
 			for(var i in chunkEntities){
@@ -8907,28 +8929,24 @@
 				if(ent.type === "Sign" && ent.x === x && ent.y === y && ent.z === z && ent.dimension === dimension) return
 			}
 			block = block || world.getBlock(x,y,z,dimension)
-			world.addEntity(new entities[entityIds.Sign](x,y,z,this.id,block),false,dimension)
+			world.addEntity(new Sign(x,y,z,block),false,dimension)
 		}
     
 		for (let i = 0; i < BLOCK_COUNT; i++) {
 			let baseBlock = blockData[i]
-      for(var t=0; t<baseBlock.textures.length; t++){
+      /*for(var t=0; t<baseBlock.textures.length; t++){
         if(semiTransTextures.includes(baseBlock.textures[t])){
           baseBlock.semiTrans = true
           break
         }
-      }
-      if(baseBlock.liquid){
+      }*/
+      if(0&&baseBlock.liquid){//todo n
 				Object.assign(baseBlock,liquidData)
       }
       if(baseBlock.sign){
         baseBlock.importantOnset = function(x,y,z,dimension,w){this.set(x,y,z,dimension,null,w)}
 				baseBlock.set = signSet
       }
-			if(baseBlock.itemFrame){
-        baseBlock.set = itemFrameSet
-        baseBlock.importantOnset = itemFrameOnset
-			}
 			
 		}
 
@@ -9044,7 +9062,7 @@
       -0.5412658773652741,0.3125,0.8125,0.1875,1, 0,0,0.1875,0.1875,1, 0,-0.625,0.1875,0.8125,1, -0.5412658773652741,-0.3125,0.8125,0.8125,1, -0.8660254037844386,0.5,-1,0,1, 0,0,-2,0,1, 0,-1,-2,1,1, -0.8660254037844386,-0.5,-1,1,1, -0.649519052838329,-0.3125,-0.25,0.1875,1, 0,-0.6875,-1,0.1875,1, 0,-0.875,-1,0.375,1, -0.649519052838329,-0.5,-0.25,0.375,1,
     ]
 	}
-	function genIcons() {
+	function genIcons() {//todo n: update icons
 		blockIcons = [null]
 		blockIcons.lengths = []
 		let texOrder = [ 1, 4, 3 ]
@@ -9075,13 +9093,8 @@
       if(block.icon){
         block = blockData[blockIds[block.icon]]
       }
-      if(block.iconTexture){
-        prevTexture = block.textures
-        var t = block.iconTexture
-        block.textures = new Array(6).fill(t)
-      }
       if(block.flatIcon){
-				let tex = textureCoords[textureMap[block.textures[2]]]
+				let tex = textureCoords[textureMap["error"]]//todo n
 				data.push(-scale, scale, 1/6, tex[2], tex[3], 1)
 				data.push(scale, scale, 1/6, tex[0], tex[1], 1)
 				data.push(scale, -scale, 1/6, tex[6], tex[7], 1)
@@ -9101,144 +9114,14 @@
         blockIcons.lengths[i | TORCH] = 6
         blockIcons[i | PANE] = buffer
         blockIcons.lengths[i | PANE] = 6
-      }else if(block.carpet){
-        v = carpetIconVerts
-        for (let j = 11; j >= 0; j--) {
-          let tex = textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]]
-          data.push(-v[j * 3 + 0] * scale)
-          data.push(v[j * 3 + 1] * scale)
-          data.push(0.1666666)
-          data.push(tex[(j * 2 + 0) % 8])
-          data.push(tex[(j * 2 + 1) % 8])
-          data.push(shadows[floor(j / 4)])
-        }
-        buffer = gl.createBuffer()
-        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
-        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
-        blockIcons[i] = buffer
-        blockIcons.lengths[i] = 6 * 3
-      }else if(block.trapdoor){
-        v = trapdoorIconVerts
-        for (let j = 11; j >= 0; j--) {
-          let tex = textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]]
-          data.push(-v[j * 3 + 0] * scale)
-          data.push(v[j * 3 + 1] * scale)
-          data.push(0.1666666)
-          data.push(tex[(j * 2 + 0) % 8])
-          data.push(tex[(j * 2 + 1) % 8])
-          data.push(shadows[floor(j / 4)])
-        }
-        buffer = gl.createBuffer()
-        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
-        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
-        blockIcons[i] = buffer
-        blockIcons.lengths[i] = 6 * 3
-        blockIcons[i | TRAPDOOR] = buffer
-        blockIcons.lengths[i | TRAPDOOR] = 6 * 3
-        blockIcons[i | TRAPDOOROPEN] = buffer
-        blockIcons.lengths[i | TRAPDOOROPEN] = 6 * 3
-      }else if(block.layers){
-        v = snowIconVerts
-        for (let j = 11; j >= 0; j--) {
-          let tex = textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]]
-          data.push(-v[j * 3 + 0] * scale)
-          data.push(v[j * 3 + 1] * scale)
-          data.push(0.1666666)
-          data.push(tex[(j * 2 + 0) % 8])
-          data.push(tex[(j * 2 + 1) % 8])
-          data.push(shadows[floor(j / 4)])
-        }
-        buffer = gl.createBuffer()
-        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
-        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
-        blockIcons[i] = buffer
-        blockIcons.lengths[i] = 6 * 3
-        blockIcons[i | LAYER1] = buffer
-        blockIcons.lengths[i | LAYER1] = 6 * 3
-        blockIcons[i | LAYER2] = buffer
-        blockIcons.lengths[i | LAYER2] = 6 * 3
-        blockIcons[i | LAYER3] = buffer
-        blockIcons.lengths[i | LAYER3] = 6 * 3
-        blockIcons[i | LAYER4] = buffer
-        blockIcons.lengths[i | LAYER4] = 6 * 3
-        blockIcons[i | LAYER5] = buffer
-        blockIcons.lengths[i | LAYER5] = 6 * 3
-        blockIcons[i | LAYER6] = buffer
-        blockIcons.lengths[i | LAYER6] = 6 * 3
-        blockIcons[i | LAYER7] = buffer
-        blockIcons.lengths[i | LAYER7] = 6 * 3
-        blockIcons[i | LAYER8] = buffer
-        blockIcons.lengths[i | LAYER8] = 6 * 3
-      }else if(block.cactus){
-        v = cactusIconVerts
-        for (let j = 11; j >= 0; j--) {
-          let tex = textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]]
-          data.push(-v[j * 3 + 0] * scale)
-          data.push(v[j * 3 + 1] * scale)
-          data.push(0.1666666)
-          data.push(tex[(j * 2 + 0) % 8])
-          data.push(tex[(j * 2 + 1) % 8])
-          data.push(shadows[floor(j / 4)])
-        }
-        buffer = gl.createBuffer()
-        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
-        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
-        blockIcons[i] = buffer
-        blockIcons.lengths[i] = 6 * 3
-        blockIcons[i | CACTUS] = buffer
-        blockIcons.lengths[i | CACTUS] = 6 * 3
-      }/*else if(block.beacon){
-        v = beaconIconVerts
-        for (let j = v.length/5-1; j >= 0; j--) {
-          let num = floor(j / (v.length/15))
-          let tex = textureCoords[textureMap[block.textures[texOrder[num]]]]
-          let tx = tex[0]
-          let ty = tex[1]
-          data.push(-v[j * 5 + 0] * scale)
-          data.push(v[j * 5 + 1] * scale)
-          data.push(0.1666666)
-          data.push(tx + v[j * 5 + 2] / 16)
-          data.push(ty + v[j * 5 + 3] / 16)
-          data.push(shadows[num])
-        }
-        buffer = gl.createBuffer()
-        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
-        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
-        blockIcons[i] = buffer
-        blockIcons.lengths[i] = 6 * 3
-        blockIcons[i | CACTUS] = buffer
-        blockIcons.lengths[i | CACTUS] = 6 * 3
-      }*/else if(block.name === "bow"){
-        v = squareVerts
-				let buffers = []
-				for(let i of block.pullTextures){
-					data = []
-					let tex = textureCoords[textureMap[i]]
-					data.push(-scale, scale, 1/6, tex[2], tex[3], 1)
-					data.push(scale, scale, 1/6, tex[0], tex[1], 1)
-					data.push(scale, -scale, 1/6, tex[6], tex[7], 1)
-					data.push(-scale, -scale, 1/6, tex[4], tex[5], 1)
-					buffer = gl.createBuffer()
-					gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
-					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
-					buffers.push(buffer)
-				}
-				blockIcons[i] = buffers[0]
-				blockIcons.lengths[i] = 6
-				blockIcons[i|SLAB] = buffers[1]
-				blockIcons.lengths[i|SLAB] = 6
-				blockIcons[i|STAIR] = buffers[2]
-				blockIcons.lengths[i|STAIR] = 6
-				blockIcons[i|CROSS] = buffers[3]
-				blockIcons.lengths[i|CROSS] = 6
-				continue
-			}else{
+      }else{//todo n: bow icon
         for (let j = 11; j >= 0; j--) {
           data.push(-hexagonVerts[j * 3 + 0] * scale)
           data.push(hexagonVerts[j * 3 + 1] * scale)
           data.push(0.1666666)
-          data.push(textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]][(j * 2 + 0) % 8])
-          data.push(textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]][(j * 2 + 1) % 8])
+					let t=block.shape.texVerts[texOrder[floor(j / 4)]]?.[0]?.texture||"error"
+          data.push(textureCoords[textureMap[t] || textureMap.error][(j * 2 + 0) % 8])
+          data.push(textureCoords[textureMap[t] || textureMap.error][(j * 2 + 1) % 8])
           data.push(shadows[floor(j / 4)])
         }
         buffer = gl.createBuffer()
@@ -9247,122 +9130,6 @@
         blockIcons[i] = buffer
         blockIcons.lengths[i] = 6 * 3
       }
-
-			data = []
-			for (let j = 11; j >= 0; j--) {
-				let tex = textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]]
-
-				data.push(-slabIconVerts[j * 3 + 0] * scale)
-				data.push(slabIconVerts[j * 3 + 1] * scale)
-				data.push(0.1666666)
-				data.push(tex[(j * 2 + 0) % 8])
-				data.push(tex[(j * 2 + 1) % 8])
-				data.push(shadows[floor(j / 4)])
-			}
-			buffer = gl.createBuffer()
-			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
-			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
-			blockIcons[i | SLAB] = buffer
-			blockIcons.lengths[i | SLAB] = 6 * 3
-
-      data = []
-			for (let j = 11; j >= 0; j--) {
-				let tex = textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]]
-
-				data.push(-verticalSlabIconVerts[j * 3 + 0] * scale)
-				data.push(verticalSlabIconVerts[j * 3 + 1] * scale)
-				data.push(0.1666666)
-				data.push(tex[(j * 2 + 0) % 8])
-				data.push(tex[(j * 2 + 1) % 8])
-				data.push(shadows[floor(j / 4)])
-			}
-			buffer = gl.createBuffer()
-			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
-			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
-			blockIcons[i | VERTICALSLAB] = buffer
-			blockIcons.lengths[i | VERTICALSLAB] = 6 * 3
-
-			data = []
-			v = stairIconVerts
-			for (let j = 23; j >= 0; j--) {
-				let num = floor(j / 8)
-				let tex = textureCoords[textureMap[block.textures[texOrder[num]]]]
-				let tx = tex[0]
-				let ty = tex[1]
-				let tw = tex[2] - tx
-				let th = tex[5] - ty
-				data.push(-v[j * 5 + 0] * scale)
-				data.push(v[j * 5 + 1] * scale)
-				data.push(0.1666666)
-				data.push(tx + v[j * 5 + 2] * tw)
-				data.push(ty + v[j * 5 + 3] * th)
-				data.push(shadows[num])
-			}
-			buffer = gl.createBuffer()
-			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
-			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
-			blockIcons[i | STAIR] = buffer
-			blockIcons.lengths[i | STAIR] = 6 * 6
-      
-      data = []
-      v = fenceIconVerts
-			for (let j = 11; j >= 0; j--) {
-        let num = floor(j / 4)
-				let tex = textureCoords[textureMap[block.textures[texOrder[num]]]]
-				let tx = tex[0]
-				let ty = tex[1]
-				let tw = tex[2] - tx
-				let th = tex[5] - ty
-				data.push(-v[j * 5 + 0] * scale)
-				data.push(v[j * 5 + 1] * scale)
-				data.push(0.1666666)
-				data.push(tx + v[j * 5 + 2] * tw)
-				data.push(ty + v[j * 5 + 3] * th)
-				data.push(shadows[num])
-			}
-			buffer = gl.createBuffer()
-			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
-			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
-			blockIcons[i | FENCE] = buffer
-			blockIcons.lengths[i | FENCE] = 6 * 3
-			
-			data = []
-			for (let j = 11; j >= 0; j--) {
-				let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]
-
-				data.push(-wallPostIconVerts[j * 3 + 0] * scale)
-				data.push(wallPostIconVerts[j * 3 + 1] * scale)
-				data.push(0.1666666)
-				data.push(tex[(j * 2 + 0) % 8])
-				data.push(tex[(j * 2 + 1) % 8])
-				data.push(shadows[Math.floor(j / 16)])
-			}
-			buffer = gl.createBuffer()
-			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
-			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
-			blockIcons[i | WALLPOST] = buffer
-			blockIcons.lengths[i | WALLPOST] = 6 * 1
-			
-			data = []
-			for (let j = 11; j >= 0; j--) {
-				let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]
-
-				data.push(-buttonIconVerts[j * 3 + 0] * scale)
-				data.push(buttonIconVerts[j * 3 + 1] * scale)
-				data.push(0.1666666)
-				data.push(tex[(j * 2 + 0) % 8])
-				data.push(tex[(j * 2 + 1) % 8])
-				data.push(shadows[Math.floor(j / 16)])
-			}
-			buffer = gl.createBuffer()
-			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
-			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
-			blockIcons[i | BUTTON] = buffer
-			blockIcons.lengths[i | BUTTON] = 6 * 1
-      
-      if(block.iconTexture){
-        block.textures = prevTexture
-      }
 		}
 	}
 
@@ -10632,6 +10399,7 @@
 		let block = world.getBlock(x, y, z, p.dimension)
 		if (block && !(blockData[block].noHitbox && !(holding && blockData[holding].allHitbox))) {
 			let shape = blockData[block].shape
+			if(blockData[block].hitbox) shape = shapes[blockData[block].hitbox]
       if(shape.hitbox) shape = shape.hitbox
 			let rt = rayTrace(x, y, z, shape, p.thirdPerson)
 
@@ -10647,6 +10415,7 @@
 		let block = world.getBlock(x, y, z, p.dimension)
 		if (block && blockData[block].solid) {
 			let shape = blockData[block].shape
+			if(blockData[block].hitbox) shape = shapes[blockData[block].hitbox]
       if(shape.hitbox) shape = shape.hitbox
 			let rt = rayTrace(x, y, z, shape, true)
 
@@ -11412,7 +11181,7 @@
 					send({type:"playSound", data:"liquid.splash", x:p.x,y:p.y-p.height*0.5,z:p.z,pitch})
 				}
         if(!performFast) for(var i=0; i<10; i++){
-          world.addParticle(new entities[entityIds.SplashParticle](p.x,p.y-p.height*0.5,p.z),p.dimension)
+          world.addParticle(new SplashParticle(p.x,p.y-p.height*0.5,p.z),p.dimension)
         }
         send({
           type:"particles", particleType:"SplashParticle",
@@ -12278,12 +12047,27 @@
 			send({type:"place",x:hitBox.pos[0],y:hitBox.pos[1],z:hitBox.pos[2], cx: (p.direction.x*hitBox.closest-(hitBox.pos[0]-round(p.x))), cy: (p.direction.y*hitBox.closest-(hitBox.pos[1]-round(p.y))), cz: (p.direction.z*hitBox.closest-(hitBox.pos[2]-round(p.z))) })
 			return
 		}
+
+		let rotate, flip = false
+		let pi = Math.PI / 4
+		if (p.ry <= pi) {
+			rotate = "north"
+		}else if (p.ry < 3 * pi) {
+			rotate = "west"
+		} else if (p.ry < 5 * pi) {
+			rotate = "south"
+		} else if (p.ry < 7 * pi) {
+			rotate = "east"
+		}else rotate = "north"
+		if (hitBox.face !== "top" && (hitBox.face === "bottom" || (p.direction.y * hitBox.closest + p.y+p.cOffsetY) % 1 < 0.5)) {
+			flip = true
+		}
     
     let adjholding = holding
     if(adjholding && pos && blockData[adjholding].useAs){
       var useAs = blockData[adjholding].useAs
       if(typeof useAs === "function"){
-        useAs = useAs(x,y,z,cblock,face)
+        useAs = blockData[adjholding].useAs(x,y,z,cblock,face,world,rotate,flip)
         if(typeof useAs === "string" && blockIds[useAs]){
           adjholding = blockIds[useAs]
         }else adjholding = useAs
@@ -12295,23 +12079,10 @@
 		try{
 		
 		let mode = adjholding < isCube && !blockData[adjholding].item ? blockMode : 0
-		let rotate = 0, flip = 0
-		let pi = Math.PI / 4
-		if (p.ry <= pi) {} // North; default
-		else if (p.ry < 3 * pi) {
-			rotate = WEST
-		} else if (p.ry < 5 * pi) {
-			rotate = SOUTH
-		} else if (p.ry < 7 * pi) {
-			rotate = EAST
-		}
-		if (hitBox.face !== "top" && (hitBox.face === "bottom" || (p.direction.y * hitBox.closest + p.y+p.cOffsetY) % 1 < 0.5)) {
-			flip = FLIP
-		}
 		let predictBlock = adjholding|mode
 		let shape = adjholding && blockData[predictBlock].shape
-		if (shape && shape.rotate) predictBlock |= rotate
-		if (shape && shape.flip) predictBlock |= flip
+		//if (shape && shape.rotate) predictBlock |= rotate//todo n
+		//if (shape && shape.flip) predictBlock |= flip
     
 		if(hitBox.pos){
 			let onclick = blockData[cblock].onclientclick
@@ -12581,7 +12352,7 @@
             break
         }
       }else if(type === "player") tex = 1//actually stepping
-      world.addParticle(new entities[entityIds.BlockParticle](blockData[block].textures[tex], ax,ay,az, type, block), dimension)
+      world.addParticle(new BlockParticle((blockData[block].shape.textureSelectors && blockData[block].shape.textureSelectors.particle) || blockData[block].textures[2], ax,ay,az, type, block), dimension)
     }
     if(!remote) send({
       type:"particles", particleType:"blockParticles",
@@ -13088,33 +12859,33 @@
 		ret[offset+1] = ((a.length>3 ? a[colorOffset+1] : a[1])+(b.length>3 ? b[colorOffset+1] : b[1])+(c.length>3 ? c[colorOffset+1] : c[1])+(d.length>3 ? d[colorOffset+1] : d[1]))*0.25
 		ret[offset+2] = ((a.length>3 ? a[colorOffset+2] : a[2])+(b.length>3 ? b[colorOffset+2] : b[2])+(c.length>3 ? c[colorOffset+2] : c[2])+(d.length>3 ? d[colorOffset+2] : d[2]))*0.25
 	}
-  let getTint = {
+  let getTint = {//todo n: entity tint
+		none: function(ret){
+			ret[0] = ret[3] = ret[6] = ret[9] = 1
+			ret[1] = ret[4] = ret[7] = ret[10] = 1
+			ret[2] = ret[5] = ret[8] = ret[11] = 1
+			return ret
+		},
     bottom: function(x,y,z,ret,dimension,block,tags){
-      let side = "tagTintPropertyBottom"
-      let tint = null
-      if(block[side]){
-        let name = block[side]
-        let tag = getTag(tags,name,block)
-        tint = block.tint[tag || 0]
-      }
-      if(block.biomeTintBottom){
-        let b = world.getBiome(x,y,z,dimension)
-        let t = block.tint
-        tint = t[b] || t.default
+			let tint
+			let b = block.tagTint ? getTag(tags,block.tagTint,block) : world.getBiome(x,y,z,dimension)
+			let t = block.tint
+			if(t){
+				tint = t[b] || t[0] || t.default
 				if(performFast){
 					ret[0] = ret[3] = ret[6] = ret[9] = tint[0]
 					ret[1] = ret[4] = ret[7] = ret[10] = tint[1]
 					ret[2] = ret[5] = ret[8] = ret[11] = tint[2]
 					return ret
 				}
-        const north = t[world.getBiome(x,y,z-1,dimension)] || t.default
-        const south = t[world.getBiome(x,y,z+1,dimension)] || t.default
-        const east = t[world.getBiome(x-1,y,z,dimension)] || t.default
-        const west = t[world.getBiome(x+1,y,z,dimension)] || t.default
-        const northeast = t[world.getBiome(x-1,y,z-1,dimension)] || t.default
-        const southeast = t[world.getBiome(x-1,y,z+1,dimension)] || t.default
-        const northwest = t[world.getBiome(x+1,y,z-1,dimension)] || t.default
-        const southwest = t[world.getBiome(x+1,y,z+1,dimension)] || t.default
+				const north = t[world.getBiome(x,y,z-1,dimension)] || t.default
+				const south = t[world.getBiome(x,y,z+1,dimension)] || t.default
+				const east = t[world.getBiome(x-1,y,z,dimension)] || t.default
+				const west = t[world.getBiome(x+1,y,z,dimension)] || t.default
+				const northeast = t[world.getBiome(x-1,y,z-1,dimension)] || t.default
+				const southeast = t[world.getBiome(x-1,y,z+1,dimension)] || t.default
+				const northwest = t[world.getBiome(x+1,y,z-1,dimension)] || t.default
+				const southwest = t[world.getBiome(x+1,y,z+1,dimension)] || t.default
 				let noisene = 0, noisese = 0, noisenw = 0, noisesw = 0
 				if(max(north.length,south.length,east.length,west.length,northeast.length,southeast.length,northwest.length,southwest.length)>3){
 					noisene = (tintNoise.noise2d((x-0.5)*0.1,(z-0.5)*0.1)>0)*3
@@ -13126,43 +12897,29 @@
 				averageTint(ret,3,tint,north,west,northwest,noisenw)
 				averageTint(ret,6,tint,south,west,southwest,noisesw)
 				averageTint(ret,9,tint,south,east,southeast,noisese)
-        return ret
-      }
-      if(tint){
-        ret[0] = ret[3] = ret[6] = ret[9] = tint[0] || 0
-        ret[1] = ret[4] = ret[7] = ret[10] = tint[1] || 0
-        ret[2] = ret[5] = ret[8] = ret[11] = tint[2] || 0
-      }else{
-        ret[0] = ret[1] = ret[2] = ret[3] = ret[4] = ret[5] = ret[6] = ret[7] = ret[8] = ret[9] = ret[10] = ret[11] = 1
-      }
-      return ret
+			}else this.none(ret)
+			return ret
     },
     top: function(x,y,z,ret,dimension,block,tags){
-      let side = "tagTintPropertyTop"
-      let tint = null
-      if(block[side]){
-        let name = block[side]
-        let tag = getTag(tags,name,block)
-        tint = block.tint[tag || 0]
-      }
-      if(block.biomeTintTop){
-        let b = world.getBiome(x,y,z,dimension)
-        let t = block.tint
-        tint = t[b] || t.default
+			let tint
+			let b = block.tagTint ? getTag(tags,block.tagTint,block) : world.getBiome(x,y,z,dimension)
+			let t = block.tint
+			if(t){
+				tint = t[b] || t[0] || t.default
 				if(performFast){
 					ret[0] = ret[3] = ret[6] = ret[9] = tint[0]
 					ret[1] = ret[4] = ret[7] = ret[10] = tint[1]
 					ret[2] = ret[5] = ret[8] = ret[11] = tint[2]
 					return ret
 				}
-        const north = t[world.getBiome(x,y,z-1,dimension)] || t.default
-        const south = t[world.getBiome(x,y,z+1,dimension)] || t.default
-        const east = t[world.getBiome(x-1,y,z,dimension)] || t.default
-        const west = t[world.getBiome(x+1,y,z,dimension)] || t.default
-        const northeast = t[world.getBiome(x-1,y,z-1,dimension)] || t.default
-        const southeast = t[world.getBiome(x-1,y,z+1,dimension)] || t.default
-        const northwest = t[world.getBiome(x+1,y,z-1,dimension)] || t.default
-        const southwest = t[world.getBiome(x+1,y,z+1,dimension)] || t.default
+				const north = t[world.getBiome(x,y,z-1,dimension)] || t.default
+				const south = t[world.getBiome(x,y,z+1,dimension)] || t.default
+				const east = t[world.getBiome(x-1,y,z,dimension)] || t.default
+				const west = t[world.getBiome(x+1,y,z,dimension)] || t.default
+				const northeast = t[world.getBiome(x-1,y,z-1,dimension)] || t.default
+				const southeast = t[world.getBiome(x-1,y,z+1,dimension)] || t.default
+				const northwest = t[world.getBiome(x+1,y,z-1,dimension)] || t.default
+				const southwest = t[world.getBiome(x+1,y,z+1,dimension)] || t.default
 				let noisene = 0, noisese = 0, noisenw = 0, noisesw = 0
 				if(max(north.length,south.length,east.length,west.length,northeast.length,southeast.length,northwest.length,southwest.length)>3){
 					noisene = (tintNoise.noise2d((x-0.5)*0.1,(z-0.5)*0.1)>0)*3
@@ -13174,43 +12931,29 @@
 				averageTint(ret,3,tint,south,west,southwest,noisesw)
 				averageTint(ret,6,tint,north,west,northwest,noisenw)
 				averageTint(ret,9,tint,north,east,northeast,noisene)
-        return ret
-      }
-      if(tint){
-        ret[0] = ret[3] = ret[6] = ret[9] = tint[0] || 0
-        ret[1] = ret[4] = ret[7] = ret[10] = tint[1] || 0
-        ret[2] = ret[5] = ret[8] = ret[11] = tint[2] || 0
-      }else{
-        ret[0] = ret[1] = ret[2] = ret[3] = ret[4] = ret[5] = ret[6] = ret[7] = ret[8] = ret[9] = ret[10] = ret[11] = 1
-      }
-      return ret
+			}else this.none(ret)
+			return ret
     },
     north: function(x,y,z,ret,dimension,block,tags){
-      let side = "tagTintPropertyNorth"
-      let tint = null
-      if(block[side]){
-        let name = block[side]
-        let tag = getTag(tags,name,block)
-        tint = block.tint[tag || 0]
-      }
-      if(block.biomeTintNorth){
-        let b = world.getBiome(x,y,z,dimension)
-        let t = block.tint
-        tint = t[b] || t.default
+			let tint
+			let b = block.tagTint ? getTag(tags,block.tagTint,block) : world.getBiome(x,y,z,dimension)
+			let t = block.tint
+			if(t){
+				tint = t[b] || t[0] || t.default
 				if(performFast){
 					ret[0] = ret[3] = ret[6] = ret[9] = tint[0]
 					ret[1] = ret[4] = ret[7] = ret[10] = tint[1]
 					ret[2] = ret[5] = ret[8] = ret[11] = tint[2]
 					return ret
 				}
-        const north = t[world.getBiome(x,y+1,z,dimension)] || t.default
-        const south = t[world.getBiome(x,y-1,z,dimension)] || t.default
-        const east = t[world.getBiome(x+1,y,z,dimension)] || t.default
-        const west = t[world.getBiome(x-1,y,z,dimension)] || t.default
-        const northeast = t[world.getBiome(x+1,y+1,z,dimension)] || t.default
-        const southeast = t[world.getBiome(x+1,y-1,z,dimension)] || t.default
-        const northwest = t[world.getBiome(x-1,y+1,z,dimension)] || t.default
-        const southwest = t[world.getBiome(x-1,y-1,z,dimension)] || t.default
+				const north = t[world.getBiome(x,y+1,z,dimension)] || t.default
+				const south = t[world.getBiome(x,y-1,z,dimension)] || t.default
+				const east = t[world.getBiome(x+1,y,z,dimension)] || t.default
+				const west = t[world.getBiome(x-1,y,z,dimension)] || t.default
+				const northeast = t[world.getBiome(x+1,y+1,z,dimension)] || t.default
+				const southeast = t[world.getBiome(x+1,y-1,z,dimension)] || t.default
+				const northwest = t[world.getBiome(x-1,y+1,z,dimension)] || t.default
+				const southwest = t[world.getBiome(x-1,y-1,z,dimension)] || t.default
 				let noisene = 0, noisese = 0, noisenw = 0, noisesw = 0
 				if(max(north.length,south.length,east.length,west.length,northeast.length,southeast.length,northwest.length,southwest.length)>3){
 					noisene = noisese = (tintNoise.noise2d((x+0.5)*0.1,z*0.1)>0)*3
@@ -13220,43 +12963,29 @@
 				averageTint(ret,3,tint,north,west,northwest,noisenw)
 				averageTint(ret,6,tint,south,west,southwest,noisesw)
 				averageTint(ret,9,tint,south,east,southeast,noisese)
-        return ret
-      }
-      if(tint){
-        ret[0] = ret[3] = ret[6] = ret[9] = tint[0] || 0
-        ret[1] = ret[4] = ret[7] = ret[10] = tint[1] || 0
-        ret[2] = ret[5] = ret[8] = ret[11] = tint[2] || 0
-      }else{
-        ret[0] = ret[1] = ret[2] = ret[3] = ret[4] = ret[5] = ret[6] = ret[7] = ret[8] = ret[9] = ret[10] = ret[11] = 1
-      }
-      return ret
+			}else this.none(ret)
+			return ret
     },
     south: function(x,y,z,ret,dimension,block,tags){
-      let side = "tagTintPropertySouth"
-      let tint = null
-      if(block[side]){
-        let name = block[side]
-        let tag = getTag(tags,name,block)
-        tint = block.tint[tag || 0]
-      }
-      if(block.biomeTintSouth){
-        let b = world.getBiome(x,y,z,dimension)
-        let t = block.tint
-        tint = t[b] || t.default
+			let tint
+			let b = block.tagTint ? getTag(tags,block.tagTint,block) : world.getBiome(x,y,z,dimension)
+			let t = block.tint
+			if(t){
+				tint = t[b] || t[0] || t.default
 				if(performFast){
 					ret[0] = ret[3] = ret[6] = ret[9] = tint[0]
 					ret[1] = ret[4] = ret[7] = ret[10] = tint[1]
 					ret[2] = ret[5] = ret[8] = ret[11] = tint[2]
 					return ret
 				}
-        const north = t[world.getBiome(x,y+1,z,dimension)] || t.default
-        const south = t[world.getBiome(x,y-1,z,dimension)] || t.default
-        const east = t[world.getBiome(x-1,y,z,dimension)] || t.default
-        const west = t[world.getBiome(x+1,y,z,dimension)] || t.default
-        const northeast = t[world.getBiome(x-1,y+1,z,dimension)] || t.default
-        const southeast = t[world.getBiome(x-1,y-1,z,dimension)] || t.default
-        const northwest = t[world.getBiome(x+1,y+1,z,dimension)] || t.default
-        const southwest = t[world.getBiome(x+1,y-1,z,dimension)] || t.default
+				const north = t[world.getBiome(x,y+1,z,dimension)] || t.default
+				const south = t[world.getBiome(x,y-1,z,dimension)] || t.default
+				const east = t[world.getBiome(x-1,y,z,dimension)] || t.default
+				const west = t[world.getBiome(x+1,y,z,dimension)] || t.default
+				const northeast = t[world.getBiome(x-1,y+1,z,dimension)] || t.default
+				const southeast = t[world.getBiome(x-1,y-1,z,dimension)] || t.default
+				const northwest = t[world.getBiome(x+1,y+1,z,dimension)] || t.default
+				const southwest = t[world.getBiome(x+1,y-1,z,dimension)] || t.default
 				let noisene = 0, noisese = 0, noisenw = 0, noisesw = 0
 				if(max(north.length,south.length,east.length,west.length,northeast.length,southeast.length,northwest.length,southwest.length)>3){
 					noisene = noisese = (tintNoise.noise2d((x-0.5)*0.1,z*0.1)>0)*3
@@ -13266,43 +12995,29 @@
 				averageTint(ret,3,tint,north,west,northwest,noisenw)
 				averageTint(ret,6,tint,south,west,southwest,noisesw)
 				averageTint(ret,9,tint,south,east,southeast,noisese)
-        return ret
-      }
-      if(tint){
-        ret[0] = ret[3] = ret[6] = ret[9] = tint[0] || 0
-        ret[1] = ret[4] = ret[7] = ret[10] = tint[1] || 0
-        ret[2] = ret[5] = ret[8] = ret[11] = tint[2] || 0
-      }else{
-        ret[0] = ret[1] = ret[2] = ret[3] = ret[4] = ret[5] = ret[6] = ret[7] = ret[8] = ret[9] = ret[10] = ret[11] = 1
-      }
-      return ret
+			}else this.none(ret)
+			return ret
     },
     east: function(x,y,z,ret,dimension,block,tags){
-      let side = "tagTintPropertyEast"
-      let tint = null
-      if(block[side]){
-        let name = block[side]
-        let tag = getTag(tags,name,block)
-        tint = block.tint[tag || 0]
-      }
-      if(block.biomeTintEast){
-        let b = world.getBiome(x,y,z,dimension)
-        let t = block.tint
-        tint = t[b] || t.default
+			let tint
+			let b = block.tagTint ? getTag(tags,block.tagTint,block) : world.getBiome(x,y,z,dimension)
+			let t = block.tint
+			if(t){
+				tint = t[b] || t[0] || t.default
 				if(performFast){
 					ret[0] = ret[3] = ret[6] = ret[9] = tint[0]
 					ret[1] = ret[4] = ret[7] = ret[10] = tint[1]
 					ret[2] = ret[5] = ret[8] = ret[11] = tint[2]
 					return ret
 				}
-        const north = t[world.getBiome(x,y+1,z,dimension)] || t.default
-        const south = t[world.getBiome(x,y-1,z,dimension)] || t.default
-        const east = t[world.getBiome(x,y,z-1,dimension)] || t.default
-        const west = t[world.getBiome(x,y,z+1,dimension)] || t.default
-        const northeast = t[world.getBiome(x,y+1,z-1,dimension)] || t.default
-        const southeast = t[world.getBiome(x,y-1,z-1,dimension)] || t.default
-        const northwest = t[world.getBiome(x,y+1,z+1,dimension)] || t.default
-        const southwest = t[world.getBiome(x,y-1,z+1,dimension)] || t.default
+				const north = t[world.getBiome(x,y+1,z,dimension)] || t.default
+				const south = t[world.getBiome(x,y-1,z,dimension)] || t.default
+				const east = t[world.getBiome(x,y,z-1,dimension)] || t.default
+				const west = t[world.getBiome(x,y,z+1,dimension)] || t.default
+				const northeast = t[world.getBiome(x,y+1,z-1,dimension)] || t.default
+				const southeast = t[world.getBiome(x,y-1,z-1,dimension)] || t.default
+				const northwest = t[world.getBiome(x,y+1,z+1,dimension)] || t.default
+				const southwest = t[world.getBiome(x,y-1,z+1,dimension)] || t.default
 				let noisene = 0, noisese = 0, noisenw = 0, noisesw = 0
 				if(max(north.length,south.length,east.length,west.length,northeast.length,southeast.length,northwest.length,southwest.length)>3){
 					noisene = noisese = (tintNoise.noise2d(x*0.1,(z-0.5)*0.1)>0)*3
@@ -13312,43 +13027,29 @@
 				averageTint(ret,3,tint,north,west,northwest,noisenw)
 				averageTint(ret,6,tint,south,west,southwest,noisesw)
 				averageTint(ret,9,tint,south,east,southeast,noisese)
-        return ret
-      }
-      if(tint){
-        ret[0] = ret[3] = ret[6] = ret[9] = tint[0] || 0
-        ret[1] = ret[4] = ret[7] = ret[10] = tint[1] || 0
-        ret[2] = ret[5] = ret[8] = ret[11] = tint[2] || 0
-      }else{
-        ret[0] = ret[1] = ret[2] = ret[3] = ret[4] = ret[5] = ret[6] = ret[7] = ret[8] = ret[9] = ret[10] = ret[11] = 1
-      }
-      return ret
+			}else this.none(ret)
+			return ret
     },
     west: function(x,y,z,ret,dimension,block,tags){
-      let side = "tagTintPropertyWest"
-      let tint = null
-      if(block[side]){
-        let name = block[side]
-        let tag = getTag(tags,name,block)
-        tint = block.tint[tag || 0]
-      }
-      if(block.biomeTintWest){
-        let b = world.getBiome(x,y,z,dimension)
-        let t = block.tint
-        tint = t[b] || t.default
+			let tint
+			let b = block.tagTint ? getTag(tags,block.tagTint,block) : world.getBiome(x,y,z,dimension)
+			let t = block.tint
+			if(t){
+				tint = t[b] || t[0] || t.default
 				if(performFast){
 					ret[0] = ret[3] = ret[6] = ret[9] = tint[0]
 					ret[1] = ret[4] = ret[7] = ret[10] = tint[1]
 					ret[2] = ret[5] = ret[8] = ret[11] = tint[2]
 					return ret
 				}
-        const north = t[world.getBiome(x,y+1,z,dimension)] || t.default
-        const south = t[world.getBiome(x,y-1,z,dimension)] || t.default
-        const east = t[world.getBiome(x,y,z+1,dimension)] || t.default
-        const west = t[world.getBiome(x,y,z-1,dimension)] || t.default
-        const northeast = t[world.getBiome(x,y+1,z+1,dimension)] || t.default
-        const southeast = t[world.getBiome(x,y-1,z+1,dimension)] || t.default
-        const northwest = t[world.getBiome(x,y+1,z-1,dimension)] || t.default
-        const southwest = t[world.getBiome(x,y-1,z-1,dimension)] || t.default
+				const north = t[world.getBiome(x,y+1,z,dimension)] || t.default
+				const south = t[world.getBiome(x,y-1,z,dimension)] || t.default
+				const east = t[world.getBiome(x,y,z+1,dimension)] || t.default
+				const west = t[world.getBiome(x,y,z-1,dimension)] || t.default
+				const northeast = t[world.getBiome(x,y+1,z+1,dimension)] || t.default
+				const southeast = t[world.getBiome(x,y-1,z+1,dimension)] || t.default
+				const northwest = t[world.getBiome(x,y+1,z-1,dimension)] || t.default
+				const southwest = t[world.getBiome(x,y-1,z-1,dimension)] || t.default
 				let noisene = 0, noisese = 0, noisenw = 0, noisesw = 0
 				if(max(north.length,south.length,east.length,west.length,northeast.length,southeast.length,northwest.length,southwest.length)>3){
 					noisene = noisese = (tintNoise.noise2d(x*0.1,(z+0.5)*0.1)>0)*3
@@ -13358,16 +13059,8 @@
 				averageTint(ret,3,tint,north,west,northwest,noisenw)
 				averageTint(ret,6,tint,south,west,southwest,noisesw)
 				averageTint(ret,9,tint,south,east,southeast,noisese)
-        return ret
-      }
-      if(tint){
-        ret[0] = ret[3] = ret[6] = ret[9] = tint[0] || 0
-        ret[1] = ret[4] = ret[7] = ret[10] = tint[1] || 0
-        ret[2] = ret[5] = ret[8] = ret[11] = tint[2] || 0
-      }else{
-        ret[0] = ret[1] = ret[2] = ret[3] = ret[4] = ret[5] = ret[6] = ret[7] = ret[8] = ret[9] = ret[10] = ret[11] = 1
-      }
-      return ret
+			}else this.none(ret)
+			return ret
     },
   }
 
@@ -13651,7 +13344,6 @@
 
 				shapeVerts = block.shape.verts
 				shapeTexVerts = block.shape.texVerts
-        shapeOriginalVerts = block.shape.originalVerts
 				shapeNormal = block.shape.normal
 
 				let texNum = 0
@@ -13661,16 +13353,12 @@
 						shadows = getShadows[side](x, y, z, blocks)
 						slights = getLight[side](x, y, z, skyLightChunks, slights, 0, block, x2,y2,z2)
 						blights = getLight[side](x, y, z, blockLightChunks, blights, 1, block, x2,y2,z2)
-            tints = getTint[side](x2, y2, z2, tints, this.type, block, tags)
 						let directionalFaces = shapeVerts[n]
 						for (let facei = 0; facei < directionalFaces.length; facei++) {
 							verts = directionalFaces[facei]
-              originalShapeVerts = shapeOriginalVerts[n][facei]
-							texVerts = textureCoords[textureMap[tex[texNum]]]
 							texShapeVerts = shapeTexVerts[n][facei]
-              if(originalShapeVerts && originalShapeVerts.t && textureMap[originalShapeVerts.t]){
-                texVerts = textureCoords[textureMap[originalShapeVerts.t]]
-              }
+              texVerts = textureCoords[textureMap[texShapeVerts.texture] || tex && textureMap[tex[texNum]] || textureMap.error]
+            	tints = texShapeVerts.tintindex>-1 ? getTint[side](x2, y2, z2, tints, this.type, block, tags) : getTint.none(tints)
 							if(block.customShape){
 								verts = verts.slice()
 								texShapeVerts = texShapeVerts.slice()
@@ -13682,7 +13370,7 @@
 								if(customTexture) texVerts = textureCoords[textureMap[customTexture]]
 								else if(customTexture === false) continue
 							}
-							if(block.randomRotate && (side === "top" && block.randomRotateTop || side === "bottom" && block.randomRotateBottom || side === "north" && block.randomRotateNorth || side === "east" && block.randomRotateEast || side === "south" && block.randomRotateSouth || side === "west" && block.randomRotateWest)){
+							/*if(block.randomRotate && (side === "top" && block.randomRotateTop || side === "bottom" && block.randomRotateBottom || side === "north" && block.randomRotateNorth || side === "east" && block.randomRotateEast || side === "south" && block.randomRotateSouth || side === "west" && block.randomRotateWest)){
 								if(block.randomRotate === "pattern"){
 									let i, j, e
 									if(n === 0 || n === 1){
@@ -13702,7 +13390,7 @@
 									if(block.randomRotate === "flip") randomRotate = floor(randomRotate*2)*2
 									else randomRotate = floor(randomRotate*4)
 								}
-							}else randomRotate = 0
+							}else randomRotate = 0*/
 							/*texIdx0 = ((randomRotate)&3)*2
 							texIdx1 = ((randomRotate+1)&3)*2
 							texIdx2 = ((randomRotate+2)&3)*2
@@ -13711,7 +13399,7 @@
 							tsx1 = texShapeVerts[2], tsy1 = texShapeVerts[3]
 							tsx2 = texShapeVerts[4], tsy2 = texShapeVerts[5]
 							tsx3 = texShapeVerts[6], tsy3 = texShapeVerts[7]
-							if(randomRotate === 2){
+							/*if(randomRotate === 2){
 								tsx0 = 1-tsx0, tsy0 = 1-tsy0
 								tsx1 = 1-tsx1, tsy1 = 1-tsy1
 								tsx2 = 1-tsx2, tsy2 = 1-tsy2
@@ -13734,7 +13422,7 @@
 								tsx2 = 1-tsy2, tsy2 = tstemp
 								tstemp = tsx3
 								tsx3 = 1-tsy3, tsy3 = tstemp
-							}
+							}*/
 							normal = shapeNormal[n][facei]
 							if(!block.shade) shadows.fill(-1)
 
@@ -13828,33 +13516,33 @@
 				let under = world.getBlock(x,y-1,z,this.type)
 				let under2 = world.getBlock(x,y-2,z,this.type)
 				if(f && !(under && blockData[under].solid)){
-					world.addParticle(new entities[entityIds.FallingDustParticle](x+rand(-0.5,0.5),y-0.5,z+rand(-0.5,0.5),f),this.type)
+					world.addParticle(new FallingDustParticle(x+rand(-0.5,0.5),y-0.5,z+rand(-0.5,0.5),f),this.type)
 				}
 				if(f && under && blockData[under].leaves && !(under2 && blockData[under2].solid)){
-					world.addParticle(new entities[entityIds.FallingDustParticle](x+rand(-0.5,0.5),y-1.5,z+rand(-0.5,0.5),f),this.type)
+					world.addParticle(new FallingDustParticle(x+rand(-0.5,0.5),y-1.5,z+rand(-0.5,0.5),f),this.type)
 				}
 				if(d && under && blockData[under].solid && !(under2 && (blockData[under2].solid || blockData[under2].liquid))){
-					world.addParticle(new entities[entityIds.DripParticle](x+rand(-0.5,0.5),y-1.51,z+rand(-0.5,0.5),d, blockData[block].name === "Water"),this.type)
+					world.addParticle(new DripParticle(x+rand(-0.5,0.5),y-1.51,z+rand(-0.5,0.5),d, blockData[block].name === "Water"),this.type)
 				}
 				if(blockData[block].clientTick){
 					blockData[block].clientTick(block,x,y,z,this.type,this.world)
 				}
 				if(dr){
-					if(!(under && blockData[under].solid)) world.addParticle(new entities[entityIds.DripParticle](x+rand(-0.5,0.5),y-0.51,z+rand(-0.5,0.5),dr),this.type)
+					if(!(under && blockData[under].solid)) world.addParticle(new DripParticle(x+rand(-0.5,0.5),y-0.51,z+rand(-0.5,0.5),dr),this.type)
 					let s = world.getBlock(x,y+1,z,this.type)
-					if(!(s && blockData[s].solid)) world.addParticle(new entities[entityIds.DripParticle](x+rand(-0.5,0.5),y+0.51,z+rand(-0.5,0.5),dr),this.type)
+					if(!(s && blockData[s].solid)) world.addParticle(new DripParticle(x+rand(-0.5,0.5),y+0.51,z+rand(-0.5,0.5),dr),this.type)
 					s = world.getBlock(x,y,z+1,this.type)
-					if(!(s && blockData[s].solid)) world.addParticle(new entities[entityIds.DripParticle](x+rand(-0.5,0.5),y+rand(-0.5,0.5),z+0.51,dr),this.type)
+					if(!(s && blockData[s].solid)) world.addParticle(new DripParticle(x+rand(-0.5,0.5),y+rand(-0.5,0.5),z+0.51,dr),this.type)
 					s = world.getBlock(x,y,z-1,this.type)
-					if(!(s && blockData[s].solid)) world.addParticle(new entities[entityIds.DripParticle](x+rand(-0.5,0.5),y+rand(-0.5,0.5),z-0.51,dr),this.type)
+					if(!(s && blockData[s].solid)) world.addParticle(new DripParticle(x+rand(-0.5,0.5),y+rand(-0.5,0.5),z-0.51,dr),this.type)
 					s = world.getBlock(x+1,y,z,this.type)
-					if(!(s && blockData[s].solid)) world.addParticle(new entities[entityIds.DripParticle](x+0.51,y+rand(-0.5,0.5),z+rand(-0.5,0.5),dr),this.type)
+					if(!(s && blockData[s].solid)) world.addParticle(new DripParticle(x+0.51,y+rand(-0.5,0.5),z+rand(-0.5,0.5),dr),this.type)
 					s = world.getBlock(x-1,y,z,this.type)
-					if(!(s && blockData[s].solid)) world.addParticle(new entities[entityIds.DripParticle](x-0.51,y+rand(-0.5,0.5),z+rand(-0.5,0.5),dr),this.type)
+					if(!(s && blockData[s].solid)) world.addParticle(new DripParticle(x-0.51,y+rand(-0.5,0.5),z+rand(-0.5,0.5),dr),this.type)
 				}
 				if(blockData[block].name === "pointedDripstone" && !(under && blockData[under].solid)){
 					let above = world.getBlock(x,y+2,z,this.type)
-					world.addParticle(new entities[entityIds.DripParticle](x,y-0.51,z,blockData[above].dripThroughBlocks||blockData[blockIds.Water].dripThroughBlocks, blockData[above].name === "Water"),this.type)
+					world.addParticle(new DripParticle(x,y-0.51,z,blockData[above].dripThroughBlocks||blockData[blockIds.Water].dripThroughBlocks, blockData[above].name === "Water"),this.type)
 				}
 			}
 		}
@@ -13948,7 +13636,6 @@
 			this.weatherVAO = glExtensions.vertex_array_object.createVertexArrayOES()
 			this.updateWeather = false
 			this.entities = {}
-			this.columnHashs = new Uint8Array(16 * 16)//used to detect when column changes
 		}
 		getBlock(x, y, z) {
 			y -= minHeight
@@ -13974,7 +13661,6 @@
       }
 			this.sections[y >> 4].setBlock(x, y & 15, z, blockID)
 			this.updateSolidTop(x,py,z,blockID)
-			this.columnHashs[z*16+x]++
 		}
 		updateSolidTop(x,y,z,blockID){
 			if(blockID && (blockData[blockID].solid || blockData[blockID].liquid)){
@@ -14003,7 +13689,6 @@
 			this.minY = py < this.minY ? py : this.minY
 			this.maxY = py > this.maxY ? py : this.maxY
 			this.updateSolidTop(x,py,z,0)
-			this.columnHashs[z*16+x]++
 		}
     getTags(x, y, z){
 			y -= minHeight
@@ -14527,11 +14212,11 @@
 				if(blockData[block].leaves){
 					let under = this.getBlock(x,y-1,z)
 					if(blockData[under].transparent && rand()>0.5){
-						world.addParticle(new entities[entityIds.DripParticle](this.x+x+rand(-0.5,0.5),y-0.51,this.z+z+rand(-0.5,0.5),blockData[blockIds.Water].dripThroughBlocks, true),this.type)
+						world.addParticle(new DripParticle(this.x+x+rand(-0.5,0.5),y-0.51,this.z+z+rand(-0.5,0.5),blockData[blockIds.Water].dripThroughBlocks, true),this.type)
 						break rain
 					}
 				}
-				this.world.addParticle(new entities[entityIds.SplashParticle](x+this.x,y+0.75,z+this.z),this.type)
+				this.world.addParticle(new SplashParticle(x+this.x,y+0.75,z+this.z),this.type)
 			}
 		}
 		load(data) {
@@ -14865,7 +14550,7 @@
     modelMatrix: new Matrix()
   }
   
-  function generateVAO(shape, textureX, textureY, textureW, textureH, cached){
+  function generateVAO(shape, textureX, textureY, textureW, textureH, cached, replaceTextures){
     const shapeVerts = shape.verts
     const shapeTexVerts = shape.texVerts
     const size = shape.size
@@ -14879,16 +14564,16 @@
 			let side = blockSides[n]
 			let directionalFaces = shapeVerts[n]
 			for (let facei = 0; facei < directionalFaces.length; facei++) {
-				let originalShapeVerts = shape.originalVerts[n][facei]
+				let texShapeVerts = shapeTexVerts[n][facei]
 				let tx = textureX, ty = textureY, tw = textureW, th = textureH
-				if(originalShapeVerts && originalShapeVerts.t && textureMap[originalShapeVerts.t]){
-					let texVerts = textureCoords[textureMap[originalShapeVerts.t]]
+				if(texShapeVerts.texture){
+					let texVerts = textureCoords[textureMap[texShapeVerts.texture]]
+					if(replaceTextures && replaceTextures[texShapeVerts.texture]) texVerts = textureCoords[textureMap[replaceTextures[texShapeVerts.texture]]]
 					tx = texVerts[0]
 					ty = texVerts[1]
 					tw = texVerts[2]-tx
 					th = texVerts[5]-ty
 				}
-				let texShapeVerts = shapeTexVerts[n][facei]
 				texture[index    ] = tx + texShapeVerts[0]*tw
 				texture[index + 1] = ty + texShapeVerts[1]*th
 				texture[index + 2] = tx + texShapeVerts[2]*tw
@@ -14932,6 +14617,74 @@
     glExtensions.vertex_array_object.bindVertexArrayOES(null)
     return {vao, size}
   }
+	function generateVAOMultipleShape(shapes){
+		let blockSides = Object.keys(Block)
+		let texture = []
+		let index = 0
+		let normal = []
+		let size = 0
+		let verts = []
+		for(let i=0; i<shapes.length; i++){
+			let shape = shapes[i]
+			const shapeVerts = shape.verts
+			const shapeTexVerts = shape.texVerts
+			size += shape.size
+			const shapeNormal = shape.normal
+			for (let n = 0; n < 6; n++) {
+				let side = blockSides[n]
+				let directionalFaces = shapeVerts[n]
+				for (let facei = 0; facei < directionalFaces.length; facei++) {
+					let texShapeVerts = shapeTexVerts[n][facei]
+					let tx = 0, ty = 0, tw = 0, th = 0
+					if(texShapeVerts.texture){
+						let texVerts = textureCoords[textureMap[texShapeVerts.texture]]
+						tx = texVerts[0]
+						ty = texVerts[1]
+						tw = texVerts[2]-tx
+						th = texVerts[5]-ty
+					}
+					texture[index    ] = tx + texShapeVerts[0]*tw
+					texture[index + 1] = ty + texShapeVerts[1]*th
+					texture[index + 2] = tx + texShapeVerts[2]*tw
+					texture[index + 3] = ty + texShapeVerts[3]*th
+					texture[index + 4] = tx + texShapeVerts[4]*tw
+					texture[index + 5] = ty + texShapeVerts[5]*th
+					texture[index + 6] = tx + texShapeVerts[6]*tw
+					texture[index + 7] = ty + texShapeVerts[7]*th
+					index += 8
+					normal.push(...shapeNormal[n][facei],...shapeNormal[n][facei],...shapeNormal[n][facei],...shapeNormal[n][facei])
+				}
+			}
+			verts.push(shapeVerts)
+		}
+		const vao = glExtensions.vertex_array_object.createVertexArrayOES()
+		const verticesBuffer = gl.createBuffer()
+		const textureBuffer = gl.createBuffer()
+		const normalBuffer = gl.createBuffer()
+		vao.tHeVerticesBuffer = verticesBuffer
+		vao.tHeTextureBuffer = textureBuffer
+		vao.tHeNormalBuffer = normalBuffer
+		glExtensions.vertex_array_object.bindVertexArrayOES(vao)
+		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
+
+		gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
+		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts.flat(Infinity)), gl.STATIC_DRAW)
+		gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)
+
+		gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
+		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
+		gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
+
+		gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer)
+		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normal), gl.STATIC_DRAW)
+		gl.vertexAttribPointer(glCache.aNormalEntity, 3, gl.FLOAT, false, 0, 0)
+
+		gl.enableVertexAttribArray(glCache.aVertexEntity)
+		gl.enableVertexAttribArray(glCache.aTextureEntity)
+		gl.enableVertexAttribArray(glCache.aNormalEntity)
+    glExtensions.vertex_array_object.bindVertexArrayOES(null)
+    return {vao, size}
+  }
 	function generatParticleVAO(shape, textureX, textureY, textureW, textureH, cached){
     const shapeVerts = shape.verts
     const shapeTexVerts = shape.texVerts
@@ -14945,15 +14698,15 @@
 			let side = blockSides[n]
 			let directionalFaces = shapeVerts[n]
 			for (let facei = 0; facei < directionalFaces.length; facei++) {
-				let originalShapeVerts = shape.originalVerts[n][facei]
+				//let originalShapeVerts = shape.originalVerts[n][facei]//todo n
 				let tx = textureX, ty = textureY, tw = textureW, th = textureH
-				if(originalShapeVerts && originalShapeVerts.t && textureMap[originalShapeVerts.t]){
+				/*if(originalShapeVerts && originalShapeVerts.t && textureMap[originalShapeVerts.t]){
 					let texVerts = textureCoords[textureMap[originalShapeVerts.t]]
 					tx = texVerts[0]
 					ty = texVerts[1]
 					tw = texVerts[2]-tx
 					th = texVerts[5]-ty
-				}
+				}*/
 				let texShapeVerts = shapeTexVerts[n][facei]
 				texture[index    ] = tx + texShapeVerts[0]*tw
 				texture[index + 1] = ty + texShapeVerts[1]*th
@@ -15007,17 +14760,16 @@
 			let side = blockSides[n]
 			let directionalFaces = shapeVerts[n]
 			for (let facei = 0; facei < directionalFaces.length; facei++) {
-				let texVerts = textureCoords[textureMap[tex[texNum]]]
-				let originalShapeVerts = shape.originalVerts[n][facei]
-				if(originalShapeVerts && originalShapeVerts.t){
-					if(replaceTextures && replaceTextures[originalShapeVerts.t]) texVerts = textureCoords[textureMap[replaceTextures[originalShapeVerts.t]]]
-					else if(textureMap[originalShapeVerts.t]) texVerts = textureCoords[textureMap[originalShapeVerts.t]]
-				}
+				let texShapeVerts = shapeTexVerts[n][facei]
+				let texVerts
+				if(texShapeVerts.texture){
+					if(replaceTextures && replaceTextures[texShapeVerts.texture]) texVerts = textureCoords[textureMap[replaceTextures[texShapeVerts.texture]]]
+					else texVerts = textureCoords[textureMap[texShapeVerts.texture]]
+				}else texVerts = textureCoords[tex && textureMap[tex[texNum]] || textureMap.error]
 				let tx = texVerts[0]
 				let ty = texVerts[1]
 				let tw = texVerts[2]-tx
 				let th = texVerts[5]-ty
-				let texShapeVerts = shapeTexVerts[n][facei]
 				texture[index    ] = tx + texShapeVerts[0]*tw
 				texture[index + 1] = ty + texShapeVerts[1]*th
 				texture[index + 2] = tx + texShapeVerts[2]*tw
@@ -15057,49 +14809,20 @@
 		return {vao, size}
 	}
 
-	let entities = [], entityIds = {}
-	class Entity {
+	let entities = []
+	let {serverEntities} = win
+	class Entity extends win.serverEntity {
 		constructor(x, y, z, pitch, yaw, velx, vely, velz, width, height, depth, vertices, texture, faces, despawns, vao, dimension) {
-			this.x = x
-			this.y = y
-			this.z = z
-			this.previousX = x
-			this.previousY = y
-			this.previousZ = z
-			this.canStepX = true
-			this.canStepY = true
-			this.pitch = pitch
-			this.yaw = yaw
-			this.roll = 0
+			super(...arguments)
 			this.pitch2 = 0
-      this.previousPitch = pitch
-      this.previousYaw = yaw
-			this.previousRoll = 0
 			this.previousPitch2 = 0
-			this.velx = velx
-			this.vely = vely
-			this.velz = velz
-			this.width = width
-			this.height = height
-			this.depth = depth
       this.offsetY = 0
       this.prevOffsetY = 0
       this.extraSize = 0
       this.hidden = false
       this.harmEffect = 0
-			this.contacts = new Contacts()
-			this.lastUpdate = performance.now()
-			this.onGround = false
-      this.hasCollided = false
-      this.gravityStength = -0.091
-      this.standingOn = 0
-      this.insideBlock = 0
-			this.despawns = despawns
-			this.spawn = this.lastUpdate
-			this.canDespawn = false
       this.dieEffect = 0
       this.dieRotate = 0
-      this.burning = false
       this.liquid = false
       this.prevLiquid = false
       this.wet = false
@@ -15107,17 +14830,13 @@
 			this.faces = faces
       this.shader = 0
 			this.world = world //also set in addEntity
-			this.chunkX = x >> 4
-			this.chunkZ = z >> 4
-			this.chunkDimension = ""
 			this.glow = false
 			this.canRide = false
 			this.lastPos = performance.now()
-			this.hitboxWidth = this.hitboxWidth || max(this.width,this.depth)//unused
-			this.hitboxHeight = this.hitboxHeight || this.height
 			this.rideOffsetX = 0
-			this.rideOffsetY = this.hitboxHeight/2
+			this.rideOffsetY = this.height/2
 			this.rideOffsetZ = 0
+			this.offsetry = 0
       if(vao){
         this.vao = vao
 				if(vao.tHeVerticesBuffer){
@@ -15144,7 +14863,6 @@
         gl.enableVertexAttribArray(glCache.aTextureEntity)
         glExtensions.vertex_array_object.bindVertexArrayOES(null)
       }
-      this.dimension = dimension
 			this.targetX = x
 			this.targetY = y
 			this.targetZ = z
@@ -15165,100 +14883,6 @@
 				this.vely += (this.vely * drag - this.vely)
 			}
 		}
-		collided(x, y, z, vx, vy, vz, block) {
-			let verts = blockData[block].shape.verts
-			let px = this.x - this.width / 2 - x
-			let py = this.y - this.height / 2 - y
-			let pz = this.z - this.depth / 2 - z
-			let pxx = this.x + this.width / 2 - x
-			let pyy = this.y + this.height / 2 - y
-			let pzz = this.z + this.depth / 2 - z
-			let minX, minY, minZ, maxX, maxY, maxZ, min, max
-    	let stuckInBlock = this.mob && this.insideBlock && blockData[this.insideBlock].solid
-
-			//Top and bottom faces
-			let faces = verts[0]
-			if (vy <= 0) {
-				faces = verts[1]
-			}
-			if (vx === null && vz === null) {
-        let col = false
-				for (let face of faces) {
-					min = face.min
-					minX = min[0]
-					minZ = min[2]
-					max = face.max
-					maxX = max[0]
-					maxZ = max[2]
-					if (face[1] > py && face[1] < pyy && minX < pxx && maxX > px && minZ < pzz && maxZ > pz) {
-            col = true
-						if (vy <= 0) {
-							this.onGround = true
-							if(!stuckInBlock) this.y = face[1] + y + this.height / 2; else this.y = this.previousY
-							this.vely = 0
-						} else {
-							if(!stuckInBlock) this.y = face[1] + y - this.height / 2; else this.y = this.previousY
-              this.vely = 0
-						}
-					}
-				}
-				return col
-			}
-
-			//West and East faces
-			if (vx < 0) {
-				faces = verts[4]
-			} else if (vx > 0) {
-				faces = verts[5]
-			}
-			if (vx !== null) {
-				let col = false
-				for (let face of faces) {
-					min = face.min
-					minZ = min[2]
-					minY = min[1]
-					max = face.max
-					maxZ = max[2]
-					maxY = max[1]
-					if (face[0] > px && face[0] < pxx && minY < pyy && maxY > py && minZ < pzz && maxZ > pz) {
-						if (maxY - py > 0.5) {
-							this.canStepX = false
-							if(!stuckInBlock) this.x = x + face[0] + (vx < 0 ? this.width / 2 : -this.width / 2); else this.y = this.previousX
-              this.velx = 0
-						}
-						col = true
-					}
-				}
-				return col
-			}
-
-			//South and North faces
-			if (vz < 0) {
-				faces = verts[2]
-			} else if (vz > 0) {
-				faces = verts[3]
-			}
-			if (vz !== null) {
-				let col = false
-				for (let face of faces) {
-					min = face.min
-					minX = min[0]
-					minY = min[1]
-					max = face.max
-					maxX = max[0]
-					maxY = max[1]
-					if (face[2] > pz && face[2] < pzz && minY < pyy && maxY > py && minX < pxx && maxX > px) {
-						if (maxY - py > 0.5) {
-							this.canStepZ = false
-							if(!stuckInBlock) this.z = z + face[2] + (vz < 0 ? this.depth / 2 : -this.depth / 2); else this.y = this.previousY
-              this.velz = 0
-						}
-						col = true
-					}
-				}
-				return col
-			}
-		}
 		move(now) {
       let steps = Math.ceil(max(abs(this.velx / (this.width/2)), abs(this.vely / (this.height/2)), abs(this.velz / (this.depth/2)), 1))
       const VX = this.velx / steps
@@ -15450,32 +15074,11 @@
 				if(chunk) chunk.entities[this.id] = this
 			}
 		}
-    moveTowards(x,y,z, rw, rh, rd, slowDown = 1, gravity){
-      var dist = dist3(this.x/rw,this.y/rh,this.z/rd,x/rw,y/rh,z/rd)
-      var aDist = abs(dist)
-      if(aDist > 1) return
-      var iDist = 1 - aDist //inverted distance
-      var velx = x-this.x
-      var vely = y-this.y
-      var velz = z-this.z
-      var mag = sqrt(velx * velx + vely * vely + velz * velz)
-      this.velx += velx*iDist/mag/slowDown
-      if(!gravity) this.vely = vely*iDist/mag/slowDown
-			else if(this.onGround) this.vely += vely*iDist/mag/slowDown*20
-      this.velz += velz*iDist/mag/slowDown
-      
-      /*var toX = lerp(iDist, this.x, x)
-      var toY = lerp(iDist, this.y, y)
-      var toZ = lerp(iDist, this.z, z)
-      this.velx = (toX - this.x) / slowDown * iDist
-      if(this.onGround) this.vely = (toY - this.y) / slowDown * iDist
-      this.velz = (toZ - this.z) / slowDown * iDist*/
-
-      /*var xd = this.x - p.x, zd = this.z - p.z;
-      var x = xd; this.velx = (x-(Math.sign(x)*7.25)) / 150
-      if(this.onGround) {var y = this.y - (p.y-p.bottomH); this.vely = (y-(Math.sign(y)*7.25)) / 40}
-      var z = zd; this.velz = (z-(Math.sign(z)*7.25)) / 150*/
-    }
+		update(){
+			this.updateVelocity(now)
+			this.move(now)
+			if(this.facesPlayer) this.facePlayer() //this.canFacePlayer = true
+		}
 		setPos(x,y,z,vx,vy,vz){
 			this.velx = vx
 			this.vely = vy
@@ -15491,14 +15094,15 @@
 				this.z = z
 			}
 		}
-		update() {
-			this.updateVelocity(now)
-			this.move(now)
-		}
 		render() {
       totalEntites++
       if(this.hidden || !p.camera.canSeeEntity(this.x,this.y,this.z,this.width+this.extraSize,this.height+this.extraSize,this.depth+this.extraSize)) return
       renderedEntities++
+
+			/*if(this.canFacePlayer) {
+        this.facePlayer()
+        this.canFacePlayer = false
+      }*/
       
       let diff = (now - this.lastUpdate) / tickTime
 			if (diff > 1) diff = 1
@@ -15514,8 +15118,13 @@
 			const modelMatrix = entityMatrices.modelMatrix;
 			modelMatrix.identity()
 			modelMatrix.translate(renderx, rendery, renderz)
-			modelMatrix.rotX(lerp(diff,this.previousPitch,this.pitch))
-			modelMatrix.rotY(lerp(diff,prevYaw,this.yaw))
+			if(this.rotSwapOrder){
+				modelMatrix.rotY(lerp(diff,prevYaw,this.yaw)+this.offsetry)
+				modelMatrix.rotX(lerp(diff,this.previousPitch,this.pitch))
+			}else{
+				modelMatrix.rotX(lerp(diff,this.previousPitch,this.pitch))
+				modelMatrix.rotY(lerp(diff,prevYaw,this.yaw)+this.offsetry)
+			}
 			if(this.pitch2 || this.previousPitch2) modelMatrix.rotX(lerp(diff,this.previousPitch2,this.pitch2))
 			if(this.roll || this.previousRoll) modelMatrix.rotZ(lerp(diff,this.previousRoll,this.roll))
 			if(this.dieRotate){
@@ -15552,11 +15161,13 @@
       if(this.shader) gl.uniform1i(glCache.shaderEntity, this.shader)
 			if(this.alwaysRender) gl.uniform3f(glCache.uPosEntity, 0, 0, 0)
 			else gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
-			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
-			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
-			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
-			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
-			glExtensions.vertex_array_object.bindVertexArrayOES(null)
+			if(this.vao){
+				gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
+				gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
+				glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
+				gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
+				glExtensions.vertex_array_object.bindVertexArrayOES(null)
+			}
       for(var part in this.parts){
         this.renderPart(this.parts[part], modelMatrix, modelViewProjectionMatrix, projectionMatrix, viewMatrix, renderx, rendery, renderz, blockLight)
       }
@@ -15569,6 +15180,36 @@
       }
 			if(this.nameText && (p.thirdPerson || this !== p.spectating && this !== p)) this.nameText.render()
 		}
+		setPartShapes(bones){
+			if(!Array.isArray(bones)) bones = [bones]
+			for(let i in bones[0]){
+				let shape = bones[0][i]
+				if(!this.parts[shape.boneName]){
+					let x=0,y=0,z=0, rx=0,ry=0,rz=0
+					let w=1,h=1,d=1
+					this.parts[shape.boneName] = {
+						name:shape.boneName,
+						size:null, vao:null,
+						x,y,z,w,h,d,rx,ry,rz,ry2:0, //x,y,z,rx,ry are relative to entity position
+						px:x,py:y,pz:z,prx:rx,pry:ry,prz:rz,
+						originalX:x, originalY:y, originalZ:z,
+						attached:shape.attached, attachChain:shape.attachChain,
+						pivot: shape.pivot
+					}
+				}
+				let part = this.parts[shape.boneName]
+				let shapes = []
+				for(let b=0; b<bones.length; b++){
+					if(!bones[b][i].hidden) shapes.push(bones[b][i])
+				}
+				if(shapes.length){
+					part.hidden = false
+					let vao = generateVAOMultipleShape(shapes)
+					part.size = vao.size
+					part.vao = vao.vao
+				}else part.hidden = true
+			}
+		}
     addPart(name,size,vao,x,y,z,w,h,d,rx,ry,rz = 0,attached = null,glow = false){
       let part =  this.parts[name] = {
         name,
@@ -15604,7 +15245,7 @@
 			if(this.yaw - prevYaw > Math.PI) prevYaw += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
 			if(this.yaw - prevYaw < -Math.PI) prevYaw -= Math.PId
 			modelMatrix.rotX(lerp(diff,this.previousPitch,this.pitch))
-			modelMatrix.rotY(lerp(diff,prevYaw,this.yaw))
+			modelMatrix.rotY(lerp(diff,prevYaw,this.yaw)+this.offsetry)
 			if(this.dieRotate){
 				modelMatrix.translate(0,-this.height/2,0)
 				modelMatrix.rotZ(this.dieRotate)
@@ -15615,6 +15256,7 @@
 				for(let partName of part.attachChain){
 					let part2 = this.parts[partName]
 					modelMatrix.translate(part2.x, part2.y, part2.z)
+					if(part2.pivot) modelMatrix.translate(part2.pivot[0], part2.pivot[1], part2.pivot[2])
 					prevYaw = part2.pry
 					if(part2.ry - prevYaw > Math.PI) prevYaw += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
 					if(part2.ry - prevYaw < -Math.PI) prevYaw -= Math.PId
@@ -15622,9 +15264,11 @@
 					if(part2.ry2) modelMatrix.rotY(lerp(diff,part2.pry2,part2.ry2))
 					modelMatrix.rotX(lerp(diff,part2.prx,part2.rx))
 					modelMatrix.rotY(lerp(diff,prevYaw,part2.ry))
+					if(part2.pivot) modelMatrix.translate(-part2.pivot[0], -part2.pivot[1], -part2.pivot[2])
 				}
 			}
 			modelMatrix.translate(part.x, part.y, part.z)
+			if(part.pivot) modelMatrix.translate(part.pivot[0], part.pivot[1], part.pivot[2])
 			prevYaw = part.pry
 			if(part.ry - prevYaw > Math.PI) prevYaw += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
 			if(part.ry - prevYaw < -Math.PI) prevYaw -= Math.PId
@@ -15632,6 +15276,7 @@
       if(part.ry2) modelMatrix.rotY(lerp(diff,part.pry2,part.ry2))
 			modelMatrix.rotX(lerp(diff,part.prx,part.rx))
 			modelMatrix.rotY(lerp(diff,prevYaw,part.ry))
+			if(part.pivot) modelMatrix.translate(-part.pivot[0], -part.pivot[1], -part.pivot[2])
       modelMatrix.scale(part.w, part.h, part.d)
       
       modelViewProjectionMatrix.identity()
@@ -15688,1528 +15333,6 @@
 			}
 		}
 	}
-
-	entities[entities.length] = class Item extends Entity {
-		static name2 = "Item"
-		constructor(x, y, z, velx, vely, velz, blockID, autoSetVel, amount, durability = null, name = null, from) {
-			super(x, y, z, 0, 0, velx, vely, velz, 0.25, 0.25, 0.25, null, null, 0, 300000/*1500000*/, glExtensions.vertex_array_object.createVertexArrayOES())
-      this.block = blockID
-      this.from = from || undefined
-      this.durability = durability
-      this.name = name
-      this.amount = amount || 1
-			this.updateShape()
-      this.gravityStength = -0.07
-      this.noHitbox = true
-      this.canFloat = true
-			this.cullFace = true
-      
-      if(autoSetVel){
-        this.velx = (Math.random()-0.5) * 0.2
-        this.vely = Math.random() * 0.2
-        this.velz = (Math.random()-0.5) * 0.2
-      }
-		}
-    goCloserToPlayer(e){
-      let xDist = this.x - e.x
-      let yDist = this.y - (e.y - e.height*0.5)
-      let zDist = this.z - e.z
-      var hRange = 1.425
-      let comeCloser = xDist > -hRange && xDist < hRange && yDist > -0.75 && yDist < 2.3 && zDist > -hRange && zDist < hRange
-      if(comeCloser){
-        this.moveTowards(e.x, Math.min(Math.max(this.y, e.y - e.height*0.5),e.y+e.height*0.5), e.z, hRange,2.3,hRange, 3)
-      }
-      /*if(pickup){
-        var dist = dist3(this.x, this.y, this.z, p.x, p.y, p.z)
-        var dist2 = dist3(this.x, this.y, this.z, p.x, p.y-1, p.z)
-        pickup = ((1 >= dist) && (dist >= -1)) || ((1 >= dist2) && (dist2 >= -1))
-      }*/
-    }
-    update() {
-			this.updateVelocity(now)
-		  this.move(now)
-      
-      this.yaw += 0.05;
-      if(this.yaw > Math.PId){
-        this.yaw -= Math.PId
-        this.previousYaw -= Math.PId
-      }
-      
-      if(now - this.spawn > 1000){
-        if(!p.spectator && !p.die && p.dimension === this.dimension) this.goCloserToPlayer(p)
-        if(multiplayer) for(var i in players){
-          var P = players[i]
-          if(!P.hidden && !P.die && P.dimension === this.dimension) this.goCloserToPlayer(P)
-        }
-      }
-      
-      if(this.willUpdateShape){
-        this.updateShape()
-        this.willUpdateShape = false
-      }
-      
-      this.offsetY = -0.1 * cos(this.yaw*2) + 0.15
-      
-      let id = this.block
-      if(id && blockData[id].tint){
-        let biome = this.world.getBiome(round(this.x),round(this.y),round(this.z),this.dimension)
-        let tints = blockData[id].tint
-        this.tint = tints[biome] || tints.default
-        this.tintGray = true
-      }
-    }
-		shape1 = [0,0,0]
-		shape2 = [-1,-1,-1, 1,1,1]
-		shape3 = [-1,-1,-1, 1,1,1, -0.5,0,0.5]
-		shape4 = [-1,-1,-1, 1,1,1, -0.5,0,0.5, 0.5,1.5,-0.5]
-		shape5 = [-1,-1,-1, 1,1,1, -0.5,0,0.5, 0.5,1.5,-0.5, 1.5,0.75,0]
-    updateShape(){
-      let amount
-      if(this.amount === 1){
-        amount = this.shape1
-      }else if(this.amount <= 16){
-        amount = this.shape2
-      }else if(this.amount <= 32){
-        amount = this.shape3
-      }else if(this.amount <= 48){
-        amount = this.shape4
-      }else{
-        amount = this.shape5
-      }
-      const block = blockData[this.block]
-			const tex = block.textures
-			const shape = block.shape
-			const shapeVerts = shape.verts
-			const shapeTexVerts = shape.texVerts
-			const size = shape.size*(amount.length/3)
-			const shapeNormal = shape.normal
-			let blockSides = Object.keys(Block)
-			let texNum = 0
-			let texture = []
-			let index = 0
-			let verts = [], vertIndex = 0
-			let normal = []
-			let offsetX = 0, offsetY = 0, offsetZ = 0
-			for(let amounti = 0; amounti < amount.length; amounti += 3){
-				offsetX = amount[amounti]/4, offsetY = amount[amounti+1]/4, offsetZ = amount[amounti+2]/4
-				texNum = 0
-				for (let n = 0; n < 6; n++) {
-					let side = blockSides[n]
-					let directionalFaces = shapeVerts[n]
-					for (let facei = 0; facei < directionalFaces.length; facei++) {
-						let texVerts = textureCoords[textureMap[tex[texNum]]]
-						let originalShapeVerts = shape.originalVerts[n][facei]
-						if(originalShapeVerts && originalShapeVerts.t && textureMap[originalShapeVerts.t]){
-							texVerts = textureCoords[textureMap[originalShapeVerts.t]]
-						}
-						let tx = texVerts[0]
-						let ty = texVerts[1]
-						let tw = texVerts[2]-tx
-						let th = texVerts[5]-ty
-						let texShapeVerts = shapeTexVerts[n][facei]
-						texture[index    ] = tx + texShapeVerts[0]*tw
-						texture[index + 1] = ty + texShapeVerts[1]*th
-						texture[index + 2] = tx + texShapeVerts[2]*tw
-						texture[index + 3] = ty + texShapeVerts[3]*th
-						texture[index + 4] = tx + texShapeVerts[4]*tw
-						texture[index + 5] = ty + texShapeVerts[5]*th
-						texture[index + 6] = tx + texShapeVerts[6]*tw
-						texture[index + 7] = ty + texShapeVerts[7]*th
-						index += 8
-						let faceVerts = directionalFaces[facei]
-						verts[vertIndex] = faceVerts[0]+offsetX
-						verts[vertIndex+1] = faceVerts[1]+offsetY
-						verts[vertIndex+2] = faceVerts[2]+offsetZ
-						verts[vertIndex+3] = faceVerts[3]+offsetX
-						verts[vertIndex+4] = faceVerts[4]+offsetY
-						verts[vertIndex+5] = faceVerts[5]+offsetZ
-						verts[vertIndex+6] = faceVerts[6]+offsetX
-						verts[vertIndex+7] = faceVerts[7]+offsetY
-						verts[vertIndex+8] = faceVerts[8]+offsetZ
-						verts[vertIndex+9] = faceVerts[9]+offsetX
-						verts[vertIndex+10] = faceVerts[10]+offsetY
-						verts[vertIndex+11] = faceVerts[11]+offsetZ
-						vertIndex += 12
-						normal.push(...shapeNormal[n][facei],...shapeNormal[n][facei],...shapeNormal[n][facei],...shapeNormal[n][facei])
-					}
-					texNum++
-				}
-			}
-      
-      var vertices = new Float32Array(verts)
-      texture = new Float32Array(texture)
-      
-			const verticesBuffer = gl.createBuffer()
-			const textureBuffer = gl.createBuffer()
-			const normalBuffer = gl.createBuffer()
-			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
-			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
-
-			gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
-			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
-			gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)
-
-			gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
-			gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
-			gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
-			
-			gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer)
-			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normal), gl.STATIC_DRAW)
-			gl.vertexAttribPointer(glCache.aNormalEntity, 3, gl.FLOAT, false, 0, 0)
-
-			gl.enableVertexAttribArray(glCache.aVertexEntity)
-			gl.enableVertexAttribArray(glCache.aTextureEntity)
-			gl.enableVertexAttribArray(glCache.aNormalEntity)
-			glExtensions.vertex_array_object.bindVertexArrayOES(null)
-      
-      this.faces = size
-    }
-	}
-  let BlockEntity = entities[entities.length] = class BlockEntity extends Entity{
-		static name2 = "BlockEntity"
-    constructor(blockID, x,y,z, solidOnGround){
-      let v = generateBlockVAO(blockID)
-      super(x, y, z, 0, 0, 0, 0, 0, 1, 1, 1, null, null, v.size, 1500000, v.vao)
-      this.block = blockID
-      this.solidOnGround = solidOnGround
-      this.lastY = y
-      this.noHitbox = true
-			this.cullFace = true
-    }
-    changeBlock(blockID){
-      if(this.block === blockID) return
-      this.block = blockID
-      let v = generateBlockVAO(blockID)
-      this.faces = v.size
-			this.vao = v.vao
-    }
-    update() {
-			this.updateVelocity(now)
-			this.move(now)
-      
-      var id = this.block
-      if(id && blockData[id].tint){
-        var biome = this.world.getBiome(round(this.x),round(this.y),round(this.z),this.dimension)
-        var tints = blockData[id].tint
-        this.tint = tints[biome] || tints.default
-        this.tintGray = true
-      }
-		}
-  }
-  
-  let PrimedTNT = entities[entities.length] = class PrimedTNT extends BlockEntity{
-		static name2 = "PrimedTNT"
-    constructor(x,y,z, timerStart, tntBlockId = blockIds.tnt){
-      super(tntBlockId, x,y,z)
-      this.velx = (Math.random() * 0.1) - 0.05
-      this.vely = Math.random() * 0.1
-      this.velz = (Math.random() * 0.1) - 0.05
-      
-      this.timerStart = timerStart || this.spawn
-      this.timeLimit = 80
-      
-      this.tntBlockId = tntBlockId
-    }
-    update() {
-			this.updateVelocity(now)
-			this.move(now)
-      
-      var i = Math.floor((now - this.timerStart) / 250)
-      this.shader = 0
-      if(!(i%2)){
-        this.shader = 1
-        if(!performFast) this.world.addParticle(new entities[entityIds.SmokeParticle](this.x,this.y+0.5-0.125,this.z), this.dimension)
-      }
-      if((now - this.spawn) / tickTime >= this.timeLimit - 10){
-        //get bigger
-        this.extraSize = min(-((this.timeLimit - 10) - ((now - this.spawn) / tickTime)) / 40,0.25)
-				this.shader = 1
-      }
-		}
-  }
-  entities[entities.length] = class PrimedSuperTNT extends PrimedTNT{
-		static name2 = "PrimedSuperTNT"
-    constructor(x,y,z, timerStart){
-      super(x,y,z, timerStart, blockIds.tnt | SLAB)
-    }
-  }
-  entities[entities.length] = class PrimedUltraTNT extends PrimedTNT{
-		static name2 = "PrimedUltraTNT"
-    constructor(x,y,z, timerStart){
-      super(x,y,z, timerStart, blockIds.tnt | STAIR)
-    }
-  }
-  entities[entities.length] = class PrimedUnTNT extends PrimedTNT{
-		static name2 = "PrimedUnTNT"
-    constructor(x,y,z, timerStart){
-      super(x,y,z, timerStart, blockIds.untnt)
-    }
-  }
-  
-  entities[entities.length] = class MovingBlock extends BlockEntity{
-		static name2 = "MovingBlock"
-		noRemoteDelete = true
-    constructor(block,x,y,z,mx,my,mz,despawns, solidWhenDone = false, tags = null){
-      super(block, x,y,z)
-      this.sx = x //s stands for start
-      this.sy = y
-      this.sz = z
-      this.mx = mx //m stands for end
-      this.my = my
-      this.mz = mz
-      this.despawns = despawns //also tells how much time for it to move
-      this.solidWhenDone = solidWhenDone
-      this.tags = tags
-      this.canStandOn = true
-      this.endAs = null
-			this.spawn2 = performance.now()
-    }
-		setPos(){}
-    update() {
-			if (this.lastUpdate - this.spawn2 - tickTime > this.despawns) {
-				this.canDespawn = true
-			}
-			this.previousX = this.x
-			this.previousY = this.y
-			this.previousZ = this.z
-      this.lastUpdate = now
-      
-      var prog = min((now - this.spawn2) / this.despawns, 1)
-      this.x = lerp(prog, this.sx, this.mx)
-      this.y = lerp(prog, this.sy, this.my)
-      this.z = lerp(prog, this.sz, this.mz)
-      
-      this.velx = this.x - this.previousX
-      this.vely = this.y - this.previousY
-      this.velz = this.z - this.previousZ
-
-      let id = this.block
-      if(id && blockData[id].tint){
-        let biome = this.world.getBiome(round(this.x),round(this.y),round(this.z),this.dimension)
-        let tints = blockData[id].tint
-        this.tint = tints[biome] || tints.default
-        this.tintGray = true
-      }
-		}
-  }
-	entities[entities.length] = class BlockDisplay extends BlockEntity{
-		static name2 = "BlockDisplay"
-    constructor(block,x,y,z,w,h,d){
-      super(block, x,y,z, w,h,d)
-			this.width = w
-			this.height = h
-			this.depth = d
-    }
-    update() {
-      let id = this.block
-      if(id && blockData[id].tint){
-        let biome = this.world.getBiome(round(this.x),round(this.y),round(this.z),this.dimension)
-        let tints = blockData[id].tint
-        this.tint = tints[biome] || tints.default
-        this.tintGray = true
-      }
-		}
-  }
-  
-  entities[entities.length] = class EnderPearl extends BlockEntity{
-		static name2 = "EnderPearl"
-    constructor(x,y,z,velx,vely,velz,from){
-      super(blockIds.enderPearl, x,y,z)
-      this.velx = velx
-      this.vely = vely
-      this.velz = velz
-      this.from = p.id
-      this.facesPlayer = true
-      
-      this.gravityStength = -0.04
-    }
-    update() {
-			this.updateVelocity(now)
-			this.move(now)
-      
-      this.canFacePlayer = true
-		}
-    render(){
-      totalEntites++
-      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width+this.extraSize,this.height+this.extraSize,this.depth+this.extraSize)) return
-      renderedEntities++
-
-      if(this.canFacePlayer) {
-        this.facePlayer()
-        this.canFacePlayer = false
-      }
-      
-      let diff = (now - this.lastUpdate) / tickTime
-			if (diff > 1) diff = 1
-			const offsetY = this.offsetY
-      let renderx = (this.x - this.previousX) * diff + this.previousX
-			let rendery = ((this.y - this.previousY) * diff + this.previousY) + offsetY
-			let renderz = (this.z - this.previousZ) * diff + this.previousZ
-      
-			const modelMatrix = entityMatrices.modelMatrix;
-			modelMatrix.identity()
-			modelMatrix.translate(renderx, rendery, renderz)
-			modelMatrix.rotY(this.yaw)
-			modelMatrix.rotX(this.pitch)
-			modelMatrix.scale(this.width + this.extraSize, this.height + this.extraSize, this.depth + this.extraSize)
-			const viewMatrix = p.camera.transformation.elements
-			const proj = p.camera.projection
-			let projectionMatrix = entityMatrices.projectionMatrix
-      projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
-      projectionMatrix = projectionMatrix.elements
-			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
-			modelViewProjectionMatrix.identity()
-			modelViewProjectionMatrix.mult(projectionMatrix)
-			modelViewProjectionMatrix.mult(viewMatrix)
-			modelViewProjectionMatrix.mult(modelMatrix.elements)
-			// row major to column major
-			modelViewProjectionMatrix.transpose()
-			modelMatrix.transpose()//for normal
-			const x = round(this.x)
-			const y = round(this.y)
-			const z = round(this.z)
-			const blockLight = this.world.getLight(x, y, z, 1, this.dimension)/15
-			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
-			gl.uniform1i(glCache.uSamplerEntity, 0)
-			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
-			gl.uniform1f(glCache.uSkylightEntity, skysLight)
-      gl.uniform1f(glCache.harmEffectEntity, 0)
-			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
-			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
-			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
-			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
-			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
-			glExtensions.vertex_array_object.bindVertexArrayOES(null)
-    }
-  }
-  
-  entities[entities.length] = class Snowball extends BlockEntity{
-		static name2 = "Snowball"
-    constructor(x,y,z,velx,vely,velz){
-      super(blockIds.snowball, x,y,z)
-      this.velx = velx
-      this.vely = vely
-      this.velz = velz
-      this.from = p.id
-      this.facesPlayer = true
-      
-      this.gravityStength = -0.04
-    }
-    update() {
-			this.updateVelocity(now)
-			this.move(now)
-      this.canFacePlayer = true
-		}
-    render(){
-      totalEntites++
-      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width+this.extraSize,this.height+this.extraSize,this.depth+this.extraSize)) return
-      renderedEntities++
-
-      if(this.canFacePlayer) {
-        this.facePlayer()
-        this.canFacePlayer = false
-      }
-      
-      let diff = (now - this.lastUpdate) / tickTime
-			if (diff > 1) diff = 1
-			const offsetY = this.offsetY
-      let renderx = (this.x - this.previousX) * diff + this.previousX
-			let rendery = ((this.y - this.previousY) * diff + this.previousY) + offsetY
-			let renderz = (this.z - this.previousZ) * diff + this.previousZ
-      
-			const modelMatrix = entityMatrices.modelMatrix;
-			modelMatrix.identity()
-			modelMatrix.translate(renderx, rendery, renderz)
-			modelMatrix.rotY(this.yaw)
-			modelMatrix.rotX(this.pitch)
-			modelMatrix.scale(this.width + this.extraSize, this.height + this.extraSize, this.depth + this.extraSize)
-			const viewMatrix = p.camera.transformation.elements
-			const proj = p.camera.projection
-			let projectionMatrix = entityMatrices.projectionMatrix
-      projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
-      projectionMatrix = projectionMatrix.elements
-			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
-			modelViewProjectionMatrix.identity()
-			modelViewProjectionMatrix.mult(projectionMatrix)
-			modelViewProjectionMatrix.mult(viewMatrix)
-			modelViewProjectionMatrix.mult(modelMatrix.elements)
-			// row major to column major
-			modelViewProjectionMatrix.transpose()
-			modelMatrix.transpose()//for normal
-			const x = round(this.x)
-			const y = round(this.y)
-			const z = round(this.z)
-			const blockLight = this.world.getLight(x, y, z, 1, this.dimension)/15
-			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
-			gl.uniform1i(glCache.uSamplerEntity, 0)
-			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
-			gl.uniform1f(glCache.uSkylightEntity, skysLight)
-			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
-			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
-			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
-			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
-			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
-			glExtensions.vertex_array_object.bindVertexArrayOES(null)
-    }
-  }
-	entities[entities.length] = class SmallFireball extends BlockEntity{
-		static name2 = "SmallFireball"
-    constructor(x,y,z,velx,vely,velz){
-      super(blockIds.fireCharge, x,y,z)
-			this.width = this.height = this.depth = 0.3125
-      this.velx = velx
-      this.vely = vely
-      this.velz = velz
-      this.from = p.id
-      this.facesPlayer = true
-      
-      this.gravityStength = -0.07
-    }
-    update() {
-			this.updateVelocity(now)
-			this.move(now)
-      this.canFacePlayer = true
-		}
-    render(){
-      totalEntites++
-      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width+this.extraSize,this.height+this.extraSize,this.depth+this.extraSize)) return
-      renderedEntities++
-
-      if(this.canFacePlayer) {
-        this.facePlayer()
-        this.canFacePlayer = false
-      }
-      
-      let diff = (now - this.lastUpdate) / tickTime
-			if (diff > 1) diff = 1
-			const offsetY = this.offsetY
-      let renderx = (this.x - this.previousX) * diff + this.previousX
-			let rendery = ((this.y - this.previousY) * diff + this.previousY) + offsetY
-			let renderz = (this.z - this.previousZ) * diff + this.previousZ
-      
-			const modelMatrix = entityMatrices.modelMatrix;
-			modelMatrix.identity()
-			modelMatrix.translate(renderx, rendery, renderz)
-			modelMatrix.rotY(this.yaw)
-			modelMatrix.rotX(this.pitch)
-			modelMatrix.scale(this.width + this.extraSize, this.height + this.extraSize, this.depth + this.extraSize)
-			const viewMatrix = p.camera.transformation.elements
-			const proj = p.camera.projection
-			let projectionMatrix = entityMatrices.projectionMatrix
-      projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
-      projectionMatrix = projectionMatrix.elements
-			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
-			modelViewProjectionMatrix.identity()
-			modelViewProjectionMatrix.mult(projectionMatrix)
-			modelViewProjectionMatrix.mult(viewMatrix)
-			modelViewProjectionMatrix.mult(modelMatrix.elements)
-			// row major to column major
-			modelViewProjectionMatrix.transpose()
-			modelMatrix.transpose()//for normal
-			const x = round(this.x)
-			const y = round(this.y)
-			const z = round(this.z)
-			const blockLight = this.world.getLight(x, y, z, 1, this.dimension)/15
-			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
-			gl.uniform1i(glCache.uSamplerEntity, 0)
-			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
-			gl.uniform1f(glCache.uSkylightEntity, skysLight)
-			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
-			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
-			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
-			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
-			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
-			glExtensions.vertex_array_object.bindVertexArrayOES(null)
-    }
-  }
-  
-  entities[entities.length] = class Egg extends BlockEntity{
-		static name2 = "Egg"
-    constructor(x,y,z,velx,vely,velz){
-      super(blockIds.egg, x,y,z)
-      this.velx = velx
-      this.vely = vely
-      this.velz = velz
-      this.from = p.id
-      this.facesPlayer = true
-      
-      this.gravityStength = -0.07
-    }
-    update() {
-			this.updateVelocity(now)
-			this.move(now)
-      this.canFacePlayer = true
-		}
-    render(){
-      totalEntites++
-      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width+this.extraSize,this.height+this.extraSize,this.depth+this.extraSize)) return
-      renderedEntities++
-
-      if(this.canFacePlayer) {
-        this.facePlayer()
-        this.canFacePlayer = false
-      }
-      
-      let diff = (now - this.lastUpdate) / tickTime
-			if (diff > 1) diff = 1
-			const offsetY = this.offsetY
-      let renderx = (this.x - this.previousX) * diff + this.previousX
-			let rendery = ((this.y - this.previousY) * diff + this.previousY) + offsetY
-			let renderz = (this.z - this.previousZ) * diff + this.previousZ
-      
-			const modelMatrix = entityMatrices.modelMatrix;
-			modelMatrix.identity()
-			modelMatrix.translate(renderx, rendery, renderz)
-			modelMatrix.rotY(this.yaw)
-			modelMatrix.rotX(this.pitch)
-			modelMatrix.scale(this.width + this.extraSize, this.height + this.extraSize, this.depth + this.extraSize)
-			const viewMatrix = p.camera.transformation.elements
-			const proj = p.camera.projection
-			let projectionMatrix = entityMatrices.projectionMatrix
-      projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
-      projectionMatrix = projectionMatrix.elements
-			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
-			modelViewProjectionMatrix.identity()
-			modelViewProjectionMatrix.mult(projectionMatrix)
-			modelViewProjectionMatrix.mult(viewMatrix)
-			modelViewProjectionMatrix.mult(modelMatrix.elements)
-			// row major to column major
-			modelViewProjectionMatrix.transpose()
-			modelMatrix.transpose()//for normal
-			const x = round(this.x)
-			const y = round(this.y)
-			const z = round(this.z)
-			const blockLight = this.world.getLight(x, y, z, 1, this.dimension)/15
-			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
-			gl.uniform1i(glCache.uSamplerEntity, 0)
-			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
-			gl.uniform1f(glCache.uSkylightEntity, skysLight)
-			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
-			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
-			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
-			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
-			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
-			glExtensions.vertex_array_object.bindVertexArrayOES(null)
-    }
-  }
-  
-  entities[entities.length] = class SlingshotShot extends BlockEntity{
-		static name2 = "SlingshotShot"
-    constructor(x,y,z,velx,vely,velz){
-      super(blockIds.ironNugget, x,y,z)
-      this.velx = velx
-      this.vely = vely
-      this.velz = velz
-      this.despawns = 10000
-      this.facesPlayer = true
-      this.gravityStength = -0.02
-    }
-    update() {
-			this.updateVelocity(now)
-			this.move(now)
-      
-      this.canFacePlayer = true
-		}
-    move(now) {
-			let pminX = floor(this.x - this.width / 2)
-			let pmaxX = ceil(this.x + this.width / 2)
-			let pminY = floor(this.y - this.height / 2)
-			let pmaxY = ceil(this.y + this.height / 2)
-			let pminZ = floor(this.z - this.depth / 2)
-			let pmaxZ = ceil(this.z + this.depth / 2)
-			let block = null
-
-      this.liquid = false
-			for (let x = pminX; x <= pmaxX; x++) {
-				for (let y = pminY; y <= pmaxY; y++) {
-					for (let z = pminZ; z <= pmaxZ; z++) {
-						let block = this.world.getBlock(x, y, z, this.dimension)
-						if (block && blockData[block].solid) {
-							this.contacts.add(x, y, z, block)
-						}
-            if(x === round(this.x) && z === round(this.z) && blockData[block].liquid){
-              this.liquid = true
-            }
-					}
-				}
-			}
-
-			this.previousX = this.x
-			this.previousY = this.y
-			this.previousZ = this.z
-
-      var xBounce, yBounce, zBounce, pvelx = this.velx, pvely = this.vely, pvelz = this.velz
-      
-			this.canStepX = false
-			this.canStepY = false
-			this.onGround = false
-      this.hasCollided = false
-			//Check collisions in the Y direction
-			this.y += this.vely
-			for (let i = 0; i < this.contacts.size; i++) {
-				block = this.contacts.array[i]
-				if (this.collided(block[0], block[1], block[2], null, this.vely, null, block[3])) {
-					this.y = this.previousY
-					this.vely = 0
-          this.hasCollided = true
-          yBounce = true
-					break
-				}
-			}
-
-			if (this.y === this.previousY) {
-				this.canStepX = true
-				this.canStepZ = true
-			}
-
-			//Check collisions in the X direction
-			this.x += this.velx
-			for (let i = 0; i < this.contacts.size; i++) {
-				block = this.contacts.array[i]
-				if (this.collided(block[0], block[1], block[2], this.velx, null, null, block[3])) {
-					if (this.canStepX && !this.world.getBlock(block[0], block[1] + 1, block[2], this.dimension) && !this.world.getBlock(block[0], block[1] + 2, block[2], this.dimension)) {
-						continue
-					}
-					this.x = this.previousX
-					this.velx = 0
-          this.hasCollided = true
-          xBounce = true
-					break
-				}
-			}
-
-			//Check collisions in the Z direction
-			this.z += this.velz
-			for (let i = 0; i < this.contacts.size; i++) {
-				block = this.contacts.array[i]
-				if (this.collided(block[0], block[1], block[2], null, null, this.velz, block[3])) {
-					if (this.canStepZ && !this.world.getBlock(block[0], block[1] + 1, block[2], this.dimension) && !this.world.getBlock(block[0], block[1] + 2, block[2]), this.dimension) {
-						continue
-					}
-					this.z = this.previousZ
-					this.velz = 0
-          this.hasCollided = true
-          zBounce = true
-					break
-				}
-			}
-      
-      if(this.onGround){
-        this.hasCollided = true
-      }
-      
-      if(xBounce) this.velx = -pvelx
-      if(yBounce) this.vely = -pvely
-      if(zBounce) this.velz = -pvelz
-
-			this.updateChunk()
-
-			this.lastUpdate = now
-			this.contacts.clear()
-		}
-    render(){
-      totalEntites++
-      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width+this.extraSize,this.height+this.extraSize,this.depth+this.extraSize)) return
-      renderedEntities++
-
-      if(this.canFacePlayer) {
-        this.facePlayer()
-        this.canFacePlayer = false
-      }
-      
-      let diff = (now - this.lastUpdate) / tickTime
-			if (diff > 1) diff = 1
-			const offsetY = this.offsetY
-      let renderx = (this.x - this.previousX) * diff + this.previousX
-			let rendery = ((this.y - this.previousY) * diff + this.previousY) + offsetY
-			let renderz = (this.z - this.previousZ) * diff + this.previousZ
-      
-			const modelMatrix = entityMatrices.modelMatrix;
-			modelMatrix.identity()
-			modelMatrix.translate(renderx, rendery, renderz)
-			modelMatrix.rotY(this.yaw)
-			modelMatrix.rotX(this.pitch)
-			modelMatrix.scale(this.width + this.extraSize, this.height + this.extraSize, this.depth + this.extraSize)
-			const viewMatrix = p.camera.transformation.elements
-			const proj = p.camera.projection
-			let projectionMatrix = entityMatrices.projectionMatrix
-      projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
-      projectionMatrix = projectionMatrix.elements
-			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
-			modelViewProjectionMatrix.identity()
-			modelViewProjectionMatrix.mult(projectionMatrix)
-			modelViewProjectionMatrix.mult(viewMatrix)
-			modelViewProjectionMatrix.mult(modelMatrix.elements)
-			// row major to column major
-			modelViewProjectionMatrix.transpose()
-			modelMatrix.transpose()//for normal
-			const x = round(this.x)
-			const y = round(this.y)
-			const z = round(this.z)
-			const blockLight = this.world.getLight(x, y, z, 1, this.dimension)/15
-			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
-			gl.uniform1i(glCache.uSamplerEntity, 0)
-			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
-			gl.uniform1f(glCache.uSkylightEntity, skysLight)
-			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
-			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
-			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
-			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
-			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
-			glExtensions.vertex_array_object.bindVertexArrayOES(null)
-    }
-  }
-  entities[entities.length] = class Arrow extends Entity{
-		static name2 = "Arrow"
-    constructor(x,y,z,dx,dy,dz, from){
-      let t = textureCoords[textureMap.arrow]
-      let v = generateVAO(shapes.arrow, t[0],t[1],t[2]-t[0],t[5]-t[1])
-      super(x, y, z, 0, 0, dx, dy, dz, 0.25, 0.25, 0.25, null, null, v.size, 60000, v.vao)
-			this.noHitbox = true
-			this.from = from
-    }
-		updateVelocity(now) {
-			this.vely += -0.005
-			let drag = this.liquid ? 0.7 : 0.99
-			if(blockData[this.standingOn].slide) drag = blockData[this.standingOn].slide
-			this.velz += (this.velz * drag - this.velz)
-			this.velx += (this.velx * drag - this.velx)
-			this.vely += (this.vely * drag - this.vely)
-		}
-    update(){
-			let pvelx = this.velx
-			let pvely = this.vely
-			let pvelz = this.velz
-			this.updateVelocity(now)
-			this.move(now)
-			if(this.hasCollided){
-				this.x = this.previousX
-				this.y = this.previousY
-				this.z = this.previousZ
-				this.velx = pvelx
-				this.vely = pvely
-				this.velz = pvelz
-			}
-		
-			this.yaw = Math.PId - (atan2(this.velz, this.velx) + Math.PI2 + Math.PI)
-			var adjacent = sqrt(this.velx*this.velx+this.velz*this.velz)
-			this.pitch = Math.PId - atan2(this.vely, adjacent)
-    }
-    render() {
-      totalEntites++
-      if(this.hidden || !p.camera.canSeeEntity(this.x,this.y,this.z,this.width+this.extraSize,this.height+this.extraSize,this.depth+this.extraSize)) return
-      renderedEntities++
-      
-      let diff = (now - this.lastUpdate) / tickTime
-			if (diff > 1) diff = 1
-			const offsetY = this.offsetY
-      let renderx = (this.x - this.previousX) * diff + this.previousX
-			let rendery = ((this.y - this.previousY) * diff + this.previousY) + offsetY
-			let renderz = (this.z - this.previousZ) * diff + this.previousZ
-      
-			const modelMatrix = entityMatrices.modelMatrix;
-			modelMatrix.identity()
-			modelMatrix.translate(renderx, rendery, renderz)
-			modelMatrix.rotY(this.yaw)
-			modelMatrix.rotX(this.pitch)
-			const viewMatrix = p.camera.transformation.elements
-			const proj = p.camera.projection
-			let projectionMatrix = entityMatrices.projectionMatrix
-      projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
-      projectionMatrix = projectionMatrix.elements
-			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
-			modelViewProjectionMatrix.identity()
-			modelViewProjectionMatrix.mult(projectionMatrix)
-			modelViewProjectionMatrix.mult(viewMatrix)
-			modelViewProjectionMatrix.mult(modelMatrix.elements)
-			// row major to column major
-			modelViewProjectionMatrix.transpose()
-			modelMatrix.transpose()//for normal
-			const x = round(this.x)
-			const y = round(this.y)
-			const z = round(this.z)
-			const blockLight = this.world.getLight(x, y, z, 1, this.dimension)/15
-			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
-			gl.uniform1i(glCache.uSamplerEntity, 0)
-			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
-			gl.uniform1f(glCache.uSkylightEntity, skysLight)
-      gl.uniform1f(glCache.harmEffectEntity, 0)
-			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
-			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
-			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
-			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
-			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
-			glExtensions.vertex_array_object.bindVertexArrayOES(null)
-    }
-  }
-  
-  entities[entities.length] = class Sign extends Entity{
-		static name2 = "Sign"
-    constructor(x,y,z,base,block){
-			let signBlock = (block & STAIR) === STAIR ? (base | CROSS) : (base | SLAB)
-      const v = generateBlockVAO(signBlock, {poleSide:blockData[block].poleSide,poleTop:blockData[block].poleTop})
-			super(x, y, z, 0, 0, 0, 0, 0, 1, 1, 1, null,null, v.size, Infinity, v.vao)
-      this.width = this.height = this.depth = 16/24
-      this.offsetY = -0.15
-      this.from = p.id
-      this.baseBlock = base
-      this.noHitbox = true
-      this.textEnt = null, this.textEnt2 = null
-      this.prevText = null, this.prevText2 = null
-      this.remote = true
-      
-      this.gravityStength = 0
-    }
-    update() {
-			let block = this.world.getBlock(this.x,this.y,this.z,this.dimension)
-			if(block != this.baseBlock){
-      	if((block&isCube) !== this.baseBlock) this.canDespawn = true
-				else{
-					let base = this.baseBlock
-					let signBlock = (block & STAIR) === STAIR ? (base | CROSS) : (base | SLAB)
-					let v = generateBlockVAO(signBlock)
-		      this.faces = v.size
-					this.vao = v.vao
-				}
-			}
-      //if(host && this.canDespawn) return blockParticles(this.block,this.x,this.y,this.z,30, "break",this.world,this.dimension)
-      
-      let tags = this.world.getTags(this.x,this.y,this.z,this.dimension)
-      if(tags){
-        var rotation = tags.rot || 0
-        this.yaw = -rotation * Math.PId / 16
-        if(this.textEnt){
-          this.textEnt.yaw = this.yaw + Math.PI
-					if(tags.color){
-            this.textEnt.color = tags.color
-          }else if(blockData[this.baseBlock].color){
-            var data = blockData[this.baseBlock].color
-            this.textEnt.color[0] = data[0]
-            this.textEnt.color[1] = data[1]
-            this.textEnt.color[2] = data[2]
-          }
-					this.textEnt.glow = !!tags.glow
-        }
-				if(this.textEnt2){
-          this.textEnt2.yaw = this.yaw
-					if(tags.color){
-            this.textEnt2.color = tags.color
-          }else if(blockData[this.baseBlock].color){
-            var data = blockData[this.baseBlock].color
-            this.textEnt2.color[0] = data[0]
-            this.textEnt2.color[1] = data[1]
-            this.textEnt2.color[2] = data[2]
-          }
-					this.textEnt2.glow = !!tags.glow2
-        }
-        if(tags.text !== this.prevText && (tags.text || tags.text === "")){
-          this.prevText = tags.text
-          if(this.textEnt){
-            this.textEnt.setText(tags.text)
-          }else{
-            this.textEnt = this.world.generateTextForEntity(tags.text,this,1/8,[0,0,0],null)
-            if((block & isState) === STAIR){
-              this.textEnt.offsetZ = -5.5/16
-            }else{
-              this.textEnt.offsetZ = 1/16
-              this.textEnt.y += 0.35
-            }
-          }
-        }
-				if(tags.text2 !== this.prevText2 && (tags.text2 || tags.text2 === "")){
-          this.prevText2 = tags.text2
-          if(this.textEnt2){
-            this.textEnt2.setText(tags.text2)
-          }else{
-            this.textEnt2 = this.world.generateTextForEntity(tags.text2,this,1/8,[0,0,0],null)
-            if((block & isState) === STAIR){
-              this.textEnt2.offsetZ = 7.25/16
-            }else{
-              this.textEnt2.offsetZ = 1.25/16
-              this.textEnt2.y += 0.35
-            }
-          }
-        }
-      }
-		}
-    render(){
-      totalEntites++
-      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width+this.extraSize,this.height+this.extraSize,this.depth+this.extraSize)) return
-      renderedEntities++
-
-      if(this.canFacePlayer) {
-        this.facePlayer()
-        this.canFacePlayer = false
-      }
-      
-      let diff = (now - this.lastUpdate) / tickTime
-			if (diff > 1) diff = 1
-			const offsetY = this.offsetY
-      let renderx = (this.x - this.previousX) * diff + this.previousX
-			let rendery = ((this.y - this.previousY) * diff + this.previousY) + offsetY
-			let renderz = (this.z - this.previousZ) * diff + this.previousZ
-      
-			const modelMatrix = entityMatrices.modelMatrix;
-			modelMatrix.identity()
-			modelMatrix.translate(renderx, rendery, renderz)
-			modelMatrix.rotY(this.yaw)
-			modelMatrix.rotX(this.pitch)
-			modelMatrix.scale(this.width + this.extraSize, this.height + this.extraSize, this.depth + this.extraSize)
-			const viewMatrix = p.camera.transformation.elements
-			const proj = p.camera.projection
-			let projectionMatrix = entityMatrices.projectionMatrix
-      projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
-      projectionMatrix = projectionMatrix.elements
-			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
-			modelViewProjectionMatrix.identity()
-			modelViewProjectionMatrix.mult(projectionMatrix)
-			modelViewProjectionMatrix.mult(viewMatrix)
-			modelViewProjectionMatrix.mult(modelMatrix.elements)
-			// row major to column major
-			modelViewProjectionMatrix.transpose()
-			modelMatrix.transpose()//for normal
-			const x = round(this.x)
-			const y = round(this.y)
-			const z = round(this.z)
-			const blockLight = this.world.getLight(x, y, z, 1, this.dimension)/15
-			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
-			gl.uniform1i(glCache.uSamplerEntity, 0)
-			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
-			gl.uniform1f(glCache.uSkylightEntity, skysLight)
-			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
-			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
-			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
-			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
-			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
-			glExtensions.vertex_array_object.bindVertexArrayOES(null)
-      
-      if(this.textEnt) this.textEnt.render()
-			if(this.textEnt2) this.textEnt2.render()
-    }
-  }
-  entities[entities.length] = class ItemFrame extends BlockEntity{
-		static name2 = "ItemFrame"
-    constructor(x,y,z,block,base){
-      super(block,x,y,z)
-      this.width = this.height = this.depth = 0.5
-      this.baseBlock = base
-      this.noHitbox = true
-      this.remote = true
-      this.rz = 0
-      this.offsetX = 0, this.offsetZ = 0
-      var off = 7/16
-      switch(base & ROTATION){
-        case NORTH:
-          this.offsetZ = off
-          break
-        case SOUTH:
-          this.offsetZ = -off
-          this.yaw = Math.PI
-          break
-        case EAST:
-          this.offsetX = off
-          this.yaw = Math.PI2
-          break
-        case WEST:
-          this.offsetX = -off
-          this.yaw = -Math.PI2
-          break
-      }
-    }
-    update(){
-      if(this.world.getBlock(this.x,this.y,this.z,this.dimension) !== this.baseBlock) this.canDespawn = true
-      var rot = this.world.getTagByName(this.x,this.y,this.z,"rot",this.dimension) || 0
-      this.rz = rot*Math.PId/8
-      this.changeBlock(this.world.getTagByName(this.x,this.y,this.z,"block",this.dimension) || 0)
-    }
-    render(){
-      totalEntites++
-      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width,this.height,this.depth)) return
-      renderedEntities++
-
-      const modelMatrix = entityMatrices.modelMatrix;
-			modelMatrix.identity()
-			modelMatrix.translate(this.x+this.offsetX, this.y, this.z+this.offsetZ)
-			modelMatrix.rotX(this.pitch)
-			modelMatrix.rotY(this.yaw)
-      modelMatrix.rotZ(this.rz)
-			modelMatrix.scale(this.width, this.height, this.depth)
-			const viewMatrix = p.camera.transformation.elements
-			const proj = p.camera.projection
-			let projectionMatrix = entityMatrices.projectionMatrix
-      projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
-      projectionMatrix = projectionMatrix.elements
-			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
-			modelViewProjectionMatrix.identity()
-			modelViewProjectionMatrix.mult(projectionMatrix)
-			modelViewProjectionMatrix.mult(viewMatrix)
-			modelViewProjectionMatrix.mult(modelMatrix.elements)
-			// row major to column major
-			modelViewProjectionMatrix.transpose()
-			modelMatrix.transpose()//for normal
-			const x = round(this.x)
-			const y = round(this.y)
-			const z = round(this.z)
-			const blockLight = this.world.getLight(x, y, z, 1, this.dimension)/15
-			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
-			gl.uniform1i(glCache.uSamplerEntity, 0)
-			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
-			gl.uniform1f(glCache.uSkylightEntity, skysLight)
-      gl.uniform1f(glCache.harmEffectEntity, 0)
-			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
-			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
-			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
-			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
-			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
-			glExtensions.vertex_array_object.bindVertexArrayOES(null)
-    }
-  }
-  
-  entities[entities.length] = class ExperienceOrb extends Entity{
-		static name2 = "ExperienceOrb"
-    //experienceOrb
-    constructor(x,y,z,value){
-      var i
-      if(!value || value <= 2){
-        i = 0
-      }else if(value <= 6){
-        i = 1
-      }else if(value <= 16){
-        i = 2
-      }else if(value <= 36){
-        i = 3
-      }else if(value <= 72){
-        i = 4
-      }else if(value <= 148){
-        i = 5
-      }else if(value <= 306){
-        i = 6
-      }else if(value <= 616){
-        i = 7
-      }else if(value <= 1236){
-        i = 8
-      }else if(value <= 2476){
-        i = 9
-      }else if(value <= 32767){
-        i = 10
-      }
-      super(x, y, z, 0, 0, 0, 0, 0, 0.5, 0.5, 0.5, null, null, experienceOrbVaos.size, 300000, experienceOrbVaos[i])
-      this.amount = value
-      this.tint = {r:1,g:1,b:1}
-      this.noHitbox = true
-      this.facesPlayer = true
-    }
-    goToPlayer(e){
-      var dist = dist3(this.x,this.y,this.z,e.x,e.y-e.height*0.5,e.z)
-      if(dist < 7.25){
-        ////var speed = (7.25 - dist) / 10
-        //var aDist = abs(dist)
-        //var xd = this.x - p.x, zd = this.z - p.z;
-        //var x = xd/*/abs(zd)*/; this.velx = (x-(Math.sign(x)*7.25)) / 150//; this.velx = -this.velx
-        //if(this.onGround) {var y = this.y - (p.y-p.bottomH); this.vely = (y-(Math.sign(y)*7.25)) / 40/*; this.vely = -this.vely*/}
-        //var z = zd/*/abs(xd)*/; this.velz = (z-(Math.sign(z)*7.25)) / 150//; this.velx = -this.velx
-        this.moveTowards(e.x, e.y-e.height*0.5, e.z, 7.25,7.25,7.25, 5, true)
-      }
-    }
-    update(){
-      if(multiplayer) for(var i in players){
-        if(!players[i].hidden && !players[i].die && players[i].dimension === this.dimension) this.goToPlayer(players[i])
-      }
-      
-			this.updateVelocity(now)
-			this.move(now)
-      
-      this.facePlayer()
-      
-      this.tint.r = min(max(abs((now-this.spawn) % 1000 - 500) / 500, 0), 1)
-      this.tint.g = 1
-      this.tint.b = 0
-    }
-    facePlayer(){
-      this.yaw = Math.PId - (atan2(p.camera.z - this.z, p.camera.x - this.x) + Math.PI2 + Math.PI)
-      var adjacent = dist2(this.x,this.z,p.camera.x,p.camera.z)
-      this.pitch = Math.PId - atan2(p.camera.y - this.y, adjacent)
-    }
-    render(){
-      totalEntites++
-      if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width,this.height,this.depth)) return
-      renderedEntities++
-
-      const modelMatrix = new Matrix();
-			modelMatrix.identity()
-			modelMatrix.translate(this.x, this.y, this.z)
-			modelMatrix.rotY(this.yaw)
-			modelMatrix.rotX(this.pitch)
-			modelMatrix.scale(this.width, this.height, this.depth)
-			const viewMatrix = p.camera.transformation.elements
-			const proj = p.camera.projection
-			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
-			const modelViewProjectionMatrix = new Matrix()
-			modelViewProjectionMatrix.identity()
-			modelViewProjectionMatrix.mult(projectionMatrix)
-			modelViewProjectionMatrix.mult(viewMatrix)
-			modelViewProjectionMatrix.mult(modelMatrix.elements)
-			// row major to column major
-			modelViewProjectionMatrix.transpose()
-			modelMatrix.transpose()//for normal
-			const x = round(this.x)
-			const y = round(this.y)
-			const z = round(this.z)
-			const blockLight = this.world.getLight(x, y, z, 1, this.dimension)/15
-			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
-			gl.uniform1i(glCache.uSamplerEntity, 0)
-			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
-			gl.uniform1f(glCache.uSkylightEntity, skysLight)
-      gl.uniform1f(glCache.harmEffectEntity, 0)
-			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
-      gl.uniform3f(glCache.tintEntity, this.tint.r,this.tint.g,this.tint.b)
-			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
-			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
-			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
-			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
-			glExtensions.vertex_array_object.bindVertexArrayOES(null)
-      gl.uniform3f(glCache.tintEntity, 1,1,1)
-    }
-  }
-
-	entities[entities.length] = class BeaconBeam extends Entity{
-		static name2 = "BeaconBeam"
-		alwaysRender = true
-		constructor(x,y,z){
-      super(x, y+(maxHeight-y)/2, z, 0, 0, 0, 0, 0, 0.25, maxHeight - y, 0.25, null, null, 0, Infinity, glExtensions.vertex_array_object.createVertexArrayOES())
-			this.willUpdateShape = true
-			this.shader = 2
-			this.remote = true
-			this.noHitbox = true
-			this.actualY = y
-			this.prevColumn = null
-			this.glow = true
-    }
-		generateVAO(y,y2,vao){
-			const shape = shapes.cube
-			const shapeVerts = shape.verts
-			const shapeTexVerts = shape.texVerts
-			const size = shape.size
-			let tex = "beaconBeam"
-			let blockSides = Object.keys(Block)
-			let texture = []
-			let index = 0
-			let verts = [], vertIndex = 0
-			let ay = this.actualY/maxHeight
-			for (let n = 0; n < 6; n++) {
-				let side = blockSides[n]
-				let directionalFaces = shapeVerts[n]
-				for (let facei = 0; facei < directionalFaces.length; facei++) {
-					let texVerts = textureCoords[textureMap[tex]]
-					let tx = texVerts[0]
-					let ty = texVerts[1]
-					let tw = texVerts[2] - tx
-					let th = texVerts[5] - ty
-					let texShapeVerts = shapeTexVerts[n][facei]
-					let newY = ay+(1-ay)*y, newY2 = ay+(1-ay)*y2
-					texture[index    ] = tx + texShapeVerts[0]*tw
-					texture[index + 1] = ty + lerp(texShapeVerts[1], newY,newY2)*th
-					texture[index + 2] = tx + texShapeVerts[2]*tw
-					texture[index + 3] = ty + lerp(texShapeVerts[3], newY,newY2)*th
-					texture[index + 4] = tx + texShapeVerts[4]*tw
-					texture[index + 5] = ty + lerp(texShapeVerts[5], newY,newY2)*th
-					texture[index + 6] = tx + texShapeVerts[6]*tw
-					texture[index + 7] = ty + lerp(texShapeVerts[7], newY,newY2)*th
-					index += 8
-					let face = directionalFaces[facei]
-					verts[vertIndex] = face[0]
-					verts[vertIndex+1] = map(face[1], -0.5,0.5, y-0.5,y2-0.5)
-					verts[vertIndex+2] = face[2]
-					verts[vertIndex+3] = face[3]
-					verts[vertIndex+4] = map(face[4], -0.5,0.5, y-0.5,y2-0.5)
-					verts[vertIndex+5] = face[5]
-					verts[vertIndex+6] = face[6]
-					verts[vertIndex+7] = map(face[7], -0.5,0.5, y-0.5,y2-0.5)
-					verts[vertIndex+8] = face[8]
-					verts[vertIndex+9] = face[9]
-					verts[vertIndex+10] = map(face[10], -0.5,0.5, y-0.5,y2-0.5)
-					verts[vertIndex+11] = face[11]
-					vertIndex += 12
-				}
-			}
-			const verticesBuffer = gl.createBuffer()
-			const textureBuffer = gl.createBuffer()
-			glExtensions.vertex_array_object.bindVertexArrayOES(vao)
-			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
-
-			gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
-			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.STATIC_DRAW)
-			gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)
-
-			gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
-			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
-			gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
-
-			gl.enableVertexAttribArray(glCache.aVertexEntity)
-			gl.enableVertexAttribArray(glCache.aTextureEntity)
-			glExtensions.vertex_array_object.bindVertexArrayOES(null)
-			return {vao,size}
-		}
-		updateShape(){
-			const top = this.world.getSolidTop(this.x,this.z,this.dimension)
-			let parts = [1,1,1,0]
-			let end = 1
-			const height = maxHeight-this.actualY
-			for(let y=this.actualY+1; y<=top; y++){
-				const block = this.world.getBlock(this.x,y,this.z,this.dimension), data = blockData[block]
-				if(data.solid && !data.transparent){
-					end = map(y-0.5, this.actualY,maxHeight, 0,1)
-					break
-				}
-				if(data.name.endsWith("StainedGlass")){
-					let color = colors.dye[data.name.replace("StainedGlass","")]
-					let y2 = map(y-0.5, this.actualY,maxHeight, 0,1)
-					parts.push(y2)
-					parts.push((color[0]+parts[parts.length-5])/2, (color[1]+parts[parts.length-4])/2, (color[2]+parts[parts.length-3])/2)
-					parts.push(y2)
-				}
-			}
-			parts.push(end)
-			for(let i=0; i<parts.length; i+=5){
-				let part = i && this.parts[i]
-				const {vao,size} = this.generateVAO(parts[i+3],parts[i+4], i ? (part ? part.vao : glExtensions.vertex_array_object.createVertexArrayOES()) : this.vao)
-				if(!i){
-					this.faces = size
-					this.tint = [parts[i],parts[i+1],parts[i+2]]
-				}else{
-					if(!part){
-						part = this.addPart(i,size,vao,0,0,0,0.25,maxHeight-this.actualY,0.25,0,0)
-						part.glow = true
-					}
-					part.size = size
-					part.tint = [parts[i],parts[i+1],parts[i+2]]
-				}
-			}
-			for(let part in this.parts){
-				if(+part >= parts.length) delete this.parts[part]
-			}
-		}
-		update() {
-			let chunk = world.getChunk(this.chunkX*16,this.chunkZ*16,this.dimension)
-			let h = chunk.columnHashs[(this.z&15)*16+(this.x&15)]
-			if(h !== this.prevColumn){
-				this.prevColumn = h
-				this.willUpdateShape = true
-			}
-			if(this.willUpdateShape){
-				this.updateShape()
-				this.willUpdateShape = false
-			}
-			this.previousYaw = this.yaw
-			this.yaw += 0.05
-      if(this.yaw > Math.PId){
-        this.yaw -= Math.PId
-        this.previousYaw -= Math.PId
-      }
-			this.lastUpdate = now
-			let block = this.world.getBlock(this.x,this.actualY,this.z,this.dimension)
-			if(block !== (blockIds.beacon | BEACON)) this.canDespawn = true
-		}
-	}
-
-	entities[entities.length] = class Minecart extends Entity{
-		static name2 = "Minecart"
-		pushes = true
-		constructor(x,y,z){
-			let tex = textureCoords[textureMap.minecart]
-      let vao = generateVAO(shapes.minecart, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-			super(x, y, z, 0, 0, 0, 0, 0, 0.98, 1, 0.98, null, null, vao.size, Infinity, vao.vao)
-			this.health = 6
-			this.noScale = true
-			this.heightOnDiagonal = 1-this.width
-			this.defaultHeight = this.height
-			this.health = 6
-			this.prevOnTrack = false
-			this.rideOffsetY = -6/16
-			this.canRide = true
-		}
-		updateVelocity(now) {
-      this.standingOn = this.world.getBlock(round(this.x), floor(this.y-this.height/2), round(this.z), this.dimension)
-      if(this.prevLiquid !== this.liquid){
-        this.prevLiquid = this.liquid
-      }
-			this.vely += this.gravityStength
-			let drag = this.liquid ? 0.7 : 0.95
-			let yDrag = this.liquid ? 0.7 : 0.95
-			if(blockData[this.standingOn].slide) drag = blockData[this.standingOn].slide
-			this.velz += (this.velz * drag - this.velz)
-			this.velx += (this.velx * drag - this.velx)
-			this.vely += (this.vely * yDrag - this.vely)
-		}
-		update(){
-			let railX = round(this.x), railY = round(this.y), railZ = round(this.z)
-			let onBlock = this.world.getBlock(railX,railY,railZ,this.dimension)
-			if(!blockData[onBlock].rail){
-				let under = this.world.getBlock(railX,railY-1,railZ,this.dimension)//to allow diagonals
-				if(blockData[under].rail) onBlock = under, railY--
-			}
-
-			this.updateVelocity(now)
-			let {velx, vely, velz} = this
-			let speed = sqrt(velx*velx+velz*velz+vely*vely)*2
-			if(speed>1){
-				this.velx /= speed, this.vely /= speed, this.velz /= speed
-			}
-			this.move(now)
-
-			this.height = this.defaultHeight
-			this.pitch = 0
-			this.offsetY = 0
-			if(onBlock && blockData[onBlock].rail){
-				let rot = onBlock&ROTATION
-				let {prevOnTrack} = this
-				if((onBlock & isState) === CUBE){
-					let velMag = sqrt(velx*velx+velz*velz)
-					if(rot === NORTH || rot === SOUTH) this.velz = prevOnTrack ? velMag*Math.sign(velz) : velz, this.velx = 0, this.x = railX, this.yaw = round(this.yaw/Math.PI)*Math.PI
-					else if(rot === EAST || rot === WEST) this.velx = prevOnTrack ? velMag*Math.sign(velx) : velx, this.velz = 0, this.z = railZ, this.yaw = round((this.yaw-Math.PI2)/Math.PI)*Math.PI+Math.PI2
-					this.vely = 0, this.y = railY
-					this.prevOnTrack = true
-				}else if((onBlock & isState) === STAIR){//corner rail
-					let originX, originZ
-					if(rot === NORTH) originX = railX-0.5, originZ = railZ-0.5
-					else if(rot === WEST) originX = railX+0.5, originZ = railZ-0.5
-					else if(rot === SOUTH) originX = railX+0.5, originZ = railZ+0.5
-					else if(rot === EAST) originX = railX-0.5, originZ = railZ+0.5
-					let dx = this.x-originX, dz = this.z-originZ
-					let mag = sqrt(dx*dx+dz*dz)*2
-					dx /= mag, dz /= mag
-					this.x = originX+dx
-					this.z = originZ+dz
-					let targetYaw = atan2(dx,dz)+Math.PI2
-					this.yaw = round((this.yaw-targetYaw)/Math.PI)*Math.PI+targetYaw
-					//below: calculate new velocity
-					let velMag = sqrt(velx*velx+velz*velz)
-					let prevDir = velx*dz + velz*-dx//more accurate if use previous dx and dz
-					let s = dz*2, c = -dx*2
-					if(prevOnTrack){
-						prevDir = Math.sign(prevDir)
-						this.velx = velMag*s*prevDir
-						this.velz = velMag*c*prevDir
-					}else{
-						this.velx = prevDir*s
-						this.velz = prevDir*c
-					}
-					this.vely = 0, this.y = railY
-					//this.world.blockParticles(4,this.x+Math.sign(velMag)*sin(this.yaw),7,this.z+Math.sign(velMag)*cos(this.yaw),1,'','')
-					/*//stop velocity in certain direction
-					let dot = this.velx*dx + this.velz*dz
-					this.velx = this.velx - dx * dot
-					this.velz = this.velz - dz * dot*/
-					this.prevOnTrack = true
-				}else if((onBlock & isState) === SLAB){//raised
-					let diagonal = sqrt(0.5)
-					let originX = railX, originY = railY, originZ = railZ, dx = 0, dy = diagonal, dz = 0
-					if(rot === NORTH) originZ -= 0.5, dz = diagonal, this.yaw = round(this.yaw/Math.PI)*Math.PI
-					else if(rot === SOUTH) originZ += 0.5, dz = -diagonal, this.yaw = round(this.yaw/Math.PI)*Math.PI
-					else if(rot === EAST) originX -= 0.5, dx = diagonal, this.yaw = round((this.yaw-Math.PI2)/Math.PI)*Math.PI+Math.PI2
-					else if(rot === WEST) originX += 0.5, dx = -diagonal, this.yaw = round((this.yaw-Math.PI2)/Math.PI)*Math.PI+Math.PI2
-					let dot = (this.x-originX)*dx + (this.z-originZ)*dz + (this.y-originY)*dy
-					this.x = originX+dx*dot
-					this.y = originY+dy*dot
-					this.z = originZ+dz*dot
-					let velMag = sqrt(velx*velx+velz*velz+vely*vely)
-					let prevDir = velx*dx + velz*dz + vely*dy//more accurate if use previous dx and dz
-					if(prevOnTrack){
-						prevDir = Math.sign(prevDir)
-						this.velx = velMag*dx*prevDir
-						this.velz = velMag*dz*prevDir
-						this.vely = velMag*dy*prevDir
-					}else{
-						this.velx = prevDir*dx
-						this.velz = prevDir*dz
-						this.vely = prevDir*dy
-					}
-					this.prevOnTrack = true
-					this.height = this.heightOnDiagonal//to allow fitting
-					this.pitch = -Math.PI4*Math.sign(sin(this.yaw)*dx+cos(this.yaw)*dz)
-					this.offsetY = 0.25
-				}else this.prevOnTrack = false
-				if(this.yaw > Math.PId) this.yaw -= Math.PId, this.previousYaw -= Math.PId
-				if(this.yaw < 0) this.yaw += Math.PId, this.previousYaw += Math.PId
-				if(blockData[onBlock].name === "poweredRail"){
-					let velMag = sqrt(velx*velx+velz*velz+vely*vely)
-					if(onBlock&FLIP){
-						if(velMag > 0.01 && velMag<8){
-							let extraSpeed = (8-velMag)*0.06
-							this.velx += this.velx/velMag*extraSpeed
-							this.velz += this.velz/velMag*extraSpeed
-							this.vely += this.vely/velMag*extraSpeed
-							if((onBlock&isState) === CUBE){
-								if(rot === NORTH || rot === SOUTH){
-									if(blockData[this.world.getBlock(railX,railY,railZ+1)].solid) this.velz = min(this.velz,-0.1)
-									else if(blockData[this.world.getBlock(railX,railY,railZ-1)].solid) this.velz = max(this.velz,0.1)
-								}else if(rot === EAST || rot === WEST){
-									if(blockData[this.world.getBlock(railX+1,railY,railZ)].solid) this.velx = min(this.velx,-0.1)
-									else if(blockData[this.world.getBlock(railX-1,railY,railZ)].solid) this.velx = max(this.velx,0.1)
-								}
-							}
-						}
-					}else{
-						this.velx *= 0.65
-						this.velz *= 0.65
-						this.vely *= 0.65
-					}
-				}
-			}else this.prevOnTrack = false
-
-			if(this.harmEffect > 0){
-				this.harmEffect--
-				this.roll = sin(this.harmEffect/3*Math.PI)*this.harmEffect*Math.PI*0.025
-			}else this.roll = 0
-		}
-		render() {
-      totalEntites++
-      if(this.hidden || !p.camera.canSeeEntity(this.x,this.y,this.z,this.width,this.height,this.depth)) return
-      renderedEntities++
-      
-      let diff = (now - this.lastUpdate) / tickTime
-			if (diff > 1) diff = 1
-			const offsetY = lerp(diff,this.prevOffsetY,this.offsetY)
-      let renderx = (this.x - this.previousX) * diff + this.previousX
-			let rendery = ((this.y - this.previousY) * diff + this.previousY) + offsetY
-			let renderz = (this.z - this.previousZ) * diff + this.previousZ
-      
-			const modelMatrix = entityMatrices.modelMatrix;
-			modelMatrix.identity()
-			modelMatrix.translate(renderx, rendery, renderz)
-			modelMatrix.rotY(lerp(diff,this.previousYaw,this.yaw))
-			modelMatrix.rotX(lerp(diff,this.previousPitch,this.pitch))
-			if(this.roll || this.previousRoll) modelMatrix.rotZ(lerp(diff,this.previousRoll,this.roll))
-			const viewMatrix = p.camera.transformation.elements
-			const proj = p.camera.projection
-			let projectionMatrix = entityMatrices.projectionMatrix
-      projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
-      projectionMatrix = projectionMatrix.elements
-			const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
-			modelViewProjectionMatrix.identity()
-			modelViewProjectionMatrix.mult(projectionMatrix)
-			modelViewProjectionMatrix.mult(viewMatrix)
-			modelViewProjectionMatrix.mult(modelMatrix.elements)
-			// row major to column major
-			modelViewProjectionMatrix.transpose()
-			modelMatrix.transpose()//for normal
-			const x = round(this.x)
-			const y = round(this.y)
-			const z = round(this.z)
-			const blockLight = this.glow ? 1 : this.world.getLight(x, y, z, 1, this.dimension)/15
-			const skysLight = this.world.getLight(x, y, z, 0, this.dimension)/15
-			gl.uniform1i(glCache.uSamplerEntity, 0)
-			gl.uniform1f(glCache.uBlockLightEntity, blockLight)
-			gl.uniform1f(glCache.uSkylightEntity, skysLight)
-      gl.uniform1f(glCache.harmEffectEntity, 0)
-			gl.uniform3f(glCache.uPosEntity, p.renderX-this.x, p.renderY-this.y, p.renderZ-this.z)
-			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
-			gl.uniformMatrix4fv(glCache.uModelMatEntity, false, modelMatrix.elements)
-			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
-			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
-			glExtensions.vertex_array_object.bindVertexArrayOES(null)
-		}
-	}
   
   class crackEntity extends Entity{
     constructor(tex, x,y,z){
@@ -18009,40 +16132,12 @@
   class Mob extends Entity{
 		static mob = true
 		mob = true
-		pushes = true
+		noScale = true
     constructor(){
 			super(...arguments)
-      /*this.moveTime = 0
-      this.spinTime = 0
-      this.spin = 0
-      this.dirx = 0
-      this.dirz = 0*/
-      this.health = 0
-			this.path = null
-			this.walking = false
-			this.panick = 0
-			this.drop = null
-			this.dropAmount = 0
-			this.burnTimer = 0
-			this.burning = false
-			this.oxygen = 20
-			this.spinTarget = 0
-			this.spinTargetPitch = 0
-			this.die = false
-			this.lastDamage = 0
-			this.lastStepSound = 0
-			this.noScale = true
-			this.target = null, this.targetEnt = null
-			this.attackCooldown = 0
-			this.attractEnt = null, this.attractedBy = null
-			this.holding = this.prevHolding = 0
-			this.canClimb = false
-			this.canFly = false
-			this.sitting = false
-			this.owner = null
-			this.name = null
-			this.effects = {}
 			this.doInterpolate = true
+			this.offsetry = Math.PI
+			this.offsetY = -this.height*0.5
     }
     mobUpdate(now) {
       this.maxBurnBlock = this.maxDamageBlock = 0
@@ -18078,7 +16173,7 @@
       }
 			if(this.prevHolding !== this.holding){
 				this.prevHolding = this.holding
-				if(this.updateHolding) this.updateHolding()
+				this.updateHolding()
 			}
 			if(this.prevName !== this.name){
 				this.prevName = this.name
@@ -18098,6 +16193,127 @@
         this.nameText.z = this.z
 			}
 		}
+		walkStart = 0
+		prevWalking = false
+		walkRot = 0
+		update(){
+      this.mobUpdate(now)
+			if(this.additionalUpdateClient) this.additionalUpdateClient()
+
+      if(this.prevWalking !== this.walking){
+        this.prevWalking = this.walking
+        this.walkStart = now
+      }
+      var walkRotTarget = 0
+      if(this.walking){
+        if(this.panick > 0) walkRotTarget = sin(((now - this.walkStart) / 500) * Math.PI) * Math.PI / 4
+        else walkRotTarget = sin(((now - this.walkStart) / 1000) * Math.PI) * Math.PI / 4
+      }
+      this.walkRot = lerp(0.5,this.walkRot,walkRotTarget)
+      if(this.parts.leg0) this.parts.leg0.rx = -this.walkRot
+      if(this.parts.leg2) this.parts.leg2.rx = this.walkRot
+      if(this.parts.leg1) this.parts.leg1.rx = this.walkRot
+      if(this.parts.leg3) this.parts.leg3.rx = -this.walkRot
+      if(this.parts.leftleg) this.parts.leftleg.rx = this.walkRot
+      if(this.parts.rightleg) this.parts.rightleg.rx = -this.walkRot
+      if(this.parts.leftLeg) this.parts.leftLeg.rx = this.walkRot
+      if(this.parts.rightLeg) this.parts.rightLeg.rx = -this.walkRot
+
+			const holdRot = Math.PI / -10
+			let armRot = (sin((now - this.spawn) / 1000) / 2 + 0.5) * Math.PI / 40
+			let leftArm = this.parts.leftArm || this.parts.leftarm || this.parts.arm0
+			let rightArm = this.parts.rightArm || this.parts.rightarm || this.parts.arm1
+			if(leftArm) leftArm.rz = armRot
+			if(rightArm) rightArm.rz = -armRot
+			if(leftArm && rightArm){
+				if(this.targetEnt){
+					if(blockData[this.holding].name === "bow"){
+						leftArm.rx = Math.PI2
+						leftArm.ry2 = Math.PI4
+						rightArm.rx = Math.PI2
+					}else if(blockData[this.holding].spyglass){
+						rightArm.rx = Math.PI2+holdRot
+					}else{
+						leftArm.rx = rightArm.rx = Math.PI2
+					}
+				}else{
+					leftArm.rx = this.walkRot
+					rightArm.rx = -this.walkRot
+				}
+			}
+
+			if(this.parts.head){
+				if(this.targetEnt || this.attractEnt){
+					let {x,y,z} = this.targetEnt || this.attractEnt
+					let yaw = angleOf(x,z,this.x,this.z)
+					this.parts.head.ry2 = -(this.yaw - yaw)
+					if(this.parts.head.ry2 - this.parts.head.pry2 > Math.PI) this.parts.head.pry2 += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
+					if(this.parts.head.ry2 - this.parts.head.pry2 < -Math.PI) this.parts.head.pry2 -= Math.PId
+					let adjacent = dist2(this.x,this.z,x,z)
+					this.parts.head.rx = Math.PId - atan2(y - (this.y+this.parts.head.y), adjacent)
+					this.parts.head.ry = 0
+				}else if(this.path){
+					let i = this.path.length - 3
+					let x = this.path[i], y = this.path[i+1], z = this.path[i+2]
+					let yaw = angleOf(x,z,this.x,this.z)
+					this.parts.head.ry = -(this.yaw - yaw)
+					if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
+					if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
+					this.parts.head.rx = this.parts.head.ry2 = 0
+				}else if(this.spinTarget){
+					let yaw = this.spinTarget
+					this.parts.head.ry = -(this.yaw - yaw)
+					if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
+					if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
+					this.parts.head.rx = this.parts.head.ry2 = 0
+				}
+			}
+		}
+		updateHolding(){
+			let part = this.parts.rightItem
+			if(!part) return
+			let v = generateBlockVAO(this.holding)
+			part.vao = v.vao
+			part.size = v.size
+			let pix = 1 / 16
+			const holdRot = Math.PI / -10
+			if(blockData[this.holding].tool){
+				part.x = 0
+				part.y = pix*-12
+				part.z = pix*6
+				part.w = part.h = part.d = 1
+				part.rx = Math.PI / 1.25
+				part.ry = Math.PI * -0.5
+			}else if(blockData[this.holding].name === "bow"){
+				part.x = 0
+				part.y = pix*-12
+				part.z = pix*12
+				part.w = part.h = part.d = 1
+				part.rx = Math.PI / 1.25
+				part.ry = Math.PI * -0.5
+			}else if(blockData[this.holding].spyglass){
+				part.x = pix*2
+				part.y = pix*-10
+				part.z = 0
+				part.w = part.h = part.d = 1
+				part.rx = -holdRot
+				part.ry = 0
+			}else if(blockData[this.holding].item){
+				part.x = -pix*6
+				part.y = 0//pix*-11
+				part.z = pix*12
+				part.w = part.h = part.d = 0.5
+				part.rx = Math.PI2
+				part.ry = 0
+			}else if(this.holding){
+				part.x = 0
+				part.y = pix*12
+				part.z = 0//pix*3
+				part.w = part.h = part.d = 0.25
+				part.rx = 0
+				part.ry = Math.PI / 4
+			}
+		}
     /*onhit(damage,remote, vx,vz, from){
       if(!remote) send({
         type:"entEvent",event:"damageMob",id:this.id,
@@ -18119,1002 +16335,988 @@
     }*/
   }
   
-  entities[entities.length] = class Cow extends Mob{
-		static name2 = "Cow"
-		defaultName = "Cow"
-    constructor(x,y,z){
-      var tex = textureCoords[textureMap.cow]
-      var vao = generateVAO(shapes.cowBody, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      super(x, y, z, 0, 0, 0, 0, 0, 1, 21/16, 1, null,null, vao.size, 300000, vao.vao)
-      var pix = 1/16
-      this.offsetY = pix*9.5
-      
-      var part = generateVAO(shapes.cowLeg,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("frontRightLeg",part.size,part.vao,pix*-4,pix*-8,pix*7,1,1,1,0,0)
-      this.addPart("frontLeftLeg",part.size,part.vao,pix*4,pix*-8,pix*7,1,1,1,0,0)
-      this.addPart("backRightLeg",part.size,part.vao,pix*-4,pix*-8,pix*-6,1,1,1,0,0)
-      this.addPart("backLeftLeg",part.size,part.vao,pix*4,pix*-8,pix*-6,1,1,1,0,0)
-      var part = generateVAO(shapes.cowHead,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("head",part.size,part.vao,0,0,pix*9,1,1,1,0,0)
-      
-      this.health = 10
-      this.prevWalking = false
-      this.walkStart = 0
-      this.walkRot = 0
-    }
-    update(){
-      this.mobUpdate(now)
+	let entityDataAdditional = {
+		Item: Item => class extends Item {
+			constructor() {
+				super(...arguments)
+				this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
+				this.updateShape()
+				this.noHitbox = true
+				this.canFloat = true
+				this.cullFace = true
+				this.prevAmount = null
+			}
+			update() {
+				super.update()
+				
+				if(now - this.spawn > 1000){
+					if(!p.spectator && !p.die && p.dimension === this.dimension) this.goCloserToPlayer(p)
+					if(multiplayer) for(var i in players){
+						var P = players[i]
+						if(!P.hidden && !P.die && P.dimension === this.dimension) this.goCloserToPlayer(P)
+					}
+				}
+				
+				if(this.amount !== this.prevAmount){
+					this.prevAmount = this.amount
+					this.updateShape()
+				}
+				
+				this.offsetY = -0.1 * cos(this.yaw*2) + 0.15
+				
+				let id = this.block
+				if(id && blockData[id].tint){
+					let biome = this.world.getBiome(round(this.x),round(this.y),round(this.z),this.dimension)
+					let tints = blockData[id].tint
+					this.tint = tints[biome] || tints.default
+					this.tintGray = true
+				}
+			}
+			shape1 = [0,0,0]
+			shape2 = [-1,-1,-1, 1,1,1]
+			shape3 = [-1,-1,-1, 1,1,1, -0.5,0,0.5]
+			shape4 = [-1,-1,-1, 1,1,1, -0.5,0,0.5, 0.5,1.5,-0.5]
+			shape5 = [-1,-1,-1, 1,1,1, -0.5,0,0.5, 0.5,1.5,-0.5, 1.5,0.75,0]
+			updateShape(){
+				let amount
+				if(this.amount === 1){
+					amount = this.shape1
+				}else if(this.amount <= 16){
+					amount = this.shape2
+				}else if(this.amount <= 32){
+					amount = this.shape3
+				}else if(this.amount <= 48){
+					amount = this.shape4
+				}else{
+					amount = this.shape5
+				}
+				const block = blockData[this.block]
+				const tex = block.textures
+				const shape = block.shape
+				const shapeVerts = shape.verts
+				const shapeTexVerts = shape.texVerts
+				const size = shape.size*(amount.length/3)
+				const shapeNormal = shape.normal
+				let blockSides = Object.keys(Block)
+				let texNum = 0
+				let texture = []
+				let index = 0
+				let verts = [], vertIndex = 0
+				let normal = []
+				let offsetX = 0, offsetY = 0, offsetZ = 0
+				for(let amounti = 0; amounti < amount.length; amounti += 3){
+					offsetX = amount[amounti]/4, offsetY = amount[amounti+1]/4, offsetZ = amount[amounti+2]/4
+					texNum = 0
+					for (let n = 0; n < 6; n++) {
+						let side = blockSides[n]
+						let directionalFaces = shapeVerts[n]
+						for (let facei = 0; facei < directionalFaces.length; facei++) {
+							let texShapeVerts = shapeTexVerts[n][facei]
+							let texVerts
+							texVerts = textureCoords[textureMap[texShapeVerts.texture] || tex && textureMap[tex[texNum]] || textureMap.error]
+							let tx = texVerts[0]
+							let ty = texVerts[1]
+							let tw = texVerts[2]-tx
+							let th = texVerts[5]-ty
+							texture[index    ] = tx + texShapeVerts[0]*tw
+							texture[index + 1] = ty + texShapeVerts[1]*th
+							texture[index + 2] = tx + texShapeVerts[2]*tw
+							texture[index + 3] = ty + texShapeVerts[3]*th
+							texture[index + 4] = tx + texShapeVerts[4]*tw
+							texture[index + 5] = ty + texShapeVerts[5]*th
+							texture[index + 6] = tx + texShapeVerts[6]*tw
+							texture[index + 7] = ty + texShapeVerts[7]*th
+							index += 8
+							let faceVerts = directionalFaces[facei]
+							verts[vertIndex] = faceVerts[0]+offsetX
+							verts[vertIndex+1] = faceVerts[1]+offsetY
+							verts[vertIndex+2] = faceVerts[2]+offsetZ
+							verts[vertIndex+3] = faceVerts[3]+offsetX
+							verts[vertIndex+4] = faceVerts[4]+offsetY
+							verts[vertIndex+5] = faceVerts[5]+offsetZ
+							verts[vertIndex+6] = faceVerts[6]+offsetX
+							verts[vertIndex+7] = faceVerts[7]+offsetY
+							verts[vertIndex+8] = faceVerts[8]+offsetZ
+							verts[vertIndex+9] = faceVerts[9]+offsetX
+							verts[vertIndex+10] = faceVerts[10]+offsetY
+							verts[vertIndex+11] = faceVerts[11]+offsetZ
+							vertIndex += 12
+							normal.push(...shapeNormal[n][facei],...shapeNormal[n][facei],...shapeNormal[n][facei],...shapeNormal[n][facei])
+						}
+						texNum++
+					}
+				}
+				
+				var vertices = new Float32Array(verts)
+				texture = new Float32Array(texture)
+				
+				const verticesBuffer = gl.createBuffer()
+				const textureBuffer = gl.createBuffer()
+				const normalBuffer = gl.createBuffer()
+				glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
+				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
 
-      if(this.prevWalking !== this.walking){
-        this.prevWalking = this.walking
-        this.walkStart = now
-      }
-      var walkRotTarget = 0
-      if(this.walking){
-        if(this.panick > 0) walkRotTarget = sin(((now - this.walkStart) / 500) * Math.PI) * Math.PI / 4
-        else walkRotTarget = sin(((now - this.walkStart) / 1000) * Math.PI) * Math.PI / 4
-      }
-      this.walkRot = lerp(0.5,this.walkRot,walkRotTarget)
-      this.parts.frontLeftLeg.rx = this.walkRot
-      this.parts.frontRightLeg.rx = -this.walkRot
-      this.parts.backLeftLeg.rx = this.walkRot
-      this.parts.backRightLeg.rx = -this.walkRot
+				gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
+				gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
+				gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)
+
+				gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
+				gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
+				gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
+				
+				gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer)
+				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normal), gl.STATIC_DRAW)
+				gl.vertexAttribPointer(glCache.aNormalEntity, 3, gl.FLOAT, false, 0, 0)
+
+				gl.enableVertexAttribArray(glCache.aVertexEntity)
+				gl.enableVertexAttribArray(glCache.aTextureEntity)
+				gl.enableVertexAttribArray(glCache.aNormalEntity)
+				glExtensions.vertex_array_object.bindVertexArrayOES(null)
+				
+				this.faces = size
+			}
+		},
+		BlockEntity: BlockEntity => class extends BlockEntity{
+			constructor(){
+				super(...arguments)
+				let v = generateBlockVAO(this.block)
+				this.faces = v.size
+				this.vao = v.vao
+				this.noHitbox = true
+				this.cullFace = true
+			}
+			changeBlock(blockID){
+				if(this.block === blockID) return
+				this.block = blockID
+				let v = generateBlockVAO(blockID)
+				this.faces = v.size
+				this.vao = v.vao
+			}
+			update() {
+				super.update()
+				
+				var id = this.block
+				if(id && blockData[id].tint){
+					var biome = this.world.getBiome(round(this.x),round(this.y),round(this.z),this.dimension)
+					var tints = blockData[id].tint
+					this.tint = tints[biome] || tints.default
+					this.tintGray = true
+				}
+			}
+		},
+		PrimedTNT: PrimedTNT => class extends PrimedTNT{
+			update() {
+				super.update()
+				
+				var i = Math.floor((now - this.timerStart) / 250)
+				this.shader = 0
+				if(!(i%2)){
+					this.shader = 1
+					if(!performFast) this.world.addParticle(new SmokeParticle(this.x,this.y+0.5-0.125,this.z), this.dimension)
+				}
+				if((now - this.spawn) / tickTime >= this.timeLimit - 10){
+					//get bigger
+					this.extraSize = min(-((this.timeLimit - 10) - ((now - this.spawn) / tickTime)) / 40,0.25)
+					this.shader = 1
+				}
+			}
+		},
+		MovingBlock: MovingBlock => class extends MovingBlock{
+			noRemoteDelete = true
+			setPos(){}
+			update() {
+				if (this.lastUpdate - this.spawn2 - tickTime > this.despawns) {
+					this.canDespawn = true
+				}
+				super.update()
+
+				let id = this.block
+				if(id && blockData[id].tint){
+					let biome = this.world.getBiome(round(this.x),round(this.y),round(this.z),this.dimension)
+					let tints = blockData[id].tint
+					this.tint = tints[biome] || tints.default
+					this.tintGray = true
+				}
+			}
+		},
+		BlockDisplay: BlockDisplay => class extends BlockDisplay{
+			update() {
+				super.update()
+				let id = this.block
+				if(id && blockData[id].tint){
+					let biome = this.world.getBiome(round(this.x),round(this.y),round(this.z),this.dimension)
+					let tints = blockData[id].tint
+					this.tint = tints[biome] || tints.default
+					this.tintGray = true
+				}
+			}
+		},
+		SlingshotShot: SlingshotShot => class extends SlingshotShot{
+			move(now) {
+				let pminX = floor(this.x - this.width / 2)
+				let pmaxX = ceil(this.x + this.width / 2)
+				let pminY = floor(this.y - this.height / 2)
+				let pmaxY = ceil(this.y + this.height / 2)
+				let pminZ = floor(this.z - this.depth / 2)
+				let pmaxZ = ceil(this.z + this.depth / 2)
+				let block = null
+
+				this.liquid = false
+				for (let x = pminX; x <= pmaxX; x++) {
+					for (let y = pminY; y <= pmaxY; y++) {
+						for (let z = pminZ; z <= pmaxZ; z++) {
+							let block = this.world.getBlock(x, y, z, this.dimension)
+							if (block && blockData[block].solid) {
+								this.contacts.add(x, y, z, block)
+							}
+							if(x === round(this.x) && z === round(this.z) && blockData[block].liquid){
+								this.liquid = true
+							}
+						}
+					}
+				}
 
-      if(this.targetEnt || this.attractEnt){
-        let {x,y,z} = this.targetEnt || this.attractEnt
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry2 = -(this.yaw - yaw)
-        if(this.parts.head.ry2 - this.parts.head.pry2 > Math.PI) this.parts.head.pry2 += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry2 - this.parts.head.pry2 < -Math.PI) this.parts.head.pry2 -= Math.PId
-        let adjacent = dist2(this.x,this.z,x,z)
-        this.parts.head.rx = Math.PId - atan2(y - (this.y+this.parts.head.y), adjacent)
-				this.parts.head.ry = 0
-      }else if(this.path){
-        let i = this.path.length - 3
-        let x = this.path[i], y = this.path[i+1], z = this.path[i+2]
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }else if(this.spinTarget){
-        let yaw = this.spinTarget
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }
-    }
-  }
-  
-  entities[entities.length] = class Pig extends Mob{
-		static name2 = "Pig"
-		defaultName = "Pig"
-    constructor(x,y,z){
-      var tex = textureCoords[textureMap.pig]
-      var vao = generateVAO(shapes.pigBody, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      super(x, y, z, 0, 0, 0, 0, 0, 1, 1, 1, null,null, vao.size, 300000, vao.vao)
-      var pix = 1/16
-      this.offsetY = pix*6
-      var part = generateVAO(shapes.pigLeg,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("frontRightLeg",part.size,part.vao,pix*-3,pix*-8,pix*5,1,1,1,0,0)
-      this.addPart("frontLeftLeg",part.size,part.vao,pix*3,pix*-8,pix*5,1,1,1,0,0)
-      this.addPart("backRightLeg",part.size,part.vao,pix*-3,pix*-8,pix*-7,1,1,1,0,0)
-      this.addPart("backLeftLeg",part.size,part.vao,pix*3,pix*-8,pix*-7,1,1,1,0,0)
-      var part = generateVAO(shapes.pigHead,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("head",part.size,part.vao,0,pix*-2,pix*10,1,1,1,0,0)
-      
-      this.health = 10
-      this.prevWalking = false
-      this.walkStart = 0
-      this.walkRot = 0
-    }
-    update(){
-      this.mobUpdate(now)
+				this.previousX = this.x
+				this.previousY = this.y
+				this.previousZ = this.z
 
-      if(this.prevWalking !== this.walking){
-        this.prevWalking = this.walking
-        this.walkStart = now
-      }
-      var walkRotTarget = 0
-      if(this.walking){
-        if(this.panick > 0) walkRotTarget = sin(((now - this.walkStart) / 500) * Math.PI) * Math.PI / 4
-        else walkRotTarget = sin(((now - this.walkStart) / 1000) * Math.PI) * Math.PI / 4
-      }
-      this.walkRot = lerp(0.5,this.walkRot,walkRotTarget)
-      this.parts.frontLeftLeg.rx = this.walkRot
-      this.parts.frontRightLeg.rx = -this.walkRot
-      this.parts.backLeftLeg.rx = this.walkRot
-      this.parts.backRightLeg.rx = -this.walkRot
+				var xBounce, yBounce, zBounce, pvelx = this.velx, pvely = this.vely, pvelz = this.velz
+				
+				this.canStepX = false
+				this.canStepY = false
+				this.onGround = false
+				this.hasCollided = false
+				//Check collisions in the Y direction
+				this.y += this.vely
+				for (let i = 0; i < this.contacts.size; i++) {
+					block = this.contacts.array[i]
+					if (this.collided(block[0], block[1], block[2], null, this.vely, null, block[3])) {
+						this.y = this.previousY
+						this.vely = 0
+						this.hasCollided = true
+						yBounce = true
+						break
+					}
+				}
 
-      if(this.targetEnt || this.attractEnt){
-        let {x,y,z} = this.targetEnt || this.attractEnt
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry2 = -(this.yaw - yaw)
-        if(this.parts.head.ry2 - this.parts.head.pry2 > Math.PI) this.parts.head.pry2 += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry2 - this.parts.head.pry2 < -Math.PI) this.parts.head.pry2 -= Math.PId
-        let adjacent = dist2(this.x,this.z,x,z)
-        this.parts.head.rx = Math.PId - atan2(y - (this.y+this.parts.head.y), adjacent)
-				this.parts.head.ry = 0
-      }else if(this.path){
-        let i = this.path.length - 3
-        let x = this.path[i], y = this.path[i+1], z = this.path[i+2]
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }else if(this.spinTarget){
-        let yaw = this.spinTarget
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }
-    }
-  }
-  entities[entities.length] = class Creeper extends Mob{
-		static name2 = "Creeper"
-		defaultName = "Creeper"
-    constructor(x,y,z){
-      var tex = textureCoords[textureMap.creeper]
-      var vao = generateVAO(shapes.creeperBody, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      super(x, y, z, 0, 0, 0, 0, 0, 0.5, 26/16, 0.5, null,null, vao.size, 300000, vao.vao)
-      var pix = 1/16
-      this.offsetY = pix*-1
-      var part = generateVAO(shapes.pigLeg,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("frontRightLeg",part.size,part.vao,pix*-2,pix*-6,pix*4,1,1,1,0,0)
-      this.addPart("frontLeftLeg",part.size,part.vao,pix*2,pix*-6,pix*4,1,1,1,0,0)
-      this.addPart("backRightLeg",part.size,part.vao,pix*-2,pix*-6,pix*-4,1,1,1,0,0)
-      this.addPart("backLeftLeg",part.size,part.vao,pix*2,pix*-6,pix*-4,1,1,1,0,0)
-      var part = generateVAO(shapes.creeperHead,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("head",part.size,part.vao,0,pix*10,0,1,1,1,0,0)
-      
-      this.health = 10
-      this.prevWalking = false
-      this.walkStart = 0
-      this.walkRot = 0
-      this.timerStart = 0
-      this.explodeAmount = 0
-      this.timeLimit = 30
-    }
-    update(){
-      this.mobUpdate(now)
+				if (this.y === this.previousY) {
+					this.canStepX = true
+					this.canStepZ = true
+				}
 
-      if(this.prevWalking !== this.walking){
-        this.prevWalking = this.walking
-        this.walkStart = now
-      }
-      var walkRotTarget = 0
-      if(this.walking){
-        if(this.panick > 0) walkRotTarget = sin(((now - this.walkStart) / 500) * Math.PI) * Math.PI / 4
-        else walkRotTarget = sin(((now - this.walkStart) / 1000) * Math.PI) * Math.PI / 4
-      }
-      this.walkRot = lerp(0.5,this.walkRot,walkRotTarget)
-      this.parts.frontLeftLeg.rx = this.walkRot
-      this.parts.frontRightLeg.rx = -this.walkRot
-      this.parts.backLeftLeg.rx = this.walkRot
-      this.parts.backRightLeg.rx = -this.walkRot
+				//Check collisions in the X direction
+				this.x += this.velx
+				for (let i = 0; i < this.contacts.size; i++) {
+					block = this.contacts.array[i]
+					if (this.collided(block[0], block[1], block[2], this.velx, null, null, block[3])) {
+						if (this.canStepX && !this.world.getBlock(block[0], block[1] + 1, block[2], this.dimension) && !this.world.getBlock(block[0], block[1] + 2, block[2], this.dimension)) {
+							continue
+						}
+						this.x = this.previousX
+						this.velx = 0
+						this.hasCollided = true
+						xBounce = true
+						break
+					}
+				}
 
-      if(this.targetEnt){
-        let {x,y,z} = this.targetEnt
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry2 = -(this.yaw - yaw)
-        if(this.parts.head.ry2 - this.parts.head.pry2 > Math.PI) this.parts.head.pry2 += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry2 - this.parts.head.pry2 < -Math.PI) this.parts.head.pry2 -= Math.PId
-        let adjacent = dist2(this.x,this.z,x,z)
-        this.parts.head.rx = Math.PId - atan2(y - (this.y+this.parts.head.y), adjacent)
-				this.parts.head.ry = 0
-      }else if(this.path){
-        let i = this.path.length - 3
-        let x = this.path[i], y = this.path[i+1], z = this.path[i+2]
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }else if(this.spinTarget){
-        let yaw = this.spinTarget
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }
+				//Check collisions in the Z direction
+				this.z += this.velz
+				for (let i = 0; i < this.contacts.size; i++) {
+					block = this.contacts.array[i]
+					if (this.collided(block[0], block[1], block[2], null, null, this.velz, block[3])) {
+						if (this.canStepZ && !this.world.getBlock(block[0], block[1] + 1, block[2], this.dimension) && !this.world.getBlock(block[0], block[1] + 2, block[2]), this.dimension) {
+							continue
+						}
+						this.z = this.previousZ
+						this.velz = 0
+						this.hasCollided = true
+						zBounce = true
+						break
+					}
+				}
+				
+				if(this.onGround){
+					this.hasCollided = true
+				}
+				
+				if(xBounce) this.velx = -pvelx
+				if(yBounce) this.vely = -pvely
+				if(zBounce) this.velz = -pvelz
 
-      let d = this.targetEnt && max(abs(this.targetEnt.x-this.x),abs(this.targetEnt.y-this.y),abs(this.targetEnt.z-this.z))
-      if(this.targetEnt && d<=3){
-        if(!this.explodeAmount){
-          this.timerStart = now
-        }
-        this.explodeAmount++
-        if(this.explodeAmount > 20) this.explodeAmount = 20
-      }else if(this.explodeAmount) this.explodeAmount--
-      this.shader = 0, this.extraSize = 0
-      if(this.explodeAmount>0){
-        var i = Math.floor((now - this.timerStart) / 125)
-        if(!(i%2)){
-          this.shader = 1
-        }
-        if((now - this.timerStart) / tickTime >= this.timeLimit - 10){
-          //get bigger
-          this.extraSize = min(-((this.timeLimit - 10) - ((now - this.timerStart) / tickTime)) / 40,0.25)
-					this.shader = 1
-        }
-      }
-    }
-  }
-  entities[entities.length] = class Sheep extends Mob{
-		static name2 = "Sheep"
-		defaultName = "Sheep"
-    constructor(x,y,z, color, wool){
-      super(x, y, z, 0, 0, 0, 0, 0, 1, 1, 1, null,null, 0, 300000, "vao")
-      var pix = 1/16
-      this.offsetY = pix*7
-      this.addPart("frontRightLeg",null,null,pix*-3,pix*-3,pix*5,1,1,1,0,0)
-      this.addPart("frontLeftLeg",null,null,pix*3,pix*-3,pix*5,1,1,1,0,0)
-      this.addPart("backRightLeg",null,null,pix*-3,pix*-3,pix*-7,1,1,1,0,0)
-      this.addPart("backLeftLeg",null,null,pix*3,pix*-3,pix*-7,1,1,1,0,0)
-      this.addPart("head",null,null,0,pix*4,pix*10,1,1,1,0,0)
-      this.health = 10
-      this.prevWalking = false
-      this.walkStart = 0
-      this.walkRot = 0
-      this.fur = true
-      this.prevFur = true
-      this.updateShape()
-      this.eating = 0
-      this.color = color
-			this.wool = wool
-      this.tintGray = true
-			this.attracts = [blockIds.wheat]
-    }
-    update(){
-      this.mobUpdate(now)
+				this.updateChunk()
 
-      if(this.prevWalking !== this.walking){
-        this.prevWalking = this.walking
-        this.walkStart = now
-      }
-      var walkRotTarget = 0
-      if(this.walking){
-        if(this.panick > 0) walkRotTarget = sin(((now - this.walkStart) / 500) * Math.PI) * Math.PI / 4
-        else walkRotTarget = sin(((now - this.walkStart) / 1000) * Math.PI) * Math.PI / 4
-      }
-      this.walkRot = lerp(0.5,this.walkRot,walkRotTarget)
-      this.parts.frontLeftLeg.rx = this.walkRot
-      this.parts.frontRightLeg.rx = -this.walkRot
-      this.parts.backLeftLeg.rx = this.walkRot
-      this.parts.backRightLeg.rx = -this.walkRot
+				this.lastUpdate = now
+				this.contacts.clear()
+			}
+		},
+		Arrow: Arrow => class extends Arrow{
+			noScale = true
+			constructor(x,y,z,dx,dy,dz, from){
+				super(...arguments)
+				this.setPartShapes(this.variantsBones.default)
+				this.noHitbox = true
+				this.from = from
+			}
+		},
+		ExperienceOrb: ExperienceOrb => class extends ExperienceOrb{
+			//experienceOrb
+			constructor(){
+				super(...arguments)
+				let value = this.value
+				let i
+				if(!value || value <= 2){
+					i = 0
+				}else if(value <= 6){
+					i = 1
+				}else if(value <= 16){
+					i = 2
+				}else if(value <= 36){
+					i = 3
+				}else if(value <= 72){
+					i = 4
+				}else if(value <= 148){
+					i = 5
+				}else if(value <= 306){
+					i = 6
+				}else if(value <= 616){
+					i = 7
+				}else if(value <= 1236){
+					i = 8
+				}else if(value <= 2476){
+					i = 9
+				}else if(value <= 32767){
+					i = 10
+				}
+				this.faces = experienceOrbVaos.size, this.vao = experienceOrbVaos[i]
+				this.tint = [1,1,1]
+				this.facesPlayer = true
+			}
+			update(){
+				for(var i in players){
+					if(!players[i].hidden && !players[i].die && players[i].dimension === this.dimension) this.goToPlayer(players[i])
+				}
+				
+				super.update()
+				
+				this.facePlayer()
+				
+				this.tint[0] = min(max(abs((now-this.spawn) % 1000 - 500) / 500, 0), 1)
+				this.tint[1] = 1
+				this.tint[2] = 0
+			}
+		},
+		Minecart: Minecart => entities[entities.length] = class extends Minecart{
+			noScale = true
+			pushes = true
+			constructor(){//todo n: use new shape
+				super(...arguments)
+				let tex = textureCoords[textureMap.minecart]
+				let vao = generateVAO(shapes.minecart, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
+				this.faces = vao.size, this.vao = vao.vao
+			}
+		},
+		TextDisplay: TextDisplay => class extends TextDisplay{
+			constructor(x,y,z,text,size,color,background,glow) {
+				super(...arguments)
+				this.offsetZ = 0
+				this.offsetX = 0
+				this.facesPlayer = true
+				
+				this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
+				this.buffer = gl.createBuffer()
+			}
+			setText(text){
+				if(!text) return this.text = text
 
-      if(this.targetEnt || this.attractEnt){
-        let {x,y,z} = this.targetEnt || this.attractEnt
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry2 = -(this.yaw - yaw)
-        if(this.parts.head.ry2 - this.parts.head.pry2 > Math.PI) this.parts.head.pry2 += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry2 - this.parts.head.pry2 < -Math.PI) this.parts.head.pry2 -= Math.PId
-        let adjacent = dist2(this.x,this.z,x,z)
-        this.parts.head.rx = Math.PId - atan2(y - (this.y+this.parts.head.y), adjacent)
-				this.parts.head.ry = 0
-      }else if(this.path){
-        let i = this.path.length - 3
-        let x = this.path[i], y = this.path[i+1], z = this.path[i+2]
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }else if(this.spinTarget){
-        let yaw = this.spinTarget
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }
-      if(this.eating){
-        if(this.parts.head.y > this.parts.head.originalY - 0.5){
-          this.parts.head.y -= 0.05
-        }else{
-          this.parts.head.rx = (sin(((now - this.spawn) / 250) * Math.PI) * Math.PI / 8)+Math.PI4
-        }
-      }else if(this.parts.head.y < this.parts.head.originalY){
-        this.parts.head.y += 0.05
-        this.parts.head.rx = 0
-        if(this.parts.head.y > this.parts.head.originalY) this.parts.head.y = this.parts.head.originalY
-      }
-      if(this.fur !== this.prevFur){
-        this.prevFur = this.fur
-        this.updateShape()
-      }
-      this.tint = this.color
-    }
-    updateShape(){
-      let tex = textureCoords[textureMap.sheepCombined]
-      let vao = generateVAO(this.fur ? shapes.sheepBodyFur : shapes.sheepBody, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.vao = vao.vao, this.faces = vao.size
-      let part = generateVAO(this.fur ? shapes.sheepLegFur : shapes.sheepLeg,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.parts.frontLeftLeg.vao = this.parts.frontRightLeg.vao = this.parts.backLeftLeg.vao = this.parts.backRightLeg.vao = part.vao
-      this.parts.frontLeftLeg.size = this.parts.frontRightLeg.size = this.parts.backLeftLeg.size = this.parts.backRightLeg.size = part.size
-      part = generateVAO(this.fur ? shapes.sheepHeadFur : shapes.sheepHead,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.parts.head.vao = part.vao
-      this.parts.head.size = part.size
-    }
-  }
-  entities[entities.length] = class Chicken extends Mob{
-		static name2 = "Chicken"
-		defaultName = "Chicken"
-    constructor(x,y,z){
-      var tex = textureCoords[textureMap.chicken]
-      var vao = generateVAO(shapes.chickenBody, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      var pix = 1/16
-      super(x, y, z, 0, 0, 0, 0, 0, 0.5, pix*11, 0.5, null,null, vao.size, 300000, vao.vao)
-      this.offsetY = pix*2.5
-      var part = generateVAO(shapes.chickenWing,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("leftWing",part.size,part.vao,pix*3.5,pix*3,0,1,1,1,0,0)
-      this.addPart("rightWing",part.size,part.vao,pix*-3.5,pix*3,0,1,1,1,0,0)
-      part = generateVAO(shapes.chickenLeg,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("rightLeg",part.size,part.vao,pix*-1.5,pix*-3,0,1,1,1,0,0)
-      this.addPart("leftLeg",part.size,part.vao,pix*1.5,pix*-3,0,1,1,1,0,0)
-      var part = generateVAO(shapes.chickenHead,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("head",part.size,part.vao,0,pix*4,pix*4.5,1,1,1,0,0)
-      
-      this.health = 4
-      this.prevWalking = false
-      this.walkStart = 0
-      this.walkRot = 0
-    }
-    update(){
-      this.mobUpdate(now)
+				if(userInfo ? userInfo.profanityFilter : true) for(var obj of Messages.remove){ //remove bad words
+					text = text.replace(obj.replace, obj.with)
+				}//if you change this, change the one in Messages.format
+
+				let textStr = text
+				text = Array.from(text)//split into unicode
+				let data = new Float32Array(text.length*32)
+				let lineData = []
+				let x = 0, y = 0
+				let lineW = []
+				let line = 0
+				let i = 0
+				let color = [0,0,0], colorSet = 0, bold = false, italic = false
+				const italicX = tan(14*Math.PI/180)
+				for (let idx = 0; idx<text.length; idx++) {
+					let l = text[idx]
+					if(l === "§"){
+						let code = text[idx+1]
+						if(code === "l"){
+							bold = true
+						}else if(code === "o"){
+							italic = true
+						}else if(code === "r"){
+							bold = false, italic = false
+							colorSet = 0
+						}else{
+							color = colors.rgb[code] || color
+							colorSet = 1
+						}
+						idx++
+						continue
+					}
+					if(l === "\n"){
+						x = 0
+						y -= 10/8//linegap = 2
+						line++
+						continue
+					}
+					
+					let coords = textCoords[bold ? "b"+l : l] || textCoords["\0"]
+					let coordsPixels = textCoordsPixels[bold ? "b"+l : l] || textCoordsPixels["\0"]
+					data[i] = x + (italic ? italicX*coordsPixels[3] : 0)
+					data[i+1] = y + coordsPixels[3]
+					data[i+2] = coords[0]
+					data[i+3] = coords[1]
+					data[i+4] = color[0]
+					data[i+5] = color[1]
+					data[i+6] = color[2]
+					data[i+7] = colorSet
+					
+					data[i+8] = x + coordsPixels[2] + (italic ? italicX*coordsPixels[3] : 0)
+					data[i+9] = y + coordsPixels[3]
+					data[i+10] = coords[0] + coords[2]
+					data[i+11] = coords[1]
+					data[i+12] = color[0]
+					data[i+13] = color[1]
+					data[i+14] = color[2]
+					data[i+15] = colorSet
+					
+					data[i+16] = x + coordsPixels[2]
+					data[i+17] = y
+					data[i+18] = coords[0] + coords[2]
+					data[i+19] = coords[1] + coords[3]
+					data[i+20] = color[0]
+					data[i+21] = color[1]
+					data[i+22] = color[2]
+					data[i+23] = colorSet
+					
+					data[i+24] = x
+					data[i+25] = y
+					data[i+26] = coords[0]
+					data[i+27] = coords[1] + coords[3]
+					data[i+28] = color[0]
+					data[i+29] = color[1]
+					data[i+30] = color[2]
+					data[i+31] = colorSet
+					
+					x += coordsPixels[2]
+					lineData[i/32] = line
+					lineW[line] = x
+					i += 32
+				}
+				for(i = 0; i<data.length; i+=8){
+					data[i] -= lineW[lineData[floor(i/32)]] / 2
+					data[i+1] -= y/2
+				}
+				
+				this.faces = i / 32
+				glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
+				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
+				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer)
+				gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW)
+				gl.enableVertexAttribArray(glCache.aVertexText)
+				gl.enableVertexAttribArray(glCache.aTextureText)
+				gl.enableVertexAttribArray(glCache.aColorText)
+				gl.enableVertexAttribArray(glCache.aColorSetText)
+				gl.vertexAttribPointer(glCache.aVertexText, 2, gl.FLOAT, false, 32, 0)
+				gl.vertexAttribPointer(glCache.aTextureText, 2, gl.FLOAT, false, 32, 8)
+				gl.vertexAttribPointer(glCache.aColorText, 3, gl.FLOAT, false, 32, 16)
+				gl.vertexAttribPointer(glCache.aColorSetText, 1, gl.FLOAT, false, 32, 28)
+				glExtensions.vertex_array_object.bindVertexArrayOES(null)
+				this.text = textStr
+			}
+			update() {
+				this.canFacePlayer = true
+				this.lastUpdate = now
+				this.previousX = this.x
+				this.previousY = this.y
+				this.previousZ = this.z
+			}
+			render(){
+				if(!this.text) return
+				world.renderTextDisplay(this)
+			}
+			renderText() {
+				if(!this.text) return
+
+				let diff = (now - this.lastUpdate) / tickTime
+				if (diff > 1) diff = 1
+				let renderx = (this.x - this.previousX) * diff + this.previousX
+				let rendery = (this.y - this.previousY) * diff + this.previousY
+				let renderz = (this.z - this.previousZ) * diff + this.previousZ
+				
+				if(this.canFacePlayer){
+					this.facePlayer()
+					this.canFacePlayer = false
+				}
+				
+				const offsetY = this.offsetY, offsetX = this.offsetX, offsetZ = this.offsetZ
+				const modelMatrix = new Matrix();
+				modelMatrix.identity()
+				modelMatrix.translate(renderx, rendery + offsetY, renderz)
+				modelMatrix.rotY(this.yaw)
+				modelMatrix.rotX(this.pitch)
+				modelMatrix.translate(0,0,offsetZ)
+				modelMatrix.scale(this.width, this.height, this.depth)
+				modelMatrix.translate(offsetX,0,0)
+				const viewMatrix = p.camera.transformation.elements
+				const proj = p.camera.projection
+				const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
+				const modelViewProjectionMatrix = new Matrix()
+				modelViewProjectionMatrix.identity()
+				modelViewProjectionMatrix.mult(projectionMatrix)
+				modelViewProjectionMatrix.mult(viewMatrix)
+				modelViewProjectionMatrix.mult(modelMatrix.elements)
+				// row major to column major
+				modelViewProjectionMatrix.transpose()
+				const x = round(this.x)
+				const y = round(this.y)
+				const z = round(this.z)
+				const blockLight = world.getLight(x, y, z, 1, this.dimension)
+				const skysLight = world.getLight(x, y, z, 0, this.dimension)
+				const lightLevel = min(max(skysLight * skyLight / 15, blockLight / 15), 1.0)
+				gl.uniform1i(glCache.uSamplerText, 9)
+				gl.uniform1i(glCache.glowText, this.glow)
+				gl.uniform1f(glCache.uLightLevelText, lightLevel)
+				gl.uniform1f(glCache.uLanternText, lantern - dist3(this.x,this.y,this.z, p.renderX,p.renderY,p.renderZ) / 10.0)
+				gl.uniform3f(glCache.colorText, ...this.color)
+				gl.uniform4f(glCache.backgroundText, ...this.background)
+				gl.uniform1f(glCache.brightnessText, brightness)
+				gl.uniformMatrix4fv(glCache.uViewText, false, modelViewProjectionMatrix.elements)
+				glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
+				gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
+				glExtensions.vertex_array_object.bindVertexArrayOES(null)
+			}
+		},
 
-      if(this.vely < 0){
-        this.vely *= 0.5
-        this.lastY = this.y
-      }
-      if(this.vely < 0 || this.liquid){
-        let rot = sin(((now - this.walkStart) / 125) * Math.PI) * Math.PI / 4 + Math.PI2
-        this.parts.leftWing.rz = rot
-        this.parts.rightWing.rz = -rot
-      }else{
-        this.parts.leftWing.rz = this.parts.rightWing.rz = 0
-      }
-      if(this.prevWalking !== this.walking){
-        this.prevWalking = this.walking
-        this.walkStart = now
-      }
-      var walkRotTarget = 0
-      if(this.walking){
-        if(this.panick > 0) walkRotTarget = sin(((now - this.walkStart) / 500) * Math.PI) * Math.PI / 4
-        else walkRotTarget = sin(((now - this.walkStart) / 1000) * Math.PI) * Math.PI / 4
-      }
-      this.walkRot = lerp(0.5,this.walkRot,walkRotTarget)
-      this.parts.leftLeg.rx = this.walkRot
-      this.parts.rightLeg.rx = -this.walkRot
+		creeper:{
+			additionalUpdateClient(){
+				let d = this.targetEnt && max(abs(this.targetEnt.x-this.x),abs(this.targetEnt.y-this.y),abs(this.targetEnt.z-this.z))
+				if(this.targetEnt && d<=3){
+					if(!this.explodeAmount){
+						this.timerStart = now
+					}
+					this.explodeAmount++
+					if(this.explodeAmount > 20) this.explodeAmount = 20
+				}else if(this.explodeAmount) this.explodeAmount--
+				this.shader = 0, this.extraSize = 0
+				if(this.explodeAmount>0){
+					var i = Math.floor((now - this.timerStart) / 125)
+					if(!(i%2)){
+						this.shader = 1
+					}
+					if((now - this.timerStart) / tickTime >= this.timeLimit - 10){
+						//get bigger
+						this.extraSize = min(-((this.timeLimit - 10) - ((now - this.timerStart) / tickTime)) / 40,0.25)
+						this.shader = 1
+					}
+				}
+			}
+		},//todo n: tint sheep
+		sheep:{
+			additionalUpdateClient(){
+				if(this.eating){
+					if(this.parts.head.y > this.parts.head.originalY - 0.5){
+						this.parts.head.y -= 0.05
+					}else{
+						this.parts.head.rx = (sin(((now - this.spawn) / 250) * Math.PI) * Math.PI / 8)+Math.PI4
+					}
+				}else if(this.parts.head.y < this.parts.head.originalY){
+					this.parts.head.y += 0.05
+					this.parts.head.rx = 0
+					if(this.parts.head.y > this.parts.head.originalY) this.parts.head.y = this.parts.head.originalY
+				}
+				if(this.fur !== this.prevFur){
+					this.prevFur = this.fur
+					this.setPartShapes(this.fur ? [this.variantsBones.default, this.variantsBones.sheared] : this.variantsBones.sheared)
+				}
+				this.tint = this.color
+			}
+		},
+		chicken:{
+			additionalUpdateClient(){
+				if(this.vely < 0 || this.liquid){
+					let rot = sin(((now - this.walkStart) / 125) * Math.PI) * Math.PI / 4 + Math.PI2
+					this.parts.wing0.rz = rot
+					this.parts.wing1.rz = -rot
+				}else{
+					this.parts.wing0.rz = this.parts.wing1.rz = 0
+				}
+			}
+		},
+		zombie:{//todo: it looks wrong
+			additionalUpdateClient(){
+				if(!this.liquid && this.world.getLight(round(this.x), round(this.y), round(this.z), 0, this.dimension)*skyLight > 11){
+					this.burnTimer += 0.2
+				}
+			}
+		},
+		skeleton:{
+			additionalUpdateClient(){
+				if(!this.liquid && this.world.getLight(round(this.x), round(this.y), round(this.z), 0, this.dimension)*skyLight > 11){
+					this.burnTimer += 0.2
+				}
+			}
+		},//todo n: spider animat, wolf
+		wolf:{
+			additionalUpdateClient(){
+				if(this.sitting){
+					this.offsetY = this.defaultOffsetY - pix*3
+					this.parts.collar.rx = this.pitch2 = -Math.PI4
+					this.parts.frontLeftLeg.rx = -Math.PI/8
+					this.parts.frontRightLeg.rx = -Math.PI/8
+					this.parts.backLeftLeg.rx = -Math.PI2
+					this.parts.backRightLeg.rx = -Math.PI2
+					this.parts.tail.y = this.parts.tail.originalY-pix*4
+					this.parts.tail.z = this.parts.tail.originalZ+pix*2
+					this.parts.frontLeftLeg.y = this.parts.frontLeftLeg.originalY+pix*3
+					this.parts.frontRightLeg.y = this.parts.frontRightLeg.originalY+pix*3
+					this.parts.backLeftLeg.y = this.parts.backLeftLeg.originalY-pix*4
+					this.parts.backRightLeg.y = this.parts.backRightLeg.originalY-pix*4
+					this.parts.head.y = this.parts.head.originalY+pix*6
+					this.parts.head.z = this.parts.head.originalZ-pix*3
+				}else{
+					this.offsetY = this.defaultOffsetY
+					this.parts.collar.rx = this.pitch2 = 0
+					this.parts.frontLeftLeg.rx = this.walkRot
+					this.parts.frontRightLeg.rx = -this.walkRot
+					this.parts.backLeftLeg.rx = this.walkRot
+					this.parts.backRightLeg.rx = -this.walkRot
+					this.parts.tail.y = this.parts.tail.originalY
+					this.parts.tail.z = this.parts.tail.originalZ
+					this.parts.frontLeftLeg.y = this.parts.frontLeftLeg.originalY
+					this.parts.frontRightLeg.y = this.parts.frontRightLeg.originalY
+					this.parts.backLeftLeg.y = this.parts.backLeftLeg.originalY
+					this.parts.backRightLeg.y = this.parts.backRightLeg.originalY
+					this.parts.head.y = this.parts.head.originalY
+					this.parts.head.z = this.parts.head.originalZ
+				}
+				this.parts.tail.rx = this.target ? Math.PI2 : this.health/20*Math.PI
+				if(this.prevTarget !== this.target || this.prevTame !== this.tame){
+					this.prevTarget = this.target
+					this.prevTame = this.tame
+					this.updateShape()
+				}
+				if(this.wet) this.wetStuff = 40
+				else if(this.wetStuff){
+					this.wetStuff--
+					this.roll = sin(this.wetStuff/2*Math.PI)*Math.PI4*this.wetStuff/40
+					this.parts.head.rz = sin(this.wetStuff+0.5/2*Math.PI)*Math.PI4*this.wetStuff/40
+					if(!performFast) world.addParticle(new SplashParticle(this.x+rand(-0.5,0.5),this.y+0.5,this.z+rand(-0.5,0.5)),this.dimension)
+				}
+				if(this.wet || !this.wetStuff){
+					this.roll = this.parts.head.rz = 0
+				}
+			}
+		},
+		blaze:{
+			putThingy(n,speed,size){
+				let part = this.parts["upperBodyParts"+n]
+				let where = (now-this.spawn)/speed+n/2
+				part.x = sin(where*Math.PI)*size
+				part.y = -6/16
+				part.z = cos(where*Math.PI)*size
+			},
+			additionalUpdateClient(){
+				if(this.burnTimer) this.burnTimer = 0
 
-      if(this.targetEnt || this.attractEnt){
-        let {x,y,z} = this.targetEnt || this.attractEnt
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry2 = -(this.yaw - yaw)
-        if(this.parts.head.ry2 - this.parts.head.pry2 > Math.PI) this.parts.head.pry2 += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry2 - this.parts.head.pry2 < -Math.PI) this.parts.head.pry2 -= Math.PId
-        let adjacent = dist2(this.x,this.z,x,z)
-        this.parts.head.rx = Math.PId - atan2(y - (this.y+this.parts.head.y), adjacent)
-				this.parts.head.ry = 0
-      }else if(this.path){
-        let i = this.path.length - 3
-        let x = this.path[i], y = this.path[i+1], z = this.path[i+2]
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }else if(this.spinTarget){
-        let yaw = this.spinTarget
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }
-    }
-  }
-  entities[entities.length] = class Zombie extends Mob{
-		static name2 = "Zombie"
-		defaultName = "Zombie"
-    constructor(x,y,z){
-      var tex = textureCoords[textureMap.zombie]
-      var vao = generateVAO(shapes.zombieBody, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      super(x, y, z, 0, 0, 0, 0, 0, 1, 2, 1, null,null, vao.size, 300000, vao.vao)
-      var pix = 1/16
-      this.offsetY = pix*2
-      var part = generateVAO(shapes.zombieLeg,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("rightLeg",part.size,part.vao,pix*-2,pix*-6,0,1,1,1,0,0)
-      this.addPart("leftLeg",part.size,part.vao,pix*2,pix*-6,0,1,1,1,0,0)
-      var part = generateVAO(shapes.zombieArm,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("rightArm",part.size,part.vao,pix*-6,pix*6,pix*0,1,1,1,0,0)
-      this.addPart("leftArm",part.size,part.vao,pix*6,pix*6,pix*0,1,1,1,0,0)
-      var part = generateVAO(shapes.zombieHead,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("head",part.size,part.vao,0,pix*10,0,1,1,1,0,0)
-      
-      this.health = 20
-      this.prevWalking = false
-      this.walkStart = 0
-      this.walkRot = 0
-			this.maxAttackCooldown = 20
-    }
-    update(){
-      this.mobUpdate(now)
-			if(!this.liquid && this.world.getLight(round(this.x), round(this.y), round(this.z), 0, this.dimension)*skyLight > 11){
-				this.burnTimer += 0.2
+				this.putThingy(0,1000,0.5)
+				this.putThingy(1,1000,0.5)
+				this.putThingy(2,1000,0.5)
+				this.putThingy(3,1000,0.5)
+				this.putThingy(4,-750,0.375)
+				this.putThingy(5,-750,0.375)
+				this.putThingy(6,-750,0.375)
+				this.putThingy(7,-750,0.375)
+				this.putThingy(8,500,0.25)
+				this.putThingy(9,500,0.25)
+				this.putThingy(10,500,0.25)
+				this.putThingy(11,500,0.25)
+			}
+		},
+		itemFrame: itemFrame => class extends itemFrame{
+			constructor(){
+				super(...arguments)
+				let tex = textureCoords[textureMap[this.type]]
+				let v = generateVAO(shapes.itemFrame, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
+				this.faces = v.size, this.vao = v.vao
+				this.display = new BlockEntity(0,0,0,0)
+				this.display.width = this.display.height = this.display.depth = 0.5
+			}
+			update(){
+				this.display.yaw = this.yaw
+				this.display.roll = this.amount*Math.PId/8
+				this.display.changeBlock(this.block)
+				this.display.x = this.x+sin(this.yaw)*7/16
+				this.display.y = this.y
+				this.display.z = this.z+cos(this.yaw)*7/16
+			}
+			render(){
+				super.render()
+				this.display.render()
 			}
+		}
+	}
 
-      if(this.prevWalking !== this.walking){
-        this.prevWalking = this.walking
-        this.walkStart = now
-      }
-      var walkRotTarget = 0
-      if(this.walking){
-        if(this.panick > 0) walkRotTarget = sin(((now - this.walkStart) / 500) * Math.PI) * Math.PI / 4
-        else walkRotTarget = sin(((now - this.walkStart) / 1000) * Math.PI) * Math.PI / 4
-      }
-      this.walkRot = lerp(0.5,this.walkRot,walkRotTarget)
-      this.parts.leftLeg.rx = this.walkRot
-      this.parts.rightLeg.rx = -this.walkRot
-      let pix = 1 / 16
-      let armRot = (sin((now - this.spawn) / 1000) / 2 + 0.5) * Math.PI / 40
-			this.parts.leftArm.rz = armRot
-			this.parts.rightArm.rz = -armRot
-			this.parts.leftArm.rx = this.walkRot
-      this.parts.rightArm.rx = -this.walkRot
-			if(this.targetEnt){
-				let offset = -(10-abs(this.attackCooldown-10))*Math.PI4/10
-				this.parts.leftArm.rx = -Math.PI2+offset
-				this.parts.rightArm.rx = -Math.PI2+offset
-			}else{
-				this.parts.leftArm.rx = this.walkRot
-				this.parts.rightArm.rx = -this.walkRot
+	let entityData = win.entityData
+	let entityClassMap = {Entity,Mob}
+	for(let i=0; i<entityData.length; i++){
+		let data = entityData[i]
+		if(!data) continue
+		let mob = data.mob
+		let ent = data.class ? data.class(entityClassMap) : (class extends (mob ? Mob : Entity) {
+			constructor(x,y,z){
+				super(x,y,z,0,0,0,0,0, data.width,data.height,data.depth, null,null,null)
+				if(this.onspawn) this.onspawn()
+				this.setPartShapes(data.variantsBones.default)
 			}
-      if(this.targetEnt){
-        let {x,y,z} = this.targetEnt
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry2 = -(this.yaw - yaw)
-        if(this.parts.head.ry2 - this.parts.head.pry2 > Math.PI) this.parts.head.pry2 += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry2 - this.parts.head.pry2 < -Math.PI) this.parts.head.pry2 -= Math.PId
-        let adjacent = dist2(this.x,this.z,x,z)
-        this.parts.head.rx = Math.PId - atan2(y - (this.y+this.parts.head.y), adjacent)
-				this.parts.head.ry = 0
-      }else if(this.path){
-        let i = this.path.length - 3
-        let x = this.path[i], y = this.path[i+1], z = this.path[i+2]
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }else if(this.spinTarget){
-        let yaw = this.spinTarget
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }
-    }
-  }
-	entities[entities.length] = class Skeleton extends Mob{
-		static name2 = "Skeleton"
-    defaultName = "Skeleton"
-    constructor(x,y,z){
-      var tex = textureCoords[textureMap.skeleton]
-      var vao = generateVAO(shapes.skeletonBody, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      super(x, y, z, 0, 0, 0, 0, 0, 0.75, 2, 0.75, null,null, vao.size, 300000, vao.vao)
-      var pix = 1/16
-      this.offsetY = pix*2
-      var part = generateVAO(shapes.skeletonLeg,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("rightLeg",part.size,part.vao,pix*-2,pix*-6,0,1,1,1,0,0)
-      this.addPart("leftLeg",part.size,part.vao,pix*2,pix*-6,0,1,1,1,0,0)
-      var part = generateVAO(shapes.skeletonArm,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("rightArm",part.size,part.vao,pix*-5,pix*6,pix*0,1,1,1,0,0)
-      this.addPart("leftArm",part.size,part.vao,pix*5,pix*6,pix*0,1,1,1,0,0)
-      var part = generateVAO(shapes.creeperHead,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("head",part.size,part.vao,0,pix*10,0,1,1,1,0,0)
-      this.addPart("holding",0,part.vao,0,0,0,1,1,1,0,0,undefined,"rightArm") //changed later
-      
-      this.health = 20
-      this.prevWalking = false
-      this.walkStart = 0
-      this.walkRot = 0
-			this.holding = blockIds.bow, this.maxAttackCooldown = 20
-    }
-		updateHolding(){
-			let part = this.parts.holding
-			let v = generateBlockVAO(this.holding)
-			part.vao = v.vao
-			part.size = v.size
-      let pix = 1 / 16
-			if(blockData[this.holding].tool){
-        part.x = 0
-        part.y = pix*-12
-        part.z = pix*6
-        part.w = part.h = part.d = 1
-        part.rx = Math.PI / 1.25
-        part.ry = Math.PI * -0.5
-      }else if(blockData[this.holding].name === "bow"){
-        part.x = 0
-        part.y = pix*-12
-        part.z = 0
-        part.w = part.h = part.d = 1
-        part.rx = Math.PI / 1.25
-        part.ry = Math.PI * -0.5
-      }else if(blockData[this.holding].spyglass){
-        part.x = pix*2
-        part.y = pix*-10
-        part.z = 0
-        part.w = part.h = part.d = 1
-        part.rx = -this.holdRot
-        part.ry = 0
-      }else if(blockData[this.holding].item){
-        part.x = 0
-        part.y = pix*-11
-        part.z = pix*4
-        part.w = part.h = part.d = 0.5
-        part.rx = Math.PI2
-        part.ry = 0
-      }else if(this.holding){
-        part.x = 0
-        part.y = pix*-12
-        part.z = pix*3
-        part.w = part.h = part.d = 0.25
-        part.rx = 0
-        part.ry = Math.PI / 4
-      }else{
-        this.parts.rightArm.rx = 0
-      }
+		})
+		Object.assign(ent.prototype, data)
+		ent.name2 = data.name
+		ent.prototype.type = data.name
+		ent.prototype.entId = i
+		if(entityDataAdditional[data.name]){
+			if(typeof entityDataAdditional[data.name] === "function") ent = entityDataAdditional[data.name](ent)
+			else Object.assign(ent.prototype, entityDataAdditional[data.name])
+		}
+		entityClassMap[data.name] = ent
+		entities[i] = ent
+	}
+	let {BlockEntity} = entityClassMap
+
+	class Sign extends Entity{
+		constructor(x,y,z,block){
+			let type = blockData[block].name.replace(/(Wall)?Sign/,"")
+			let pole = blockData[blockIds[type+"Log"]].shape
+			let tex = textureCoords[textureMap[blockData[blockIds[type+"Planks"]].shape.texVerts[2][0].texture]]
+			const v = generateVAO(blockData[block].useAsWall ? shapes.sign : shapes.wallSign, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1], false, {poleSide:pole.texVerts[2][0].texture,poleTop:pole.texVerts[1][0].texture})
+			super(x, y, z, 0, 0, 0, 0, 0, 1, 1, 1, null,null, v.size, Infinity, v.vao)
+			this.width = this.height = this.depth = 16/24
+			this.block = block
+			this.offsetY = -0.15
+			this.from = p.id
+			this.noHitbox = true
+			this.textEnt = null, this.textEnt2 = null
+			this.prevText = null, this.prevText2 = null
+			this.remote = true
+			
+			this.gravityStength = 0
 		}
-    update(){
-      this.mobUpdate(now)
-			if(!this.liquid && this.world.getLight(round(this.x), round(this.y), round(this.z), 0, this.dimension)*skyLight > 11){
-				this.burnTimer += 0.2
+		update() {
+			let block = this.world.getBlock(this.x,this.y,this.z,this.dimension)
+			if(block != this.block){
+				this.canDespawn = true
 			}
-
-      if(this.prevWalking !== this.walking){
-        this.prevWalking = this.walking
-        this.walkStart = now
-      }
-      var walkRotTarget = 0
-      if(this.walking){
-        if(this.panick > 0) walkRotTarget = sin(((now - this.walkStart) / 500) * Math.PI) * Math.PI / 4
-        else walkRotTarget = sin(((now - this.walkStart) / 1000) * Math.PI) * Math.PI / 4
-      }
-      this.walkRot = lerp(0.5,this.walkRot,walkRotTarget)
-      this.parts.leftLeg.rx = this.walkRot
-      this.parts.rightLeg.rx = -this.walkRot
-      let armRot = (sin((now - this.spawn) / 1000) / 2 + 0.5) * Math.PI / 40
-			this.parts.leftArm.rz = armRot
-			this.parts.rightArm.rz = -armRot
-			if(this.targetEnt){
-				if(blockData[this.holding].name === "bow"){
-          this.parts.leftArm.rx = -Math.PI2
-          this.parts.leftArm.ry2 = -Math.PI4
-          this.parts.rightArm.rx = -Math.PI2
-        }else if(blockData[this.holding].spyglass){
-          this.parts.rightArm.rx = -Math.PI2+this.holdRot
-        }else{
-					this.parts.leftArm.rx = this.parts.rightArm.rx = -Math.PI2
+			
+			let tags = this.world.getTags(this.x,this.y,this.z,this.dimension)
+			if(tags){
+				var rotation = tags.rot || 0
+				this.yaw = -rotation * Math.PId / 16
+				if(this.textEnt){
+					this.textEnt.yaw = this.yaw + Math.PI
+					if(tags.color){
+						this.textEnt.color = tags.color
+					}else if(blockData[this.block].color){
+						var data = blockData[this.block].color
+						this.textEnt.color[0] = data[0]
+						this.textEnt.color[1] = data[1]
+						this.textEnt.color[2] = data[2]
+					}
+					this.textEnt.glow = !!tags.glow
+				}
+				if(this.textEnt2){
+					this.textEnt2.yaw = this.yaw
+					if(tags.color){
+						this.textEnt2.color = tags.color
+					}else if(blockData[this.block].color){
+						var data = blockData[this.block].color
+						this.textEnt2.color[0] = data[0]
+						this.textEnt2.color[1] = data[1]
+						this.textEnt2.color[2] = data[2]
+					}
+					this.textEnt2.glow = !!tags.glow2
+				}
+				if(tags.text !== this.prevText && (tags.text || tags.text === "")){
+					this.prevText = tags.text
+					if(this.textEnt){
+						this.textEnt.setText(tags.text)
+					}else{
+						this.textEnt = this.world.generateTextForEntity(tags.text,this,1/8,[0,0,0],null)
+						if(!blockData[block].useAsWall){
+							this.textEnt.offsetZ = -5.5/16
+						}else{
+							this.textEnt.offsetZ = 1/16
+							this.textEnt.y += 0.35
+						}
+					}
+				}
+				if(tags.text2 !== this.prevText2 && (tags.text2 || tags.text2 === "")){
+					this.prevText2 = tags.text2
+					if(this.textEnt2){
+						this.textEnt2.setText(tags.text2)
+					}else{
+						this.textEnt2 = this.world.generateTextForEntity(tags.text2,this,1/8,[0,0,0],null)
+						if(!blockData[block].useAsWall){
+							this.textEnt2.offsetZ = 7.25/16
+						}else{
+							this.textEnt2.offsetZ = 1.25/16
+							this.textEnt2.y += 0.35
+						}
+					}
 				}
-			}else{
-				this.parts.leftArm.rx = this.walkRot
-				this.parts.rightArm.rx = -this.walkRot
 			}
-      if(this.targetEnt){
-        let {x,y,z} = this.targetEnt
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry2 = -(this.yaw - yaw)
-        if(this.parts.head.ry2 - this.parts.head.pry2 > Math.PI) this.parts.head.pry2 += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry2 - this.parts.head.pry2 < -Math.PI) this.parts.head.pry2 -= Math.PId
-        let adjacent = dist2(this.x,this.z,x,z)
-        this.parts.head.rx = Math.PId - atan2(y - (this.y+this.parts.head.y), adjacent)
-				this.parts.head.ry = 0
-      }else if(this.path){
-        let i = this.path.length - 3
-        let x = this.path[i], y = this.path[i+1], z = this.path[i+2]
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }else if(this.spinTarget){
-        let yaw = this.spinTarget
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }
-    }
-  }
-	entities[entities.length] = class Spider extends Mob{
-		static name2 = "Spider"
-		experience = 5
-    constructor(x,y,z,cave){
-      var tex = textureCoords[textureMap[cave ? "caveSpider" : "spider"]]
-      var vao = generateVAO(shapes.spiderBody, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-			let s = cave ? 0.7 : 1
-      super(x, y, z, 0, 0, 0, 0, 0, s, s, s, null,null, vao.size, 300000, vao.vao)
-			this.noScale = false
-      var pix = 1/16
-      this.offsetY = pix*2
-			let legRot = Math.PI/8
-      let part = generateVAO(shapes.spiderLeg,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("rightLeg0",part.size,part.vao,pix*-3,0,0,1,1,1,0,0,legRot)
-      this.addPart("rightLeg1",part.size,part.vao,pix*-3,0,0,1,1,1,0,0,legRot)
-      this.addPart("rightLeg2",part.size,part.vao,pix*-3,0,0,1,1,1,0,0,legRot)
-      this.addPart("rightLeg3",part.size,part.vao,pix*-3,0,0,1,1,1,0,0,legRot)
-      this.addPart("leftLeg0",part.size,part.vao,pix*3,0,0,1,1,1,0,0,-legRot)
-      this.addPart("leftLeg1",part.size,part.vao,pix*3,0,0,1,1,1,0,0,-legRot)
-      this.addPart("leftLeg2",part.size,part.vao,pix*3,0,0,1,1,1,0,0,-legRot)
-      this.addPart("leftLeg3",part.size,part.vao,pix*3,0,0,1,1,1,0,0,-legRot)
-      part = generateVAO(shapes.spiderHead,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("head",part.size,part.vao,0,0,pix*7,1,1,1,0,0)
-			let eyeTex = textureCoords[textureMap.spiderEyes]
-			let eye = generateVAO(shapes.spiderHead, eyeTex[0],eyeTex[1],eyeTex[2]-eyeTex[0],eyeTex[5]-eyeTex[1])
-      this.addPart("eyes",eye.size,eye.vao,0,0,0,1,1,1,0,0,0,"head",true)
-			let head = this.parts.head
-			delete this.parts.head
-			this.parts.head = head//put in front
-      
-			this.fur = !!cave
-      this.defaultName = cave ? "Cave Spider" : "Spider"
-      this.health = 16
-      this.prevWalking = false
-      this.walkStart = 0
-      this.walkRot = 0
-			this.canClimb = true
-			this.maxAttackCooldown = 20
-    }
-    update(){
-      this.mobUpdate(now)
+		}
+		render(){
+			super.render()
+			if(this.textEnt) this.textEnt.render()
+			if(this.textEnt2) this.textEnt2.render()
+		}
+	}
+	class BeaconBeam extends Entity{
+		alwaysRender = true
+		constructor(x,y,z){
+			super(x, y+(maxHeight-y)/2, z, 0, 0, 0, 0, 0, 0.25, maxHeight - y, 0.25, null, null, 0, Infinity, glExtensions.vertex_array_object.createVertexArrayOES())
+			this.willUpdateShape = true
+			this.shader = 2
+			this.remote = true
+			this.noHitbox = true
+			this.actualY = y
+			this.prevColumn = null
+			this.glow = true
+		}
+		generateVAO(y,y2,vao){
+			const shape = shapes.cube
+			const shapeVerts = shape.verts
+			const shapeTexVerts = shape.texVerts
+			const size = shape.size
+			let tex = "beaconBeam"
+			let blockSides = Object.keys(Block)
+			let texture = []
+			let index = 0
+			let verts = [], vertIndex = 0
+			let ay = this.actualY/maxHeight
+			for (let n = 0; n < 6; n++) {
+				let side = blockSides[n]
+				let directionalFaces = shapeVerts[n]
+				for (let facei = 0; facei < directionalFaces.length; facei++) {
+					let texVerts = textureCoords[textureMap[tex]]
+					let tx = texVerts[0]
+					let ty = texVerts[1]
+					let tw = texVerts[2] - tx
+					let th = texVerts[5] - ty
+					let texShapeVerts = shapeTexVerts[n][facei]
+					let newY = ay+(1-ay)*y, newY2 = ay+(1-ay)*y2
+					texture[index    ] = tx + texShapeVerts[0]*tw
+					texture[index + 1] = ty + lerp(texShapeVerts[1], newY,newY2)*th
+					texture[index + 2] = tx + texShapeVerts[2]*tw
+					texture[index + 3] = ty + lerp(texShapeVerts[3], newY,newY2)*th
+					texture[index + 4] = tx + texShapeVerts[4]*tw
+					texture[index + 5] = ty + lerp(texShapeVerts[5], newY,newY2)*th
+					texture[index + 6] = tx + texShapeVerts[6]*tw
+					texture[index + 7] = ty + lerp(texShapeVerts[7], newY,newY2)*th
+					index += 8
+					let face = directionalFaces[facei]
+					verts[vertIndex] = face[0]
+					verts[vertIndex+1] = map(face[1], -0.5,0.5, y-0.5,y2-0.5)
+					verts[vertIndex+2] = face[2]
+					verts[vertIndex+3] = face[3]
+					verts[vertIndex+4] = map(face[4], -0.5,0.5, y-0.5,y2-0.5)
+					verts[vertIndex+5] = face[5]
+					verts[vertIndex+6] = face[6]
+					verts[vertIndex+7] = map(face[7], -0.5,0.5, y-0.5,y2-0.5)
+					verts[vertIndex+8] = face[8]
+					verts[vertIndex+9] = face[9]
+					verts[vertIndex+10] = map(face[10], -0.5,0.5, y-0.5,y2-0.5)
+					verts[vertIndex+11] = face[11]
+					vertIndex += 12
+				}
+			}
+			const verticesBuffer = gl.createBuffer()
+			const textureBuffer = gl.createBuffer()
+			glExtensions.vertex_array_object.bindVertexArrayOES(vao)
+			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
 
-      if(this.prevWalking !== this.walking){
-        this.prevWalking = this.walking
-        this.walkStart = now
-      }
-      var walkRotTarget = 0
-      if(this.walking){
-        if(this.panick > 0) walkRotTarget = sin(((now - this.walkStart) / 125) * Math.PI) * 0.1
-        else walkRotTarget = sin(((now - this.walkStart) / 250) * Math.PI) * 0.1
-      }
-      this.walkRot = lerp(0.5,this.walkRot,walkRotTarget)
-      this.parts.leftLeg0.ry = this.walkRot+Math.PI2*1.3
-      this.parts.leftLeg1.ry = -this.walkRot+Math.PI2*1.1
-      this.parts.leftLeg2.ry = this.walkRot+Math.PI2*0.9
-      this.parts.leftLeg3.ry = -this.walkRot+Math.PI2*0.6
-      this.parts.rightLeg0.ry = -this.walkRot-Math.PI2*1.3
-      this.parts.rightLeg1.ry = this.walkRot-Math.PI2*1.1
-      this.parts.rightLeg2.ry = -this.walkRot-Math.PI2*0.9
-      this.parts.rightLeg3.ry = this.walkRot-Math.PI2*0.6
-      if(this.targetEnt){
-        let {x,y,z} = this.targetEnt
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry2 = -(this.yaw - yaw)
-        if(this.parts.head.ry2 - this.parts.head.pry2 > Math.PI) this.parts.head.pry2 += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry2 - this.parts.head.pry2 < -Math.PI) this.parts.head.pry2 -= Math.PId
-        let adjacent = dist2(this.x,this.z,x,z)
-        this.parts.head.rx = Math.PId - atan2(y - (this.y+this.parts.head.y), adjacent)
-				this.parts.head.ry = 0
-      }else if(this.path){
-        let i = this.path.length - 3
-        let x = this.path[i], y = this.path[i+1], z = this.path[i+2]
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }else if(this.spinTarget){
-        let yaw = this.spinTarget
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }
-    }
-  }
-	entities[entities.length] = class Wolf extends Mob{
-		static name2 = "Wolf"
-    defaultName = "Wolf"
-    constructor(x,y,z){
-      super(x, y, z, 0, 0, 0, 0, 0, 0.6, 0.8, 0.6, null,null, null, Infinity, "vao")
-      var pix = 1/16
-      this.defaultOffsetY = pix*4.5
-      this.addPart("head",null,null,0,0,pix*10,1,1,1,0,0)
-      this.addPart("frontRightLeg",null,null,pix*-1.5,pix*-3,pix*5,1,1,1,0,0)
-      this.addPart("frontLeftLeg",null,null,pix*1.5,pix*-3,pix*5,1,1,1,0,0)
-      this.addPart("backRightLeg",null,null,pix*-1.5,pix*-3,pix*-6,1,1,1,0,0)
-      this.addPart("backLeftLeg",null,null,pix*1.5,pix*-3,pix*-6,1,1,1,0,0)
-      this.addPart("tail",null,null,0,0,pix*-8,1,1,1,Math.PI2,0)
-      this.addPart("collar",null,null,0,0,pix*6.1,1,1,1,0,0)
-			this.updateShape()
-      
-      this.health = 8
-      this.prevWalking = false
-      this.walkStart = 0
-      this.walkRot = 0
-			this.hostile = true
-      this.minFollowDist = 1.5
-      this.maxFollowDist = 16
-			this.detectionDist = 16
-			this.attackStrength = 4
-			this.maxAttackCooldown = 20
-			this.attacks = ["Sheep","Rabbit","Fox","Skeleton"]
-			this.prevTarget = null
-			this.attracts = [blockIds.bone]
-			this.wetStuff = 0
-			this.tame = false
-			this.prevTame = false
-			this.color = colors.dye.red.slice()
-    }
+			gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
+			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.STATIC_DRAW)
+			gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)
+
+			gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
+			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
+			gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
+
+			gl.enableVertexAttribArray(glCache.aVertexEntity)
+			gl.enableVertexAttribArray(glCache.aTextureEntity)
+			glExtensions.vertex_array_object.bindVertexArrayOES(null)
+			return {vao,size}
+		}
 		updateShape(){
-			var tex = textureCoords[textureMap[this.target ? "wolfAngry" : (this.tame ? "wolfTame" : "wolf")]]
-      var vao = generateVAO(shapes.wolfBody, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.faces = vao.size
-			this.vao = vao.vao
-      var pix = 1/16
-      var part = generateVAO(shapes.wolfHead,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.parts.head.size = part.size
-			this.parts.head.vao = part.vao
-      var part = generateVAO(shapes.wolfLeg,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.parts.backLeftLeg.vao = this.parts.frontLeftLeg.vao = this.parts.backRightLeg.vao = this.parts.frontRightLeg.vao = part.vao
-      this.parts.backLeftLeg.size = this.parts.frontLeftLeg.size = this.parts.backRightLeg.size = this.parts.frontRightLeg.size = part.size
-      var part = generateVAO(shapes.wolfTail,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.parts.tail.vao = part.vao
-			this.parts.tail.size = part.size
-			if(this.tame){
-				var tex = textureCoords[textureMap.wolfCollar]
-				this.parts.collar.hidden = false
-				var part = generateVAO(shapes.wolfBody,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-				this.parts.collar.vao = part.vao
-				this.parts.collar.size = part.size
-				this.parts.collar.tint = this.color
-			}else this.parts.collar.hidden = true
+			const top = this.world.getSolidTop(this.x,this.z,this.dimension)
+			let parts = [1,1,1,0]
+			let end = 1
+			const height = maxHeight-this.actualY
+			for(let y=this.actualY+1; y<=top; y++){
+				const block = this.world.getBlock(this.x,y,this.z,this.dimension), data = blockData[block]
+				if(data.solid && !data.transparent){
+					end = map(y-0.5, this.actualY,maxHeight, 0,1)
+					break
+				}
+				if(data.name.endsWith("StainedGlass")){
+					let color = colors.dye[data.name.replace("StainedGlass","")]
+					let y2 = map(y-0.5, this.actualY,maxHeight, 0,1)
+					parts.push(y2)
+					parts.push((color[0]+parts[parts.length-5])/2, (color[1]+parts[parts.length-4])/2, (color[2]+parts[parts.length-3])/2)
+					parts.push(y2)
+				}
+			}
+			parts.push(end)
+			for(let i=0; i<parts.length; i+=5){
+				let part = i && this.parts[i]
+				const {vao,size} = this.generateVAO(parts[i+3],parts[i+4], i ? (part ? part.vao : glExtensions.vertex_array_object.createVertexArrayOES()) : this.vao)
+				if(!i){
+					this.faces = size
+					this.tint = [parts[i],parts[i+1],parts[i+2]]
+				}else{
+					if(!part){
+						part = this.addPart(i,size,vao,0,0,0,0.25,maxHeight-this.actualY,0.25,0,0)
+						part.glow = true
+					}
+					part.size = size
+					part.tint = [parts[i],parts[i+1],parts[i+2]]
+				}
+			}
+			for(let part in this.parts){
+				if(+part >= parts.length) delete this.parts[part]
+			}
 		}
-    update(){
-      this.mobUpdate(now)
-      let pix = 1 / 16
-
-      if(this.prevWalking !== this.walking){
-        this.prevWalking = this.walking
-        this.walkStart = now
-      }
-      var walkRotTarget = 0
-      if(this.walking){
-        if(this.panick > 0) walkRotTarget = sin(((now - this.walkStart) / 500) * Math.PI) * Math.PI / 4
-        else walkRotTarget = sin(((now - this.walkStart) / 1000) * Math.PI) * Math.PI / 4
-      }
-      this.walkRot = lerp(0.5,this.walkRot,walkRotTarget)
-			if(this.sitting){
-				this.offsetY = this.defaultOffsetY - pix*3
-				this.parts.collar.rx = this.pitch2 = -Math.PI4
-				this.parts.frontLeftLeg.rx = -Math.PI/8
-				this.parts.frontRightLeg.rx = -Math.PI/8
-				this.parts.backLeftLeg.rx = -Math.PI2
-				this.parts.backRightLeg.rx = -Math.PI2
-				this.parts.tail.y = this.parts.tail.originalY-pix*4
-				this.parts.tail.z = this.parts.tail.originalZ+pix*2
-				this.parts.frontLeftLeg.y = this.parts.frontLeftLeg.originalY+pix*3
-				this.parts.frontRightLeg.y = this.parts.frontRightLeg.originalY+pix*3
-				this.parts.backLeftLeg.y = this.parts.backLeftLeg.originalY-pix*4
-				this.parts.backRightLeg.y = this.parts.backRightLeg.originalY-pix*4
-				this.parts.head.y = this.parts.head.originalY+pix*6
-				this.parts.head.z = this.parts.head.originalZ-pix*3
-			}else{
-				this.offsetY = this.defaultOffsetY
-				this.parts.collar.rx = this.pitch2 = 0
-				this.parts.frontLeftLeg.rx = this.walkRot
-				this.parts.frontRightLeg.rx = -this.walkRot
-				this.parts.backLeftLeg.rx = this.walkRot
-				this.parts.backRightLeg.rx = -this.walkRot
-				this.parts.tail.y = this.parts.tail.originalY
-				this.parts.tail.z = this.parts.tail.originalZ
-				this.parts.frontLeftLeg.y = this.parts.frontLeftLeg.originalY
-				this.parts.frontRightLeg.y = this.parts.frontRightLeg.originalY
-				this.parts.backLeftLeg.y = this.parts.backLeftLeg.originalY
-				this.parts.backRightLeg.y = this.parts.backRightLeg.originalY
-				this.parts.head.y = this.parts.head.originalY
-				this.parts.head.z = this.parts.head.originalZ
-			}
-			this.parts.tail.rx = this.target ? Math.PI2 : this.health/20*Math.PI
-      if(this.targetEnt || this.attractEnt){
-        let {x,y,z} = this.targetEnt || this.attractEnt
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry2 = -(this.yaw - yaw)
-        if(this.parts.head.ry2 - this.parts.head.pry2 > Math.PI) this.parts.head.pry2 += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry2 - this.parts.head.pry2 < -Math.PI) this.parts.head.pry2 -= Math.PId
-        let adjacent = dist2(this.x,this.z,x,z)
-        this.parts.head.rx = Math.PId - atan2(y - (this.y+this.parts.head.y), adjacent)
-				this.parts.head.ry = 0
-      }else if(this.path){
-        let i = this.path.length - 3
-        let x = this.path[i], y = this.path[i+1], z = this.path[i+2]
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }else if(this.spinTarget){
-        let yaw = this.spinTarget
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }
-			if(this.prevTarget !== this.target || this.prevTame !== this.tame){
-				this.prevTarget = this.target
-				this.prevTame = this.tame
-				this.updateShape()
+		update() {
+			let h = world.getSolidTop(round(this.x),round(this.y),round(this.z),this.dimension)
+			if(h !== this.prevColumn){
+				this.prevColumn = h
+				this.willUpdateShape = true
 			}
-			if(this.wet) this.wetStuff = 40
-			else if(this.wetStuff){
-				this.wetStuff--
-				this.roll = sin(this.wetStuff/2*Math.PI)*Math.PI4*this.wetStuff/40
-				this.parts.head.rz = sin(this.wetStuff+0.5/2*Math.PI)*Math.PI4*this.wetStuff/40
-				if(!performFast) world.addParticle(new entities[entityIds.SplashParticle](this.x+rand(-0.5,0.5),this.y+0.5,this.z+rand(-0.5,0.5)),this.dimension)
+			if(this.willUpdateShape){
+				this.updateShape()
+				this.willUpdateShape = false
 			}
-			if(this.wet || !this.wetStuff){
-				this.roll = this.parts.head.rz = 0
+			this.previousYaw = this.yaw
+			this.yaw += 0.05
+			if(this.yaw > Math.PId){
+				this.yaw -= Math.PId
+				this.previousYaw -= Math.PId
 			}
-    }
-  }
-	entities[entities.length] = class Blaze extends Mob{
-		static name2 = "Blaze"
-    defaultName = "Blaze"
-    constructor(x,y,z){
-      var tex = textureCoords[textureMap.none]
-      var vao = generateVAO(shapes.cube, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      var pix = 1/16
-      super(x, y, z, 0, 0, 0, 0, 0, 1, pix*22, 1, null,null, vao.size, 300000, vao.vao)
-      tex = textureCoords[textureMap.blaze]
-      var part = generateVAO(shapes.creeperHead,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("head",part.size,part.vao,0,pix*10,0,1,1,1,0,0)
-      var part = generateVAO(shapes.blazeThingy,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("thingy1_0",part.size,part.vao,0,pix*8,0,1,1,1,0,0)
-      this.addPart("thingy1_1",part.size,part.vao,0,pix*8,0,1,1,1,0,0)
-      this.addPart("thingy1_2",part.size,part.vao,0,pix*8,0,1,1,1,0,0)
-      this.addPart("thingy1_3",part.size,part.vao,0,pix*8,0,1,1,1,0,0)
-      this.addPart("thingy2_0",part.size,part.vao,0,pix*6,0,1,1,1,0,0)
-      this.addPart("thingy2_1",part.size,part.vao,0,pix*6,0,1,1,1,0,0)
-      this.addPart("thingy2_2",part.size,part.vao,0,pix*6,0,1,1,1,0,0)
-      this.addPart("thingy2_3",part.size,part.vao,0,pix*6,0,1,1,1,0,0)
-      this.addPart("thingy3_0",part.size,part.vao,0,pix*-2,0,1,1,1,0,0)
-      this.addPart("thingy3_1",part.size,part.vao,0,pix*-2,0,1,1,1,0,0)
-      this.addPart("thingy3_2",part.size,part.vao,0,pix*-2,0,1,1,1,0,0)
-      this.addPart("thingy3_3",part.size,part.vao,0,pix*-2,0,1,1,1,0,0)
-      
-      this.health = 20
-			this.hostile = true
-			this.maxAttackCooldown = 200
-			this.canFly = true
-    }
-		putThingy(layer,n,speed,size){
-			let part = this.parts["thingy"+layer+"_"+n]
-			let where = (now-this.spawn)/speed+n/2
-			part.x = sin(where*Math.PI)*size
-			part.z = cos(where*Math.PI)*size
+			this.lastUpdate = now
+			this.hidden = !world.getTagByName(round(this.x),round(this.y),round(this.z),"on",this.dimension)
 		}
-    update(){
-      this.mobUpdate(now)
-			if(this.burnTimer) this.burnTimer = 0
-
-      this.putThingy(1,0,1000,0.5)
-			this.putThingy(1,1,1000,0.5)
-			this.putThingy(1,2,1000,0.5)
-			this.putThingy(1,3,1000,0.5)
-			this.putThingy(2,0,-750,0.375)
-			this.putThingy(2,1,-750,0.375)
-			this.putThingy(2,2,-750,0.375)
-			this.putThingy(2,3,-750,0.375)
-			this.putThingy(3,0,500,0.25)
-			this.putThingy(3,1,500,0.25)
-			this.putThingy(3,2,500,0.25)
-			this.putThingy(3,3,500,0.25)
-			if(this.targetEnt && this.attackCooldown > 0 && this.attackCooldown < 100) this.burning = true
-      if(this.targetEnt){
-        let {x,y,z} = this.targetEnt
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry2 = -(this.yaw - yaw)
-        if(this.parts.head.ry2 - this.parts.head.pry2 > Math.PI) this.parts.head.pry2 += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry2 - this.parts.head.pry2 < -Math.PI) this.parts.head.pry2 -= Math.PId
-        let adjacent = dist2(this.x,this.z,x,z)
-        this.parts.head.rx = Math.PId - atan2(y - (this.y+this.parts.head.y), adjacent)
-				this.parts.head.ry = 0
-      }else if(this.path){
-        let i = this.path.length - 3
-        let x = this.path[i], y = this.path[i+1], z = this.path[i+2]
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }else if(this.spinTarget){
-        let yaw = this.spinTarget
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }
-    }
-  }
-	entities[entities.length] = class Enderman extends Mob{
-		static name2 = "Enderman"
-		defaultName = "Enderman"
-    constructor(x,y,z){
-      let tex = textureCoords[textureMap.enderman]
-      let vao = generateVAO(shapes.endermanBody, tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      super(x, y, z, 0, 0, 0, 0, 0, 0.75, 3, 0.75, null,null, vao.size, 300000, vao.vao)
-      let pix = 1/16
-      this.offsetY = pix*13
-      let part = generateVAO(shapes.endermanLeg,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("rightLeg",part.size,part.vao,pix*-2,pix*-6,0,1,1,1,0,0)
-      this.addPart("leftLeg",part.size,part.vao,pix*2,pix*-6,0,1,1,1,0,0)
-      this.addPart("rightArm",part.size,part.vao,pix*-4,pix*6,pix*0,1,1,1,0,0)
-      this.addPart("leftArm",part.size,part.vao,pix*4,pix*6,pix*0,1,1,1,0,0)
-      part = generateVAO(shapes.creeperHead,tex[0],tex[1],tex[2]-tex[0],tex[5]-tex[1])
-      this.addPart("head",part.size,part.vao,0,pix*10,0,1,1,1,0,0)
-			let eyeTex = textureCoords[textureMap.endermanEyes]
-			let eye = generateVAO(shapes.creeperHead, eyeTex[0],eyeTex[1],eyeTex[2]-eyeTex[0],eyeTex[5]-eyeTex[1])
-      this.addPart("eyes",eye.size,eye.vao,0,0,0,1,1,1,0,0,0,"head",true)
-			let head = this.parts.head
-			delete this.parts.head
-			this.parts.head = head//put in front
-      
-      this.health = 40
-      this.prevWalking = false
-      this.walkStart = 0
-      this.walkRot = 0
-			this.maxAttackCooldown = 20
-    }
-    update(){
-      this.mobUpdate(now)
-      if(this.prevWalking !== this.walking){
-        this.prevWalking = this.walking
-        this.walkStart = now
-      }
-      let walkRotTarget = 0
-      if(this.walking){
-        if(this.panick > 0) walkRotTarget = sin(((now - this.walkStart) / 500) * Math.PI) * Math.PI / 4
-        else walkRotTarget = sin(((now - this.walkStart) / 1000) * Math.PI) * Math.PI / 4
-      }
-      this.walkRot = lerp(0.5,this.walkRot,walkRotTarget)
-      this.parts.leftLeg.rx = this.walkRot
-      this.parts.rightLeg.rx = -this.walkRot
-      let pix = 1 / 16
-      let armRot = (sin((now - this.spawn) / 1000) / 2 + 0.5) * Math.PI / 40
-			this.parts.leftArm.rz = armRot
-			this.parts.rightArm.rz = -armRot
-			this.parts.leftArm.rx = this.walkRot
-      this.parts.rightArm.rx = -this.walkRot
-      if(this.targetEnt){
-        let {x,y,z} = this.targetEnt
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry2 = -(this.yaw - yaw)
-        if(this.parts.head.ry2 - this.parts.head.pry2 > Math.PI) this.parts.head.pry2 += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry2 - this.parts.head.pry2 < -Math.PI) this.parts.head.pry2 -= Math.PId
-        let adjacent = dist2(this.x,this.z,x,z)
-        this.parts.head.rx = Math.PId - atan2(y - (this.y+this.parts.head.y), adjacent)
-				this.parts.head.ry = 0
-      }else if(this.path){
-        let i = this.path.length - 3
-        let x = this.path[i], y = this.path[i+1], z = this.path[i+2]
-        let yaw = angleOf(x,z,this.x,this.z)
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }else if(this.spinTarget){
-        let yaw = this.spinTarget
-        this.parts.head.ry = -(this.yaw - yaw)
-        if(this.parts.head.ry - this.parts.head.pry > Math.PI) this.parts.head.pry += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
-        if(this.parts.head.ry - this.parts.head.pry < -Math.PI) this.parts.head.pry -= Math.PId
-        this.parts.head.rx = this.parts.head.ry2 = 0
-      }
-    }
-  }
+	}
 
-	entities[entities.length] = class EnderDragon extends Mob{
+	/*entities[entities.length] = class EnderDragon extends Mob{
 		static name2 = "EnderDragon"
 		defaultName = "Ender Dragon"
     constructor(x,y,z){
@@ -19205,12 +17407,13 @@
         this.parts.head.rx = this.parts.head.ry2 = 0
       }
     }
-  }
+  }*/
   
   class Particle extends Entity{
+		facesPlayer = true
 		constructor() {
 			super(...arguments)
-      this.tint = null
+      this.tint = null//todo: tint
       this.tintGray = false
 			this.gravityStength = -0.08
 			this.drag = 0.9
@@ -19278,7 +17481,7 @@
 			this.velx += (this.velx * drag - this.velx)
 			this.vely += (this.vely * yDrag - this.vely)
 		}
-		move(now) {
+		/*move(now) {
       let steps = Math.ceil(max(abs(this.velx / (this.width/2)), abs(this.vely / (this.height/2)), abs(this.velz / (this.depth/2)), 1))
       const VX = this.velx / steps
       const VY = this.vely / steps
@@ -19414,15 +17617,14 @@
       }
 			this.lastUpdate = now
 			this.contacts.clear()
-		}
-		update() {
+		}*/
+		update(){
 			this.updateVelocity(now)
 			this.move(now)
 			if (now - this.spawn > this.despawns) {
 				this.canDespawn = true
 			}
-      
-      this.canFacePlayer = true
+			this.facePlayer()
 		}
 		render() {
       totalEntites++
@@ -19435,11 +17637,6 @@
 			let rendery = (this.y - this.previousY) * diff + this.previousY
 			let renderz = (this.z - this.previousZ) * diff + this.previousZ
       
-      if(this.canFacePlayer){
-        this.facePlayer()
-        this.canFacePlayer = false
-      }
-      
 			const offsetY = this.offsetY
 			const modelMatrix = new Matrix();
 			modelMatrix.identity()
@@ -19479,9 +17676,8 @@
 		}
 	}
   
-  entities[entities.length] = class BlockParticle extends Particle{
-		static name2 = "BlockParticle"
-    constructor(tex, x,y,z, type, id){
+  class BlockParticle extends Particle{
+		constructor(tex, x,y,z, type, id){
       let s=0.25
       let offX = rand(0.75), offY = rand(0.75)
       let velx = (Math.random()-0.5) * 0.4,
@@ -19540,11 +17736,7 @@
       this.block = id, this.tex = tex
     }
     update(){
-			this.updateVelocity(now)
-			this.move(now)
-			if (now - this.spawn > this.despawns) {
-				this.canDespawn = true
-			}
+			super.update()
       var id = this.block
       if(id && blockData[id].tint){
         var biome = world.getBiome(round(this.x),round(this.y),round(this.z),this.dimension)
@@ -19552,14 +17744,11 @@
         this.tint = tints[biome] || tints.default
         this.tintGray = true
       }
-      
-      this.canFacePlayer = true
     }
   }
   
-  entities[entities.length] = class PoofParticle extends Particle{
-		static name2 = "PoofParticle"
-    constructor(x,y,z){
+	class PoofParticle extends Particle{
+		constructor(x,y,z){
       super(x, y, z, 0, 0, rand(-0.05, 0.05), 0, rand(-0.05, 0.05), 0.5, 0.5, 0.5, null, null, genericVaos.size, rand(1000, 3000), genericVaos[floor(rand(8))])
       this.brightness = rand(0.8, 1)
       this.speed = rand(0.01, 0.05)
@@ -19572,10 +17761,9 @@
 			if (now - this.spawn > this.despawns) {
 				this.canDespawn = true
 			}
-      
-      this.canFacePlayer = true
+			this.facePlayer()
     }
-    render(){
+    /*render(){
       totalEntites++
       if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width,this.height,this.depth)) return
       renderedEntities++
@@ -19618,12 +17806,12 @@
 			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
 			glExtensions.vertex_array_object.bindVertexArrayOES(null)
       if(this.tint) gl.uniform3f(glCache.tintParticle, 1,1,1)
-    }
+    }*/
   }
   function poof(x,y,z,amount,dimension, w,h,d, unremote){
 		if(!amount) amount = w*h*d*20
     if(!performFast) for(var i=0; i<amount; i++){
-      world.addParticle(new entities[entityIds.PoofParticle](x+rand(-w/2,w/2),y+rand(-h/2,h/2),z+rand(-d/2,d/2)), dimension)
+      world.addParticle(new PoofParticle(x+rand(-w/2,w/2),y+rand(-h/2,h/2),z+rand(-d/2,d/2)), dimension)
     }
     if(unremote) send({
       type:"particles",particleType:"poof",
@@ -19646,7 +17834,7 @@
         for (let Z = -d2; Z <= d2; Z+=space) {
           let n = X * X / w2 + Y * Y / h2 + Z * Z / d2
           if (n < 1) {
-            world.addParticle(new entities[entityIds.PoofParticle](x+X,y+Y-1,z+Z), dimension)
+            world.addParticle(new PoofParticle(x+X,y+Y-1,z+Z), dimension)
           }
         }
       }
@@ -19654,24 +17842,17 @@
   }
   win.playerPoof = playerPoof
   
-  entities[entities.length] = class FallingDustParticle extends Particle{
-		static name2 = "FallingDustParticle"
+  class FallingDustParticle extends Particle{
     constructor(x,y,z, tint){
       super(x, y, z, 0, 0, 0, 0, 0, 0.25, 0.25, 0.25, null, null, genericVaos.size, rand(4000, 8000), genericVaos[floor(rand(8))])
       this.tint = tint
       this.gravityStength = -0.008
     }
     update(){
-			this.updateVelocity(now)
-			this.move(now)
-			if (now - this.spawn > this.despawns) {
-				this.canDespawn = true
-			}
+			super.update()
       if(this.onGround) this.canDespawn = true
-      
-      this.canFacePlayer = true
     }
-    render(){
+    /*render(){
       totalEntites++
       if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width,this.height,this.depth)) return
       renderedEntities++
@@ -19719,15 +17900,14 @@
 			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
 			glExtensions.vertex_array_object.bindVertexArrayOES(null)
       if(this.tint) gl.uniform3f(glCache.tintParticle, 1,1,1)
-    }
+    }*/
   }
 
-  entities[entities.length] = class RedstoneParticle extends Particle{
-		static name2 = "RedstoneParticle"
-    constructor(x,y,z, tint, blue){
+  class RedstoneParticle extends Particle{
+		 constructor(x,y,z, tint, blue){
       var s = rand(0.125,0.5)
       super(x, y, z, 0, 0, rand(-0.01,0.01), rand(-0.01,0.01), rand(-0.01,0.01), s, s, s, null, null, genericVaos.size, genericVaos.length*tickTime, genericVaos[genericVaos.length-1])
-      this.tint = tint || blockData[blockIds.redstoneDust][blue ? "blueTint" : "tint"][round(rand(10,15))]
+      this.tint = tint || (blue ? blockData[blockIds.redstoneDust].tint : blockData[blockIds.blueRedstoneDust].tint)[round(rand(10,15))]
     }
     update(){
 			this.updateVelocity(now)
@@ -19737,10 +17917,9 @@
 			if (now - this.spawn > this.despawns) {
 				this.canDespawn = true
 			}
-      
-      this.canFacePlayer = true
+			this.facePlayer()
     }
-    render(){
+    /*render(){
       totalEntites++
       if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width,this.height,this.depth)) return
       renderedEntities++
@@ -19788,11 +17967,10 @@
 			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
 			glExtensions.vertex_array_object.bindVertexArrayOES(null)
       if(this.tint) gl.uniform3f(glCache.tintParticle, 1,1,1)
-    }
+    }*/
   }
   
-  entities[entities.length] = class ShockwaveParticle extends Particle{
-		static name2 = "ShockwaveParticle"
+  class ShockwaveParticle extends Particle{
     constructor(x,y,z, delay){
       var vao = shockwaveVaos[8]
       var frameTime = 25
@@ -19814,12 +17992,14 @@
 			if (now - this.spawn > this.despawns) {
 				this.canDespawn = true
 			}
+			this.facePlayer()
+    }
+		render(){
       this.index = Math.floor((now - this.spawn) / this.frameTime)
       this.vao = shockwaveVaos[this.index]
-      
-      this.canFacePlayer = true
-    }
-    render(){
+			super.render()
+		}
+    /*render(){
       totalEntites++
       if(this.hidden || !p.camera.canSeeEntity(this.x,this.y,this.z,this.width,this.height,this.depth)) return
       renderedEntities++
@@ -19862,12 +18042,11 @@
 			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
 			glExtensions.vertex_array_object.bindVertexArrayOES(null)
       if(this.tint) gl.uniform3f(glCache.tintParticle, 1,1,1)
-    }
+    }*/
   }
   
-  entities[entities.length] = class SmokeParticle extends Particle{
-		static name2 = "SmokeParticle"
-    constructor(x,y,z){
+ 	class SmokeParticle extends Particle{
+		constructor(x,y,z){
       var frameTime = tickTime
       super(x, y, z, 0, 0, rand(-0.02,0.02), 0, rand(-0.02,0.02), 0.125, 0.125, 0.125, null, null, genericVaos.size, genericVaos.length*frameTime, genericVaos[0])
       this.brightness = rand(0, 0.2)
@@ -19885,10 +18064,9 @@
       
       this.index = genericVaos.length - 1 - Math.floor((now - this.spawn) / this.frameTime)
       this.vao = genericVaos[this.index]
-      
-      this.canFacePlayer = true
+			this.facePlayer()
     }
-    render(){
+    /*render(){
       totalEntites++
       if(!p.camera.canSeeEntity(this.x,this.y,this.z,this.width,this.height,this.depth)) return
       renderedEntities++
@@ -19931,12 +18109,11 @@
 			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
 			glExtensions.vertex_array_object.bindVertexArrayOES(null)
       if(this.tint) gl.uniform3f(glCache.tintParticle, 1,1,1)
-    }
+    }*/
   }
   
-  entities[entities.length] = class NoteParticle extends Particle{
-		static name2 = "NoteParticle"
-    constructor(x,y,z, note){
+  class NoteParticle extends Particle{
+		constructor(x,y,z, note){
       let tex = "note"
       const shape = shapes.blockParticle
       const shapeVerts = shape.verts
@@ -20082,12 +18259,10 @@
 			if (now - this.spawn > this.despawns) {
 				this.canDespawn = true
 			}
-      
-      this.canFacePlayer = true
+			this.facePlayer()
 		}
   }
-	entities[entities.length] = class HeartParticle extends Particle{
-		static name2 = "HeartParticle"
+	class HeartParticle extends Particle{
     constructor(x,y,z){
       let tex = "heartParticle"
       const shape = shapes.blockParticle
@@ -20129,13 +18304,11 @@
 			if (now - this.spawn > this.despawns) {
 				this.canDespawn = true
 			}
-      
-      this.canFacePlayer = true
+			this.facePlayer()
 		}
   }
 
-  entities[entities.length] = class GlintParticle extends Particle{
-		static name2 = "GlintParticle"
+  class GlintParticle extends Particle{
     constructor(x,y,z){
       const shape = shapes.blockParticle
       const shapeVerts = shape.verts
@@ -20172,7 +18345,7 @@
   }
   function glint(x,y,z,dimension,remote){
     for(var i = 0; i<20; i++){
-      world.addParticle(new entities[entityIds.GlintParticle](rand(x-.6,x+.6),rand(y-.6,y+.6),rand(z-.6,z+.6)),dimension)
+      world.addParticle(new GlintParticle(rand(x-.6,x+.6),rand(y-.6,y+.6),rand(z-.6,z+.6)),dimension)
     }
     if(!remote) send({
       type:"particles", particleType:"glint",
@@ -20180,9 +18353,8 @@
     })
   }
   win.glint = glint
-  entities[entities.length] = class FlameParticle extends Particle{
-		static name2 = "FlameParticle"
-    constructor(x,y,z,type){
+  class FlameParticle extends Particle{
+	  constructor(x,y,z,type){
       const shape = shapes.blockParticle
       const shapeVerts = shape.verts
       const shapeTexVerts = shape.texVerts
@@ -20219,12 +18391,11 @@
       if (now - this.spawn > this.despawns) {
 				this.canDespawn = true
 			}
-      this.canFacePlayer = true
+			this.facePlayer()
 		}
   }
-  entities[entities.length] = class LavaParticle extends Particle{
-		static name2 = "LavaParticle"
-    constructor(x,y,z){
+  class LavaParticle extends Particle{
+	  constructor(x,y,z){
       const shape = shapes.blockParticle
       const shapeVerts = shape.verts
       const shapeTexVerts = shape.texVerts
@@ -20258,7 +18429,7 @@
 			this.glow = true
     }
     update() {
-      world.addParticle(new entities[entityIds.SmokeParticle](this.x,this.y,this.z), this.dimension)
+      world.addParticle(new SmokeParticle(this.x,this.y,this.z), this.dimension)
 			this.updateVelocity(now)
 			this.move(now)
       if (now - this.spawn > this.despawns || this.liquid && now - this.spawn > 500) {
@@ -20268,13 +18439,12 @@
         this.width = this.height = this.depth = this.width - 0.02
         if(this.width <= 0) this.canDespawn = true
       }
-      this.canFacePlayer = true
+			this.facePlayer()
 		}
   }
 
-  entities[entities.length] = class DripParticle extends Particle{
-		static name2 = "DripParticle"
-    constructor(x,y,z,tint,splash){
+  class DripParticle extends Particle{
+	  constructor(x,y,z,tint,splash){
       super(x, y-0.125, z, 0, 0, 0, 0, 0, 0.25, 0.25, 0.25, null, null, dripVaos.size, 20000, dripVaos.hang)
       this.tint = tint
       this.gravityStength = -0.065
@@ -20292,18 +18462,17 @@
         this.vao = dripVaos.land
         if(this.animation > 1 || this.splash){
           this.canDespawn = true
-          if(this.splash) world.addParticle(new entities[entityIds.SplashParticle](this.x,this.y,this.z),this.dimension)
+          if(this.splash) world.addParticle(new SplashParticle(this.x,this.y,this.z),this.dimension)
         }
       }else if(!delay) this.vao = dripVaos.fall
 			if (now - this.spawn > this.despawns || this.liquid && now - this.spawn > 500) {
 				this.canDespawn = true
 			}
-      this.canFacePlayer = true
+			this.facePlayer()
     }
   }
-  entities[entities.length] = class SplashParticle extends Particle{
-		static name2 = "SplashParticle"
-    constructor(x,y,z){
+  class SplashParticle extends Particle{
+	  constructor(x,y,z){
       var s = 0.5
       super(x, y, z, 0, 0, rand(-0.3,0.3), rand(0.4,0.7), rand(-0.3,0.3), s, s, s, null, null, splashVaos.size, 20000, splashVaos[floor(rand(4))])
       this.gravityStength = -0.032
@@ -20314,12 +18483,11 @@
 			if (now - this.spawn > this.despawns || this.onGround || this.liquid && now - this.spawn > 500) {
 				this.canDespawn = true
 			}
-      this.canFacePlayer = true
+			this.facePlayer()
     }
   }
-	entities[entities.length] = class Spark extends Particle{
-		static name2 = "Spark"
-    constructor(x,y,z,vx,vy,vz,color){
+	class Spark extends Particle{
+	  constructor(x,y,z,vx,vy,vz,color){
       var frameTime = tickTime*10
       super(x, y, z, 0, 0, vx, vy, vz, 0.5, 0.5, 0.5, null, null, sparkVaos.size, sparkVaos.length*frameTime, sparkVaos[0])
       this.tint = color
@@ -20335,11 +18503,7 @@
 			this.velx += (this.velx * drag - this.velx)
 		}
     update(){
-			this.updateVelocity(now)
-			this.move(now)
-			if (now - this.spawn > this.despawns) {
-				this.canDespawn = true
-			}
+			super.update()
       
       this.index = sparkVaos.length - 1 - Math.floor((now - this.spawn) / this.frameTime)
       this.vao = sparkVaos[this.index]
@@ -20365,7 +18529,7 @@
 				let a = cos(vx*Math.PId) * cos(vy*Math.PId) * cos(vz*Math.PId)
 				vx *= a, vy *= a, vz *= a
 			}
-			world.addParticle(new entities[entityIds.Spark](x,y,z,vx,vy,vz,color),dimension)
+			world.addParticle(new Spark(x,y,z,vx,vy,vz,color),dimension)
 		}
 		if(!remote) send({
       type:"particles", particleType:"fireworkExplode",
@@ -20695,206 +18859,9 @@
     }
   }
   
-  entities[entities.length] = class TextDisplay extends Entity{
-		static name2 = "TextDisplay"
-		constructor(x,y,z,text,size,color,background,glow) {
-      size = size || 1/2
-			super(x, y, z, 0, 0, 0, 0, 0, size, size, size, null,null, 0, 0)
-      this.gravityStength = 0
-      this.offsetZ = 0
-      this.offsetX = 0
-      this.facesPlayer = true
-      
-      this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
-      this.buffer = gl.createBuffer()
-      this.setText(text)
-      this.color = color || [1,1,1]
-      this.background = background || [0,0,0,0]
-      this.glow = glow || false
-      this.size = size
-		}
-    setText(text){
-      if(userInfo ? userInfo.profanityFilter : true) for(var obj of Messages.remove){ //remove bad words
-        text = text.replace(obj.replace, obj.with)
-      }//if you change this, change the one in Messages.format
-
-			let textStr = text
-			text = Array.from(text)//split into unicode
-      let data = new Float32Array(text.length*32)
-      let lineData = []
-      let x = 0, y = 0
-      let lineW = []
-      let line = 0
-      let i = 0
-      let color = [0,0,0], colorSet = 0, bold = false, italic = false
-			const italicX = tan(14*Math.PI/180)
-			for (let idx = 0; idx<text.length; idx++) {
-        let l = text[idx]
-        if(l === "§"){
-					let code = text[idx+1]
-					if(code === "l"){
-						bold = true
-					}else if(code === "o"){
-						italic = true
-					}else if(code === "r"){
-						bold = false, italic = false
-						colorSet = 0
-					}else{
-						color = colors.rgb[code] || color
-						colorSet = 1
-					}
-          idx++
-          continue
-        }
-        if(l === "\n"){
-          x = 0
-          y -= 10/8//linegap = 2
-          line++
-          continue
-        }
-        
-        let coords = textCoords[bold ? "b"+l : l] || textCoords["\0"]
-				let coordsPixels = textCoordsPixels[bold ? "b"+l : l] || textCoordsPixels["\0"]
-        data[i] = x + (italic ? italicX*coordsPixels[3] : 0)
-        data[i+1] = y + coordsPixels[3]
-        data[i+2] = coords[0]
-        data[i+3] = coords[1]
-        data[i+4] = color[0]
-        data[i+5] = color[1]
-        data[i+6] = color[2]
-        data[i+7] = colorSet
-        
-        data[i+8] = x + coordsPixels[2] + (italic ? italicX*coordsPixels[3] : 0)
-        data[i+9] = y + coordsPixels[3]
-        data[i+10] = coords[0] + coords[2]
-        data[i+11] = coords[1]
-        data[i+12] = color[0]
-        data[i+13] = color[1]
-        data[i+14] = color[2]
-        data[i+15] = colorSet
-        
-        data[i+16] = x + coordsPixels[2]
-        data[i+17] = y
-        data[i+18] = coords[0] + coords[2]
-        data[i+19] = coords[1] + coords[3]
-        data[i+20] = color[0]
-        data[i+21] = color[1]
-        data[i+22] = color[2]
-        data[i+23] = colorSet
-        
-        data[i+24] = x
-        data[i+25] = y
-        data[i+26] = coords[0]
-        data[i+27] = coords[1] + coords[3]
-        data[i+28] = color[0]
-        data[i+29] = color[1]
-        data[i+30] = color[2]
-        data[i+31] = colorSet
-        
-        x += coordsPixels[2]
-        lineData[i/32] = line
-        lineW[line] = x
-        i += 32
-			}
-      for(i = 0; i<data.length; i+=8){
-        data[i] -= lineW[lineData[floor(i/32)]] / 2
-        data[i+1] -= y/2
-      }
-      
-      this.faces = i / 32
-      glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
-			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
-			gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer)
-			gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW)
-			gl.enableVertexAttribArray(glCache.aVertexText)
-			gl.enableVertexAttribArray(glCache.aTextureText)
-			gl.enableVertexAttribArray(glCache.aColorText)
-			gl.enableVertexAttribArray(glCache.aColorSetText)
-			gl.vertexAttribPointer(glCache.aVertexText, 2, gl.FLOAT, false, 32, 0)
-			gl.vertexAttribPointer(glCache.aTextureText, 2, gl.FLOAT, false, 32, 8)
-			gl.vertexAttribPointer(glCache.aColorText, 3, gl.FLOAT, false, 32, 16)
-			gl.vertexAttribPointer(glCache.aColorSetText, 1, gl.FLOAT, false, 32, 28)
-			glExtensions.vertex_array_object.bindVertexArrayOES(null)
-      this.text = textStr
-    }
-		update() {
-      this.canFacePlayer = true
-			this.lastUpdate = now
-			this.previousX = this.x
-			this.previousY = this.y
-			this.previousZ = this.z
-		}
-    render(){
-      world.renderTextDisplay(this)
-    }
-		renderText() {
-      let diff = (now - this.lastUpdate) / tickTime
-			if (diff > 1) diff = 1
-      let renderx = (this.x - this.previousX) * diff + this.previousX
-			let rendery = (this.y - this.previousY) * diff + this.previousY
-			let renderz = (this.z - this.previousZ) * diff + this.previousZ
-      
-      if(this.canFacePlayer){
-        this.facePlayer()
-        this.canFacePlayer = false
-      }
-      
-			const offsetY = this.offsetY, offsetX = this.offsetX, offsetZ = this.offsetZ
-			const modelMatrix = new Matrix();
-			modelMatrix.identity()
-			modelMatrix.translate(renderx, rendery + offsetY, renderz)
-			modelMatrix.rotY(this.yaw)
-			modelMatrix.rotX(this.pitch)
-      modelMatrix.translate(0,0,offsetZ)
-			modelMatrix.scale(this.width, this.height, this.depth)
-      modelMatrix.translate(offsetX,0,0)
-			const viewMatrix = p.camera.transformation.elements
-			const proj = p.camera.projection
-			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
-			const modelViewProjectionMatrix = new Matrix()
-			modelViewProjectionMatrix.identity()
-			modelViewProjectionMatrix.mult(projectionMatrix)
-			modelViewProjectionMatrix.mult(viewMatrix)
-			modelViewProjectionMatrix.mult(modelMatrix.elements)
-			// row major to column major
-			modelViewProjectionMatrix.transpose()
-			const x = round(this.x)
-			const y = round(this.y)
-			const z = round(this.z)
-			const blockLight = world.getLight(x, y, z, 1, this.dimension)
-			const skysLight = world.getLight(x, y, z, 0, this.dimension)
-			const lightLevel = min(max(skysLight * skyLight / 15, blockLight / 15), 1.0)
-			gl.uniform1i(glCache.uSamplerText, 9)
-      gl.uniform1i(glCache.glowText, this.glow)
-			gl.uniform1f(glCache.uLightLevelText, lightLevel)
-			gl.uniform1f(glCache.uLanternText, lantern - dist3(this.x,this.y,this.z, p.renderX,p.renderY,p.renderZ) / 10.0)
-      gl.uniform3f(glCache.colorText, ...this.color)
-      gl.uniform4f(glCache.backgroundText, ...this.background)
-      gl.uniform1f(glCache.brightnessText, brightness)
-			gl.uniformMatrix4fv(glCache.uViewText, false, modelViewProjectionMatrix.elements)
-			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
-			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
-			glExtensions.vertex_array_object.bindVertexArrayOES(null)
-		}
-	}
-	let entityOrder = ['Item','BlockEntity', 'PrimedTNT', 'PrimedSuperTNT', 'PrimedUltraTNT', 'PrimedUnTNT', 'MovingBlock', 'EnderPearl', 'Snowball', 'Egg', 'SlingshotShot', 'Arrow', 'Sign', 'ItemFrame', 'ExperienceOrb', 'Cow', 'Pig', 'Creeper', 'Sheep', 'Chicken', 'Zombie', 'Skeleton', 'Spider', 'EnderDragon', 'BlockParticle', 'PoofParticle', 'FallingDustParticle', 'RedstoneParticle', 'ShockwaveParticle', 'SmokeParticle', 'NoteParticle', 'GlintParticle', 'FlameParticle', 'LavaParticle', 'DripParticle', 'SplashParticle', 'Spark', 'TextDisplay','Wolf','HeartParticle',"Blaze","SmallFireball","BlockDisplay","BeaconBeam","Enderman","Minecart"]
-	let unorderedEntities = entities.slice()
-	for(let i=0; i<entities.length; i++){
-		entityIds[entities[i].name2] = i
-	}
-	for(let i=0; i<entityOrder.length; i++){
-		if(entityIds[entityOrder[i]] === undefined){
-			delete entities[i]
-			delete entityIds[entityOrder[i]]
-			continue
-		}
-		entities[i] = unorderedEntities[entityIds[entityOrder[i]]]
-		entities[i].prototype.entId = i
-		entities[i].prototype.type = entities[i].name2
-		entityIds[entities[i].name2] = i
-	}
+	let {entityIds} = win
 	console.log(entities.length,'entities and particles')
-	win.entities = entities, win.entityIds = entityIds
+	win.entities = entities
 
 	let analytics = {
 		totalTickTime: 0,
@@ -22658,7 +20625,7 @@
 			case 1022: playSound("random.anvil_land",0,1,1,posSound(o.location.x,o.location.y,o.location.z)); break
 			case 2000:{
 				if(!performFast) for(let i=0; i<o.amount; i++){
-					world.addParticle(new entities[entityIds.SmokeParticle](o.location.x+rand()-0.5,o.location.y+rand()-0.5,o.location.z+rand()-0.5),p.dimension)
+					world.addParticle(new SmokeParticle(o.location.x+rand()-0.5,o.location.y+rand()-0.5,o.location.z+rand()-0.5),p.dimension)
 				}
 				break
 			}
@@ -22951,7 +20918,7 @@
 					}
 				}
       
-	      if(blockID && blockData[blockID].importantOnset){
+	      if((!noOnupdate || !remote) && blockID && blockData[blockID].importantOnset){
 	        blockData[blockID].importantOnset(x,y,z, dimension,this)
 	      }
 			}else if(!blockData[blockID]) return
@@ -23286,26 +21253,22 @@
 			if(!objFormat && p.data[0] !== 0 || preBetaVersion) return this.posEntityOldBab(p, m, preBetaVersion)
 			let now = performance.now()
 			if(!objFormat) p = bitArrayToPacket(p,this.entityPacketType)
-			const entType = entityOrder[p.entId]
+			const entType = entities[p.entId].name2
 			let ent = this.getEntity(p.id)
 			if(ent){
 				if(entType === "TextDisplay" && ent.text !== p.text) ent.setText(p.text)
-				if(entType === "Item" && ent.amount !== p.amount) ent.amount = p.amount, ent.willUpdateShape = true
 			}else{
 				ent = entities[p.entId]
-				switch(entType){
+					if(ent.mob){
+					ent = new ent(p.x,p.y,p.z) //todo n: cave spider 'cave', fur
+				}
+				else switch(entType){
 					case "Item":
 						ent = new ent(p.x, p.y, p.z, p.velx, p.vely, p.velz, p.block, false, p.amount, p.durability||null, null)
 						break
 					case "BlockEntity":
 						ent = new ent(p.block, p.x,p.y,p.z, p.solidOnGround)
 						break
-					case "PrimedTNT":
-					case "PrimedSuperTNT":
-					case "PrimedUltraTNT":
-					case "PrimedUnTNT":
-						ent = new ent(p.x,p.y,p.z)
-						break
 					case "MovingBlock":
 						ent = new ent(p.block, p.sx,p.sy,p.sz,p.mx,p.my,p.mz,p.despawns,p.solidWhenDone)
 						break
@@ -23317,39 +21280,14 @@
 					case "SmallFireball":
 					case "Egg":
 					case "SlingshotShot":
-					case "Arrow":
-						ent = new ent(p.x,p.y,p.z,0,0,0)
-						break
 					case "ExperienceOrb":
 						ent = new ent(p.x,p.y,p.z,p.amount)
 						break
-					case "Cow":
-					case "Pig":
-					case "Creeper":
-					case "Chicken":
-					case "Zombie":
-					case "Skeleton":
-					case "Wolf":
-					case "Blaze":
-					case "Enderman":
-						ent = new ent(p.x,p.y,p.z)
-						break
-					case "Sheep":
-						ent = new ent(p.x,p.y,p.z, p.color, p.wool)
-						break
-					case "Spider":
-						ent = new ent(p.x,p.y,p.z,p.fur)
-						break
-					case "EnderDragon":
-						ent = new ent(p.x,p.y,p.z)
-						break
 					case "TextDisplay":
 						ent = new ent(p.x,p.y,p.z,p.text,p.size,p.color,p.background,p.glow)
 						break
-					case "Minecart":
-						ent = new ent(p.x,p.y,p.z)
-						break
 					default:
+						ent = new ent(p.x,p.y,p.z)
 						break
 				}
 				if(!ent) return
@@ -23406,6 +21344,8 @@
 				ent.harmEffect = p.harmEffect
 				ent.health = p.health
 			}
+			if("amount" in ent) ent.amount = p.amount
+			if("block" in ent) ent.block = p.block
 			ent.updateChunk()
 			return ent
 		}
@@ -23456,7 +21396,7 @@
           break
         case "SplashParticle":
           if(!performFast) for(var i=0; i<o.amount; i++){
-            this.addParticle(new entities[entityIds.SplashParticle](o.x,o.y,o.z),o.dimension)
+            this.addParticle(new SplashParticle(o.x,o.y,o.z),o.dimension)
           }
           break
         case "glint":
@@ -23466,17 +21406,17 @@
           poof(o.x,o.y,o.z,o.amount,o.dimension,o.data.w,o.data.h,o.data.d)
           break
         case "NoteParticle":
-          this.addParticle(new entities[entityIds.NoteParticle](o.x,o.y,o.z, o.data), o.dimension)
+          this.addParticle(new NoteParticle(o.x,o.y,o.z, o.data), o.dimension)
           break
         case "explosion":
           for(let i=0; i<o.data.length; i+=5){
-            this.addParticle(new entities[entityIds.ShockwaveParticle](o.data[i], o.data[i+1], o.data[i+2], o.data[i+4]), o.data[i+3],o.dimension)
-            this.addParticle(new entities[entityIds.PoofParticle](o.data[i], o.data[i+1], o.data[i+2]), o.data[i+3],o.dimension)
+            this.addParticle(new ShockwaveParticle(o.data[i], o.data[i+1], o.data[i+2], o.data[i+4]), o.data[i+3],o.dimension)
+            this.addParticle(new PoofParticle(o.data[i], o.data[i+1], o.data[i+2]), o.data[i+3],o.dimension)
           }
           break
 				case "flameCube":
 					if(!performFast) for(let i=0; i<o.amount; i++){
-						this.addParticle(new entities[entityIds.FlameParticle](o.x+rand(-0.6,0.6),o.y+rand(-0.6,0.6),o.z+rand(-0.6,0.6)),o.dimension)
+						this.addParticle(new FlameParticle(o.x+rand(-0.6,0.6),o.y+rand(-0.6,0.6),o.z+rand(-0.6,0.6)),o.dimension)
 					}
 					break
 				case "fireworkExplode":
@@ -23484,12 +21424,12 @@
           break
 				case "hearts":
 					for(let i=0; i<o.amount; i++){
-						this.addParticle(new entities[entityIds.HeartParticle](o.x+rand()-0.5,o.y+rand()-0.5,o.z+rand()-0.5),o.dimension)
+						this.addParticle(new HeartParticle(o.x+rand()-0.5,o.y+rand()-0.5,o.z+rand()-0.5),o.dimension)
 					}
 					break
 				case "smokeCube":
 					if(!performFast) for(let i=0; i<o.amount; i++){
-						this.addParticle(new entities[entityIds.SmokeParticle](o.x+rand()-0.5,o.y+rand()-0.5,o.z+rand()-0.5),o.dimension)
+						this.addParticle(new SmokeParticle(o.x+rand()-0.5,o.y+rand()-0.5,o.z+rand()-0.5),o.dimension)
 					}
 					break
       }
@@ -24798,7 +22738,7 @@
 		window.uploadWorld.style.left = width/2+208*ss+"px"
 		window.uploadWorld.style.top = 50*ss+"px"
 
-		const worldSelectBottom = height - 120*ss, worldSelectTop = 90*ss
+		const worldSelectBottom = height - 90*ss, worldSelectTop = 90*ss
 		placeElementCoords(window.worlds, width*0.005, worldSelectTop, width*0.9975, worldSelectBottom)
 		placeElementCoords(window.servers, width*0.005, worldSelectTop, width*0.9975, worldSelectBottom)
 		placeElementCoords(window.seeds, width*0.005, worldSelectTop-20*ss, width*0.9975, worldSelectBottom+20*ss)
@@ -25779,6 +23719,52 @@
 		}
 		return new Uint8Array(mainarr.arr)
 	}
+	function chunkString (str, len) {
+		const size = Math.ceil(str.length/len)
+		const r = Array(size)
+		let offset = 0
+	
+		for (let i = 0; i < size; i++) {
+			r[i] = str.substr(offset, len)
+			offset += len
+		}
+	
+		return r
+	}
+	function chunkArray(array,chunkSize){
+		let chunks = []
+		for (let i = 0; i < array.length; i += chunkSize) {
+			const chunk = array.slice(i, i + chunkSize);
+			chunks.push(chunk)
+		}
+		return chunks
+	}
+	function hex2bin(hex){//from https://stackoverflow.com/questions/45053624/convert-hex-to-binary-in-javascript
+		hex = hex.toLowerCase()
+		var out = "";
+		for(var c of hex) {
+			switch(c) {
+				case '0': out += "0000"; break;
+				case '1': out += "0001"; break;
+				case '2': out += "0010"; break;
+				case '3': out += "0011"; break;
+				case '4': out += "0100"; break;
+				case '5': out += "0101"; break;
+				case '6': out += "0110"; break;
+				case '7': out += "0111"; break;
+				case '8': out += "1000"; break;
+				case '9': out += "1001"; break;
+				case 'a': out += "1010"; break;
+				case 'b': out += "1011"; break;
+				case 'c': out += "1100"; break;
+				case 'd': out += "1101"; break;
+				case 'e': out += "1110"; break;
+				case 'f': out += "1111"; break;
+				default: return "";
+			}
+		}
+		return out;
+	}
 	//stuff starting with "hex" are from unifont.zip
 	const fontData = {
 		"\0":"#####-\n#---#-\n#---#-\n#---#-\n#---#-\n#---#-\n#####-",
@@ -26085,7 +24071,7 @@
   let textureImageData //for drawing on canvas
   let textureImageCanvas
   let textureImageCtx
-  let textureSize = 256
+  let textureSize = 512
   let textureH = 4096
 	let initTextureProgress = 0
 	let setPixOffsetX
@@ -26145,6 +24131,7 @@
         num <<= 8
         num += base256DecodeMap.get(char)
       }
+			if(isNaN(num))debugger
       return num
     }
     getPixels = function(str, r = 255, g = 255, b = 255, includeSize = false) {
@@ -26507,7 +24494,7 @@
 	}
   
 	let lastAnimations = null
-	function updateTextures() {
+	function updateTextures() {return//todo n
 		if(!lastAnimations){
 			lastAnimations = {}
 		}else if(performFast) return
@@ -26975,7 +24962,7 @@
           let distance = sqrt((ent.x - p.x)*(ent.x - p.x) + (ent.y - p.y)*(ent.y - p.y) + (ent.z - p.z)*(ent.z - p.z))
           if (distance < closest) {
             closest = distance
-            cname = ent.name || ent.defaultName
+            cname = ent.name || ent.Name
           }
 					if(ent.target === p.id){
 						closestHostile = min(closestHostile, distance)
@@ -28730,13 +26717,14 @@
 		//Send the block textures to the GPU
 		await initTextures()
 		for(let s in shapes){
-			for(let v of shapes[s].varients){
-				if(!v) continue
-				let buffer = gl.createBuffer()
-				gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
-				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(v.verts.flat(Infinity)), gl.STATIC_DRAW)
-				v.buffer = buffer
-			}
+			//for(let v of shapes[s].varients){
+				//if(!v) continue
+			let v=shapes[s]
+			let buffer = gl.createBuffer()
+			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
+			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(v.verts.flat(Infinity)), gl.STATIC_DRAW)
+			v.buffer = buffer
+			//}
 		}
 
     /*var data = []
@@ -30101,7 +28089,7 @@
       reportError('Web Audio API is not supported in this browser');
       return
     }
-		listener = audioCtx.listener
+		listener = audioCtx.listener
 		if(!listener || !listener.positionX) alert("AudioListener not supported. No 3D sound.")
 		win.audioCtx = audioCtx, win.listener = listener
     
@@ -32637,13 +30625,16 @@
 	window.init = MineKhan()
 	init()
 }else{
-	let script = document.createElement("script")
 	let lastSlash = location.href.lastIndexOf("/")
 	let lastDot = location.href.indexOf(".",lastSlash)
 	if(lastDot === -1) lastDot = location.href.indexOf("?",lastSlash)//remove query which comes after dot
 	if(lastDot<0) lastDot = location.href.length
-	script.src = location.href.substring(0,lastDot)+"-world.js"
-	script.onload = function(){
+	let filename = location.href.substring(0,lastDot)+"-world.js"
+	
+	let script = document.createElement("script")
+	script.type = "module"
+	script.src = filename
+	script.onload = () => {
 		window.init = MineKhan()
 		init()
 	}
