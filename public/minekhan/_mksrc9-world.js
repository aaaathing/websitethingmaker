"use strict"

const version = "Beta 1.1.2"
let win, isNode = false
try{
	win = window
}catch{
	win = module.exports
	isNode = true
}
let workerCount, workerURL
if(isNode){
	workerCount = 1//require("os").cpus()
	workerURL = require("path").join(require("os").tmpdir(), "mkServerWorkerTemp.js")
	require("fs").writeFileSync(workerURL, "("+webWorkerCode.toString()+")()")
	win.Worker = require("worker_threads").Worker
}else{
	workerCount = navigator.hardwareConcurrency
	workerURL = URL.createObjectURL(new Blob(["("+webWorkerCode.toString()+")()"], { type: "text/javascript" }))
}
win.version = version
workerCount = (workerCount || 4) - 1 || 1
{
	// I'm throwing stuff in the window scope since I can't be bothered to figure out how all this fancy import export stuff works
	let workers = win.workers = []
	let allWorkers = win.allWorkers = []
	let waitingJobs = [], waitingMsgs = []
	for (let i = 0, count = workerCount; i < count; i++) { // Generate between 1 and (processors - 1) workers.
		let worker = new win.Worker(workerURL)
		worker.id = i
		let doNewJob = function(){
			workers.push(worker)
			if(waitingMsgs[worker.id].length){
				waitingMsgs[worker.id].shift()()
			}else if(waitingJobs.length){
				waitingJobs.shift()()
			}
		}
		let onmessage = function(e){
			let data = isNode ? e : e.data
			if(data === "started") return doNewJob()
			let [promise, resolve, onProgress] = worker.theJob
			if(data.progress){
				return onProgress(data.progress)
			}
			resolve(data)
			doNewJob()
		}
		if(isNode) worker.on("message",onmessage)
		else worker.onmessage = onmessage
		//workers.push(worker)//done when started
		allWorkers.push(worker)
		waitingMsgs.push([])
	}

	win.doWork = function(data,onProgress) {
		let job = []
		let promise = new Promise(resolve => {
			job[1] = resolve
			let worker = workers.shift()
			if(!worker){
				waitingJobs.push(() => {
					worker = workers.shift()
					worker.theJob = job
					worker.postMessage(data)
				})
			}else{
				worker.theJob = job
				worker.postMessage(data)
			}
		})
		job[0] = promise
		job[2] = onProgress
		return promise
	}
	function sendMsg(data,id){
		let job = []
		let promise = new Promise(resolve => {
			job[1] = resolve
			let worker = allWorkers[id]
			if(!workers.includes(worker)){
				waitingMsgs[id].push(() => {
					worker = allWorkers[id]
					workers.splice(workers.indexOf(worker),1)
					worker.theJob = job
					worker.postMessage(data)
				})
			}else{
				workers.splice(workers.indexOf(worker),1)
				worker.theJob = job
				worker.postMessage(data)
			}
		})
		job[0] = promise
		return promise
	}
	win.sendAllWorkers = async function(msg){
		let p = []
		for(let i=0; i<allWorkers.length; i++){
			p.push(sendMsg(msg,i))
		}
		await Promise.all(p)
	}
}

const { cos, sin, round, floor, ceil, min, max, abs, sqrt, atan, atan2, tan } = Math;
const rand = function(a,b){
	if(arguments.length === 2){
		return (Math.random()*(b-a))+a
	}else if(arguments.length === 1){
		return Math.random()*a
	}else return Math.random()
}
const avg = function(){
	var res = 0, c = 0
	for(var i=0; i<arguments.length; i++){
		if(!arguments[i] && arguments[i] !== 0) continue
		res += arguments[i]
		c++
	}
	res /= c
	return res
}
/*const divideWithRemainder = function(a,b){
	var n=a/b
	var f=floor(n)
	var r=n-f
	n=f
	r=floor(r*b)
	return {n,r}
}*/
const mod = function(a,b){
	return a - floor(a/b)*b
}
Math.PI2 = Math.PI / 2
Math.PI4 = Math.PI / 4
Math.PId = Math.PI * 2
function xyArrayHas(arr,arr2,x,y,z,arrLen=arr.length,arr2Len=arr2&&arr2.length){
	for(var i=0; i<arrLen; i+=4){
		if(arr[i] === x && arr[i+1] === y && arr[i+2] === z){
			return true
		}
	}
	if(arr2){
		for(var i=0; i<arr2Len; i+=4){
			if(arr2[i] === x && arr2[i+1] === y && arr2[i+2] === z){
				return true
			}
		}
	}
}
//from https://stackoverflow.com/questions/1344500/efficient-way-to-insert-a-number-into-a-sorted-array-of-numbers
function insertSorted(array, value) {
	let low = 0,
			high = array.length;

	while (low < high) {
			let mid = (low + high) >>> 1;
			if (array[mid] < value) low = mid + 1;
			else high = mid;
	}
	array.splice(low,0,value)
	return array
}
function emptyIfNullish(v){
	return v||v===0 ? v : ""
}

// Shh don't tell anyone I'm override native objects
String.prototype.hashCode = function() {
	var hash = 0, i, chr;
	if (this.length === 0) return hash;
	for (i = 0; i < this.length; i++) {
		chr   = this.charCodeAt(i);
		hash  = ((hash << 5) - hash) + chr;
		hash |= 0; // Convert to 32bit integer
	}
	return hash;
}
Uint8Array.prototype.toString = function() {
	let str = ""
	for (let i = 0; i < this.length; i++) {
		str += String.fromCharCode(this[i])
	}
	return btoa(str)
}
/*Uint8Array.prototype.toJSON = function(){
	return "BitArray("+this.length*8+")"
}*/
function atoarr(data){
	let bytes = atob(data)
	let arr = new Uint8Array(bytes.length)
	for (let i = 0; i < bytes.length; i++) arr[i] = bytes.charCodeAt(i)
	return arr
}
function chunkString (str, len) {
	const size = Math.ceil(str.length/len)
	const r = Array(size)
	let offset = 0

	for (let i = 0; i < size; i++) {
		r[i] = str.substr(offset, len)
		offset += len
	}

	return r
}
function chunkArray(array,chunkSize){
	let chunks = []
	for (let i = 0; i < array.length; i += chunkSize) {
		const chunk = array.slice(i, i + chunkSize);
		chunks.push(chunk)
	}
	return chunks
}
function hex2bin(hex){//from https://stackoverflow.com/questions/45053624/convert-hex-to-binary-in-javascript
	hex = hex.toLowerCase()
	var out = "";
	for(var c of hex) {
		switch(c) {
			case '0': out += "0000"; break;
			case '1': out += "0001"; break;
			case '2': out += "0010"; break;
			case '3': out += "0011"; break;
			case '4': out += "0100"; break;
			case '5': out += "0101"; break;
			case '6': out += "0110"; break;
			case '7': out += "0111"; break;
			case '8': out += "1000"; break;
			case '9': out += "1001"; break;
			case 'a': out += "1010"; break;
			case 'b': out += "1011"; break;
			case 'c': out += "1100"; break;
			case 'd': out += "1101"; break;
			case 'e': out += "1110"; break;
			case 'f': out += "1111"; break;
			default: return "";
		}
	}
	return out;
}

function sleep(ms) {
	return new Promise(resolve => setTimeout(resolve, ms))
}
const generateID = () => "" + Date.now().toString(36) + (Math.random() * 1000000 | 0).toString(36)
function map(v, min, max, min2, max2){
	return min2 + (max2 - min2) * ((v - min) / (max - min));
}
function mapFrom(v, min, max){
	return (v - min) / (max - min)
}
function mapClamped(v, min, max){
	return Math.min(Math.max(((v - min) / (max - min)),0),1);
}
function lerp(t, a, b) {
	return a + t * (b - a);
}
function dist2(x,y,x2,y2){
	let xDist = x - x2
	let yDist = y - y2
	return sqrt((xDist*xDist)+(yDist*yDist))
}
function dist3(x,y,z,x2,y2,z2){
	let xDist = x - x2
	let yDist = y - y2
	let zDist = z - z2
	return sqrt((xDist*xDist)+(yDist*yDist)+(zDist*zDist))
}
function dist3Sq(x,y,z,x2,y2,z2){
	let xDist = x - x2
	let yDist = y - y2
	let zDist = z - z2
	return (xDist*xDist)+(yDist*yDist)+(zDist*zDist)
}
function mag(x,y,z) {
	return sqrt(x * x + y * y + z * z)
}
function angleOf(x,y,fromx,fromy){
	let a = atan2(x - fromx, y - fromy)
	if(a<0) a+=Math.PId
	return a
}
function line3DConncected(endX, endY, endZ, startX, startY, startZ, array){
	var x1 = Math.round(endX), y1 = Math.round(endY), z1 = Math.round(endZ), x0 = Math.round(startX), y0 = Math.round(startY), z0 = Math.round(startZ);
	var dx = Math.abs(x1 - x0);
	var dy = Math.abs(y1 - y0);
	var dz = Math.abs(z1 - z0);
	var stepX = x0 < x1 ? 1 : -1;
	var stepY = y0 < y1 ? 1 : -1;
	var stepZ = z0 < z1 ? 1 : -1;
	var hypotenuse = Math.sqrt(dx*dx + dy*dy + dz*dz);
	var tMaxX = hypotenuse*0.5 / dx;
	var tMaxY = hypotenuse*0.5 / dy;
	var tMaxZ = hypotenuse*0.5 / dz;
	var tDeltaX = hypotenuse / dx;
	var tDeltaY = hypotenuse / dy;
	var tDeltaZ = hypotenuse / dz;
	while (x0 !== x1 || y0 !== y1 || z0 !== z1){
		if (tMaxX < tMaxY) {
				if (tMaxX < tMaxZ) {
						x0 = x0 + stepX;
						tMaxX = tMaxX + tDeltaX;
				} else if (tMaxX > tMaxZ){
						z0 = z0 + stepZ;
						tMaxZ = tMaxZ + tDeltaZ;
				} else{
						x0 = x0 + stepX;
						tMaxX = tMaxX + tDeltaX;
						z0 = z0 + stepZ;
						tMaxZ = tMaxZ + tDeltaZ;
				}
		} else if (tMaxX > tMaxY){
				if (tMaxY < tMaxZ) {
						y0 = y0 + stepY;
						tMaxY = tMaxY + tDeltaY;
				} else if (tMaxY > tMaxZ){
						z0 = z0 + stepZ;
						tMaxZ = tMaxZ + tDeltaZ;
				} else{
						y0 = y0 + stepY;
						tMaxY = tMaxY + tDeltaY;
						z0 = z0 + stepZ;
						tMaxZ = tMaxZ + tDeltaZ;

				}
		} else{
				if (tMaxY < tMaxZ) {
						y0 = y0 + stepY;
						tMaxY = tMaxY + tDeltaY;
						x0 = x0 + stepX;
						tMaxX = tMaxX + tDeltaX;
				} else if (tMaxY > tMaxZ){
						z0 = z0 + stepZ;
						tMaxZ = tMaxZ + tDeltaZ;
				} else{
						x0 = x0 + stepX;
						tMaxX = tMaxX + tDeltaX;
						y0 = y0 + stepY;
						tMaxY = tMaxY + tDeltaY;
						z0 = z0 + stepZ;
						tMaxZ = tMaxZ + tDeltaZ;

				}
		}
		array.push(x0, y0, z0);
	}
}
//https://www.geeksforgeeks.org/bresenhams-algorithm-for-3-d-line-drawing/
function line3D(x2, y2, z2, x1, y1, z1, array){
	x1 = round(x1)
	y1 = round(y1)
	z1 = round(z1)
	x2 = round(x2)
	y2 = round(y2)
	z2 = round(z2)
	array.push(x1, y1, z1);
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let dz = abs(z2 - z1);
	let xs;
	let ys;
	let zs;
	if (x2 > x1) {
		xs = 1;
	} else {
		xs = -1;
	}
	if (y2 > y1) {
		ys = 1;
	} else {
		ys = -1;
	}
	if (z2 > z1) {
		zs = 1;
	} else {
		zs = -1;
	}

	// Driving axis is X-axis"
	if (dx >= dy && dx >= dz) {
		let p1 = 2 * dy - dx;
		let p2 = 2 * dz - dx;
		while (x1 != x2) {
			x1 += xs;
			if (p1 >= 0) {
				y1 += ys;
				p1 -= 2 * dx;
			}
			if (p2 >= 0) {
				z1 += zs;
				p2 -= 2 * dx;
			}
			p1 += 2 * dy;
			p2 += 2 * dz;
			array.push(x1, y1, z1);
		}

		// Driving axis is Y-axis"
	} else if (dy >= dx && dy >= dz) {
		let p1 = 2 * dx - dy;
		let p2 = 2 * dz - dy;
		while (y1 != y2) {
			y1 += ys;
			if (p1 >= 0) {
				x1 += xs;
				p1 -= 2 * dy;
			}
			if (p2 >= 0) {
				z1 += zs;
				p2 -= 2 * dy;
			}
			p1 += 2 * dx;
			p2 += 2 * dz;
			array.push(x1, y1, z1);
		}

		// Driving axis is Z-axis"
	} else {
		let p1 = 2 * dy - dz;
		let p2 = 2 * dx - dz;
		while (z1 != z2) {
			z1 += zs;
			if (p1 >= 0) {
				y1 += ys;
				p1 -= 2 * dz;
			}
			if (p2 >= 0) {
				x1 += xs;
				p2 -= 2 * dz;
			}
			p1 += 2 * dy;
			p2 += 2 * dx;
			array.push(x1, y1, z1);
		}
	}
}
let emptyFunc = function(){}

// await window.yieldThread() will pause the current task until the event loop is cleared
{
	const channel = new MessageChannel()
	let toYield = {}, toYieldId = 0
	channel.port1.onmessage = e => {
		toYield[e.data]()
		delete toYield[e.data]
	}
	win.yieldThread = function() {
		return new Promise(resolve => {
			let id = toYieldId++
			toYield[id] = resolve
			channel.port2.postMessage(id)
		})
	}
}
function mapFrom(v, min, max){
	return ((v - min) / (max - min))
}
function preferMiddle(x,middle,resMin,resMax){
	//x is 0 to 1
	//middle is a big number between resMin and resMax
	
	let prevMiddle = middle
	middle = mapFrom(middle,resMin,resMax)
	if(x>middle){
		x = mapFrom(x,middle,1)
		x **= 2
		x = lerp(x,prevMiddle,resMax)
	}else{
		x = mapFrom(x,middle,0)
		x **= 2
		x = lerp(x,prevMiddle,resMin)
	}
	return x
}
function preferMiddleSimple(x){
	let px = x
	x = (x-0.5)*2
	x**=3
	x = x/2+0.5
	return x
}

{//Begin
let tickSpeed = 20
let tickTime = 1000/tickSpeed
function fillTextureArray(textures){
	if (textures.length === 3) {
		textures[3] = textures[2];
		textures[4] = textures[2];
		textures[5] = textures[2];
	} else if (textures.length === 2) {
		// Top and bottom are the first texture, sides are the second.
		textures[2] = textures[1];
		textures[3] = textures[2];
		textures[4] = textures[2];
		textures[5] = textures[2];
		textures[1] = textures[0];
	}else if(textures.length === 4){
		textures[4] = textures[5] = textures[3]
		textures[3] = textures[2]
	}
	return textures
}
function mix(r,g,b,r2,g2,b2,amount){
	r = lerp(r,r2,amount)
	g = lerp(g,g2,amount)
	b = lerp(b,b2,amount)
	return [r,g,b]
}
function coltoarr(color){
	return [((color>>16)&255)/255, ((color>>8)&255)/255, (color&255)/255]
}
function expandTints(o){
	let ret = {}
	for(let i in o){
		let names = i.split(",")
		let value
		if(Array.isArray(o[i])){
			value = []
			for(let j of o[i]){
				value.push(...coltoarr(j))
			}
		}else value = coltoarr(o[i])
		for(let j of names) ret[j] = value
	}
	return ret
}
function adjustTints(o,r,g=r,b=r){
	let ret = {}
	for(let i in o){
		ret[i] = [r(o[i][0]),g(o[i][1]),b(o[i][2])]
	}
	return ret
}
const grassColor = {/*r:145/255,g:189/255,b:89/255*/r:71/255,g:206/255,b:49/255}
//var foliageColor = {/*r:119/255,g:171/255,b:47/255*/r:26/255,g:191/255,b:0}
const leafColor = {r:72/255,g:181/255,b:24/255}
const grassTint = {
	a_snowyField:[128/255,180/255,151/255],
	a_desert:[191/255,183/255,85/255],
	a_field:[121/255,192/255,90/255],
	a_jungle:[71/255,206/255,49/255],
	a_giantJungle:[0,0.9,0],
	a_bambooForest:[71/255,206/255,49/255],
	a_oakForest:[121/255,192/255,90/255],

...expandTints({
	default:0x8eb971,
	/*"plains,beach,sunflowerPlains":0x91bd59,
	"frozenRiver,snowyPlains,iceSpikes,grove,frozenPeaks,jaggedPeaks,snowySlopes,snowyTaiga,frozenOcean,deepFrozenOcean":0x80b497,
	snowyBeach:0x83b593,
	meadow:0x86b87f,*/
	"savanna,savannaPlateau,windsweptSavanna,grassySavanna":0xd6bb4d,
	"badlands,woodedBadlands,erodedBadlands":0x90814d,
	//"forest,flowerForest,shrubland":0x79c05a,
	//darkForest:0x507a32,
	/*"birchForest,oldBirchForest,sparseForest":0x88bb67,
	oldPineTaiga:0x86b87f,
	"oldSpruceTaiga,taiga":0x86b783,
	"windsweptGravellyHills,windsweptForest,windsweptHills,stonyShore":0x8ab689,
	"jungle,bambooJungle":0x59c93c,
	sparseJungle:0x64c73f,
	stonePeaks:0x9abe4b,*/
	//lushHills:0x00ad34,
	"swamp,mangroveSwamp":[0x6A7039,0x4C763C],
	marsh:0x92ad6f,
	cherryGrove:0xb6db61,
	forest:0x79c05a,
	trashland:0x424a2a,
	lushCaves:0xb9b75b,
	dripstoneCaves:0x8db58a,
	"netherWastes,crimsonForest,warpedForest":0xbfb755,
	"end,endIslands":0x8eb971
})
}
/*const foliageTint = {
	default:[foliageColor.r,foliageColor.g,foliageColor.b],
	snowyPlains:[128/255,180/255,151/255],
	desert:[191/255,183/255,85/255],
	plains:[121/255,192/255,90/255],
	forest:[121/255,192/255,90/255],
}*/
const leafTint = {
	a_snowyField:[96/255,161/255,123/255],
	a_desert:[174/255,164/255,42/255],
	a_field:[89/255,174/255,48/255],
	a_jungle:[48/255,187/255,11/255],
	a_giantJungle:[0.1,0.8,0],
	a_bambooForest:[48/255,187/255,11/255],
	a_oakForest:[89/255,174/255,48/255],
	
...expandTints({
	default:0x71a74d,//used for water biomes
	/*"plains,beach,sunflowerPlains":0x77ab2f,
	"frozenRiver,snowyPlains,iceSpikes,grove,frozenPeaks,jaggedPeaks,snowySlopes,snowyTaiga,frozenOcean,deepFrozenOcean":0x60a17b,
	snowyBeach:0x64a278,
	meadow:0x68a55f,
	*/"savanna,savannaPlateau,windsweptSavanna,grassySavanna":0x96b330,
	"badlands,woodedBadlands,erodedBadlands":0x9e814d,
	/*"forest,flowerForest,darkForest,shrubland":0x59ae30,
	"birchForest,oldBirchForest,sparseForest":0x6ba941,
	oldPineTaiga:0x68a55f,
	"oldSpruceTaiga,taiga":0x68a464,
	"windsweptGravellyHills,windsweptForest,windsweptHills,stonyShore":0x6da36b,
	"jungle,bambooJungle":0x30bb0b,
	sparseJungle:0x3eb80f,
	stonePeaks:0x82ac1e,*/
	//lushHills:0x18ad39,
	swamp:0x6A7039,
	mangroveSwamp:0x8DB127,
	cherryGrove:0xb6db61,
	forest:0x59ae30,
	trashland:0x5a6932,
	lushCaves:0xa6a432,
	dripstoneCaves:0x70a26c,
	"netherWastes,crimsonForest,warpedForest":0xaea42a,
	"end,endIslands":0x71a74d
})
}
const skyColor = {
	a_snowyField:[127/255, 161/255, 1],
	a_desert:[110/255, 177/255, 1],
	a_field:[121/255, 166/255,1],
	a_jungle:[119/255, 168/255,1],
	a_giantJungle:[119/255, 168/255,1],
	a_bambooForest:[119/255, 168/255,1],
	a_oakForest:[121/255, 166/255,1],
	
...expandTints({
	default:0x7ba4ff,
	"plains,beach,sunflowerPlains,swamp,mangroveSwamp":0x78a7ff,
	"frozenRiver,snowyPlains,iceSpikes,frozenOcean,deepFrozenOcean,snowyBeach":0x7fa1ff,
	grove:0x81a0ff,
	"frozenPeaks,jaggedPeaks":0x859dff,
	snowySlopes:0x829fff,
	snowyTaiga:0x839eff,
	"meadow,oldPineTaiga,cherryGrove":0x7ca3ff,
	"desert,savanna,savannaPlateau,windsweptSavanna,grassySavanna,badlands,woodedBadlands,erodedBadlands":0x6eb1ff,
	"forest,flowerForest,darkForest,shrubland":0x79a6ff,
	"birchForest,oldBirchForest,sparseForest":0x7aa5ff,
	"oldSpruceTaiga,taiga":0x7da3ff,
	"windsweptGravellyHills,windsweptForest,windsweptHills,stonyShore":0x7da2ff,
	"jungle,bambooJungle,sparseJungle":0x77a8ff,
	stonePeaks:0x76a8ff,
	//lushHills:0x4a5fff,
	trashland:0x4c7575,
	//lushCaves:0x2a4524,
	//dripstoneCaves:0x4d4b3e,
	netherWastes:0x330808,
	crimsonForest:0x330303,
	warpedForest:0x1a051a,
	"end,endIslands":0xa080a0
})
}
win.skyColor = skyColor
const waterColor = [68/255,175/255,245/255]
const waterTint = {
	a_snowyField:[20/255,85/255,155/255],
	a_desert:[50/255,165/255,162/255],
	a_field:[30/255,151/255,242/255],
	a_jungle:[13/255,138/255,227/255],
	a_giantJungle:[20/255,162/255,197/255],
	a_bambooForest:[20/255,162/255,197/255],
	a_oakForest:[30/255,151/255,242/255],
	
...expandTints({
	"default,void,plains,grove,snowySlopes,frozenPeaks,stonePeaks,jaggedPeaks,sunflowerPlains,rockyPlains":0x44aff5,
	warmOcean:0x02b0e5,
	"lukewarmOcean,deepLukewarmOcean":0x0d96db,
	"coldOcean,deepColdOcean":0x2080c9,
	"frozenOcean,deepFrozenOcean":0x2570b5,
	"ocean,deepOcean":0x1787d4,
	snowyBeach:0x1463a5,
	snowyTaiga:0x205e83,
	frozenRiver:0x185390,
	meadow:0x44aff5,
	"river,rockyRiver":0x0084ff,
	beach:0x157cab,
	stonyShore:0x0d67bb,
	"snowyPlains,iceSpikes":0x14559b,
	taiga:0x287082,
	"oldPineTaiga,oldSpruceTaiga":0x2d6d77,
	darkForest:0x3b6cd1,
	flowerForest:0x20a3cc,
	"forest,shrubland,sparseForest,bambooForest":0x1e97f2,
	birchForest:0x0677ce,
	oldBirchForest:0x0a74c4,
	"jungle,bambooJungle":0x14a2c5,
	sparseJungle:0x0d8ae3,
	"savanna,grassySavanna,dryRiver":0x2c8b9c,
	"savannaPlateau,windsweptSavanna":0x2590a8,
	"desert,dryShrubland":0x32a598,
	badlands:0x4e7f81,
	erodedBadlands:0x497f99,
	woodedBadlands:0x55809e,
	"windsweptForest,windsweptGravellyHills,alpineHills":0x0e63ab,
	windsweptHills:0x007bf7,
	cherryGrove:0x5db7ef,
	//lushHills:0x1774ff,
	"swamp,marsh":0x4C6559,
	mangroveSwamp:0x3A7A6A,
	mushroomFields:0x8a8997,
	trashland:0x008040,
	"lushCaves,dripstoneCaves":0x44aff5,
	"netherWastes,crimsonForest,warpedForest":0x905957,
	"end,endIslands":0x62529e
})
}


//each mob: [mob name, min, max]
const defaultMobs = [["Sheep",4,4],["Pig",4,4],["Chicken",4,4],["Cow",4,4]]
const grassMobs = [...defaultMobs,["Horse",2,6],["Donkey",1,3]]
const taigaMobs = [...grassMobs,["Rabbit",2,3],["Fox",2,4]]
const beachMobs = [["Turtle",4,4]]
const peakMobs = [["Rabbit",2,3],["Goat",1,3]]
const defaultHostileMobs = [["Zombie",4,4],["Skeleton",4,4],["Creeper",4,4],["Enderman",4,4],["Spider",4,4]]
const meadowMobs = [["Rabbit",2,6],["Sheep",2,4],["Donkey",1,2]]
const swampMobs = [...defaultMobs,["Frog",2,5]]
const swampHostileMobs = [["Slime",4,4],["Witch",1,1]]
let biomeData = { //[temperature, rainfall (snow exluded), passive mobs, hostile mobs]
	void:[0.5,0.5],

	a_snowyField:[2/20,0.5],
	a_desert:[17/20,0],
	a_field:[9/20,0.5,defaultMobs],
	a_jungle:[10/20,0.5,defaultMobs],
	a_giantJungle:[12/20,0.5,defaultMobs],
	a_bambooForest:[10/20,0.5,defaultMobs],
	a_oakForest:[9/20,0.5,defaultMobs],

	ocean:[0.5,0.5],
	deepOcean:[0.5,0.5],
	warmOcean:[0.8,0.6],
	lukewarmOcean:[0.6,0.5],
	deepLukewarmOcean:[0.6,0.5],
	coldOcean:[0.35,0.5],
	deepColdOcean:[0.35,0.5],
	frozenOcean:[0.1515,0.5],
	deepFrozenOcean:[0.152,0.5],
	plains:[0.8,0.4, grassMobs],
	iceSpikes:[0,0.1],
	snowyPlains:[0,0.1, [["Rabbit",1,1],["PolarBear",1,1]]],
	grove:[-0.2,0.5, taigaMobs],
	alpineHills:[0.18,0.25,taigaMobs],
	snowyTaiga:[-0.5,0.1, taigaMobs],
	taiga:[0.25,0.8, taigaMobs],
	shrubland:[0.85,0.4, grassMobs],
	meadow:[0.3,0.5, meadowMobs],
	forest:[0.7,0.8, grassMobs],
	sparseForest:[0.6,0.6, grassMobs],
	oldPineTaiga:[0.3,0.8, taigaMobs],
	oldSpruceTaiga:[0.25,0.8, taigaMobs],
	flowerForest:[0.7,0.8, grassMobs],
	oldBirchForest:[0.6,0.6, grassMobs],
	birchForest:[0.7,0.8, grassMobs],
	darkForest:[0.6,0.6, grassMobs],
	savanna:[1.2,0.2, grassMobs],
	grassySavanna:[1.2,0.2, grassMobs],
	sparseJungle:[0.95,0.8, grassMobs],
	bambooJungle:[0.95,0.9, grassMobs],
	jungle:[0.95,0.9, grassMobs],
	desert:[2,0],
	snowyBeach:[0.05,0.3, beachMobs],
	beach:[0.8,0.4, beachMobs],
	snowySlopes:[-0.3,0.9, peakMobs],
	windsweptGravellyHills:[0.2,0.3, grassMobs],
	//lushHills:[0.2,0.8, grassMobs],
	windsweptHills:[0.2,0.3, grassMobs],
	windsweptForest:[0.2,0.3, grassMobs],
	frozenPeaks:[-0.7,0.9],
	stonePeaks:[1,0.3],
	jaggedPeaks:[-0.7,0.9, peakMobs],
	frozenRiver:[0,0.5],
	river:[0.5,0.5],
	dryRiver:[1,0.1],
	rockyRiver:[0.5,0.4],
	sunflowerPlains:[0.8,0.4, grassMobs],
	stonyShore:[0.2,0.3],
	savannaPlateau:[1,0, grassMobs],
	erodedBadlands:[2,0],
	badlands:[2,0],
	woodedBadlands:[2,0],
	windsweptSavanna:[1.1,0.5, grassMobs],
	rockyPlains:[0.8,0.4, grassMobs],
	mushroomFields:[0.9,1, ["Mooshroom",4,4]],
	cherryGrove:[0.3,0.5, meadowMobs],
	dryShrubland:[1,0.2],
	swamp:[0.8,0.5,swampMobs,swampHostileMobs],
	mangroveSwamp:[0.8,0.9],
	bambooForest:[0.7,0.8, grassMobs],
	marsh:[0.8,0.3],

	trashland:[0.25,0],

	dripstoneCaves:[0.2,0],
	lushCaves:[0.9,0],

	warpedForest:[2,0],
	crimsonForest:[2,0],
	netherWastes:[2,0, ["Blaze",4,4]],

	end:[0.5,0.5],
	endIslands:[0.5,0.5]
}
win.biomeData = biomeData
let biomes = Object.keys(biomeData)
let biomeIds = Object.fromEntries(biomes.map((b,i) => [b,i]))
win.biomeIds = biomeIds
function getNetherBiome(biome) {
	if(biome > 0.4 && biome < 0.5){
		return "warpedForest"
	}else if(biome > 0.4){
		return "crimsonForest"
	}
	return "netherWastes"
}
function getBiome(biome){
	if(biome > 0.6){
		return "a_snowyField"
	}else if(biome > 0.5){
		return "a_desert"
	}else if(biome > 0.4){
		return "a_field"
	}else if(biome > 0.37){
		return "a_jungle"
	}else if(biome > 0.35){
		return "a_giantJungle"
	}else if(biome > 0.3){
		return "a_bambooForest"
	}else{
		return "a_oakForest"
	}
}
function getBiomeTemperature(biome,y){
	if(!biomeData[biome]) return 0
	let t = biomeData[biome][0]
	if(y > 80) t -= (y-80)/800
	return t
}

for(let i in biomeData){
	let data = biomeData[i]
	if(!waterTint[i]) logError("Missing water tint for "+i)
	if(grassTint[i] && leafTint[i]) continue
	let rainfall = max(min(data[1],1),0)
	let temperature = max(min(data[0],1),0)
	let temperatureHigher = 1-(1-temperature)**2
	if(!grassTint[i]){
		grassTint[i] = [//0x00ad34
			lerp(rainfall, lerp(temperature, 115, 192), lerp(temperatureHigher, 0, 70))/255,
			lerp(rainfall, lerp(temperature, 161, 183), lerp(temperatureHigher, 173, 205))/255,
			lerp(rainfall, lerp(temperature, 135, 86), lerp(temperatureHigher, 52, 54))/255
		]
	}
	if(!leafTint[i]){
		leafTint[i] = [
			lerp(rainfall, lerp(temperature, 86, 174), lerp(temperatureHigher, 24, 29))/255,
			lerp(rainfall, lerp(temperature, 145, 164), lerp(temperatureHigher, 173, 191))/255,
			lerp(rainfall, lerp(temperature, 111, 41), lerp(temperatureHigher, 56, 1))/255
		]
	}
	/*if(!skyColor[i]){
		let t = min(max(data[0]/3,-1),1)
		skyColor[i] = [ 0.62222224 - t*0.05, 0.5+t*0.1, 1 ]
	}*/
}

let sit
let generator = {
	height: 80, // Height of the hills
	smooth: 0.01, // Smoothness of the terrain
	extra: 30, // Extra height added to the world.
	caveSize: 0.00, // Redefined right above where it's used
	biomeSmooth: 0.007, // Smoothness of biomes
}
win.generator = generator //for mods
const {doWork, sendAllWorkers, yieldThread} = win
const maxHeight = 319
const minHeight = -64
const weatherHeight = 192
const minEntityY = minHeight-40
const netherHeight = 127
const waterHeight = 62

const blockData = [
	{
		name: "air",
		id: 0,
		textures: new Array(6).fill("none"),
		transparent: true,
		shadow: false,
		hidden: true
	},
	{
		name: "grass",
		Name: "Grass Block",
		textures: [ "dirt", "grassTop", "grassSide" ],
		hardness: 0.6,
		blastResistance:0.6,
		drop:"dirt",
		type:"ground",
		grassSound: true,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			var top = world.getBlock(x,y+1,z)
			var isSnow = blockData[top].name === "snow" || blockData[top].name === "snowBlock"
			if(b === blockIds.grass && isSnow){
				world.setBlock(x,y,z,blockIds.grass | CROSS)
			}else if(b === (blockIds.grass | CROSS) && !isSnow){
				world.setBlock(x,y,z,blockIds.grass)
			}
		},
		compostChance:0.3,
		category:"nature",
		craftSlabs:true, craftStairs:true,
		invTint: [grassColor.r,grassColor.g,grassColor.b],
		tint:grassTint,
		biomeTintTop:true,
		biomeTintEast:true,
		biomeTintWest:true,
		biomeTintNorth:true,
		biomeTintSouth:true,
		randomRotate:true,
		randomRotateTop:true,
		randomRotateBottom:true,
	},
	{ name: "dirt", Name:"Dirt", hardness:0.5, blastResistance:0.5, type:"ground",category:"nature",
		digSound: ["dirt.dig1", "dirt.dig2", "dirt.dig3", "dirt.dig4"],
		stepSound: ["dirt.step1", "dirt.step2","dirt.step3","dirt.step4"],
	 	randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true,
	},
	{ name: "stone", Name:"Stone", drop:"cobblestone", type:"rock1",category:"nature", hardness:5, blastResistance:6, stoneSound:true, craftSlabs:true, craftStairs:true,randomRotate:"flip",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true},
	{ name: "bedrock", Name:"Bedrock", category:"nature", hardness:1000, blastResistance:3600000, stoneSound:true, pistonPush:false, pistonPull:false,randomRotate:"flip",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true},
	{ name: "sand", Name:"Sand", hardness:0.5, blastResistance:0.5,fallingDust:[212/255, 195/255, 148/255], category:"nature",
		onupdate: function(x,y,z,b,world,sx,sy,sz){
			fall(x,y,z,b,world,false)
		},
		ongetexploded:function(x,y,z,b,world){
			fall(x,y,z,b,world,true)
		},
		digSound: ["sand.dig1", "sand.dig2", "sand.dig3", "sand.dig4"],
		stepSound: ["sand.step1", "sand.step2","sand.step3","sand.step4","sand.step5"]},
	{ name: "gravel", Name:"Gravel", hardness:0.6, blastResistance:0.6, type:"ground",category:"nature",fallingDust:[132/255, 126/255, 124/255],
		onupdate: function(x,y,z,b,world,sx,sy,sz){
			fall(x,y,z,b,world,false)
		},
		ongetexploded:function(x,y,z,b,world){
			fall(x,y,z,b,world,true)
		},
		drop: function(){
			if(round(random(10)) === 1) return "flint"
			else return "gravel"
		},
		digSound: ["gravel.dig1", "gravel.dig2", "gravel.dig3", "gravel.dig4"],
		stepSound: ["gravel.step1", "gravel.step2","gravel.step3","gravel.step4"]},
	{
		name: "leaves",
		Name: "Leaves",
		transparent: true,
		shadow:false,
		cullFace:0,
		hardness: 0.2,
		blastResistance:0.2,
		type:"plant2",
		category:"nature",
		drop: function(){
			if(rand() > 0.8){
				let r = floor(rand(3))
				if(r === 0) return "stick"
				else if(r === 1) return "oakSapling"
				else return "apple"
			}
		},
		dropSelfWhenSheared:true,
		shearBreakTime:0.05,
		burnChance: 0.2,
		burnTime: 30,
		compostChance:0.3,
		grassSound: true,
		decreaseLight:1
	},
	{
		name: "glass",
		Name:"Glass",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		blastResistance:0.3,
		type: "glass",
		category:"build",
		glassSound: true
	},
	{ name: "cobblestone", Name:"Cobblestone", hardness:2, blastResistance:6, type:"rock1",category:"build", stoneSound:true, craftSlabs:true, craftStairs:true},
	{ name: "mossyCobble", Name:"Mossy Cobblestone", hardness:2, blastResistance:6, type:"rock1",category:"build", stoneSound:true, craftSlabs:true, craftStairs:true},
	{ name: "stoneBricks", Name:"Stone Bricks", hardness:1.5, type:"rock1",category:"build", stoneSound:true, craftSlabs:true, craftStairs:true},
	{ name: "mossyStoneBricks", Name:"Mossy Stone Bricks", hardness:1.5, type:"rock1",category:"build", stoneSound:true, craftSlabs:true, craftStairs:true},
	{ name: "bricks", Name:"Bricks", hardness:2, type:"rock1",category:"build", stoneSound:true, craftSlabs:true, craftStairs:true},
	{ name: "coalOre", Name:"Coal Ore", hardness:3, type:"rock1",category:"nature", drop:"coal", stoneSound:true, experience:0.1},
	{ name: "ironOre", Name:"Iron Ore", hardness:3, type:"rock2",category:"nature", drop:"rawIron", stoneSound:true, dropAmount:[1,3]},
	{ name: "goldOre", Name:"Gold Ore", hardness:3, type:"rock3",category:"nature", drop:"rawGold", stoneSound:true, dropAmount:[1,3]},
	{ name: "diamondOre", Name:"Diamond Ore", hardness:3, type:"rock3",category:"nature", drop:"diamond", stoneSound:true, experience:1, dropAmount:[1,3]},
	{ name: "redstoneOre", Name:"Redstone Ore", hardness:3, type:"rock3",category:"nature", stoneSound:true, drop:"redstone", dropAmount:[6,9], experience:0.3},
	{ name: "lapisOre", Name:"Lapis Lazuli Ore", hardness:3, type:"rock2",category:"nature", drop:"lapisLazuli", stoneSound:true, experience:0.5, dropAmount:[1,3]},
	{ name: "emeraldOre", Name:"Emerald Ore", hardness:3, type:"rock3",category:"nature", drop:"emerald", stoneSound:true, experience:1.5, dropAmount:[1,3]},
	{ name: "coalBlock", Name:"Block of Coal", hardness:5, type:"rock1",category:"build", stoneSound:true, burnChance:0.4, burnTime:50},
	{ name: "ironBlock", Name:"Block of Iron", hardness:5, type:"metal2",category:"build", stoneSound:true},
	{ name: "goldBlock", Name:"Block of Gold", hardness:3, type:"metal3",category:"build", stoneSound:true},
	{ name: "diamondBlock", Name:"Block of Diamond", hardness:3, type:"metal3",category:"build", stoneSound:true},
	{
		name: "redstoneBlock", Name:"Block of Redstone", hardness:5, type:"metal1",category:"redstone", stoneSound:true,
		onset:function(x,y,z,world){
			world.setPower(x,y,z,16,false)
			world.spreadPower(x,y,z, 16)
		},
		ondelete: function(x,y,z,prevTags,prev,world){
			world.setPower(x,y,z,0)
			world.unspreadPower(x,y,z, 16)
		},
		damage:1,
		dieMessage: p => p.username+" died from radiation from block of redstone."
	},
	{ name: "lapisBlock", Name:"Block of Lapis Lazuli", hardness:3, type:"metal2",category:"build", stoneSound:true},
	{ name: "emeraldBlock", Name:"Block of Emerald", hardness:5, type:"metal3",category:"build", stoneSound:true},
	{ name: "oakPlanks", Name:"Oak Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40, craftSlabs:true, craftStairs:true},
	{
		name: "oakLog",
		Name:"Oak Log",
		textures: [ "logTop", "logSide" ],
		hardness:2,
		woodSound:true,
		type:"wood",
		category:"nature",
		burnChance:0.1,
		burnTime:50,
		log:true
	},
	{ name: "acaciaPlanks", Name:"Acacia Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40, craftSlabs:true, craftStairs:true},
	{
		name: "acaciaLog",
		Name:"Acacia Log",
		textures: [ "acaciaLogTop", "acaciaLogSide" ],
		hardness:2,
		woodSound:true,
		type:"wood",
		category:"nature",
		burnChance:0.1,
		burnTime:50,
		log:true
	},
	{ name: "birchPlanks", Name:"Birch Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40, craftSlabs:true, craftStairs:true},
	{
		name: "birchLog",
		Name:"Birch Log",
		textures: [ "birchLogTop", "birchLogSide" ],
		hardness:2,
		woodSound:true,
		type:"wood",
		category:"nature",
		burnChance:0.1,
		burnTime:50,
		log:true
	},
	{ name: "darkOakPlanks", Name:"Dark Oak Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40, craftSlabs:true, craftStairs:true},
	{
		name: "darkOakLog",
		Name:"Dark Oak Log",
		textures: [ "darkOakLogTop", "darkOakLogSide" ],
		hardness:2,
		woodSound:true,
		type:"wood",
		category:"nature",
		burnChance:0.1,
		burnTime:50,
		log:true
	},
	{ name: "junglePlanks", Name:"Jungle Planks", type:"wood",category:"build", hardness:2,woodSound:true, burnChance:0.1, burnTime:40, craftSlabs:true, craftStairs:true},
	{
		name: "jungleLog",
		Name:"Jungle Log",
		textures: [ "jungleLogTop", "jungleLogSide" ],
		hardness:2,
		woodSound:true,
		type:"wood",
		category:"nature",
		burnChance:0.1,
		burnTime:50,
		log:true
	},
	{ name: "sprucePlanks", Name:"Spruce Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40, craftSlabs:true, craftStairs:true},
	{
		name: "spruceLog",
		Name:"Spruce Log",
		textures: [ "spruceLogTop", "spruceLogSide" ],
		hardness:2,
		woodSound:true,
		type:"wood",
		category:"nature",
		burnChance:0.1,
		burnTime:50,
		log:true
	},
	{ name: "whiteWool", Name:"White Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
	{ name: "orangeWool", Name:"Orange Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
	{ name: "magentaWool", Name:"Magenta Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
	{ name: "lightBlueWool", Name:"Light Blue Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
	{ name: "yellowWool", Name:"Yellow Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
	{ name: "limeWool", Name:"Lime Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
	{ name: "pinkWool", Name:"Pink Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
	{ name: "grayWool", Name:"Gray Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
	{ name: "lightGrayWool", Name:"Light Gray Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
	{ name: "cyanWool", Name:"Cyan Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
	{ name: "purpleWool", Name:"Purple Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
	{ name: "blueWool", Name:"Blue Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
	{ name: "brownWool", Name:"Brown Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
	{ name: "greenWool", Name:"Green Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
	{ name: "redWool", Name:"Red Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
	{ name: "blackWool", Name:"Black Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
	{ name: "whiteConcrete", Name:"White Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
	{ name: "orangeConcrete", Name:"Orange Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
	{ name: "magentaConcrete", Name:"Magenta Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
	{ name: "lightBlueConcrete", Name:"Light Blue Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
	{ name: "yellowConcrete", Name:"Yellow Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
	{ name: "limeConcrete", Name:"Lime Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
	{ name: "pinkConcrete", Name:"Pink Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
	{ name: "grayConcrete", Name:"Gray Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
	{ name: "lightGrayConcrete", Name:"Light Gray Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
	{ name: "cyanConcrete", Name:"Cyan Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
	{ name: "purpleConcrete", Name:"Purple Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
	{ name: "blueConcrete", Name:"Blue Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
	{ name: "brownConcrete", Name:"Brown Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
	{ name: "greenConcrete", Name:"Green Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
	{ name: "redConcrete", Name:"Red Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
	{ name: "blackConcrete", Name:"Black Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
	{
		name: "bookshelf",
		Name:"Bookshelf",
		textures: [ "oakPlanks", "bookshelf" ],
		stoneSound: true,
		type:"wood",
		category:"decoration",
		burnChance:0.4,
		burnTime:30
	},
	{ name: "netherrack",
		Name:"Netherrack",
		hardness:0.4,
		type:"rock1",
		category:"nature",
		burnTime:Infinity,
		digSound: ["netherrack.dig1", "netherrack.dig2", "netherrack.dig3", "netherrack.dig4", "netherrack.dig5", "netherrack.dig6"],
		stepSound: ["netherrack.step1", "netherrack.step2","netherrack.step3","netherrack.step4","netherrack.step5","netherrack.step6"],
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{ name: "soulSand",
		Name:"Soul Sand",
		category:"nature",
		speedFactor: 0.5,
		canHaveSoulFire: true,
		digSound: ["soul_sand.dig1", "soul_sand.dig2", "soul_sand.dig3", "soul_sand.dig4", "soul_sand.dig5", "soul_sand.dig6","soul_sand.step7","soul_sand.step8","soul_sand.step9"],
		stepSound: ["soul_sand.step1", "soul_sand.step2","soul_sand.step3","soul_sand.step4","soul_sand.step5","soul_sand.step6"],
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name: "glowstone",
		Name:"Glowstone",
		hardness:0.3,
		type:"rock1",
		category:"decoration",
		lightLevel: 15,
		glassSound: true,
		shadow:false,
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{ name: "netherBricks",
		Name:"Nether Bricks",
		category:"build",
		craftSlabs:true, craftStairs:true,
		digSound: ["nether_bricks.dig1", "nether_bricks.dig2", "nether_bricks.dig3", "nether_bricks.dig4", "nether_bricks.dig5", "nether_bricks.dig6"],
		stepSound: ["nether_bricks.step1", "nether_bricks.step2","nether_bricks.step3","nether_bricks.step4","nether_bricks.step5","nether_bricks.step6"]},
	{ name: "redNetherBricks",
		Name:"Red Nether Bricks",
		category:"build",
		craftSlabs:true, craftStairs:true,
		digSound: ["nether_bricks.dig1", "nether_bricks.dig2", "nether_bricks.dig3", "nether_bricks.dig4", "nether_bricks.dig5", "nether_bricks.dig6"],
		stepSound: ["nether_bricks.step1", "nether_bricks.step2","nether_bricks.step3","nether_bricks.step4","nether_bricks.step5","nether_bricks.step6"]},
	{
		name: "netherQuartzOre", 
		Name:"Nether Quartz Ore",
		category:"nature",
		digSound: ["nether_ore.dig1", "nether_ore.dig2", "nether_ore.dig3", "nether_ore.dig4"],
		stepSound: ["nether_ore.step1", "nether_ore.step2","nether_ore.step3","nether_ore.step4","nether_ore.step5"],
		drop: "quartz",
		dropAmount: [1,2],
		hardness:3,
		blastResistance:3,
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name: "quartzBlock",
		Name:"Block of Quartz",
		category:"build",
		textures: ["quartzBlockBottom", "quartzBlockTop", "quartzBlockSide"],
		stoneSound: true,
		hardness:1.5,
		blastResistance:6,
		craftSlabs:true, craftStairs:true,
	},
	{
		name: "quartzPillar",
		Name:"Pillar",
		category:"build",
		textures: ["quartzPillarTop", "quartzPillar"],
		stoneSound: true,
		hardness:1.5,
		blastResistance:6
	},
	{
		name: "chiseledQuartzBlock",
		Name:"Chiseled Quartz Block",
		category:"build",
		textures: ["chiseledQuartzBlockTop", "chiseledQuartzBlock"],
		stoneSound: true,
		hardness:1.5,
		blastResistance:6
	},
	{ name: "chiseledStoneBricks", Name:"Chiseled Stone Bricks",category:"build", hardness:1.5, blastResistance:6, stoneSound:true},
	{ name: "smoothStone", Name:"Smooth Stone",category:"build", hardness:1.5, blastResistance:6, stoneSound:true, randomRotate:"flip",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true},
	{ name: "andesite", Name:"Andesite", stoneSound:true,category:"nature", hardness:1.5, blastResistance:6, randomRotate:"flip",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true},
	{ name: "polishedAndesite", Name:"Polished Andesite",category:"build", hardness:1.5, blastResistance:6, stoneSound:true, craftSlabs:true, craftStairs:true},
	{ name: "diorite", Name:"Diorite", stoneSound:true,category:"nature", hardness:1.5, blastResistance:6, randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true},
	{ name: "polishedDiorite", Name:"Polished Diorite",category:"build", hardness:1.5, blastResistance:6, stoneSound:true, craftSlabs:true, craftStairs:true},
	{ name: "granite", Name:"Granite", stoneSound:true,category:"nature", hardness:1.5, blastResistance:6, randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true},
	{ name: "polishedGranite", Name:"Polished Granite",category:"build", hardness:1.5, blastResistance:6, stoneSound:true, craftSlabs:true, craftStairs:true},
	{ // I swear, if y'all don't stop asking about TNT every 5 minutes!
		name: "tnt",
		Name:"TNT",
		textures: ["tntBottom", "tntTop", "tntSides"],
		superTntTextures: ["superTntBottom","superTntTop","superTnt"],
		ultraTntTextures: ["ultraTntBottom","ultraTntTop","ultraTnt"],
		//onupdate: function(x,y,z){
		//  explode(x,y,z,5)
		//}, flint and steel explodes it
		explode: function(x,y,z, how,world){
			world.setBlock(x,y,z,0)
			var e = new entities[entityIds.PrimedTNT](x,y,z)
			world.addEntity(e)
			world.playSound(x,y,z, "random.fuse")
			switch(how){
				case "explosion":
					e.timeLimit = rand(10,30)
			}
		},
		superTntExplode: function(x,y,z,world){
			world.setBlock(x,y,z,0)
			var e = new entities[entityIds.PrimedSuperTNT](x,y,z)
			world.addEntity(e)
			world.playSound(x,y,z, "random.fuse")
		},
		ultraTntExplode: function(x,y,z,world){
			world.setBlock(x,y,z,0)
			var e = new entities[entityIds.PrimedUltraTNT](x,y,z)
			world.addEntity(e)
			world.playSound(x,y,z, "random.fuse")
		},
		onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,world){
			var power = world.getRedstonePower(x,y,z)
			if(power > 0) this.explode(x,y,z,null,world)
		},
		onset:function(x,y,z,world){
			var power = world.getRedstonePower(x,y,z)
			if(power > 0) this.explode(x,y,z,null,world)
		},
		burnChance:0.6,
		onburn:function(x,y,z,world){
			this.explode(x,y,z,null,world)
		},
		category:"redstone",
		grassSound: true
	},
	{
		name: "portal",
		solid:false,
		shadow: false,
		portal: true,
		transparent:true,
		cullFace:"same",
		lightLevel: 11,
		flatIcon:true,
		drop:"air",
		glassSound: true,
		ambientSound:"portal.portal",
		pistonPush:false,
		pistonPull:false,
		hidden:true,
		serverontouch: function(x,y,z,ent){
			ent.portalEffect += 2.5
			if(ent.portalEffect >= 100 && ent.portalFadeOutEffect <= 0){
				if(ent.type === "Player") ent.connection.send({type:"portalOut"})
				ent.portalFadeOutEffect = 100
				if(ent.dimension === ""){
					ent.x /= 8, ent.z /= 8
				}else{
					ent.x *= 8, ent.z *= 8
				}
				ent.tp(ent.x,ent.y,ent.z,ent.dimension === "nether" ? "" : "nether")
				ent.doingPortal = blockIds.portal
				ent.world.playSound(x,y,z,"portal.travel")
				if(ent.type === "Player") ent.addAchievment("Into the Nether")
			}
		},
		searchForPortal:function(x,y,z,world){
			for(let x2=0; x2<128; x2++) for(let y2=0; y2<128; y2++) for(let z2=0; z2<128; z2++) {
				let x3 = x+((x2%2)?-(x2+1)/2:x2/2)//alternate back and forth, example: 0, -1, 1, -2, 2
				let y3 = y+((y2%2)?-(y2+1)/2:y2/2)
				let z3 = z+((z2%2)?-(z2+1)/2:z2/2)
				if(blockData[world.getBlock(x3,y3,z3)].name === "portal") return [x3,y3,z3]
			}
		},
		doneLoading:function(p,world){
			let portal = this.searchForPortal(round(p.x),round(p.y),round(p.z),world)
			if(portal){
				p.tp(portal[0],portal[1]-0.5+p.height*0.5,portal[2])
				p.lastY = p.y
			}else{
				let portalFill = 0, px = round(p.x), py = round(p.y), pz = round(p.z) //cant use p2 because just finished loading
				let dy = 32
				mainLoop:for(let y = 32; y<128; y++){
					for(let x=px-2; x<px+2; x++) for(let z=pz-2; z<pz+2; z++){
						if(blockData[world.getBlock(x,y,z)].solid){
							portalFill = 0
							continue mainLoop
						}
					}
					portalFill++, dy = y
					if(portalFill === 6) break mainLoop
				}
				if(portalFill === 6){
					let x = px, z = pz, y = dy
					if(rand() > 0.5){
						world.setBlock(x-2,y-5,z,blockIds.obsidian)
						world.setBlock(x-1,y-5,z,blockIds.obsidian)
						world.setBlock(x,y-5,z,blockIds.obsidian)
						world.setBlock(x+1,y-5,z,blockIds.obsidian)
						//layer2
						world.setBlock(x-2,y-4,z,blockIds.obsidian)
						world.setBlock(x-1,y-4,z,blockIds.portal|PORTAL|NORTH)
						world.setBlock(x,y-4,z,blockIds.portal|PORTAL|NORTH)
						world.setBlock(x+1,y-4,z,blockIds.obsidian)
						world.setBlock(x-2,y-3,z,blockIds.obsidian)
						world.setBlock(x-1,y-3,z,blockIds.portal|PORTAL|NORTH)
						world.setBlock(x,y-3,z,blockIds.portal|PORTAL|NORTH)
						world.setBlock(x+1,y-3,z,blockIds.obsidian)
						world.setBlock(x-2,y-2,z,blockIds.obsidian)
						world.setBlock(x-1,y-2,z,blockIds.portal|PORTAL|NORTH)
						world.setBlock(x,y-2,z,blockIds.portal|PORTAL|NORTH)
						world.setBlock(x+1,y-2,z,blockIds.obsidian)
						//layer5
						world.setBlock(x-2,y-1,z,blockIds.obsidian)
						world.setBlock(x-1,y-1,z,blockIds.obsidian)
						world.setBlock(x,y-1,z,blockIds.obsidian)
						world.setBlock(x+1,y-1,z,blockIds.obsidian)
					}else{
						world.setBlock(x,y-5,z-2,blockIds.obsidian)
						world.setBlock(x,y-5,z-1,blockIds.obsidian)
						world.setBlock(x,y-5,z,blockIds.obsidian)
						world.setBlock(x,y-5,z+1,blockIds.obsidian)
						//layer2
						world.setBlock(x,y-4,z-2,blockIds.obsidian)
						world.setBlock(x,y-4,z-1,blockIds.portal|PORTAL|EAST)
						world.setBlock(x,y-4,z,blockIds.portal|PORTAL|EAST)
						world.setBlock(x,y-4,z+1,blockIds.obsidian)
						world.setBlock(x,y-3,z-2,blockIds.obsidian)
						world.setBlock(x,y-3,z-1,blockIds.portal|PORTAL|EAST)
						world.setBlock(x,y-3,z,blockIds.portal|PORTAL|EAST)
						world.setBlock(x,y-3,z+1,blockIds.obsidian)
						world.setBlock(x,y-2,z-2,blockIds.obsidian)
						world.setBlock(x,y-2,z-1,blockIds.portal|PORTAL|EAST)
						world.setBlock(x,y-2,z,blockIds.portal|PORTAL|EAST)
						world.setBlock(x,y-2,z+1,blockIds.obsidian)
						//layer5
						world.setBlock(x,y-1,z-2,blockIds.obsidian)
						world.setBlock(x,y-1,z-1,blockIds.obsidian)
						world.setBlock(x,y-1,z,blockIds.obsidian)
						world.setBlock(x,y-1,z+1,blockIds.obsidian)
					}
					p.tp(x,dy-5+0.5+p.height*0.5,z)
					p.lastY = p.y
				}else world.sendAll({type:"message",fromServer:true,data:"§cFailed to find and place portal"})
			}
		}
	},
	{ name: "obsidian", Name:"Obsidian", stoneSound:true, type:"rock4",category:"nature", hardness:50, blastResistance:1200, pistonPush:false, pistonPull:false, randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true},
	//the old redstone dust added before this version of minekhan was public (early 2021)
	/*{
		name:"redstoneDust",
		onupdate: function(x,y,z){
			var neigbors = [
				world.getBlock(x+1,y,z),
				world.getBlock(x-1,y,z),
				world.getBlock(x,y,z+1),
				world.getBlock(x,y,z-1),
				world.getBlock(x,y+1,z),
				world.getBlock(x,y-1,z)
			];
			
			if(neigbors.includes(blockIds.redstoneBlock) || neigbors.includes(blockIds.redstoneDustOn)){
				world.setBlock(x,y,z, blockIds.redstoneDustOn, false, true)
			}
			
		}
	},
	{
		name:"redstoneDustOn",
		hidden: true,
		onupdate: function(x,y,z){
			var checked = []
			
			function touchingSource(x,y,z, t){
				t = t || 0;
				t ++;
				
				var neighbors = [
					[x+1,y,z],
					[x-1,y,z],
					[x,y,z+1],
					[x,y,z-1],
					[x,y+1,z],
					[x,y-1,z]
				];
				
				for(var i=0; i<neighbors.length; i++){
					var value = neighbors[i];
					var block = world.getBlock(value[0], value[1], value[2])
					
					if(block === blockIds.redstoneBlock){
						return true;
					}
					
					if(t<10){
						if( !(checked.includes[value]) && (block === blockIds.redstoneDust || block === blockIds.buffer) && touchingSource(value[0], value[1], value[2], t)){
							checked.push(value);
							return true
						};
					}
					
				}
				return false;
			}
			
			if(!touchingSource(x,y,z)){
				world.setBlock(x,y,z, blockIds.redstoneDust);
			}
			
			//world.setBlock(x,y,z, blockIds.redstoneDust);
		}
	},*/
	{
		name:"redstone",
		Name:"Redstone Dust",
		item:true,
		useAs:"redstoneDust",
		category:"redstone",
	},
	{
		name:"redstoneDust",
		textures:"redstoneDustDot",
		shadow:false,
		transparent:true,
		solid:false,
		hidden:true,
		smoothLight:false,
		damage:(x,y,z,world) => world.getPower(x,y,z)/15,
		dieMessage: p => p.username+" died from radiation from redstone dust.",
		drop: "redstone",
		carryRedstone:true,
		tagBits:{
			north:[0,1],
			south:[1,1],
			east:[2,1],
			west:[3,1],
			northUp:[4,1],
			southUp:[5,1],
			eastUp:[6,1],
			westUp:[7,1],
			northDown:[8,1],
			southDown:[9,1],
			eastDown:[10,1],
			westDown:[11,1],
			up:[12,1],
			down:[13,1]
		},
		tint:[[75,0,0],[111,0,0],[121,0,0],[130,0,0],[140,0,0],[151,0,0],[161,0,0],[171,0,0],[181,0,0],[191,0,0],[202,0,0],[211,0,0],[221,0,0],[231,6,0],[241,27,0],[252,49,0]].map(v => {v[0]/=255;v[1]/=255;v[2]/=255;return v}),
		blueTint:[[0,75,75],[0,111,111],[0,121,121],[0,130,130],[0,140,140],[0,151,151],[0,161,161],[0,171,171],[0,181,181],[0,191,191],[0,202,202],[0,211,211],[0,221,221],[6,231,231],[27,241,241],[49,252,252]].map(v => {v[0]/=255;v[1]/=255;v[2]/=255;return v}),
		tagTintPropertyTop: "power",
		tagTintPropertyBottom: "power",
		tagTintPropertyNorth: "power",
		tagTintPropertySouth: "power",
		tagTintPropertyEast: "power",
		tagTintPropertyWest: "power",
		onupdate: function(x,y,z,b,world,sx,sy,sz){
			let tags = world.getTags(x,y,z)
			let north, south, east, west
			let northUp = getTagBits(tags,"northUp",this.id), southUp = getTagBits(tags,"southUp",this.id), eastUp = getTagBits(tags,"eastUp",this.id), westUp = getTagBits(tags,"westUp",this.id)
			let northDown = getTagBits(tags,"northDown",this.id), southDown = getTagBits(tags,"southDown",this.id), eastDown = getTagBits(tags,"eastDown",this.id), westDown = getTagBits(tags,"westDown",this.id)
			let up, down
			let pnorthUp = northUp, psouthUp = southUp, peastUp = eastUp, pwestUp = westUp,
					pnorthDown = northDown, psouthDown = southDown, peastDown = eastDown, pwestDown = westDown
			
			let above = world.getBlock(x,y+1,z)
			if(above && !blockData[above].transparent){
				westUp = eastUp = southUp = northUp = up = false
			}else{
				westUp = this.connectable(x+1,y+1,z,"westUp",b,world)
				eastUp = this.connectable(x-1,y+1,z,"eastUp",b,world)
				southUp = this.connectable(x,y+1,z-1,"southUp",b,world)
				northUp = this.connectable(x,y+1,z+1,"northUp",b,world)
				up = this.connectable(x,y+1,z,"up",b,world)
			}
			
			westDown = this.connectable(x+1,y-1,z,"westDown",b,world)
			eastDown = this.connectable(x-1,y-1,z,"eastDown",b,world)
			southDown = this.connectable(x,y-1,z-1,"southDown",b,world)
			northDown = this.connectable(x,y-1,z+1,"northDown",b,world)
			down = this.connectable(x,y-1,z,"down",b,world)
			
			west = westUp || westDown || this.connectable(x+1,y,z,"west",b,world)
			east = eastUp || eastDown || this.connectable(x-1,y,z,"east",b,world)
			south = southUp || southDown || this.connectable(x,y,z-1,"south",b,world)
			north = northUp || northDown || this.connectable(x,y,z+1,"north",b,world)
			
			if(north + south + east + west === 1){
				//make it a line. it can't be half of a line
				if(north) south = true
				if(south) north = true
				if(east) west = true
				if(west) east = true
			}
			if(up || down){
				north = south = east = west = true
			}
			world.setTagByName(x,y,z,"north",north,true,true)
			world.setTagByName(x,y,z,"south",south,true,true)
			world.setTagByName(x,y,z,"east",east,true,true)
			world.setTagByName(x,y,z,"west",west,true,true)
			world.setTagByName(x,y,z,"northUp",northUp,true,true)
			world.setTagByName(x,y,z,"southUp",southUp,true,true)
			world.setTagByName(x,y,z,"eastUp",eastUp,true,true)
			world.setTagByName(x,y,z,"westUp",westUp,true,true)
			world.setTagByName(x,y,z,"northDown",northDown,true,true)
			world.setTagByName(x,y,z,"southDown",southDown,true,true)
			world.setTagByName(x,y,z,"eastDown",eastDown,true,true)
			world.setTagByName(x,y,z,"westDown",westDown,true,true)
			world.setTagByName(x,y,z,"up",up,true,true)
			world.setTagByName(x,y,z,"down",down,false,false)//notice last one not lazy and not remote
			
			//set texture and stuff
			let sum = north + south + east + west
			let block = this.id //dot
			if(sum === 2){
				if(north && west) block = this.id | STAIR | EAST
				else if(west && south) block = this.id | STAIR | SOUTH
				else if(south && east) block = this.id | STAIR | WEST
				else if(east && north) block = this.id | STAIR | NORTH
				else{
					if(north || south) block = this.id | SLAB | NORTH
					if(east || west) block = this.id | SLAB | EAST
				}
			}else if(sum === 3){
				if(east && west){
					if(north) block = this.id | DOOR | NORTH
					else block = this.id | DOOR | SOUTH
				}else if(north && south){
					if(east) block = this.id | DOOR | WEST
					else block = this.id | DOOR | EAST
				}
			}else if(sum === 4) block = this.id | PANE
			if((b & FLIP) === FLIP) block |= FLIP //blue redstone
			if(world.getBlock(x,y,z) !== block){
				world.setBlock(x,y,z,block,false,false,false,true)
				//world.updateBlock(x,y,z,false,false,null,null,null,dimension)
			}
			if(pnorthUp != northUp) world.updateBlock(x,y+1,z+1), world.unspreadPower(x,y+1,z+1,world.getPower(x,y+1,z+1), true)
			if(psouthUp != southUp) world.updateBlock(x,y+1,z-1), world.unspreadPower(x,y+1,z-1,world.getPower(x,y+1,z-1), true)
			if(pwestUp != westUp) world.updateBlock(x+1,y+1,z), world.unspreadPower(x+1,y+1,z,world.getPower(x+1,y+1,z), true)
			if(peastUp != eastUp) world.updateBlock(x-1,y+1,z), world.unspreadPower(x-1,y+1,z,world.getPower(x-1,y+1,z), true)
			if(pnorthDown != northDown) world.updateBlock(x,y-1,z+1), world.unspreadPower(x,y-1,z+1,world.getPower(x,y-1,z+1), true)
			if(psouthDown != southDown) world.updateBlock(x,y-1,z-1), world.unspreadPower(x,y-1,z-1,world.getPower(x,y-1,z-1), true)
			if(pwestDown != westDown) world.updateBlock(x+1,y-1,z), world.unspreadPower(x+1,y-1,z,world.getPower(x+1,y-1,z), true)
			if(peastDown != eastDown) world.updateBlock(x-1,y-1,z), world.unspreadPower(x-1,y-1,z,world.getPower(x-1,y-1,z), true)
			//above: number != boolean

			this.onpowerupdate(x,y,z,x,y,z,false,world)
		},
		onset:function(x,y,z,world){
			//this.onupdate(x,y,z,null,null,null,null,null,dimension)
			let power = world.getRedstoneWirePower(x,y,z)
			var strong = world.getSurroundingBlockPower(x,y,z) === "strong"
			if(strong) power = 15
			world.setTagByName(x,y,z,"power",power,false)
			if(power) world.spreadPower(x,y,z,power)
		},
		ondelete:function(x,y,z,tags,prev,world){
			const power = getTagBits(tags,"power",this.id)
			if(power) world.unspreadPower(x,y,z,power)
			
			if(getTagBits(tags,"north",this.id)){
				var block = world.getBlock(x,y,z+1)
				if(block && !blockData[block].transparent){
					world.setBlockPower(x,y,z+1, null, "south")
				}
			}
			if(getTagBits(tags,"south",this.id)){
				var block = world.getBlock(x,y,z-1)
				if(block && !blockData[block].transparent){
					world.setBlockPower(x,y,z-1, null, "north")
				}
			}
			if(getTagBits(tags,"west",this.id)){
				var block = world.getBlock(x+1,y,z)
				if(block && !blockData[block].transparent){
					world.setBlockPower(x+1,y,z, null, "east")
				}
			}
			if(getTagBits(tags,"east",this.id)){
				var block = world.getBlock(x-1,y,z)
				if(block && !blockData[block].transparent){
					world.setBlockPower(x-1,y,z, null, "west")
				}
			}
			var block = world.getBlock(x,y-1,z)
			if(block && !blockData[block].transparent){
				world.setBlockPower(x,y-1,z, null, "top")
			}
			
			//update the diagnolly connecting redstone
			if(getTagBits(tags,"northUp",this.id)) world.updateBlock(x,y+1,z+1), world.unspreadPower(x,y+1,z+1,world.getPower(x,y+1,z+1), true)
			if(getTagBits(tags,"southUp",this.id)) world.updateBlock(x,y+1,z-1), world.unspreadPower(x,y+1,z-1,world.getPower(x,y+1,z-1), true)
			if(getTagBits(tags,"westUp",this.id)) world.updateBlock(x+1,y+1,z), world.unspreadPower(x+1,y+1,z,world.getPower(x+1,y+1,z), true)
			if(getTagBits(tags,"eastUp",this.id)) world.updateBlock(x-1,y+1,z), world.unspreadPower(x-1,y+1,z,world.getPower(x-1,y+1,z), true)
			if(getTagBits(tags,"northDown",this.id)) world.updateBlock(x,y-1,z+1), world.unspreadPower(x,y-1,z+1,world.getPower(x,y-1,z+1), true)
			if(getTagBits(tags,"southDown",this.id)) world.updateBlock(x,y-1,z-1), world.unspreadPower(x,y-1,z-1,world.getPower(x,y-1,z-1), true)
			if(getTagBits(tags,"westDown",this.id)) world.updateBlock(x+1,y-1,z), world.unspreadPower(x+1,y-1,z,world.getPower(x+1,y-1,z), true)
			if(getTagBits(tags,"eastDown",this.id)) world.updateBlock(x-1,y-1,z), world.unspreadPower(x-1,y-1,z,world.getPower(x-1,y-1,z), true)
		},
		onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,world){
			if(x===sx && y===sy && z===sz && !blockPowerChanged){
				var tags = world.getTags(x,y,z)
				if(getTagBits(tags,"power",this.id)){
					if(getTagBits(tags,"north",this.id) && world.getBlockPower(x,y,z+1, "south") !== "weak"){
						var block = world.getBlock(x,y,z+1)
						if(block && !blockData[block].transparent){
							world.setBlockPower(x,y,z+1, "weak", "south")
						}
					}
					if(getTagBits(tags,"south",this.id) && world.getBlockPower(x,y,z-1, "north") !== "weak"){
						var block = world.getBlock(x,y,z-1)
						if(block && !blockData[block].transparent){
							world.setBlockPower(x,y,z-1, "weak", "north")
						}
					}
					if(getTagBits(tags,"west",this.id) && world.getBlockPower(x+1,y,z, "east") !== "weak"){
						var block = world.getBlock(x+1,y,z)
						if(block && !blockData[block].transparent){
							world.setBlockPower(x+1,y,z, "weak", "east")
						}
					}
					if(getTagBits(tags,"east",this.id) && world.getBlockPower(x-1,y,z, "west") !== "weak"){
						var block = world.getBlock(x-1,y,z)
						if(block && !blockData[block].transparent){
							world.setBlockPower(x-1,y,z, "weak", "west")
						}
					}
				}else{
					if(world.getBlockPower(x,y,z+1, "south")){
						var block = world.getBlock(x,y,z+1)
						if(block && !blockData[block].transparent){
							world.setBlockPower(x,y,z+1, null, "south")
						}
					}
					if(world.getBlockPower(x,y,z-1, "north")){
						block = world.getBlock(x,y,z-1)
						if(block && !blockData[block].transparent){
							world.setBlockPower(x,y,z-1, null, "north")
						}
					}
					if(world.getBlockPower(x+1,y,z, "east")){
						block = world.getBlock(x+1,y,z)
						if(block && !blockData[block].transparent){
							world.setBlockPower(x+1,y,z, null, "east")
						}
					}
					if(world.getBlockPower(x-1,y,z, "west")){
						block = world.getBlock(x-1,y,z)
						if(block && !blockData[block].transparent){
							world.setBlockPower(x-1,y,z, null, "west")
						}
					}
				}
				var target = getTagBits(tags,"power",this.id) ? "weak" : null
				if(target !== world.getBlockPower(x,y-1,z, "top")){
					var block = world.getBlock(x,y-1,z)
					if(block && !blockData[block].transparent){
						world.setBlockPower(x,y-1,z, target, "top")
					}
				}
			}else if(blockPowerChanged){
				var shouldBeOn = /*world.getRedstoneWirePower(x,y,z) || */world.getSurroundingBlockPower(x,y,z) === "strong"
				var power = world.getPower(x,y,z)
				if(shouldBeOn && !power){
					world.setPower(x,y,z,15,false)
					world.spreadPower(x,y,z,15)
				}else if(!shouldBeOn && power){
					world.unspreadPower(x,y,z,15,true)
				}
			}
		},
		connectables: ["redstoneBlock", "redstoneLamp", "tnt", "redstoneTorch", "lever", "redstoneConnector","is:button", "piston","pistonSticky","is:pressurePlate","dropper","dispenser","target","is:coloredRedstoneLamp","noteBlock", "daylightDetector","is:commandBlock"],
		connectable: function(x,y,z, d, b,world) {
			var id = world.getBlock(x,y,z)
			if(!id) return false
			
			var up = false, down = false
			switch(d){
				case "northUp":
				case "southUp":
				case "eastUp":
				case "westUp":
				case "up":
					up = true
					break
				case "northDown":
				case "southDown":
				case "eastDown":
				case "westDown":
				case "down":
					down = true
					break
			}
			
			if(down && d !== "down"){
				var block = world.getBlock(x,y+1,z)
				if(block && !blockData[block].transparent) return false
			}
			if(up || down) return blockData[id].name === "redstoneDust" && (id & FLIP) === (b & FLIP)
			
			if(blockData[id].name === "redstoneDust" && (id & FLIP) === (b & FLIP)) return true
			if(this.connectables.includes(blockData[id].name)) return true
			for(var i of this.connectables){
				if(i.startsWith("is:")){
					if(blockData[id][i.replace("is:","")]) return true
				}
			}
			if(blockData[id].name === "repeater" || blockData[id].name === "notGate"){
				var canIt = false
				var facing = blockData[id].getFacing(x,y,z,world)
				switch(facing){
					case "north":
					case "south":
						canIt = d === "north" || d === "south"
						break
					case "east":
					case "west":
						canIt = d === "east" || d === "west"
				}
				return canIt
			}else if(blockData[id].name === "observer"){
				var facing = blockData[id].getFacing(x,y,z,world)
				switch(facing){
					case "east":
						return d === "east"
					case "west":
						return d === "west"
					case "north":
						return d === "south"
					case "south":
						return d === "north"
				}
			}else if(blockData[id].logicGate){
				var facing = blockData[id].getFacing(x,y,z,world)
				switch(facing){
					case "east":
						return d === "east" || d === "north" || d === "south"
					case "west":
						return d === "west" || d === "north" || d === "south"
					case "north":
						return d === "south" || d === "east" || d === "west"
					case "south":
						return d === "north" || d === "east" || d === "west"
				}
			}else if(blockData[id].name === "comparator"){
				var facing = blockData[id].getFacing(x,y,z,world)
				var canIt
				switch(facing){
					case "east":
						canIt = canIt || d === "east" || d === "north" || d === "south"
					case "west":
						canIt = canIt || d === "west" || d === "north" || d === "south"
					case "north":
						canIt = canIt || d === "south" || d === "east" || d === "west"
					case "south":
						canIt = canIt || d === "north" || d === "east" || d === "west"
				}
				switch(facing){
					case "north":
					case "south":
						canIt = canIt || d === "north" || d === "south"
						break
					case "east":
					case "west":
						canIt = canIt || d === "east" || d === "west"
				}
				return canIt
			}
			return false
		},
	},
	/*{
		name: "buffer",
		textures: ["bufferTop", "bufferMiddle"],
		category:"redstone",
		onupdate: function(x,y,z){
			setTimeout(() => {
				var isOn = world.getBlock(x,y+1,z);
				isOn = isOn === blockIds.redstoneDustOn || isOn === blockIds.redstoneBlock;
				if(isOn && world.getBlock(x,y-1,z) === blockIds.redstoneDust ){
					setTimeout(function(){world.setBlock(x,y-1,z, blockIds.redstoneDustOn)}, 500);
				}
			}, 10)
		}
	},*/
	{
		name:"blueRedstone",
		Name:"Blue Redstone Dust",
		item:true,
		useAs:() => blockIds.redstoneDust | FLIP,
		category:"redstone",
	},
	{ name: "soup",category:"food"},
	{ name: "soup2",category:"food"},
	{
		name: "soup3",
		transparent:true,
		category:"food"
	},
	{ name: "soup4",category:"food"},
	{ name: "randomSoup",category:"food"},
	{
		name: "redStain",
		transparent: true,
	},
	{
		name:"poision potion",
		transparent:true,
		crossShape:true,
	},
	
	{
		name: "light",
		textures: "none",
		transparent:true,
		lightLevel: 15,
		solid: false,
		iconTexture: "light_15",
		flatIcon: true,
		shadow: false,
		noHitbox:true,
		pistonPush:false,
		pistonPull:false,
		rarity:"epic"
	},
	
	{
		name: "autumnLeaves",
		transparent: true,
		cullFace:0,
		burnChance: 0.2,
		burnTime: 30,
		category:"nature",
		decreaseLight:1
	},
	{
		name: "darkLeaves",
		transparent: true,
		cullFace:0,
		burnChance: 0.2,
		burnTime: 30,
		category:"nature",
		hardness: 0.2,
		blastResistance:0.2,
		type:"plant2",
		drop: function(){
			if(rand() > 0.8) return "stick"
		},
		dropSelfWhenSheared:true,
		shearBreakTime:0.05,
		compostChance:0.3,
		grassSound: true,
		decreaseLight:1
	},
	{
		name: "redBerryLeaves",
		transparent: true,
		cullFace:0,
		burnChance: 0.2,
		burnTime: 30,
		category:"nature",
		hardness: 0.2,
		blastResistance:0.2,
		type:"plant2",
		drop: function(){
			if(rand() > 0.8){
				let r = floor(rand(3))
				if(r === 0) return "greenGrapes"
				else if(r === 1) return "purpleGrapes"
				else return "stick"
			}
		},
		dropSelfWhenSheared:true,
		shearBreakTime:0.05,
		compostChance:0.3,
		grassSound: true,
		decreaseLight:1
	},
	{
		name: "blueBerryLeaves",
		transparent: true,
		cullFace:0,
		burnChance: 0.2,
		burnTime: 30,
		category:"nature",
		hardness: 0.2,
		blastResistance:0.2,
		type:"plant2",
		drop: function(){
			if(rand() > 0.8){
				let r = floor(rand(3))
				if(r === 0) return "greenGrapes"
				else if(r === 1) return "purpleGrapes"
				else return "stick"
			}
		},
		dropSelfWhenSheared:true,
		shearBreakTime:0.05,
		compostChance:0.3,
		grassSound: true,
		decreaseLight:1
	},
	{
		name: "yellowLeaves",
		transparent: true,
		cullFace:0,
		burnChance: 0.2,
		burnTime: 30,
		category:"nature",
		decreaseLight:1,
		hardness: 0.2,
	},
	
	{ name: "lilyOftheValley",
		Name:"Lily of The Valley",
		solid: false,
		transparent: true,
		shadow: false,
		potCross: true,
		crossShape: true,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		randomOffset:true
	},
	{ name: "poppy",
		Name:"Poppy",
		solid: false,
		transparent: true,
		shadow: false,
		potCross: true,
		crossShape: true,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		randomOffset:true
	},
	{ name: "dandelion",
		Name:"Dandelion",
		solid: false,
		transparent: true,
		shadow: false,
		potCross: true,
		crossShape: true,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		randomOffset:true
	},
	{ name: "blueOrchid",
		Name:"Blue Orchid",
		solid: false,
		transparent: true,
		shadow: false,
		crossShape: true,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		potCross:true,
		randomOffset:true
	},
	{ name: "pinkTulip",
		Name:"Pink Tulip",
			solid: false,
			transparent: true,
			shadow: false,
		potCross: true,
			crossShape: true,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		randomOffset:true
	},
	{ name: "orangeTulip",
		Name:"Orange Tulip",
			solid: false,
			transparent: true,
			shadow: false,
		potCross: true,
			crossShape: true,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		randomOffset:true
	},
	{ name: "redTulip",
		Name:"Red Tulip",
			solid: false,
			transparent: true,
			shadow: false,
		potCross: true,
			crossShape: true,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		randomOffset:true
	},
	{ name: "whiteTulip",
		Name:"White Tulip",
			solid: false,
			transparent: true,
			shadow: false,
		potCross: true,
			crossShape: true,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		randomOffset:true
	},
	{ name: "azureBluet",
		Name:"Azure Bluet",
			solid: false,
			transparent: true,
			shadow: false,
		potCross: true,
			crossShape: true,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		randomOffset:true
	},
	{ name: "cornFlower",
		Name:"Cornflower",
			solid: false,
			transparent: true,
			shadow: false,
		potCross: true,
			crossShape: true,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		randomOffset:true
	},
	{ name: "purpleFlower",
		Name:"Purple Flower (i don't think this exsists in minecraft)",
			solid: false,
			transparent: true,
			shadow: false,
		potCross: true,
			crossShape: true,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		hidden:true
	},
	{ name: "allium",
		Name:"Allium",
			solid: false,
			transparent: true,
			shadow: false,
		potCross: true,
			crossShape: true,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		randomOffset:true
	},
	{ name: "oxeyeDaisy",
		Name:"Oxeye Daisy",
			solid: false,
			transparent: true,
			shadow: false,
		potCross: true,
			crossShape: true,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		randomOffset:true
	},
	{ name: "lilac",
		Name:"Lilac",
			solid: false,
			transparent: true,
			shadow: false,
			tallcrossShape: true,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		randomOffset:true
	},
	{ name: "roseBush",
		Name:"Rose Bush",
			solid: false,
			transparent: true,
			shadow: false,
			tallcrossShape: true,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		randomOffset:true
	},
	{ name: "peony",
		Name:"Peony",
			solid: false,
			transparent: true,
			shadow: false,
			tallcrossShape: true,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		randomOffset:true
	},
	{ name: "witherRose",
		Name:"Wither Rose",
		solid: false,
		transparent: true,
		shadow: false,
		potCross: true,
		crossShape: true,
		serverontouch: (x,y,z,ent) => ent.applyEffect("wither",1,2,false),
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		randomOffset:true
	},
	{
		name: "TallGrass",
		Name:"Grass",
		solid: false,
		transparent: true,
		shadow: false,
		shade:false,
		crossShape: true,
		drop: "wheatSeeds",
		dropAmount:[0,1],
		dropSelfWhenSheared:true,
		shearDropAmount:1,
		compostChance:0.5,
		liquidBreakable:"drop",
		category:"nature",
		invTint:[grassColor.r,grassColor.g,grassColor.b],
		tint:grassTint,
		biomeTintNorth:true,
		biomeTintSouth:true,
		biomeTintEast:true,
		biomeTintWest:true,
		randomHeight:true,
		randomOffset:true
	},
	
	{ 
		name: "oakDoor",
		Name:"Oak Door",
		transparent: true,
		shadow: false,
		textures: "oakDoorConnected",
		door:true,
		woodSound:true,
		hardness:3,
		type:"wood",
		category:"build"
	},
	{
		name: "spruceDoor",
		Name:"Spruce Door",
		transparent: true,
		shadow: false,
		textures:"spruceDoorConnected",
		door:true,
		woodSound:true,
		hardness:3,
		type:"wood",
		category:"build"
	},
	{
		name: "ironDoor",
		Name:"Iron Door",
		transparent: true,
		shadow: false,
		textures:"ironDoorConnected",
		door:true,
		stoneSound:true,
		hardness:3,
		type:"wood",
		category:"build"
	},
	{
		name: "darkOakDoor",
		Name:"Dark Oak Door",
		transparent: true,
		shadow: false,
		textures:"darkOakDoorConnected",
		door:true,
		woodSound:true,
		hardness:3,
		type:"wood",
		category:"build"
	},
	{
		name: "birchDoor",
		Name:"Birch Door",
		transparent: true,
		shadow: false,
		textures:"birchDoorConnected",
		door:true,
		woodSound:true,
		hardness:3,
		type:"wood",
		category:"build"
	},
	{
		name: "jungleDoor",
		Name:"Jungle Door",
		transparent: true,
		shadow: false,
		textures:"jungleDoorConnected",
		door:true,
		woodSound:true,
		hardness:3,
		type:"wood",
		category:"build"
	},
	{
		name: "acaciaDoor",
		Name:"Acacia Door",
		transparent: true,
		shadow: false,
		textures:"acaciaDoorConnected",
		door:true,
		woodSound:true,
		hardness:3,
		type:"wood",
		category:"build"
	},
	{
		name: "warpedDoor",
		Name:"Warped Door",
		transparent: true,
		shadow: false,
		textures:"warpedDoorConnected",
		door:true,
		woodSound:true,
		hardness:3,
		type:"wood",
		category:"build"
	},
	{
		name: "crimsonDoor",
		Name:"Crimson Door",
		transparent: true,
		shadow: false,
		textures:"crimsonDoorConnected",
		door:true,
		woodSound:true,
		hardness:3,
		type:"wood",
		category:"build"
	},
	
	{
		name: "torch",
		Name:"Torch",
		transparent: true,
		shadow: false,
		torch: true,
		lightLevel: 13,
		woodSound:true,
		solid:false,
		category:"decoration"
	},
	{
		name: "soulTorch",
		Name:"Soul Torch",
		transparent: true,
		shadow: false,
		torch: true,
		lightLevel: 10,
		woodSound:true,
		solid:false,
		category:"decoration"
	},
	
	{
		name: "lantern",
		Name:"Lantern",
		transparent: true,
		shadow: false,
		lightLevel: 13,
		iconTexture: "lanternIcon",
		lantern: true,
		category:"decoration",
		digSound: ["lantern.dig1", "lantern.dig2", "lantern.dig3", "lantern.dig4", "lantern.dig5", "lantern.dig6"],
		placeSound: ["lantern.place1", "lantern.place2","lantern.place3","lantern.place4","lantern.place5","lantern.place6"]
	},
	{
		name: "soulLantern",
		Name:"Soul Lantern",
		transparent: true,
		shadow: false,
		lightLevel: 10,
		iconTexture:"soulLanternIcon",
		lantern: true,
		category:"decoration",
		digSound: ["lantern.dig1", "lantern.dig2", "lantern.dig3", "lantern.dig4", "lantern.dig5", "lantern.dig6"],
		placeSound: ["lantern.place1", "lantern.place2","lantern.place3","lantern.place4","lantern.place5","lantern.place6"]
	},
	
	{
		name: "beacon",
		Name:"Beacon",
		hardness:3,
		transparent: true,
		shadow: false,
		beacon: true,
		lightLevel: 15,
		glassSound: true,
		pistonPush:false,
		pistonPull:false,
		category:"decoration",
		rarity:"rare",
		tagBits:null,
		beaconBlocks:["ironBlock","goldBlock","emeraldBlock","diamondBlock","netheriteBlock"],
		getSize:function(x,y,z,world){
			let minSize
			sizeLoop:for(let size=1; size<4; size++){
				for(let x2=x-size; x2<=x+size; x2++) for(let z2=z-size; z2<=z+size; z2++){
					let block2 = world.getBlock(x2,y-size,z2)
					if(!this.beaconBlocks.includes(blockData[block2].name)) break sizeLoop
				}
				minSize = size
			}
			return minSize
		},
		update: function(x,y,z,world){
			let minSize = this.getSize(x,y,z,world), block = world.getBlock(x,y,z)
			if(minSize){
				if(block !== (this.id | BEACON)){
					world.setBlock(x,y,z,this.id|BEACON,false,false,false,true)
				}
			}else if(block !== this.id) world.setBlock(x,y,z,this.id,false,false,false,true)
			return minSize
		},
		onplace: function(x,y,z, player,world){
			this.update(x,y,z,world)
		}
	},
	
	{
		name: "cactus",
		Name:"Cactus",
		textures: ["cactusBottom", "cactusTop", "cactusSide"],
		transparent: true,
		cactus: true,
		damage: 1,
		potCross: true,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			needsSupportingBlocks(x,y,z,b,world)
		},
		compostChance:0.5,
		liquidBreakable:"drop",
		category:"nature"
	},
	
	{
		name: "glassPane",
		Name:"Glass Pane",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		pane:true,
		textures: ["glassPaneTop","glassPaneTop","glass","glass","glassPaneSide","glassPaneSide"],
		glassSound: true,
		category:"build"
	},
	
	{
		name: "ladder",
		Name:"Ladder",
		transparent: true,
		shadow: false,
		wallFlat: true,ladder:true,
		hardness:0.4,
		type:"wood",
		category:"decoration"
	},
	{
		name: "vine",
		Name:"Vine",
		transparent: true,
		shadow: false,
		wallFlat: true,ladder:true,
		drop:"air",
		dropSelfWhenSheared:true,
		shearBreakTime:0.35,
		liquidBreakable:"drop",
		solid:false,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			var fx = x, fz = z
			switch(b){
				case this.id | WALLFLAT | NORTH:
					fz++
					break
				case this.id | WALLFLAT | SOUTH:
					fz--
					break
				case this.id | WALLFLAT | EAST:
					fx++
					break
				case this.id | WALLFLAT | WEST:
					fx--
					break
			}
			var block = world.getBlock(fx,y,fz)
			var above = world.getBlock(x,y+1,z)
			if(!world.world.settings.blocksFall || block && blockData[block].solid || above === b) return
			world.setTimeout(function(){
				var block = world.getBlock(fx,y,fz)
				var above = world.getBlock(x,y+1,z)
				if(block && blockData[block].solid || above === b) return
				
				world.setBlock(x,y,z, 0)
				world.addItems(x,y,z,0,0,0,b&isCube,true)
				world.blockParticles(b,x,y,z,30, "break")
				world.blockSound(b, "dig", x,y,z)
			},tickTime,x,y,z)
		},
		
		compostChance:0.5,
		category:"nature",
		tint:leafTint,
		biomeTintTop:true,
		biomeTintBottom:true,
		biomeTintEast:true,
		biomeTintWest:true,
		biomeTintNorth:true,
		biomeTintSouth:true,
		invTint:[leafColor.r,leafColor.g,leafColor.b],
	},
	
	{
		name: "Water",
		textures:["Water","waterFlow"],
		transparent: true,
		liquid: true,
		wet:true,
		solid:false,
		shadow: false,
		cullFace:0,
		blastResistance:100,
		hidden:true,
		dripThroughBlocks:[43/255, 63/255, 213/255],
		getLevelDifference:function(level,dimension){return level-1},
		canDuplicate:true,
		drop:"air",
		density:1,
		inLiquid:1,
		flowSound:"liquid.water",
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			var block = world.getBlock(x,y+1,z)
			if (block && blockData[block].name === "Lava") {
				return world.setBlock(x,y,z,blockIds.stone,false,false,false,false)
			}
			var n = world.getBlock(x,y,z+1)
			var s = world.getBlock(x,y,z-1)
			var e = world.getBlock(x+1,y,z)
			var w = world.getBlock(x-1,y,z)
			if (n && blockData[n].name === "Lava" || s && blockData[s].name === "Lava" || e && blockData[e].name === "Lava" || w && blockData[w].name === "Lava") {
				return world.setBlock(x,y,z,blockIds.cobblestone,false,false,false,false)
			}
			if(!world.world.settings.blocksFall) return
			var me = this
			world.setTimeout(() => me.flow(x,y,z,world), tickTime*5, x,y,z)
		},
		decreaseLight:1,
		tint:waterTint,
		biomeTintTop:true,
		biomeTintBottom:true,
		biomeTintEast:true,
		biomeTintWest:true,
		biomeTintNorth:true,
		biomeTintSouth:true,
		invTint:waterColor
	},
	{
		name: "Lava",
		textures:["Lava","lavaFlow"],
		transparent: true,
		liquid: true,
		solid:false,
		lightLevel:15,
		damage:4,
		burnEnt:true,
		dieMessage: p => p.username+" tried to swim in lava.",
		shadow: false,
		blastResistance:100,
		hidden:true,
		temperature:25,
		dripThroughBlocks:[210/255, 59/255, 17/255],
		drop:"air",
		density:2,
		inLiquid:2,
		ambientSound:"liquid.lava",
		getLevelDifference:function(level,dimension){return dimension === "nether" ? level-1 : level-2},
		tick:function(x,y,z,world){
			blockData[blockIds.fire].spread(x,y,z,world)
		},
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			let block = world.getBlock(x,y+1,z)
			if (block && blockData[block].name === "Water") {
				return world.setBlock(x,y,z,blockIds.obsidian,false,false,false,false)
			}
			const under = world.getBlock(x,y-1,z)
			const n = world.getBlock(x,y,z+1)
			const s = world.getBlock(x,y,z-1)
			const e = world.getBlock(x+1,y,z)
			const w = world.getBlock(x-1,y,z)
			if(blockData[under].name === "soulSoil"){
				if (blockData[n].name === "ice" || blockData[n].name === "packedIce" || blockData[n].name === "blueIce" || blockData[s].name === "ice" || blockData[s].name === "packedIce" || blockData[s].name === "blueIce" || blockData[e].name === "ice" || blockData[e].name === "packedIce" || blockData[e].name === "blueIce" || blockData[w].name === "ice" || blockData[w].name === "packedIce" || blockData[w].name === "blueIce") {
					return world.setBlock(x,y,z,blockIds.basalt,false,false,false,false)
				}
			}
			if(blockData[under].name === "honeyBlock" || blockData[n].name === "honeyBlock" || blockData[s].name === "honeyBlock" || blockData[e].name === "honeyBlock" || blockData[w].name === "honeyBlock"){
				return world.setBlock(x,y,z,blockIds.limestone,false,false,false,false)
			}
			if(!world.world.settings.blocksFall) return
			var me = this
			world.setTimeout(() => me.flow(x,y,z,world), tickTime*(world.dimension === "nether" ? 10 : 30), x,y,z)
		},
		getY:function(x,y,z){
			var block = world.getBlock(x,y,z)
			return (min((this.getLevel(block))*2,14.5)/16)-0.5
		},
		onspawnflow:function(x,y,z,world){
			const under = world.getBlock(x,y-1,z)
			if(under === blockIds.Water){
				world.spawnBlock(x,y-1,z,blockIds.stone,true)
				return true
			}
		},
	},
	
	{
		name: "craftingTable",
		Name:"Crafting Table",
		textures: ["oakPlanks","craftingTableTop","craftingTableFront","craftingTableSide"],
		onclientclick: () => {changeScene("crafting"); releasePointer()},
		woodSound: true,
		hardness:2.5,
		type:"wood",
		category:"items"
	},
	
	{
		name: "crimsonNylium",
		Name:"Crimson Nylium",
		textures: ["netherrack", "crimsonNyliumTop", "crimsonNyliumSide"],
		nyliumSound: true,
		category:"nature",
		hardness:0.4,
		blastResistance:0.4,
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true
	},
	{
		name: "warpedNylium",
		Name:"Warped Nylium",
		textures: ["netherrack", "warpedNyliumTop", "warpedNyliumSide"],
		nyliumSound: true,
		category:"nature",
		hardness:0.4,
		blastResistance:0.4,
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true
	},
	{
		name: "crimsonStem",
		Name:"Crimson Stem",
		textures: ["crimsonStemTop", "crimsonStemSide"],
		stemSound: true,
		hardness:2,
		blastResistance:2,
		type:"wood",
		category:"nature"
	},
	{
		name: "warpedStem",
		Name:"Warped Stem",
		textures: ["warpedStemTop", "warpedStemSide"],
		stemSound: true,
		hardness:2,
		blastResistance:2,
		type:"wood",
		category:"nature"
	},
	{ name: "netherWartBlock",
		Name:"Nether Wart Block",hardness:1,compostChance:0.85,category:"nature",
		digSound: ["netherwart.dig1", "netherwart.dig2", "netherwart.dig3", "netherwart.dig4", "netherwart.dig5", "netherwart.dig6"],
		stepSound: ["netherwart.step1", "netherwart.step2","netherwart.step3","netherwart.step4","netherwart.step5"],
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{ name: "warpedWartBlock",
		Name:"Warped Wart Block",hardness:1,compostChance:0.85,category:"nature",
		digSound: ["netherwart.dig1", "netherwart.dig2", "netherwart.dig3", "netherwart.dig4", "netherwart.dig5", "netherwart.dig6"],
		stepSound: ["netherwart.step1", "netherwart.step2","netherwart.step3","netherwart.step4","netherwart.step5"],
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{ name: "shroomlight", lightLevel:15,Name:"Shroomlight",hardness:1,compostChance:0.65,category:"nature",
		digSound: ["shroomlight.dig1", "shroomlight.dig2", "shroomlight.dig3", "shroomlight.dig4", "shroomlight.dig5"],
		stepSound: ["shroomlight.step1", "shroomlight.step2","shroomlight.step3","shroomlight.step4","shroomlight.step5","shroomlight.step6"]},
	{ 
		name: "warpedFungus",
		Name:"Warped Fungus",
		solid: false,
		shadow: false,
		transparent: true,
		crossShape: true,
		potCross: true,
		compostChance:0.65,
		category:"nature",
		digSound: ["fungus.dig1", "fungus.dig2", "fungus.dig3", "fungus.dig4", "fungus.dig5", "fungus.dig6"],
		growBonemeal: function(x,y,z,world){
			win.serverSaveWorldGen()
			world.getChunk(x,z).spawnNetherMushroom(x&15,y-1,z&15,x,z,"warpedForest")
			win.serverRestoreWorldGen()
		},
		randomOffset:true,
	},
	{
		name: "blackstone",
		Name:"Blackstone",
		textures: ["blackstoneTop", "blackstone" ],
		stoneSound: true,
		category:"nature",
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
		craftSlabs:true, craftStairs:true,
	},
	{ name: "gildedBlackstone", Name:"Gilded Blackstone", category:"nature",stoneSound: true, randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true},
	{ name: "polishedBlackstoneBricks", Name:"Polished Blackstone Bricks", category:"build",stoneSound: true, craftSlabs:true, craftStairs:true},
	{ name: "chiseledPolishedBlackstone", Name:"Chiseled Polished Blackstone", category:"build",stoneSound: true},
	{
		name: "netheriteBlock",
		Name:"Netherite Block",
		type:"rock4",
		category:"build",
		hardness:50,
		blastResistance:1200,
		digSound: ["netherite.dig1", "netherite.dig2", "netherite.dig3", "netherite.dig4"],
		stepSound: ["netherite.step1", "netherite.step2","netherite.step3","netherite.step4","netherite.step5","netherite.step6"]
	},
	{
		name: "basalt",
		Name: "Basalt",
		category:"nature",
		textures: [ "basaltTop", "basaltSide" ],
		basaltSound: true,
		hardness:1.25
	},
	{
		name: "polishedBasalt",
		Name: "Polished Basalt",
		category:"build",
		textures: [ "polishedBasaltTop", "polishedBasaltSide" ],
		basaltSound: true,
		hardness:1.25
	},
	{ name: "chain", Name:"Chain", category:"build",transparent:true, shadow:false, chain:true, iconTexture:"chainIcon",
		digSound: ["chain.dig1", "chain.dig2", "chain.dig3", "chain.dig4"],
		stepSound: ["chain.step1", "chain.step2","chain.step3","chain.step4","chain.step5","chain.step6"]},
	{ name: "warpedPlanks", Name:"Warped Planks", hardness:2, type:"wood",category:"build", woodSound:true, craftSlabs:true, craftStairs:true},
	{ 
		name: "warpedTrapdoor",
		Name: "Warped Trapdoor",
		transparent: true,
		shadow: false,
		trapdoor: true,
		woodSound:true,
		category:"build"
	},
	{
		name: "magma", Name:"Magma Block", lightLevel:15,hardness:0.5, type:"rock1",
		damage:1,
		dieMessage: p => p.username+" discovered the floor was lava.",
		burnTime:Infinity,
		category:"nature",
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name: "crimsonFungus",
		Name: "Crimson Fungus",
		solid: false,
		shadow: false,
		transparent: true,
		crossShape: true,
		potCross: true,
		compostChance:0.65,
		category:"nature",
		digSound: ["fungus.dig1", "fungus.dig2", "fungus.dig3", "fungus.dig4", "fungus.dig5", "fungus.dig6"],
		growBonemeal: function(x,y,z,world){
			win.serverSaveWorldGen()
			world.getChunk(x,z).spawnNetherMushroom(x&15,y-1,z&15,x,z,"crimsonForest")
			win.serverRestoreWorldGen()
		},
		randomOffset:true,
	},
	{ 
		name: "warpedRoots",
		Name: "Warped Roots",
		transparent: true,
		solid: false,
		shadow: false,
		crossShape: true,
		rootSound: true,
		compostChance:0.65,
		category:"nature",
		potCross:true,
		potCrossTexture:"warpedRootsPot",
		randomOffset:true,
	},
	{ 
		name: "crimsonRoots",
		Name: "Crimson Roots",
		transparent: true,
		solid: false,
		shadow: false,
		crossShape: true,
		rootSound: true,
		compostChance:0.65,
		category:"nature",
		potCross:true,
		potCrossTexture:"crimsonRootsPot",
		randomOffset:true,
	},
	{ 
		name: "twistingVines",
		transparent: true,
		solid: false,
		shadow: false,
		transparent: true,
		crossShape: true,
		ladder:true,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			var top = world.getBlock(x,y+1,z)
			var isIt = blockData[top].name === "twistingVines" || blockData[top].name === "twistingVinesPlant"
			if(isIt){
				world.setBlock(x,y,z,blockIds.twistingVinesPlant | CROSS,false,false,false,false)
			}
		},
		hidden:true,
		drop:"twistinVinesPlant"
	},
	{
		name: "twistingVinesPlant",
		Name: "Twisting Vines",
		transparent: true,
		solid: false,
		shadow: false,
		transparent: true,
		crossShape: true,
		ladder:true,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			var top = world.getBlock(x,y+1,z)
			var isIt = blockData[top].name === "twistingVines" || blockData[top].name === "twistingVinesPlant"
			if(!isIt){
				world.setBlock(x,y,z,blockIds.twistingVines | CROSS,false,false,false,false)
			}
		},
		category:"nature",
	},
	{
		name: "weepingVines",
		transparent: true,
		solid: false,
		shadow: false,
		crossShape: true,
		ladder:true,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			var top = world.getBlock(x,y-1,z)
			var isIt = blockData[top].name === "weepingVines" || blockData[top].name === "weepingVinesPlant"
			if(isIt){
				world.setBlock(x,y,z,blockIds.weepingVinesPlant | CROSS,false,false,false,false)
			}
		},
		hidden:true,
		drop:"weepingVinesPlant"
	},
	{
		name: "weepingVinesPlant",
		Name:"Weeping Vines",
		transparent: true,
		solid: false,
		shadow: false,
		crossShape: true,
		ladder:true,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			var top = world.getBlock(x,y-1,z)
			var isIt = blockData[top].name === "weepingVines" || blockData[top].name === "weepingVinesPlant"
			if(!isIt){
				world.setBlock(x,y,z,blockIds.weepingVines | CROSS,false,false,false,false)
			}
		},
		category:"nature"
	},
	{ 
		name: "netherSprouts",
		Name: "Nether Sprouts",
		solid: false,
		shadow: false,
		transparent: true,
		crossShape: true,
		compostChance:0.5,
		category:"nature",
		digSound: ["nether_sprouts.dig1", "nether_sprouts.dig2", "nether_sprouts.dig3", "nether_sprouts.dig4"],
		stepSound: ["nether_sprouts.step1", "nether_sprouts.step2","nether_sprouts.step3","nether_sprouts.step4","nether_sprouts.step5"],
		randomOffset:true,
	},
	
	{ name: "stoneButton", Name:"Stone Button", textures:"stone", category:"redstone",button:true, transparent: true, shadow:false, stone:true },
	
	{ 
		name: "RespawnAnchorOff",
		category:"items",
		textures: ["respawnAnchorBottom", "respawnAnchorTopOff", "respawnAnchorSide0"],
		//onupdate: (x,y,z) => {if(world.type !== "nether"){explode(x,y,z,2)}}
	},
	{ 
		name: "RespawnAnchor1",
		textures: ["respawnAnchorBottom", "respawnAnchorTop1", "respawnAnchorSide1"],
		hidden: true
	},
	{ 
		name: "RespawnAnchor2",
		textures: ["respawnAnchorBottom", "respawnAnchorTop2", "respawnAnchorSide2"],
		hidden: true
	},
	{ 
		name: "RespawnAnchor3",
		textures: ["respawnAnchorBottom", "respawnAnchorTop3", "respawnAnchorSide3"],
		hidden: true
	},
	{ 
		name: "RespawnAnchor",
		textures: ["respawnAnchorBottom", "respawnAnchorTop", "respawnAnchorSide4"],
		hidden: true
	},
	
	{
		name:"redBed",
		Name:"Red Bed",
		textures: "redBed",
		iconTexture: "redBedIcon",
		flatIcon: true,
		transparent: true,
		bed: true,
		bounciness: 0.6,
		category:"items"
	},
	
	{
		name: "flintAndSteel",
		Name:"Flint & Steel",
		textures: "flintAndSteel",
		item: true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			if(block === blockIds.tnt){
				blockData[blockIds.tnt].explode(x,y,z,null,world)
				item.durability--
			}else if(block === (blockIds.tnt | SLAB)){
				blockData[blockIds.tnt].superTntExplode(x,y,z,world)
				item.durability--
			}else if(block === (blockIds.tnt | STAIR)){
				blockData[blockIds.tnt].ultraTntExplode(x,y,z,world)
				item.durability--
			}else if(block === blockIds.untnt){
				blockData[blockIds.untnt].explode(x,y,z,null,world)
				item.durability--
			}else{
				var attached = world.getBlock(x,y,z)
				var b = blockIds.fire
				if(attached && blockData[attached].canHaveSoulFire) b = blockIds.soulFire
				;([x,y,z] = movePositionByFace(face,x,y,z))
				switch(face){
					case "bottom": b |= STAIR; break
					case "north": b |= SLAB | SOUTH; break
					case "south": b |= SLAB | NORTH; break
					case "east": b |= SLAB | WEST; break
					case "west": b |= SLAB | EAST; break
				}
				item.durability--
				if(block === blockIds.obsidian && blockData[blockIds.fire].tryCreatePortal(x,y,z,world)) return
				world.setBlock(x,y,z,b,false,false,false,false)
				world.playSound(x,y,z, "fire.ignite")
			}
		},
		durability:64,
		stackSize:1,
		category:"items"
	},
	
	{
		name: "barrier",
		Name:"That Invisible Block with a 🚫 Icon",
		textures: "none",
		iconTexture: "barrier",
		flatIcon:true,
		transparent:true,
		hardness:Infinity,
		pistonPush:false,
		pistonPull:false,
		category:"items",
		rarity:"epic"
	},
	{
		name: "oakSapling",
		Name:"Oak Sapling",
		crossShape: true,
		potCross: true,
		transparent: true,
		solid: false,
		shadow:false,
		liquidBreakable:"drop",
		grow: function(x,y,z,world){
			win.serverSaveWorldGen()
			world.getChunk(x,z).spawnSmallTree(x&15,y-1,z&15,x,z,false)
			win.serverRestoreWorldGen()
		},
		compostChance:0.3,
		category:"nature"
	},
	
	{ 
		name: "crimsonTrapdoor",
		Name:"Crimson Trapdoor",
		transparent: true,
		trapdoor: true,
		woodSound: true,
		category:"build"
	},
	{ 
		name: "oakTrapdoor",
		Name:"Oak Trapdoor",
		transparent: true,
		trapdoor: true,
		woodSound: true,
		category:"build"
	},
	{ 
		name: "spruceTrapdoor",
		Name:"Spruce Trapdoor",
		transparent: true,
		trapdoor: true,
		woodSound: true,
		category:"build"
	},
	{ 
		name: "darkOakTrapdoor",
		Name:"Dark Oak Trapdoor",
		transparent: true,
		trapdoor: true,
		woodSound: true,
		category:"build"
	},
	{ 
		name: "birchTrapdoor",
		Name:"Birck Trapdoor",
		transparent: true,
		trapdoor: true,
		woodSound: true,
		category:"build"
	},
	{ 
		name: "jungleTrapdoor",
		Name:"Jungle Trapdoor",
		transparent: true,
		trapdoor: true,
		woodSound: true,
		category:"build"
	},
	{ 
		name: "acaciaTrapdoor",
		Name:"Acaica Trapdoor",
		transparent: true,
		trapdoor: true,
		woodSound: true,
		category:"build"
	},
	{ 
		name: "ironTrapdoor",
		Name:"Iron Trapdoor",
		transparent: true,
		trapdoor: true,
		stoneSound: true,
		category:"build"
	},
	
	{ 
		name: "cryingObsidian",
		Name:"Obsidian: 😢",
		shadow: false,
		lightLevel: 10,
		stoneSound:true,
		type:"rock4",
		hardness:50,
		blastResistance:1200,
		pistonPush:false,
		pistonPull:false,
		drip:[106/255, 6/255, 187/255],
		category:"nature",
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{ name: "netherGoldOre",
		Name:"Nether Gold Ore",
		digSound: ["nether_ore.dig1", "nether_ore.dig2", "nether_ore.dig3", "nether_ore.dig4"],
		stepSound: ["nether_ore.step1", "nether_ore.step2","nether_ore.step3","nether_ore.step4","nether_ore.step5"],
		drop: "goldNugget",
		dropAmount: [1,3],
		category:"nature",
		hardness:3,
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name: "flowerPot",
		Name:"Flower Pot",
		transparent: true,
		shadow: false,
		pot: true,
		iconTexture:"flowerPotIcon",
		flatIcon:true,
		category:"decoration",
		liquidBreakable:"drop"
	},
	{
		name: "acaciaSapling",
		Name:"Acacia Sapling",
		transparent: true,
		shadow: false,
		solid: false,
		crossShape: true,
		potCross: true,
		compostChance:0.3,
		category:"nature",
		liquidBreakable:"drop",
		grow: function(x,y,z,world){
			win.serverSaveWorldGen()
			world.getChunk(x,z).spawnAcacia(x&15,y-1,z&15,x,z,true)
			win.serverRestoreWorldGen()
		},
	},
	{
		name: "birchSapling",
		Name:"Birch Sapling",
		transparent: true,
		shadow: false,
		solid: false,
		crossShape: true,
		potCross: true,
		category:"nature",
		liquidBreakable:"drop",
		grow: function(x,y,z,world){
			win.serverSaveWorldGen()
			world.getChunk(x,z).spawnSmallTree(x&15,y-1,z&15,x,z,true)
			win.serverRestoreWorldGen()
		},
		compostChance:0.3
	},
	{
		name: "darkOakSapling",
		Name:"Dark Oak Sapling",
		transparent: true,
		shadow: false,
		solid: false,
		crossShape: true,
		potCross: true,
		compostChance:0.3,
		category:"nature",
		liquidBreakable:"drop"
	},
	{
		name: "jungleSapling",
		Name:"Jungle Sapling",
		transparent: true,
		shadow: false,
		solid: false,
		crossShape: true,
		potCross: true,
		compostChance:0.3,
		category:"nature",
		liquidBreakable:"drop",
		grow: function(x,y,z,world){
			win.serverSaveWorldGen()
			world.getChunk(x,z).spawnCocoaTree(x&15,y-1,z&15,x,z,true)
			win.serverRestoreWorldGen()
		}
	},
	{
		name: "spruceSapling",
		Name:"Spruce Sapling",
		transparent: true,
		shadow: false,
		solid: false,
		crossShape: true,
		potCross: true,
		compostChance:0.3,
		category:"nature",
		liquidBreakable:"drop",
		grow: function(x,y,z,world){
			win.serverSaveWorldGen()
			world.getChunk(x,z).spawnSpruce(x&15,y-1,z&15,x,z,true)
			win.serverRestoreWorldGen()
		}
	},
	{
		name: "unused_blueOrchidPot",
		textures:"error",
		transparent: true,
		shadow: false,
		solid: false,
		potCross: true,
		hidden:true
	},
	{
		name: "unused_warpedRoots",
		textures:"error",
		transparent: true,
		shadow: false,
		solid: false,
		potCross: true,
		hidden:true,
		drop:"warpedRoots",
		liquidBreakable:"drop"
	},
	{
		name: "unused_crimsonRoots",
		textures:"error",
		transparent: true,
		shadow: false,
		solid: false,
		potCross: true,
		hidden:true,
		drop:"crimsonRoots",
		liquidBreakable:"drop"
	},
	{ name: "whiteCarpet", Name: "White Carpet", textures: "whiteWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
	{ name: "orangeCarpet", Name: "Orange Carpet", textures: "orangeWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
	{ name: "magentaCarpet", Name: "Magenta Carpet", textures: "magentaWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
	{ name: "lightBlueCarpet", Name: "Light Blue Carpet", textures: "lightBlueWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
	{ name: "yellowCarpet", Name: "Yellow Carpet", textures: "yellowWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
	{ name: "limeCarpet", Name: "Lime Carpet", textures: "limeWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
	{ name: "pinkCarpet", Name: "Pink Carpet", textures: "pinkWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
	{ name: "grayCarpet", Name: "Gray Carpet", textures: "grayWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
	{ name: "lightGrayCarpet", Name: "Light Gray Carpet", textures: "lightGrayWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
	{ name: "cyanCarpet", Name: "Cyan Carpet", textures: "cyanWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
	{ name: "purpleCarpet", Name: "Purple Carpet", textures: "purpleWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
	{ name: "blueCarpet", Name: "Blue Carpet", textures: "blueWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
	{ name: "brownCarpet", Name: "Brown Carpet", textures: "brownWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
	{ name: "greenCarpet", Name: "Green Carpet", textures: "greenWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
	{ name: "redCarpet", Name: "Red Carpet", textures: "redWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
	{ name: "blackCarpet", Name: "Black Carpet", textures: "blackWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
	
	{ name: "polishedBlackstone", Name: "Polished Blackstone", category:"build",stoneSound:true, craftSlabs:true, craftStairs:true},
	{ name: "chiseledNetherBricks",
		Name: "Chiseled Nether Bricks",
		category:"build",
		digSound: ["nether_bricks.dig1", "nether_bricks.dig2", "nether_bricks.dig3", "nether_bricks.dig4", "nether_bricks.dig5", "nether_bricks.dig6"],
		stepSound: ["nether_bricks.step1", "nether_bricks.step2","nether_bricks.step3","nether_bricks.step4","nether_bricks.step5","nether_bricks.step6"]},
	{ name: "crackedNetherBricks",
		Name:"Cracked Nether Bricks",
		category:"build",
		digSound: ["nether_bricks.dig1", "nether_bricks.dig2", "nether_bricks.dig3", "nether_bricks.dig4", "nether_bricks.dig5", "nether_bricks.dig6"],
		stepSound: ["nether_bricks.step1", "nether_bricks.step2","nether_bricks.step3","nether_bricks.step4","nether_bricks.step5","nether_bricks.step6"]},
	{ name: "smoothBasalt", Name: "Smooth Basalt", basaltSound: true},
	
	{
		name: "oakLogSW",
		textures: ["logSide","logSide","logTop","logSide"],
		SW: true, woodSound:true, hidden:true
	},
	{
		name: "acaciaLogSW",
		textures: ["acaciaLogSide","acaciaLogSide","acaciaLogTop","acaciaLogSide"],
		SW: true, woodSound:true, hidden:true
	},
	{
		name: "birchLogSW",
		textures: ["birchLogSide","birchLogSide","birchLogTop","birchLogSide"],
		SW: true, woodSound:true, hidden:true
	},
	{
		name: "darkOakLogSW",
		textures: ["darkOakLogSide","darkOakLogSide","darkOakLogTop","darkOakLogSide"],
		SW: true, woodSound:true, hidden:true
	},
	{
		name: "jungleLogSW",
		textures: ["jungleLogSide","jungleLogSide","jungleLogTop","jungleLogSide"],
		SW: true, woodSound:true, hidden:true
	},
	{
		name: "spruceLogSW",
		textures: ["spruceLogSide","spruceLogSide","spruceLogTop","spruceLogSide"],
		SW: true, woodSound:true, hidden:true
	},
	{
		name: "crimsonStemSW",
		textures: ["crimsonStemSide","crimsonStemSide","crimsonStemTop","crimsonStemSide"],
		SW: true, stemSound:true, hidden:true
	},
	{
		name: "warpedStemSW",
		textures: ["warpedStemSide","warpedStemSide","warpedStemTop","warpedStemSide"],
		SW: true, stemSound:true, hidden:true
	},
	{
		name: "basaltSW",
		textures: ["basaltSide","basaltSide","basaltTop","basaltSide"],
		SW: true, basaltSound:true, hidden:true
	},
	{
		name: "polishedBasaltSW",
		textures: ["polishedBasaltSide","polishedBasaltSide","polishedBasaltTop","polishedBasaltSide"],
		SW: true, basaltSound: true, hidden:true
	},
	{ name:"crimsonPlanks", Name: "Crimson Planks", woodSound:true, hardness:2, type:"wood",category:"build", craftSlabs:true, craftStairs:true },
	{
		name:"deadBush",
		Name:"Dead Bush",
		solid: false,
		transparent: true,
		shadow: false,
		potCross: true,
		crossShape: true,
		drop: "stick",
		dropAmount: [0,2],
		dropSelfWhenSheared:true,
		shearDropAmount:1,
		liquidBreakable:"drop",
		category:"nature",
		randomOffset:true
	},
	{ name:"stick", Name:"Stick", category:"items",item:true },
	{ name:"coal", Name:"Coal", category:"items",item:true },
	{ name:"ironIngot", Name:"Iron Ingot", category:"items",item:true },
	{ name:"copperIngot", Name:"Copper Ingot", category:"items",item:true },
	{ name:"goldIngot", Name:"Gold Ingot", category:"items",item:true },
	{ name:"diamond", Name:"Diamond", category:"items",item:true },
	{ name:"lapisLazuli", Name:"Lapis Lazuli", category:"items",item:true },
	{ name:"emerald", Name:"Emerald", category:"items",item:true },
	{ name:"copperOre", Name:"Copper Ore", hardness:3, drop:"rawCopper", dropAmount:[2,5], type:"rock2",category:"nature", stoneSound:true },
	{ name:"rawIron", Name:"Raw Iron", category:"items",item:true },
	{ name:"rawCopper", Name:"Raw Copper", category:"items",item:true },
	{ name:"rawGold", Name:"Raw Gold", category:"items",item:true },
	
	{
		name: "netherWart",
		Name:"Nether Wart",
		transparent: true,
		shadow: false,
		solid: false,
		crop: true,
		flatIcon:true,
		iconTexture:"netherWartIcon",
		compostChance:0.65,
		category:"nature",
	},
	{
		name: "wheat",
		Name:"Wheat",
		transparent: true,
		shadow: false,
		solid: false,
		crop: true,
		flatIcon:true,
		iconTexture:"wheatIcon",
		fullDrop:["wheat","wheatSeeds"],
		drop:"wheatSeeds",
		liquidBreakable:"drop",
		textures:new Array(6).fill('wheatStage0'),
		textures1:new Array(6).fill('wheatStage1'),
		textures2:new Array(6).fill('wheatStage2'),
		textures3:new Array(6).fill('wheatStage3'),
		textures4:new Array(6).fill('wheatStage4'),
		textures5:new Array(6).fill('wheatStage5'),
		textures6:new Array(6).fill('wheatStage6'),
		textures7:new Array(6).fill('wheat'),
		compostChance:0.65,
		category:"nature",
		growBonemeal:function(x,y,z,world){
			world.setBlock(x,y,z, this.id|LANTERN)
		}
	},
	{
		name: "lodestone",
		Name:"Lodestone",
		textures: ["lodestoneTop", "lodestoneSide"]
	},
	{
		name: "anvil",
		Name:"Anvil",
		transparent: true,
		anvil: true,
		digSound: "anvil.land",
		stepSound: ["stone.step1", "stone.step2","stone.step3","stone.step4","stone.step5","stone.step6"],
		onclientclick:function(x,y,z,dimension){
			changeScene("anvil")
			releasePointer()
		},
		onupdate: function(x,y,z,b,world,sx,sy,sz){
			fall(x,y,z,b,world,false)
		},
		ongetexploded:function(x,y,z,b,world){
			fall(x,y,z,b,world,true)
		},
		category:"items",
	},
	
	{
		name: "slimeBlock",
		Name:"Slime Block",
		transparent: true,
		shadow: false,
		bounciness: 1,
		speedFactor: 0.5,
		shapeName:"slimeBlock",
		category:"build",
		sticky:true,
		damageResistance:1,
	},
	{ 
		name:"soulSoil",
		Name:"Soul Soil",
		speedFactor: 0.5,
		canHaveSoulFire: true,
		category:"nature",
	},
	{ name:"blueIce", Name:"Blue Ice", category:"nature",slide:0.9, glassSound: true, temperature:3},
	{ name:"ice", Name:"Ice", category:"nature",transparent:true, shadow:false, slide:0.9, glassSound: true, temperature:3},
	{ name:"packedIce", Name:"Packed Ice", category:"nature",slide:0.9, glassSound: true, temperature:3},
	{ name:"calcite", Name:"Calcite", category:"nature" },
	{
		name:"furnace",
		Name:"Furnace",
		textures: ["furnaceTop","furnaceTop","furnaceSide","furnaceFront","furnaceSide","furnaceSide"],
		rotate: true,
		tagBits: null,
		hasContents:function(tags){return tags&&tags.furnace},
		setContents: function(x,y,z,world){
			var data = {furnace:true, input:0, fuel:0, output:0, smeltStart:0, burnStart:0, canBurn:false, smelting:false, xp:0}
			world.setTags(x, y, z, data,false)
			return data
		},
		update:function(x,y,z,world){
			let data = world.getTags(x,y,z)
			if(!data) return
			let prevSmelting = data.smelting
			data.smelting = false
			let smeltTo, fuel
			if(data.input && data.fuel){
				smeltTo = smelts[data.input.id]
				fuel = smeltFuel[data.fuel.id]
				if(!fuel){
					for(let i in smeltFuel){
						if(checkCraftType(parseInt(i) || i,data.fuel.id)){
							fuel = smeltFuel[i]
							break
						}
					}
				}
				if(!smeltTo){
					for(let i in smelts){
						if(checkCraftType(parseInt(i) || i,data.input.id)){
							smeltTo = smelts[i]
							break
						}
					}
				}
				if(smeltTo && fuel) data.smelting = true
			}
			if(data.smelting){
				if(!prevSmelting){
					data.smeltStart = Date.now()
      		data.burnStart = Date.now()
				}
				var seconds = (Date.now() - data.smeltStart) / 1000
				var progress = seconds * 20 //ticks
				var burnProgress = (Date.now() - data.burnStart) / 1000
				data.progress = progress / smeltTo.time
				data.burnProgress = 1-(burnProgress / fuel.time)
				if(progress >= smeltTo.time){
					var a = floor(progress/smeltTo.time)
					for(var i=0; i<a; i++){
						data.input.amount --
						data.xp += smeltTo.xp
						if(data.output){
							data.output.amount ++
						}else{
							data.output = {id:smeltTo.id, amount:1}
						}
						if(data.input.amount <= 0){
							data.input = 0
							break
						}
					}
					data.smeltStart += (a/20)*smeltTo.time*1000
					world.updateTags(x,y,z)
				}
				if(burnProgress >= fuel.time){
					data.canBurn = false
				}
				if(!data.canBurn){
					var a = floor(burnProgress/fuel.time)
					for(var i=0; i<a; i++){
						data.fuel.amount --
						if(data.fuel.amount === 0){
							data.fuel = 0
							break
						}
					}
					world.updateTags(x,y,z)
					data.burnStart += a*fuel.time*1000
					data.canBurn = true
				}
			}
			if(!data.smelting){
				if((!data.fuel || !data.fuel.id) && data.burnProgress) data.burnProgress = 0
				if((!data.input || !data.input.id) && data.progress) data.progress = 0
			}
			
			var block = world.getBlock(x,y,z)
			var needs = blockIds.furnace | (block & ROTATION)
			if(data.smelting){
				needs |= SLAB
			}
			if(block !== needs){
				world.setBlock(x,y,z, needs, false, false, false, true)//last argument is keepTags
			}
		},
		tick:function(block,x,y,z,world){
			this.update(x,y,z,world)
		},
		stoneSound:true,
		category:"items",
	},
	{
		name:"blastFurnace",
		Name:"Blast Furnace",
		textures: ["blastFurnaceTop","blastFurnaceTop","blastFurnaceSide","blastFurnaceFront","blastFurnaceSide","blastFurnaceSide"],
		rotate: true,
		category:"items",
	},
	{
		name:"smoker",
		Name:"Smoker",
		textures: ["smokerBottom","smokerTop","smokerSide","smokerFront","smokerSide","smokerSide"],
		rotate: true,
		category:"items",
	},
	{
		name:"noteBlock",
		Name:"Note Block",
		tagBits:{
			on:[0,1],
			note:[1,5]
		},
		onclick:function(x,y,z,world){
			var note = world.getTagByName(x,y,z,"note")
			if(!note && note !== 0) note = -1
			note ++
			if(note >= 24) note = 0
			world.setTagByName(x,y,z,"note",note,false)
			blockData[blockIds.noteBlock].playNote(x,y,z,world)
		},
		onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,world){
			var power = world.getRedstonePower(x,y,z) || world.getSurroundingBlockPower(x,y,z) ? true : false
			var on = world.getTagByName(x,y,z,"on") || false
			if(power !== on) {
				world.setTagByName(x,y,z,"on",power,false)
				if(power){
					this.playNote(x,y,z,world)
				}
			}
		},
		playNote:function(x,y,z,world){
			var note = world.getTagByName(x,y,z,"note") || 0
			if(!note && note !== 0) return
			var pitch = 2**((note-12)/12)
			var instrument = "harp"
			var block = world.getBlock(x,y-1,z)
			if(block && this.noteTypes[blockData[block].name]) instrument = this.noteTypes[blockData[block].name]
			if(block){
				for(var i in this.noteTypes){
					if(i.startsWith("type:") && i.replace("type:","") === blockData[block].type){
						instrument = this.noteTypes[i]
					}
				}
			}
			world.playSound(x,y,z, "note."+instrument, 1, pitch)
			
			world.sendAll({
				type:"particles", particleType:"NoteParticle",
				x,y:y+0.5,z, dimension:world.dimension, data:note
			})
		},
		noteTypes:(function(obj){
			var obj2 = {}
			for(var i in obj){
				if(typeof obj[i] === "string"){
					obj2[obj[i]] = i
				}else{
					for(var i2 of obj[i]){
						obj2[i2] = i
					}
				}
			}
			return obj2
		})({
			bass:"type:wood",
			snare:["sand","gravel"],
			hat:["glass","seaLantern","beacon"],
			bd: ['type:rock1', 'type:rock2', 'type:rock3'],
			bell: "goldBlock",
			flute: ["clay", "honeycombBlock"],
			icechime: ["packedIce"],
			guitar: "type:wool",
			xylobone: ["boneBlock","boneBlockSW"],
			iron_xylophone: ["ironBlock"],
			cow_bell: "soulSand",
			didgeridoo: "pumpkin",
			bit: "emeraldBlock",
			banjo: ["hayBlock", "hayBlockSW"],
			pling: "glowstone"
		}),
		category:"redstone",
	},
	{
		name:"jukebox",
		Name:"Jukebox",
		textures: ["jukeboxTop","jukeboxSide"],
		category:"items"
	},
	{
		name:"loom",
		Name:"Loom",
		textures: ["loomBottom","loomTop","loomFront","loomSide","loomSide","loomSide"],
		rotate: true,
		category:"items"
	},
	
	{
		name:"sandstone",
		Name:"Sandstone",
		textures: ["sandstoneBottom", "sandstoneTop", "sandstone"],
		category:"nature",
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
		craftSlabs:true, craftStairs:true
	},
	{ name:"chiseledSandstone",
		Name:"Chiseled Sandstone",
		textures: ["sandstoneBottom", "sandstoneTop","chiseledSandstone"],
		category:"build",
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true
	},
	{ name:"cutSandstone",
		Name:"Cut Sandstone",
		textures: ["sandstoneBottom", "sandstoneTop","cutSandstone"],
		category:"build",
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
		craftSlabs:true, craftStairs:true
	},
	{ name:"smoothSandstone", Name:"Smooth Sandstone", textures:"sandstoneTop", category:"nature",randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true },
	{
		name: "DoubleTallGrass",
		Name:"Tall Grass",
		solid: false,
		transparent: true,
		shadow: false,
		textures: "tallGrassConnected",
		tallcrossShape: true,
		drop:function(){
			var r = rand()
			if(r > 0.9){
				return "tomatoSeeds"
			}else if(r > 0.8){
				return "corn"
			}else if(r > 0.5){
				return "wheatSeeds"
			}
		},
		compostChance:0.3,
		liquidBreakable:"drop",
		category:"nature",
		invTint:[grassColor.r,grassColor.g,grassColor.b],
		tint:grassTint,
		biomeTintNorth:true,
		biomeTintSouth:true,
		biomeTintEast:true,
		biomeTintWest:true,
		randomOffset:true,
	},
	{
		name:"apple",
		Name:"Apple",
		item:true,
		edible: true,
		eatWhenFull: false,
		food: 4,
		saturation: 2.4,
		eatResult: "appleCore",
		compostChance:0.65,
		category:"food",
	},
	
	{
		name:"woodenPickaxe",
		Name:"Wooden Pickaxe",
		item: true,
		pickaxe: true,
		mineSpeed: 2,
		durability: 59,
		attackDamage: 2,
		category:"tools",
	},
	{
		name:"stonePickaxe",
		Name:"Stone Pickaxe",
		item: true,
		pickaxe: true,
		mineSpeed: 4,
		durability: 131,
		attackDamage: 2,
		material:"cobblestone",
		category:"tools",
	},
	{
		name:"ironPickaxe",
		Name:"Iron Pickaxe",
		item: true,
		pickaxe: true,
		mineSpeed: 6,
		durability: 250,
		attackDamage: 3,
		material:"ironIngot",
		category:"tools",
	},
	{
		name:"goldenPickaxe",
		Name:"Golden Pickaxe",
		item: true,
		pickaxe: true,
		mineSpeed: 12,
		durability: 32,
		attackDamage: 4,
		material:"goldIngot",
		category:"tools",
	},
	{
		name:"diamondPickaxe",
		Name:"Diamond Pickaxe",
		item: true,
		pickaxe: true,
		mineSpeed: 8,
		durability: 1561,
		attackDamage: 5,
		material:"diamond",
		category:"tools",
	},
	{ name:"flint", Name:"Flint", item:true, category:"items" },
	{
		name:"mossBlock",
		Name: "Moss Block",
		hardness:0.1,
		type: "plant2",
		compostChance:0.65,
		category:"nature"
	},
	{
		name:"mossCarpet",
		Name: "Moss Carpet",
		textures: "mossBlock",
		hardness:0.1,
		carpet: true,
		compostChance:0.3,
		liquidBreakable:"drop",
		category:"nature"
	},
	{
		name: "caveVines",
		Name:"Cave Vines",
		solid: false,
		transparent: true,
		shadow: false,
		crossShape: true,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			var top = world.getBlock(x,y-1,z)
			var isIt = blockData[top].name === "caveVines" || blockData[top].name === "caveVinesPlant" || blockData[top].name === "caveVinesLit" || blockData[top].name === "caveVinesPlantLit"
			if(isIt){
				world.setBlock(x,y,z,blockIds.caveVinesPlant | CROSS,false,false,false,false)
			}
		},
		liquidBreakable:"drop",
		category:"nature"
	},
	{
		name: "caveVinesPlant",
		solid: false,
		transparent: true,
		shadow: false,
		crossShape: true,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			var top = world.getBlock(x,y-1,z)
			var isIt = blockData[top].name === "caveVines" || blockData[top].name === "caveVinesPlant" || blockData[top].name === "caveVinesLit" || blockData[top].name === "caveVinesPlantLit"
			if(!isIt){
				world.setBlock(x,y,z,blockIds.caveVines | CROSS,false,false,false,false)
			}
		},
		hidden:true,
		drop:"caveVines",
		liquidBreakable:"drop"
	},
	{
		name: "caveVinesLit",
		Name: "Cave Vines With Glow Berries",
		solid: false,
		transparent: true,
		shadow: false,
		crossShape: true,
		lightLevel: 14,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			var top = world.getBlock(x,y-1,z)
			var isIt = blockData[top].name === "caveVines" || blockData[top].name === "caveVinesPlant" || blockData[top].name === "caveVinesLit" || blockData[top].name === "caveVinesPlantLit"
			if(isIt){
				world.setBlock(x,y,z,blockIds.caveVinesPlantLit | CROSS,false,false,false,false)
			}
		},
		liquidBreakable:"drop",
		category:"nature"
	},
	{
		name: "caveVinesPlantLit",
		solid: false,
		transparent: true,
		shadow: false,
		crossShape: true,
		lightLevel: 14,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			var top = world.getBlock(x,y-1,z)
			var isIt = blockData[top].name === "caveVines" || blockData[top].name === "caveVinesPlant" || blockData[top].name === "caveVinesLit" || blockData[top].name === "caveVinesPlantLit"
			if(!isIt){
				world.setBlock(x,y,z,blockIds.caveVinesLit | CROSS,false,false,false,false)
			}
		},
		hidden:true,
		liquidBreakable:"drop"
	},
	
	{
		name:"sporeBlossom",
		Name:"Spore Blossom",
		sporeBlossom: true,
		shadow:false,
		transparent: true,
		compostChance:0.65,
		category:"nature"
	},
	{
		name: "rootedDirt",
		Name: "Rooted Dirt",
		category:"nature",
		type:"ground",
		hardness:0.5, blastResistance:0.5,
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true,
		digSound: ["dirt.dig1", "dirt.dig2", "dirt.dig3", "dirt.dig4"],
		stepSound: ["dirt.step1", "dirt.step2","dirt.step3","dirt.step4"]
	},
	{
		name: "hangingRoots",
		Name: "Hanging Roots",
		solid: false,
		transparent: true,
		shadow: false,
		crossShape: true,
		compostChance:0.3,
		liquidBreakable:"drop",
		category:"nature",
		randomOffset:true
	},
	{
		name:"azalea",
		Name:"Azalea",
		textures: ["azaleaTop", "azaleaSide"],
		potTex:["pottedAzaleaBushTop","pottedAzaleaBushSide"],
		azalea: true,
		transparent: true,
		potCross:true,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature"
	},
	{
		name:"floweringAzalea",
		Name:"Flowering Azalea",
		textures: ["floweringAzaleaTop","floweringAzaleaSide"],
		potTex:["pottedFloweringAzaleaBushTop","pottedFloweringAzaleaBushSide"],
		azalea: true,
		transparent: true,
		potCross:true,
		compostChance:0.85,
		liquidBreakable:"drop",
		category:"nature",
		lightLevel:10//make lush caves brighter
	},
	
	{
		name:"sunflower",
		Name:"Sunflower",
		textures:["sunflowerBack","sunflowerFront","sunflowerConnected"],
		sunflower: true,
		transparent:true,
		shadow:false,
		iconTexture: "sunflowerFront",
		solid:false,
		category:"nature"
	},
	
	{
		name: "bucket",
		Name:"Bucket",
		item: true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			if(block === blockIds.Water){
				item.id = blockIds.waterBucket
				world.setBlock(x,y,z,0)
			}
			if(block === blockIds.Lava){
				item.id = blockIds.lavaBucket
				world.setBlock(x,y,z,0)
			}
			if(block === blockIds.powderSnow){
				item.id = blockIds.powderSnowBucket
				world.setBlock(x,y,z,0)
			}
			if(block === blockIds.oil){
				item.id = blockIds.oilBucket
				world.setBlock(x,y,z,0)
			}
		},
		stackSize: 1,
		allHitbox: true,
		category:"items"
	},
	{
		name: "waterBucket",
		Name:"Water Bucket",
		item: true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			if(p.survival) item.id = blockIds.bucket
			let pos = movePositionByFace(face,x,y,z)
			world.setBlock(pos[0],pos[1],pos[2],blockIds.Water)
		},
		stackSize: 1,
		category:"items"
	},
	{
		name: "lavaBucket",
		Name:"Lava Bucket",
		item: true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			if(p.survival) item.id = blockIds.bucket
			let pos = movePositionByFace(face,x,y,z)
			world.setBlock(pos[0],pos[1],pos[2],blockIds.Lava)
		},
		stackSize: 1,
		category:"items"
	},
	
	{
		name: "spawnCow",
		item: true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			let pos = movePositionByFace(face,x,y,z)
			let ent = new entities[entityIds.Cow](pos[0],pos[1],pos[2])
			if(item.customName) ent.name = item.customName
			world.addEntity(ent)
			item.amount--
		},
		spawnMob: function(x,y,z,world){
			world.addEntity(new entities[entityIds.Cow](x,y,z),false)
		},
		category:"items"
	},
	
	{
		name:"sugarCane",
		Name:"Sugar Cane",
		iconTexture: "sugarCaneIcon",
		flatIcon: true,
		solid: false,
		transparent: true,
		shadow: false,
		compostChance:0.5,
		category:"nature",
		smoothLight:false,
		tint:grassTint,
		purpleTint:{
			default:[180/255,123/255,142/255],
		},
		biomeTintNorth:true,
		biomeTintSouth:true,
		biomeTintEast:true,
		biomeTintWest:true,
		randomOffset:true
	},
	
	{
		name:"woodenSword",
		Name:"Wooden Swords aren't even sharp!",
		item: true,
		sword: true,
		durability: 59,
		attackDamage: 4,
		category:"tools"
	},
	{
		name:"stoneSword",
		Name:"Stone Sword",
		item: true,
		sword: true,
		durability: 131,
		attackDamage: 5,
		material:"cobblestone",
		category:"tools"
	},
	{
		name:"ironSword",
		Name:"Iron Sword",
		item: true,
		sword: true,
		durability: 250,
		attackDamage: 6,
		material:"ironIngot",
		category:"tools"
	},
	{
		name:"goldenSword",
		Name:"Golden Sword",
		item: true,
		sword: true,
		durability: 32,
		attackDamage: 4,
		material:"goldIngot",
		category:"tools"
	},
	{
		name:"diamondSword",
		Name:"Diamond Sword",
		item: true,
		sword: true,
		durability: 1561,
		attackDamage: 7,
		material:"diamond",
		category:"tools"
	},
	
	{ name:"azaleaLeaves",
		Name:"Azalea Leaves",
		transparent: true,
		cullFace:0,
		hardness: 0.2,
		type:"plant2",
		drop: function(){
			if(rand() > 0.05){
				let r = floor(rand(2))
				if(r === 0) return "azalea"
				else return "floweringAzalea"
			}
		},
		burnChance: 0.2,
		burnTime: 30,
		compostChance:0.3,
		category:"nature",
		grassSound: true,
		leaves:true
	},
	{ name:"floweringAzaleaLeaves",
		Name:"Flowering Azalea Leaves",
		transparent: true,
		cullFace:0,
		hardness: 0.2,
		type:"plant2",
		drop: function(){
			if(rand() > 0.05){
				let r = floor(rand(2))
				if(r === 0) return "azalea"
				else return "floweringAzalea"
			}
		},
		burnChance: 0.2,
		burnTime: 30,
		compostChance:0.5,
		category:"nature",
		grassSound: true,
		leaves:true
	},
	
	{
		name: "spawnPig",
		item: true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			let pos = movePositionByFace(face,x,y,z)
			let ent = new entities[entityIds.Pig](pos[0],pos[1],pos[2])
			if(item.customName) ent.name = item.customName
			world.addEntity(ent)
			item.amount--
		},
		spawnMob: function(x,y,z,world){
			world.addEntity(new entities[entityIds.Pig](x,y,z),false)
		},
		category:"items"
	},
	
	{name:"tuff",Name:"Tuff",category:"nature",hardness:1.5},
	{name:"deepslate", Name:"Deepslate", textures:["deepslateTop","deepslate"],category:"nature",hardness:3,deepslateSound:true, randomRotate:"flip",randomRotateTop:true,randomRotateBottom:true, craftSlabs:true, craftStairs:true},
	{name:"cobbledDeepslate", Name:"Cobbled Deepslate",deepslateSound:true,category:"nature",hardness:3.5, randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true},
	{name:"chiseledDeepslate", Name:"Chiseled Deepslate",category:"build",hardness:3.5,deepslateSound:true},
	{name:"polishedDeepslate",Name:"Polished Deepslate",category:"build",hardness:3.5,deepslateSound:true, craftSlabs:true, craftStairs:true},
	{name:"deepslateTiles",Name:"Deepslate Tiles",category:"build",hardness:3.5,deepslateSound:true, craftSlabs:true, craftStairs:true},
	{name:"deepslateBricks",Name:"Deepslate Bricks",category:"build",hardness:3.5,deepslateBricksSound:true, craftSlabs:true, craftStairs:true},
	{name:"crackedDeepslateTiles",Name:"Cracked Deepslate Tiles",category:"build",hardness:3.5,deepslateSound:true},
	{name:"crackedDeepslateBricks",Name:"Cracked Deepslate Bricks",category:"build",hardness:3.5,deepslateBricksSound:true},
	{name:"deepslateCoalOre",Name:"Deepslate Coal Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"coal", dropAmount:[1,3]},
	{name:"deepslateIronOre",Name:"Deepslate Iron Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"rawIron", dropAmount:[1,3]},
	{name:"deepslateCopperOre",Name:"Deepslate Copper Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"rawCopper", dropAmount:[2,5]},
	{name:"deepslateGoldOre",Name:"Deepslate Gold Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"rawGold", dropAmount:[1,3]},
	{name:"deepslateDiamondOre",Name:"Deepslate Diamond Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"diamond", dropAmount:[1,3]},
	{name:"deepslateRedstoneOre",Name:"Deepslate Redstone Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"redstone", dropAmount:[6,9]},
	{name:"deepslateEmeraldOre",Name:"Deepslate Emerald Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"emerald", dropAmount:[1,3]},
	{name:"deepslateLapisOre",Name:"Deepslate Lapis Lazuli Ore",category:"nature",hardness:4.5,deepslateSound:true,drop:"lapisLazuli", dropAmount:[1,3]},
	
	{name:"amethystBlock",Name:"Amethyst Block", category:"nature",hardness:1.5,amethystSound: true},
	{name:"amethystShard",Name:"Amythest Shard",category:"items",item:true},
	{name:"buddingAmethyst",Name:"Budding Amethyst", category:"nature",hardness:1.5,amethystSound: true},
	{name:"smallAmethystBud",Name:"Small Amethyst Bud",category:"nature",hardness:1.5,sideCross:true,
		solid: false,
		transparent: true,
		shadow: false,
		amethystClusterSound: true,
		lightLevel:1
	},
	{name:"mediumAmethystBud",Name:"Medium Amethyst Bud",category:"nature",hardness:1.5,sideCross:true,
		solid: false,
		transparent: true,
		shadow: false,
		amethystClusterSound: true,
		lightLevel:2
	},
	{name:"largeAmethystBud",Name:"Large Amethyst Bud",category:"nature",hardness:1.5,sideCross:true,
		solid: false,
		transparent: true,
		shadow: false,
		amethystClusterSound: true,
		lightLevel:4
	},
	{name:"amethystCluster",Name:"Amethyst Cluster",category:"nature",hardness:1.5,sideCross:true,
		solid: false,
		transparent: true,
		shadow: false,
		amethystClusterSound: true,
		drop: "amethystShard",
		lightLevel:5
	},
	
	{
		name:"snowBlock",
		Name:"Block of Snow",
		textures:"snow",
		hardness: 0.2,
		drop:"snowball",
		dropAmount: 4,
		temperature:5,
		category:"nature",
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name:"snow",
		Name:"Snow Layer",
		layers: true,
		transparent:true,
		shadow:true,
		drop:"snowball",
		hardness: 0.1,
		fallingDust:[248/255, 253/255, 253/255],
		onupdate: function(x,y,z,b,world,sx,sy,sz){
			fall(x,y,z,b,world,false)
		},
		ongetexploded:function(x,y,z,b,world){
			fall(x,y,z,b,world,true)
		},
		temperature:5,
		liquidBreakable:"drop",
		category:"nature",
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name:"powderSnow",
		Name:"Powder Snow",
		solid:false,
		powder: true,
		hardness: 0.25,
		drop:"air",
		transparent:true,
		temperature:5,
		category:"nature",
	},
	{
		name:"snowball",
		Name:"Snowball",
		item: true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			item.amount--
			var pd = p.direction
			world.addEntity(new entities[entityIds.Snowball](p.x+pd.x,p.y+pd.y,p.z+pd.z, pd.x*0.8, pd.y*0.8, pd.z*0.8,p.id))
		},
		useAnywhere:true,
		category:"items",
	},
	{
		name:"powderSnowBucket",
		Name:"Powder Snow Bucket",
		item:true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			if(p.survival) item.id = blockIds.bucket
			var pos = movePositionByFace(face,x,y,z)
			world.setBlock(pos[0],pos[1],pos[2],blockIds.powderSnow)
		},
		stackSize: 1,
		category:"items",
	},
	
	{
		name:"bread",
		Name:"Bread",
		edible: true,
		item:true,
		eatWhenFull: false,
		food: 6,
		saturation: 11,
		compostChance:0.85,
		category:"food",
	},
	
	{
		name:"boneBlock",
		Name:"Bone Block",
		textures:["boneBlockTop","boneBlockSide"],
		category:"nature",
	},
	{
		name:"farmland",
		Name:"Farmland",
		textures:["dirt","farmland","dirt"],
		_1PixLower: true,
		category:"nature",
		hardness:0.6, blastResistance:0.5,
		type:"ground",
		tick:function(block,x,y,z,world){
			var target = this.id
			for(var X=x-4;X<=x+4;X++){
				for(var Z=z-4;Z<=z+4;Z++){
					var b = world.getBlock(X,y,Z), a = world.getBlock(X,y+1,Z)
					if(b && blockData[b].name === "Water" || a && blockData[a].name === "Water") target = this.id|SLAB
				}
			}
			if(block !== target) world.setBlock(x,y,z,target,false,false,false,false)
		}
	},
	
	{
		name:"glowBerries",
		Name:"Glow Berries",
		edible: true,
		item:true,
		eatWhenFull: false,
		food: 2,
		saturation: 0.4,
		compostChance:0.3,
		category:"food",
	},
	
	{
		name:"hayBlock",
		Name:"Hay Bale",
		textures:["hayBlockTop","hayBlockSide"],
		type:"plant2",
		damageResistance:0.8,
		burnChance: 0.2,
		burnTime: 20,
		category:"decoration",
	},
	{
		name:"hayBlockSW",
		textures: ["hayBlockSide","hayBlockSide","hayBlockTop","hayBlockSide"],
		SW: true,
		type:"plant2",
		damageResistance:0.8,
		compostChance:0.85,
		hidden:true
	},
	
	{
		name:"woodenShovel",
		Name:"Wooden Shovel",
		item: true,
		shovel: true,
		durability: 59,
		mineSpeed:2,
		attackDamage: 2,
		category:"tools"
	},
	{
		name:"stoneShovel",
		Name:"Stone Shovel",
		item: true,
		shovel: true,
		durability: 131,
		mineSpeed:3.6,
		attackDamage: 4,
		material:"cobblestone",
		category:"tools"
	},
	{
		name:"ironShovel",
		Name:"Iron Shovel",
		item: true,
		shovel: true,
		durability: 250,
		mineSpeed:6,
		attackDamage: 4,
		material:"ironIngot",
		category:"tools"
	},
	{
		name:"goldenShovel",
		Name:"Golden Shovel",
		item: true,
		shovel: true,
		durability: 32,
		mineSpeed:12,
		attackDamage: 2,
		material:"goldIngot",
		category:"tools"
	},
	{
		name:"diamondShovel",
		Name:"Diamond Shovel",
		item: true,
		shovel: true,
		durability: 1561,
		mineSpeed:8,
		attackDamage: 5,
		material:"diamond",
		category:"tools"
	},
	
	{
		name:"woodenAxe",
		Name:"Wooden Axe",
		item: true,
		axe: true,
		durability: 59,
		mineSpeed:2,
		attackDamage: 7,
		attackSpeed:0.8,
		category:"tools"
	},
	{
		name:"stoneAxe",
		Name:"Stone Axe",
		item: true,
		axe: true,
		durability: 131,
		mineSpeed:4,
		attackDamage: 9,
		attackSpeed:0.8,
		material:"cobblestone",
		category:"tools"
	},
	{
		name:"ironAxe",
		Name:"Iron Axe",
		item: true,
		axe: true,
		durability: 250,
		mineSpeed:6,
		attackDamage: 9,
		attackSpeed:0.9,
		material:"ironIngot",
		category:"tools"
	},
	{
		name:"goldenAxe",
		Name:"Golden Axe",
		item: true,
		axe: true,
		durability: 32,
		mineSpeed:12,
		attackDamage: 7,
		attackSpeed:1,
		material:"goldIngot",
		category:"tools"
	},
	{
		name:"diamondAxe",
		Name:"Diamond Axe",
		item: true,
		axe: true,
		durability: 1561,
		mineSpeed:8,
		attackDamage: 9,
		attackSpeed:1,
		material:"diamond",
		category:"tools"
	},
	
	{
		name: "strippedOakLog",
		Name: "Stripped Oak Log",
		textures: ["strippedOakLogTop", "strippedOakLog"],
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"build",
		log:true
	},
	{
		name: "strippedOakLogSW",
		textures: ["strippedOakLog", "strippedOakLog", "strippedOakLogTop","strippedOakLog"],
		woodSound:true,
		SW: true,
		hidden:true
	},
	{
		name: "strippedBirchLog",
		Name: "Stripped Birch Log",
		textures: ["strippedBirchLogTop", "strippedBirchLog"],
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"build",
		log:true
	},
	{
		name: "strippedBirchLogSW",
		textures: ["strippedBirchLog", "strippedBirchLog", "strippedBirchLogTop","strippedBirchLog"],
		woodSound:true,
		SW: true,
		hidden:true
	},
	{
		name: "strippedAcaciaLog",
		Name: "Stripped Acacia Log",
		textures: ["strippedAcaciaLogTop", "strippedAcaciaLog"],
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"build",
		log:true
	},
	{
		name: "strippedAcaciaLogSW",
		textures: ["strippedAcaciaLog", "strippedAcaciaLog", "strippedAcaciaLogTop","strippedAcaciaLog"],
		woodSound:true,
		SW: true,
		hidden:true
	},
	{
		name: "strippedJungleLog",
		Name: "Stripped Jungle Log",
		textures: ["strippedJungleLogTop", "strippedJungleLog"],
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"build",
		log:true
	},
	{
		name: "strippedJungleLogSW",
		textures: ["strippedJungleLog", "strippedJungleLog", "strippedJungleLogTop","strippedJungleLog"],
		woodSound:true,
		SW: true,
		hidden:true
	},
	{
		name: "strippedSpruceLog",
		Name: "Stripped Spruce Log",
		textures: ["strippedSpruceLogTop", "strippedSpruceLog"],
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"build",
		log:true
	},
	{
		name: "strippedSpruceLogSW",
		textures: ["strippedSpruceLog", "strippedSpruceLog", "strippedSpruceLogTop","strippedSpruceLog"],
		woodSound:true,
		SW: true,
		hidden:true
	},
	{
		name: "strippedDarkOakLog",
		Name: "Stripped Dark Oak Log",
		textures: ["strippedDarkOakLogTop", "strippedDarkOakLog"],
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"build",
		log:true
	},
	{
		name: "strippedDarkOakLogSW",
		textures: ["strippedDarkOakLog", "strippedDarkOakLog", "strippedDarkOakLogTop","strippedDarkOakLog"],
		woodSound:true,
		SW: true,
		hidden:true
	},
	
	{
		name:"boneBlockSW",
		textures:["boneBlockSide","boneBlockSide","boneBlockTop","boneBlockSide"],
		SW: true,
		hidden:true
	},
	
	{
		name:"redMushroom",
		Name:"Red Mushroom",
		solid: false,
		transparent: true,
		shadow: false,
		potCross: true,
		crossShape: true,
		lightLevel:1,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		growBonemeal: function(x,y,z,world){
			win.serverSaveWorldGen()
			world.getChunk(x,z).spawnHugeMushroom(x&15,y-1,z&15,x,z,false)
			win.serverRestoreWorldGen()
		},
		randomOffset:true,
	},
	{
		name:"brownMushroom",
		Name:"Brown Mushroom",
		solid: false,
		transparent: true,
		shadow: false,
		potCross: true,
		crossShape: true,
		lightLevel:1,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		growBonemeal: function(x,y,z,world){
			win.serverSaveWorldGen()
			world.getChunk(x,z).spawnHugeMushroom(x&15,y-1,z&15,x,z,true)
			win.serverRestoreWorldGen()
		},
		randomOffset:true,
	},
	{
		name:"mushroomStem",
		Name: "Mushroom Stem",
		mushroomBlock:true,
		compostChance:0.65,
		category:"nature"
	},
	{
		name:"redMushroomBlock",
		Name: "Red Mushroom Block",
		mushroomBlock:true,
		compostChance:0.85,
		category:"nature"
	},
	{
		name:"brownMushroomBlock",
		Name: "Brown Mushroom Block",
		mushroomBlock:true,
		compostChance:0.85,
		category:"nature"
	},
	
	{
		name:"mycelium",
		Name:"Mycelium",
		textures:["dirt","myceliumTop","myceliumSide"],
		type:"ground",
		category:"nature",
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
		hardness: 0.6,
		blastResistance:0.6,
		drop:"dirt",
		grassSound: true,
	},
	
	{
		name:"terracotta",
		Name:"Terracotta",
		category:"build"
	},
	{
		name:"redTerracotta",
		Name:"Terracotta with watermelon juice",
		category:"build"
	},
	{
		name:"blueTerracotta",
		Name:"Terracotta with blueberry juice",
		category:"build"
	},
	{
		name:"cyanTerracotta",
		Name:"Terracotta with cyan colored fruit punch",
		category:"build"
	},
	{
		name:"grayTerracotta",
		Name:"Dusty Terracotta",
		category:"build"
	},
	{
		name:"limeTerracotta",
		Name:"Terracotta with leaf juice",
		category:"build"
	},
	{
		name:"pinkTerracotta",
		Name:"Terracotta with fruit punch",
		category:"build"
	},
	{
		name:"blackTerracotta",
		Name:"Terracotta painted black",
		category:"build"
	},
	{
		name:"brownTerracotta",
		Name:"Dirty Terracotta",
		category:"build"
	},
	{
		name:"greenTerracotta",
		Name:"Terracotta with some other leaf juice",
		category:"build"
	},
	{
		name:"whiteTerracotta",
		Name:"Terracotta with flour",
		category:"build"
	},
	{
		name:"orangeTerracotta",
		Name:"Orange Terracotta",
		category:"build"
	},
	{
		name:"purpleTerracotta",
		Name:"Purple Terracotta",
		category:"build"
	},
	{
		name:"yellowTerracotta",
		Name:"Terracotta with lemon juice",
		category:"build"
	},
	{
		name:"magentaTerracotta",
		Name:"Magenta Terracotta",
		category:"build"
	},
	{
		name:"lightBlueTerracotta",
		Name:"Light Blue Terracotta",
		category:"build"
	},
	{
		name:"lightGrayTerracotta",
		Name:"Light Gray Terracotta",
		category:"build"
	},
	{
		name:"redGlazedTerracotta",
		Name:"Watermelon Swirl",
		category:"build",
		pistonPush:false,
		pistonPull:false,
		randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name:"blueGlazedTerracotta",
		Name:"Blue Fan",
		category:"build",
		pistonPush:false,
		pistonPull:false,
		randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name:"cyanGlazedTerracotta",
		Name:"Creeper in the skies",
		category:"build",
		pistonPush:false,
		pistonPull:false,
		randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name:"grayGlazedTerracotta",
		Name:"Bunch of Dust",
		category:"build",
		pistonPush:false,
		pistonPull:false,
		randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name:"limeGlazedTerracotta",
		Name:"Overlapping lilies",
		category:"build",
		pistonPush:false,
		pistonPull:false,
		randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name:"pinkGlazedTerracotta",
		Name:"Pink turtle shell",
		category:"build",
		pistonPush:false,
		pistonPull:false,
		randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name:"blackGlazedTerracotta",
		Name:"Red monster",
		category:"build",
		pistonPush:false,
		pistonPull:false,
		randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name:"brownGlazedTerracotta",
		Name:"Mudslide in the ocean",
		category:"build",
		pistonPush:false,
		pistonPull:false,
		randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name:"greenGlazedTerracotta",
		Name:"Camouflaged monster",
		category:"build",
		pistonPush:false,
		pistonPull:false,
		randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name:"whiteGlazedTerracotta",
		Name:"Sun & clouds",
		category:"build",
		pistonPush:false,
		pistonPull:false,
		randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name:"orangeGlazedTerracotta",
		Name:"Flower Monster",
		category:"build",
		pistonPush:false,
		pistonPull:false,
		randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name:"purpleGlazedTerracotta",
		Name:"Sword & pickaxe monster",
		category:"build",
		pistonPush:false,
		pistonPull:false,
		randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name:"yellowGlazedTerracotta",
		Name:"Some kind of bug",
		category:"build",
		pistonPush:false,
		pistonPull:false,
		randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name:"magentaGlazedTerracotta",
		Name:"Arrow",
		category:"build",
		pistonPush:false,
		pistonPull:false,
		randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name:"lightBlueGlazedTerracotta",
		Name:"Monster sticking out tongue and eyes facing opposite direction",
		category:"build",
		pistonPush:false,
		pistonPull:false,
		randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	{
		name:"lightGrayGlazedTerracotta",
		Name:"Monster with blue eyes and mouth",
		category:"build",
		pistonPush:false,
		pistonPull:false,
		randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	
	{
		name:"ancientDebris",
		Name:"Ancient Debris",
		textures:["ancientDebrisTop","ancientDebrisSide"],
		hardness:30,
		type:"rock4",
		category:"nature",
	},
	
	{
		name:"wheatSeeds",
		Name:"Seeds",
		item:true,
		useAs:function(x,y,z,block,face){
			if(!block) return
			if(face === "top" && blockData[block].name === "farmland") return "wheat"
		},
		compostChance:0.3,
		category:"items"
	},
	
	{
		name:"yellowStainedGlass",
		Name: "Yellow Stained Glass",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		type:"glass",
		glassSound: true,
		category:"build"
	},
	{
		name:"whiteStainedGlass",
		Name: "White Stained Glass",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		type:"glass",
		glassSound: true,
		category:"build"
	},
	{
		name:"redStainedGlass",
		Name: "Red Stained Glass",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		type:"glass",
		glassSound: true,
		category:"build"
	},
	{
		name:"purpleStainedGlass",
		Name: "Purple Stained Glass",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		type:"glass",
		glassSound: true,
		category:"build"
	},
	{
		name:"pinkStainedGlass",
		Name: "Pink Stained Glass",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		type:"glass",
		glassSound: true,
		category:"build"
	},
	{
		name:"orangeStainedGlass",
		Name: "Orange Stained Glass",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		type:"glass",
		glassSound: true,
		category:"build"
	},
	{
		name:"magentaStainedGlass",
		Name: "Magenta Stained Glass",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		type:"glass",
		glassSound: true,
		category:"build"
	},
	{
		name:"limeStainedGlass",
		Name: "Lime Stained Glass",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		type:"glass",
		glassSound: true,
		category:"build"
	},
	{
		name:"lightGrayStainedGlass",
		Name: "Light Gray Stained Glass",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		type:"glass",
		glassSound: true,
		category:"build"
	},
	{
		name:"lightBlueStainedGlass",
		Name: "Light Blue Stained Glass",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		type:"glass",
		glassSound: true,
		category:"build"
	},
	{
		name:"greenStainedGlass",
		Name: "Green Stained Glass",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		type:"glass",
		glassSound: true,
		category:"build"
	},
	{
		name:"grayStainedGlass",
		Name: "Gray Stained Glass",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		type:"glass",
		glassSound: true,
		category:"build"
	},
	{
		name:"cyanStainedGlass",
		Name: "Cyan Stained Glass",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		type:"glass",
		glassSound: true,
		category:"build"
	},
	{
		name:"brownStainedGlass",
		Name: "Brown Stained Glass",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		type:"glass",
		glassSound: true,
		category:"build"
	},
	{
		name:"blueStainedGlass",
		Name: "Blue Stained Glass",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		type:"glass",
		glassSound: true,
		category:"build"
	},
	{
		name:"blackStainedGlass",
		Name: "Black Stained Glass",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		type:"glass",
		glassSound: true,
		category:"build"
	},
	
	{
		name: "yellowStainedGlassPane",
		Name: "Yellow Stained Glass Pane",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		pane:true,
		textures: ["yellowStainedGlassPaneTop","yellowStainedGlassPaneTop","yellowStainedGlass","yellowStainedGlass","yellowStainedGlassPaneSide","yellowStainedGlassPaneSide"],
		glassSound: true,
		category:"build"
	},
	{
		name: "whiteStainedGlassPane",
		Name: "White Stained Glass Pane",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		pane:true,
		textures: ["whiteStainedGlassPaneTop","whiteStainedGlassPaneTop","whiteStainedGlass","whiteStainedGlass","whiteStainedGlassPaneSide","whiteStainedGlassPaneSide"],
		glassSound: true,
		category:"build"
	},
	{
		name: "redStainedGlassPane",
		Name: "Red Stained Glass Pane",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		pane:true,
		textures: ["redStainedGlassPaneTop","redStainedGlassPaneTop","redStainedGlass","redStainedGlass","redStainedGlassPaneSide","redStainedGlassPaneSide"],
		glassSound: true,
		category:"build"
	},
	{
		name: "purpleStainedGlassPane",
		Name: "Purple Stained Glass Pane",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		pane:true,
		textures: ["purpleStainedGlassPaneTop","purpleStainedGlassPaneTop","purpleStainedGlass","purpleStainedGlass","purpleStainedGlassPaneSide","purpleStainedGlassPaneSide"],
		glassSound: true,
		category:"build"
	},
	{
		name: "pinkStainedGlassPane",
		Name: "Pink Stained Glass Pane",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		pane:true,
		textures: ["pinkStainedGlassPaneTop","pinkStainedGlassPaneTop","pinkStainedGlass","pinkStainedGlass","pinkStainedGlassPaneSide","pinkStainedGlassPaneSide"],
		glassSound: true,
		category:"build"
	},
	{
		name: "orangeStainedGlassPane",
		Name: "Orange Stained Glass Pane",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		pane:true,
		textures: ["orangeStainedGlassPaneTop","orangeStainedGlassPaneTop","orangeStainedGlass","orangeStainedGlass","orangeStainedGlassPaneSide","orangeStainedGlassPaneSide"],
		glassSound: true,
		category:"build"
	},
	{
		name: "magentaStainedGlassPane",
		Name: "Magenta Stained Glass Pane",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		pane:true,
		textures: ["magentaStainedGlassPaneTop","magentaStainedGlassPaneTop","magentaStainedGlass","magentaStainedGlass","magentaStainedGlassPaneSide","magentaStainedGlassPaneSide"],
		glassSound: true,
		category:"build"
	},
	{
		name: "limeStainedGlassPane",
		Name: "Lime Stained Glass Pane",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		pane:true,
		textures: ["limeStainedGlassPaneTop","limeStainedGlassPaneTop","limeStainedGlass","limeStainedGlass","limeStainedGlassPaneSide","limeStainedGlassPaneSide"],
		glassSound: true,
		category:"build"
	},
	{
		name: "lightGrayStainedGlassPane",
		Name: "Light Gray Stained Glass Pane",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		pane:true,
		textures: ["lightGrayStainedGlassPaneTop","lightGrayStainedGlassPaneTop","lightGrayStainedGlass","lightGrayStainedGlass","lightGrayStainedGlassPaneSide","lightGrayStainedGlassPaneSide"],
		glassSound: true,
		category:"build"
	},
	{
		name: "lightBlueStainedGlassPane",
		Name: "Light Blue Stained Glass Pane",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		pane:true,
		textures: ["lightBlueStainedGlassPaneTop","lightBlueStainedGlassPaneTop","lightBlueStainedGlass","lightBlueStainedGlass","lightBlueStainedGlassPaneSide","lightBlueStainedGlassPaneSide"],
		glassSound: true,
		category:"build"
	},
	{
		name: "greenStainedGlassPane",
		Name: "Green Stained Glass Pane",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		pane:true,
		textures: ["greenStainedGlassPaneTop","greenStainedGlassPaneTop","greenStainedGlass","greenStainedGlass","greenStainedGlassPaneSide","greenStainedGlassPaneSide"],
		glassSound: true,
		category:"build"
	},
	{
		name: "grayStainedGlassPane",
		Name: "Gray Stained Glass Pane",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		pane:true,
		textures: ["grayStainedGlassPaneTop","grayStainedGlassPaneTop","grayStainedGlass","grayStainedGlass","grayStainedGlassPaneSide","grayStainedGlassPaneSide"],
		glassSound: true,
		category:"build"
	},
	{
		name: "cyanStainedGlassPane",
		Name: "Cyan Stained Glass Pane",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		pane:true,
		textures: ["cyanStainedGlassPaneTop","cyanStainedGlassPaneTop","cyanStainedGlass","cyanStainedGlass","cyanStainedGlassPaneSide","cyanStainedGlassPaneSide"],
		glassSound: true,
		category:"build"
	},
	{
		name: "brownStainedGlassPane",
		Name: "Brown Stained Glass Pane",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		pane:true,
		textures: ["brownStainedGlassPaneTop","brownStainedGlassPaneTop","brownStainedGlass","brownStainedGlass","brownStainedGlassPaneSide","brownStainedGlassPaneSide"],
		glassSound: true,
		category:"build"
	},
	{
		name: "blueStainedGlassPane",
		Name: "Blue Stained Glass Pane",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		pane:true,
		textures: ["blueStainedGlassPaneTop","blueStainedGlassPaneTop","blueStainedGlass","blueStainedGlass","blueStainedGlassPaneSide","blueStainedGlassPaneSide"],
		glassSound: true,
		category:"build"
	},
	{
		name: "blackStainedGlassPane",
		Name: "Black Stained Glass Pane",
		transparent: true,
		shadow: false,
		hardness: 0.3,
		pane:true,
		textures: ["blackStainedGlassPaneTop","blackStainedGlassPaneTop","blackStainedGlass","blackStainedGlass","blackStainedGlassPaneSide","blackStainedGlassPaneSide"],
		glassSound: true,
		category:"build"
	},
	
	{
		name: "cobweb",
		Name:"Cobweb",
		solid: false,
		transparent: true,
		shadow: false,
		crossShape: true,
		hardness:4,
		drop:"air",
		dropSelfWhenSheared:true,
		shearBreakTime:0.4,
		liquidBreakable:"drop",
		category:"decoration"
	},
	
	{
		name: "strippedCrimsonStem",
		Name: "Stripped Crimson Stem",
		textures: ["strippedCrimsonStemTop", "strippedCrimsonStem"],
		hardness:2,
		stemSound:true,
		category:"build"
	},
	{
		name: "strippedCrimsonStemSW",
		textures: ["strippedCrimsonStem", "strippedCrimsonStem", "strippedCrimsonStemTop","strippedCrimsonStem"],
		hardness:2,
		stemSound:true,
		SW: true,
		hidden:true
	},
	{
		name: "strippedWarpedStem",
		Name: "Stripped Warped Stem",
		textures: ["strippedWarpedStemTop", "strippedWarpedStem"],
		hardness:2,
		stemSound:true,
		category:"build"
	},
	{
		name: "strippedWarpedStemSW",
		textures: ["strippedWarpedStem", "strippedWarpedStem", "strippedWarpedStemTop","strippedWarpedStem"],
		hardness:2,
		stemSound:true,
		SW: true,
		hidden:true
	},
	
	{
		name: "oakPressurePlate",
		Name: "Oak Pressure Plate",
		textures: "oakPlanks",
		pressurePlate: true,
		hardness:0.5,
		type:"wood",
		category:"redstone"
	},
	{
		name: "birchPressurePlate",
		Name: "Birch Pressure Plate",
		textures: "birchPlanks",
		pressurePlate: true,
		hardness:0.5,
		type:"wood",
		category:"redstone"
	},
	{
		name: "sprucePressurePlate",
		Name: "Spruce Pressure Plate",
		textures: "sprucePlanks",
		pressurePlate: true,
		hardness:0.5,
		type:"wood",
		category:"redstone"
	},
	{
		name: "junglePressurePlate",
		Name: "Jungle Pressure Plate",
		textures: "junglePlanks",
		pressurePlate: true,
		hardness:0.5,
		type:"wood",
		category:"redstone"
	},
	{
		name: "acaciaPressurePlate",
		Name: "Acacia Pressure Plate",
		textures: "acaciaPlanks",
		pressurePlate: true,
		hardness:0.5,
		type:"wood",
		category:"redstone"
	},
	{
		name:"darkOakPressurePlate",
		Name: "Dark Oak Pressure Plate",
		textures: "darkOakPlanks",
		pressurePlate: true,
		hardness:0.5,
		type:"wood",
		category:"redstone"
	},
	{
		name: "warpedPressurePlate",
		Name: "Warped Pressure Plate",
		textures: "warpedPlanks",
		pressurePlate: true,
		hardness:0.5,
		type:"wood",
		category:"redstone"
	},
	{
		name: "crimsonPressurePlate",
		Name: "Crimson Pressure Plate",
		textures: "crimsonPlanks",
		pressurePlate: true,
		hardness:0.5,
		type:"wood",
		category:"redstone"
	},
	{
		name: "stonePressurePlate",
		Name: "Stone Pressure Plate",
		textures: "stone",
		pressurePlate: true,
		type:"stone",
		hardness:0.5,
		category:"redstone"
	},
	{
		name: "polishedBlackstonePressurePlate",
		textures: "polishedBlackstone",
		pressurePlate: true,
		type:"stone",
		hardness:0.5,
		category:"redstone"
	},
	{
		name: "lightWeightedPressurePlate",
		textures: "goldBlock",
		pressurePlate: true,
		type:"stone",
		hardness:0.5,
		lightWeighted:true,
		category:"redstone"
	},
	{
		name: "heavyWeightedPressurePlate",
		textures: "ironBlock",
		pressurePlate: true,
		type:"stone",
		hardness:0.5,
		heavyWeighted:true,
		category:"redstone"
	},
	{
		name:"oakButton",
		Name: "Oak Button",
		textures:"oakPlanks",
		button:true,
		transparent: true,
		shadow:false,
		category:"redstone"
	},
	{
		name:"birchButton",
		Name: "Birch Button",
		textures:"birchPlanks",
		button:true,
		transparent: true,
		shadow:false,
		category:"redstone"
	},
	{
		name:"acaciaButton",
		Name: "Acacia Button",
		textures:"acaciaPlanks",
		button:true,
		transparent: true,
		shadow:false,
		category:"redstone"
	},
	{
		name:"darkOakButton",
		Name: "Dark Oak Button",
		textures:"darkOakPlanks",
		button:true,
		transparent: true,
		shadow:false,
		category:"redstone"
	},
	{
		name:"jungleButton",
		Name: "Jungle Button",
		textures:"junglePlanks",
		button:true,
		transparent: true,
		shadow:false,
		category:"redstone"
	},
	{
		name:"spruceButton",
		Name: "Spruce Button",
		textures:"sprucePlanks",
		button:true,
		transparent: true,
		shadow:false,
		category:"redstone"
	},
	{
		name:"warpedButton",
		Name: "Warped Button",
		textures:"warpedPlanks",
		button:true,
		transparent: true,
		shadow:false,
		category:"redstone"
	},
	{
		name:"crimsonButton",
		Name: "Crimson Button",
		textures:"crimsonPlanks",
		button:true,
		transparent: true,
		shadow:false,
		category:"redstone"
	},
	{
		name:"polishedBlackstoneButton",
		Name: "Polished Blackstone Button",
		textures:"polishedBlackstone",
		button:true,
		transparent:true,
		shadow:false,
		stone:true,
		category:"redstone"
	},
	{
		name:"copperBlock",
		Name:"Block of Copper",
		category:"build"
	},
	
	{
		name:"crackedPolishedBlackstoneBricks",
		Name:"Cracked Polished Blackstone Bricks",
		category:"build"
	},
	{
		name:"crackedStoneBricks",
		Name:"Cracked Stone Bricks",
		category:"build"
	},
	
	{
		name:"woodenHoe",
		Name:"Wooden Hoe",
		item: true,
		hoe: true,
		durability: 59,
		mineSpeed:2,
		attackDamage: 1,
		attackSpeed:1,
		category:"tools"
	},
	{
		name:"stoneHoe",
		Name:"Stone Hoe",
		item: true,
		hoe: true,
		durability: 131,
		mineSpeed:4,
		attackDamage: 1,
		attackSpeed:2,
		material:"cobblestone",
		category:"tools"
	},
	{
		name:"ironHoe",
		Name:"Iron Hoe",
		item: true,
		hoe: true,
		durability: 250,
		mineSpeed:6,
		attackDamage: 1,
		attackSpeed:3,
		material:"ironIngot",
		category:"tools"
	},
	{
		name:"goldenHoe",
		Name:"Golden Hoe",
		item: true,
		hoe: true,
		durability: 32,
		mineSpeed:12,
		attackDamage: 1,
		attackSpeed:1,
		material:"goldIngot",
		category:"tools"
	},
	{
		name:"diamondHoe",
		Name:"Diamond Hoe",
		item: true,
		hoe: true,
		durability: 1561,
		mineSpeed:8,
		attackDamage: 1,
		attackSpeed:4,
		material:"diamond",
		category:"tools"
	},
	
	{
		name:"podzol",
		Name:"Podzol",
		textures:["dirt","podzolTop","podzolSide"],
		category:"nature",
		hardness:0.5,
		blastResistance:0.5,
		type:"ground",
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			let top = world.getBlock(x,y+1,z)
			let isSnow = blockData[top].name === "snow" || blockData[top].name === "snowBlock"
			if(b === blockIds.podzol && isSnow){
				world.setBlock(x,y,z,blockIds.podzol | CROSS,false,false,false,false)
			}else if(b === (blockIds.podzol | CROSS) && !isSnow){
				world.setBlock(x,y,z,blockIds.podzol,false,false,false,false)
			}
		},
		compostChance:0.3,
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
		digSound: ["dirt.dig1", "dirt.dig2", "dirt.dig3", "dirt.dig4"],
		stepSound: ["dirt.step1", "dirt.step2","dirt.step3","dirt.step4"]
	},
	
	{
		name:"rawIronBlock",
		Name:"Block of Raw Iron",
		type:"rock2",
		hardness:5,
		category:"build"
	},
	{
		name:"rawGoldBlock",
		Name:"Block of Raw Gold",
		type:"rock3",
		hardness:5,
		category:"build"
	},
	{
		name:"rawCopperBlock",
		Name:"Block of Raw Copper",
		type:"rock2",
		hardness:5,
		category:"build"
	},
	
	{
		name:"netheriteScrap",
		Name:"Netherite Scrap",
		item:true,
		category:"items"
	},
	{
		name:"netheriteIngot",
		Name:"Netherite Ingot",
		item:true,
		category:"items"
	},
	{
		name:"netheritePickaxe",
		Name:"Netherite Pickaxe",
		item: true,
		pickaxe: true,
		mineSpeed: 9,
		durability: 2031,
		attackDamage: 6,
		material:"netheriteIngot",
		category:"tools"
	},
	{
		name:"netheriteSword",
		Name:"Netherite Sword",
		item: true,
		sword: true,
		durability: 2031,
		attackDamage: 8,
		material:"netheriteIngot",
		category:"tools"
	},
	{
		name:"netheriteAxe",
		Name:"Netherite Axe",
		item: true,
		axe: true,
		durability: 2031,
		mineSpeed:9,
		attackDamage: 10,
		attackSpeed:1,
		material:"netheriteIngot",
		category:"tools"
	},
	{
		name:"netheriteShovel",
		Name:"Netherite Shovel",
		item: true,
		shovel: true,
		durability: 2031,
		mineSpeed:9,
		attackDamage: 6,
		material:"netheriteIngot",
		category:"tools"
	},
	{
		name:"netheriteHoe",
		Name:"Nethrite Hoe",
		item: true,
		hoe: true,
		durability: 2031,
		mineSpeed:9,
		attackDamage: 1,
		attackSpeed:4,
		material:"netheriteIngot",
		category:"tools"
	},
	
	{
		name:"cartographyTable",
		Name:"Cartograpgy Table",
		textures: ["cartographyTableSide3","cartographyTableTop","cartographyTableSide3","cartographyTableSide1","cartographyTableSide2","cartographyTableSide3"],
		rotate:true,
		category:"items"
	},
	
	{
		name:"cake",
		Name:"Cake",
		textures:["cakeBottom","cakeTop","cakeSide"],
		cake:true,
		transparent:true,
		flatIcon:true,
		iconTexture:"cake",
		compostChance:1,
		category:"food"
	},
	
	{
		name:"smithingTable",
		Name:"Smithing Table",
		textures:["smithingTableBottom","smithingTableTop","smithingTableFront","smithingTableSide"],
		category:"items"
	},
	{
		name:"stonecutter",
		Name:"Stonecutter",
		textures:["stonecutterBottom","stonecutterTop","stonecutterSide"],
		transparent:true,
		stonecutter:true,
		category:"items"
	},
	{
		name:"itemFrame",
		Name:"Item Frame",
		transparent:true,
		itemFrame:true,
		flatIcon:true,
		iconTexture:"itemFrameIcon",
		category:"items"
	},
	
	{
		name:"enderPearl",
		Name:"Ender Pearl",
		item:true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			item.amount--
			world.addEntity(new entities[entityIds.EnderPearl](p.x,p.y,p.z, p.direction.x, p.direction.y, p.direction.z, p.id))
		},
		useAnywhere:true,
		category:"items"
	},
	
	{
		name:"ironNugget",
		Name:"Iron Nugget",
		item:true,
		category:"items"
	},
	{
		name:"goldNugget",
		Name:"Gold Nugget",
		item:true,
		category:"items"
	},
	
	{
		name:"pumpkin",
		Name:"Pumpkin",
		textures:["pumpkinSide","pumpkinTop","pumpkinSide"],
		compostChance:0.65,
		category:"nature"
	},
	{
		name:"carvedPumpkin",
		Name:"Carved Pumpkin",
		textures:["pumpkinSide","pumpkinTop","pumpkinSide","carvedPumpkin","pumpkinSide","pumpkinSide"],
		rotate:true,
		compostChance:0.65,
		category:"nature"
	},
	{
		name:"jackOLantern",
		Name:"Jack o'Lantern",
		textures:["pumpkinSide","pumpkinTop","pumpkinSide","jackOLantern","pumpkinSide","pumpkinSide"],
		lightLevel:15,
		rotate:true,
		compostChance:0.65,
		category:"nature"
	},
	
	{
		name:"shears",
		Name:"Shears",
		item:true,
		shears:true,
		category:"items"
	},
	
	{
		name:"pumpkinSeeds",
		Name:"Pumpkin Seeds",
		item:true,
		compostChance:0.3,
		category:"items"
	},
	{
		name:"melonSeeds",
		Name:"Watermelon Seeds",
		item:true,
		compostChance:0.3,
		category:"items"
	},
	
	{
		name:"melon",
		Name:"Watermelon",
		textures:["melonSide","melonTop","melonSide"],
		hardness:1,
		drop:"melonSlice",
		dropAmount:[3,7],
		compostChance:0.65,
		category:"nature"
	},
	{
		name:"melonSlice",
		Name:"Slice of Watermelon",
		item:true,
		edible: true,
		food: 2,
		saturation: 1.2,
		compostChance:0.5,
		category:"food"
	},
	
	{
		name:"redstoneLamp",
		Name:"Redstone Lamp",
		//if you chang this, change colored lamps too
		onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,world){
			var power = world.getRedstonePower(x,y,z) || world.getSurroundingBlockPower(x,y,z)
			var block = this.id
			if(power){
				block = this.id | SLAB
			}
			if(world.getBlock(x,y,z) !== block) world.setBlock(x,y,z,block,false,false,false,false)
		},
		onset:function(x,y,z,world){
			this.onpowerupdate(x,y,z,null,null,null,null,world)
		},
		category:"redstone"
	},
	{
		name:"glowstoneDust",
		Name:"Glowstone Dust",
		item:true,
		category:"items"
	},
	
	{
		name:"quartz",
		Name:"Quartz",
		item:true,
		category:"items"
	},
	
	{
		name: "endPortalFrame", 
		Name:"End Portal Frame",
		textures: ["endStone", "endPortalFrameTop", "endPortalFrameSide"],
		category:"items",
		blastResistance:3600000,
		hardness:Infinity,
		lightLevel:1,
		glassSound: true,
		eyeplace:function(x,y,z,world){
			this.findFullFrame(x+1,y,z,world)
			this.findFullFrame(x-1,y,z,world)
			this.findFullFrame(x,y,z+1,world)
			this.findFullFrame(x,y,z-1,world)
		},
		findFullFrame:function(x,y,z,world){
			if(blockData[world.getBlock(x,y,z)].solid) return
			let spread = [], spreadAt = [x,y,z,0]
			let minX = x, minZ = z
			let maxX = x, maxZ = z
			while(spreadAt.length){
				let [sx,sy,sz] = spreadAt
				if(Math.max(Math.abs(x-sx),Math.abs(y-sy),Math.abs(z-sz)) > 2) return //portal area isn't that big
				minX = Math.min(minX,sx), minZ = Math.min(minZ,sz)
				maxX = Math.max(maxX,sx), maxZ = Math.max(maxZ,sz)
				if(!xyArrayHas(spread,spreadAt,sx,sy,sz+1)){
					let b = world.getBlock(sx,sy,sz+1)
					if(!blockData[b].solid) spreadAt.push(sx,sy,sz+1,0)
					else if(blockData[b].name !== this.name) return
				}
				if(!xyArrayHas(spread,spreadAt,sx,sy,sz-1)){
					let b = world.getBlock(sx,sy,sz-1)
					if(!blockData[b].solid) spreadAt.push(sx,sy,sz-1,0)
					else if(blockData[b].name !== this.name) return
				}
				if(!xyArrayHas(spread,spreadAt,sx+1,sy,sz)){
					let b = world.getBlock(sx+1,sy,sz)
					if(!blockData[b].solid) spreadAt.push(sx+1,sy,sz,0)
					else if(blockData[b].name !== this.name) return
				}
				if(!xyArrayHas(spread,spreadAt,sx-1,sy,sz)){
					let b = world.getBlock(sx-1,sy,sz)
					if(!blockData[b].solid) spreadAt.push(sx-1,sy,sz,0)
					else if(blockData[b].name !== this.name) return
				}
				spread.push(...spreadAt.splice(0,4))
			}
			//check if frame is correct
			x = minX-1, z = minZ-1
			if(world.getBlock(x+1,y,z) !== (this.id | SLAB | SOUTH)) return
			if(world.getBlock(x+2,y,z) !== (this.id | SLAB | SOUTH)) return
			if(world.getBlock(x+3,y,z) !== (this.id | SLAB | SOUTH)) return
			if(world.getBlock(x+4,y,z+1) !== (this.id | SLAB | EAST)) return
			if(world.getBlock(x+4,y,z+2) !== (this.id | SLAB | EAST)) return
			if(world.getBlock(x+4,y,z+3) !== (this.id | SLAB | EAST)) return
			if(world.getBlock(x+1,y,z+4) !== (this.id | SLAB | NORTH)) return
			if(world.getBlock(x+2,y,z+4) !== (this.id | SLAB | NORTH)) return
			if(world.getBlock(x+3,y,z+4) !== (this.id | SLAB | NORTH)) return
			if(world.getBlock(x,y,z+1) !== (this.id | SLAB | WEST)) return
			if(world.getBlock(x,y,z+2) !== (this.id | SLAB | WEST)) return
			if(world.getBlock(x,y,z+3) !== (this.id | SLAB | WEST)) return

			//place the frame
			world.setBlock(x+1,y,z+1,blockIds.endPortal)
			world.setBlock(x+2,y,z+1,blockIds.endPortal)
			world.setBlock(x+3,y,z+1,blockIds.endPortal)
			world.setBlock(x+1,y,z+2,blockIds.endPortal)
			world.setBlock(x+2,y,z+2,blockIds.endPortal)
			world.setBlock(x+3,y,z+2,blockIds.endPortal)
			world.setBlock(x+1,y,z+3,blockIds.endPortal)
			world.setBlock(x+2,y,z+3,blockIds.endPortal)
			world.setBlock(x+3,y,z+3,blockIds.endPortal)

			world.playSound(x+2,y,z+2,"end_portal.endportal")
		}
	},
	{
		name: "eyeOfEnder",
		Name:"Eye of Ender",
		flatIcon:true,
		item:true,
		placeSound:["end_portal.eyeplace1","end_portal.eyeplace2","end_portal.eyeplace3"],
		category:"items"
	},
	{
		name:"endStone",
		Name:"End Stone",
		category:"nature",
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	
	{
		name:"redSand",
		Name:"Red Sand",
		hardness:0.5,
		fallingDust:[178/255, 94/255, 26/255],
		onupdate: function(x,y,z,b,world,sx,sy,sz){
			fall(x,y,z,b,world,false)
		},
		ongetexploded:function(x,y,z,b,world){
			fall(x,y,z,b,world,true)
		},
		category:"nature",
		digSound: ["sand.dig1", "sand.dig2", "sand.dig3", "sand.dig4"],
		stepSound: ["sand.step1", "sand.step2","sand.step3","sand.step4","sand.step5"]
	},
	{
		name:"redSandstone",
		Name:"Red Sandstone",
		textures: ["redSandstoneBottom", "redSandstoneTop", "redSandstone"],
		category:"nature",
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
		craftSlabs:true, craftStairs:true
	},
	{ name:"chiseledRedSandstone",
		Name:"Chiseled Red Sandstone",
		textures: ["redSandstoneBottom", "redSandstoneTop","chiseledRedSandstone"],
		category:"build",
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true
	},
	{ name:"cutRedSandstone",
		Name:"Cut Red Sandstone",
		textures: ["redSandstoneBottom", "redSandstoneTop","cutRedSandstone"],
		category:"build",
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
		craftSlabs:true, craftStairs:true
	},
	{ name:"smoothRedSandstone", Name:"Smooth Red Sandstone", textures:"redSandstoneTop", category:"nature", randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true },
	
	{
		name:"purpurBlock",
		Name:"Purpur Block",
		category:"build",
		craftSlabs:true, craftStairs:true
	},
	{
		name:"purpurPillar",
		Name:"Purpur Pillar",
		textures:["purpurPillarTop","purpurPillar"],
		category:"build"
	},
	{
		name:"purpurPillarSW",
		textures:["purpurPillar","purpurPillar","purpurPillarTop","purpurPillar"],
		SW: true,
		hidden:true
	},
	
	{
		name:"prismarine",
		Name:"Prismarine",
		category:"build",
		craftSlabs:true, craftStairs:true
	},
	{
		name:"prismarineBricks",
		Name:"Prismarine Bricks",
		category:"build",
		craftSlabs:true, craftStairs:true
	},
	{
		name:"darkPrismarine",
		Name:"Dark Prismarine",
		category:"build",
		craftSlabs:true, craftStairs:true
	},
	
	{
		name:"prismarineCrystals",
		Name:"Prismarine Crystals",
		category:"items",
		item:true
	},
	{
		name:"prismarineShard",
		Name:"Prismarine Shard",
		item:true,
		category:"items"
	},
	
	{
		name:"seaLantern",
		Name:"Sea Lantern",
		lightLevel:15,
		hardness:0.3,
		category:"decoration"
	},
	
	{
		name:"oakLeaves",
		Name: "Oak Leaves",
		transparent: true,
		cullFace:0,
		hardness:0.2,
		type:"plant2",
		leaves:true,
		drop: function(){
			if(rand() > 0.8){
				let r = floor(rand(3))
				if(r === 0) return "stick"
				else if(r === 1) return "oakSapling"
				else{
					return rand() > 0.8 ? "orange" : "apple"
				}
			}
		},
		dropSelfWhenSheared:true,
		shearBreakTime:0.05,
		burnChance: 0.2,
		burnTime: 30,
		compostChance:0.3,
		grassSound: true,
		
		category:"nature",
		tint:leafTint,
		biomeTintTop:true,
		biomeTintBottom:true,
		biomeTintEast:true,
		biomeTintWest:true,
		biomeTintNorth:true,
		biomeTintSouth:true,
		invTint:[leafColor.r,leafColor.g,leafColor.b],
	},
	
	{
		name: "acaciaLeaves",
		Name:"Acacia Leaves",
		transparent: true,
		cullFace:0,
		hardness:0.2,
		type:"plant2",
		leaves:true,
		drop: function(){
			if(rand() > 0.8){
				let r = floor(rand(3))
				if(r === 0) return "stick"
				else if(r === 1) return "acaciaSapling"
			}
		},
		dropSelfWhenSheared:true,
		shearBreakTime:0.05,
		burnChance: 0.2,
		burnTime: 30,
		compostChance:0.3,
		grassSound: true,
		
		category:"nature",
		tint:leafTint,
		biomeTintTop:true,
		biomeTintBottom:true,
		biomeTintEast:true,
		biomeTintWest:true,
		biomeTintNorth:true,
		biomeTintSouth:true,
		invTint:[leafColor.r,leafColor.g,leafColor.b],
	},
	{
		name: "birchLeaves",
		Name:"Birch Leaves",
		transparent: true,
		cullFace:0,
		hardness:0.2,
		type:"plant2",
		leaves:true,
		drop: function(){
			if(rand() > 0.8){
				let r = floor(rand(3))
				if(r === 0) return "stick"
				else if(r === 1) return "birchSapling"
			}
		},
		dropSelfWhenSheared:true,
		shearBreakTime:0.05,
		burnChance: 0.2,
		burnTime: 30,
		compostChance:0.3,
		grassSound: true,
		category:"nature",
      
		tint:leafTint,
		biomeTintTop:true,
		biomeTintBottom:true,
		biomeTintEast:true,
		biomeTintWest:true,
		biomeTintNorth:true,
		biomeTintSouth:true,
		invTint:[leafColor.r,leafColor.g,leafColor.b],
	},
	{
		name: "darkOakLeaves",
		Name:"Dark Oak Leaves",
		transparent: true,
		cullFace:0,
		hardness:0.2,
		type:"plant2",
		leaves:true,
		drop: function(){
			if(rand() > 0.8){
				let r = floor(rand(3))
				if(r === 0) return "stick"
				else if(r === 1) return "darkOakSapling"
				else return "apple"
			}
		},
		dropSelfWhenSheared:true,
		shearBreakTime:0.05,
		burnChance: 0.2,
		burnTime: 30,
		compostChance:0.3,
		grassSound: true,
		
		category:"nature"
	},
	{
		name: "jungleLeaves",
		Name:"Jungle Leaves",
		transparent: true,
		cullFace:0,
		hardness:0.2,
		type:"plant2",
		leaves:true,
		drop: function(){
			if(rand() > 0.8){
				let r = floor(rand(3))
				if(r === 0) return "stick"
				else if(r === 1) return "jungleSapling"
			}
		},
		dropSelfWhenSheared:true,
		shearBreakTime:0.05,
		burnChance: 0.2,
		burnTime: 30,
		compostChance:0.3,
		grassSound: true,
		
		category:"nature",
      
		tint:leafTint,
		biomeTintTop:true,
		biomeTintBottom:true,
		biomeTintEast:true,
		biomeTintWest:true,
		biomeTintNorth:true,
		biomeTintSouth:true,
		invTint:[leafColor.r,leafColor.g,leafColor.b],
	},
	{
		name: "spruceLeaves",
		Name:"Spruce Leaves",
		transparent: true,
		cullFace:0,
		hardness:0.2,
		type:"plant2",
		leaves:true,
		drop: function(){
			if(rand() > 0.8){
				let r = floor(rand(3))
				if(r === 0) return "stick"
				else if(r === 1) return "spruceSapling"
			}
		},
		dropSelfWhenSheared:true,
		shearBreakTime:0.05,
		burnChance: 0.2,
		burnTime: 30,
		compostChance:0.3,
		grassSound: true,
		category:"nature"
	},
	
	{
		name:"spyglass",
		Name:"Spyglass",
		textures:"spyglassModel",
		iconTexture:"spyglass",
		item:true,
		spyglass:true,
		category:"items"
	},
	
	{
		name:"egg",
		Name:"Egg",
		item:true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			item.amount--
			let pd = p.direction
			world.addEntity(new entities[entityIds.Egg](p.x+pd.x,p.y+pd.y,p.z+pd.z, pd.x*0.8, pd.y*0.8, pd.z*0.8, p.id))
		},
		useAnywhere:true,
		category:"items"
	},
	{
		name:"noodles",
		Name:"Noodles",
		item:true,
		category:"food",
		hidden:true
	},
	
	{
		name:"bowl",
		Name:"Bowl",
		item:true,
		category:"items"
	},
	{
		name:"mushroomStew",
		Name:"Mushroom Stew",
		edible: true,
		item:true,
		eatWhenFull: false,
		food: 6,
		saturation: 7.2,
		eatResult:"bowl",
		category:"food"
	},
	{
		name:"ramen",
		Name:"Ramen! Yum!",
		edible: true,
		item:true,
		eatWhenFull: true,
		food: 8,
		saturation: 10,
		eatResult:"bowl",
		category:"food",
		hidden:true
	},
	{
		name:"orange",
		Name:"Orange",
		edible: true,
		item:true,
		eatWhenFull: false,
		food: 4,
		saturation: 2.4,
		category:"food"
	},
	
	{
		name:"fern",
		Name:"Fern",
		solid: false,
		transparent: true,
		shadow: false,
		flatIcon: true,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		potCross:true,
		invTint:[grassColor.r,grassColor.g,grassColor.b],
		tint:grassTint,
		biomeTintNorth:true,
		biomeTintSouth:true,
		biomeTintEast:true,
		biomeTintWest:true,
		randomOffset:true,
	},
	{
		name: "largeFern",
		Name:"Large Fern",
		solid: false,
		transparent: true,
		shadow: false,
		textures: "largeFernConnected",
		tallcrossShape: true,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		invTint:[grassColor.r,grassColor.g,grassColor.b],
		tint:grassTint,
		biomeTintNorth:true,
		biomeTintSouth:true,
		biomeTintEast:true,
		biomeTintWest:true,
		randomHeight:true,
		randomOffset:true
	},
	
	{
		name:"fire",
		fire:true,
		damage:1,
		burnEnt:true,
		transparent:true,
		shadow:false,
		shade:false,
		solid:false,
		lightLevel:15,
		ambientSound:"fire.fire",
		temperature:20,
		smoothLight:false,
		hidden:true,
		liquidBreakable:true,
		noHitbox:true,
		tagBits:{
			age:[0,8]
		},
		getAttached:function(x,y,z,block,getBlockOnly,world){
			var ax = x, ay = y, az = z
			switch(block){
				case this.id:
					ay--
					break
				case this.id | STAIR:
					ay++
					break
				case this.id | SLAB | NORTH:
					az++
					break
				case this.id | SLAB | SOUTH:
					az--
					break
				case this.id | SLAB | EAST:
					ax++
					break
				case this.id | SLAB | WEST:
					ax--
					break
			}
			var attached = world.getBlock(ax,ay,az)
			if(getBlockOnly) return attached
			else return [attached,ax,ay,az]
		},
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			var block = this.getAttached(x,y,z,b,true,world)
			if(!block || !blockData[block].solid && !blockData[block].liquid) world.setBlock(x,y,z,0,false,false,false,false)
		},
		tick:function(x,y,z,world){
			var block = world.getBlock(x,y,z)
			var attached = this.getAttached(x,y,z,block,false,world)
			var ax = attached[1], ay = attached[2], az = attached[3]
			attached = attached[0]
			var age = world.getTagByName(x,y,z,"age")
			if(!age) age = 0
			age += rand(10,11)
			//finish burning
			if(age >= 15 && (!attached || !blockData[attached].burnTime)){
				return world.setBlock(x,y,z,0,false,false,false,false)
			}
			if(attached && blockData[attached].burnTime && age > blockData[attached].burnTime){
				world.setBlock(x,y,z,0,false,false,false,false)
				world.setBlock(ax,ay,az,0,false,false,false,false)
				return
			}
			if(age > 255) age = 255
			world.setTagByName(x,y,z,"age",age,false)

			if(world.weather === "rain" && world.weatherAmount > 0.5){
				let top = world.getSolidTop(x,z)
				if(y > top) world.setBlock(x,y,z,0,false,false,false,false) //rain extinguish
			}
			
			this.spread(x,y,z,world)
		},
		spread:function(x,y,z,world){
			for(var i=x-1; i<=x+1; i++){
				for(var j=y-1; j<=y+4; j++){
					for(var k=z-1; k<=z+1; k++){
						var block = world.getBlock(i,j,k)
						if(block && blockData[block].burnChance && rand() < blockData[block].burnChance){
							if(blockData[block].onburn) blockData[block].onburn(i,j,k,world)
							var block
							let rx, ry, rz
							//find a place where the fire can go
							for(var t=0; t<6; t++){
								rx = i, ry = j, rz = k
								switch(floor(rand(6))){
									case 0:
										block = this.id
										ry++
										break
									case 1:
										block = this.id | STAIR
										ry--
										break
									case 2:
										block = this.id | SLAB | NORTH
										rz--
										break
									case 3:
										block = this.id | SLAB | SOUTH
										rz++
										break
									case 4:
										block = this.id | SLAB | EAST
										rx--
										break
									case 5:
										block = this.id | SLAB | WEST
										rx++
										break
								}
								if(!world.getBlock(rx,ry,rz)) break
							}
							if(!world.getBlock(rx,ry,rz)) world.setBlock(rx,ry,rz,block,false,false,false,false)
						}
					}
				}
			}
		},
		tryCreatePortalZ:function(x,y,z,world){ //weird portals are allowed
			let spread = [], spreadAt = [x,y,z,0], maxSpread = 23, block
			while(spreadAt.length){
				let [sx,sy,sz,i] = spreadAt.splice(0,4)
				spread.push(sx,sy,sz,i)
				if(max(abs(sx-x),abs(sy-y),abs(sz-z)) > maxSpread) return
				block = world.getBlock(sx,sy,sz+1)
				if(!xyArrayHas(spread,spreadAt,sx,sy,sz+1)){
					if(!blockData[block].solid) spreadAt.push(sx,sy,sz+1,i+1)
					else if(block !== blockIds.obsidian) return
				}
				block = world.getBlock(sx,sy,sz-1)
				if(!xyArrayHas(spread,spreadAt,sx,sy,sz-1)){
					if(!blockData[block].solid) spreadAt.push(sx,sy,sz-1,i+1)
					else if(block !== blockIds.obsidian) return
				}
				block = world.getBlock(sx,sy+1,sz)
				if(!xyArrayHas(spread,spreadAt,sx,sy+1,sz)){
					if(!blockData[block].solid) spreadAt.push(sx,sy+1,sz,i+1)
					else if(block !== blockIds.obsidian) return
				}
				block = world.getBlock(sx,sy-1,sz)
				if(!xyArrayHas(spread,spreadAt,sx,sy-1,sz)){
					if(!blockData[block].solid) spreadAt.push(sx,sy-1,sz,i+1)
					else if(block !== blockIds.obsidian) return
				}
			}
			for(let i=0; i<spread.length; i+=4){
				world.setBlock(spread[i],spread[i+1],spread[i+2],blockIds.portal|PORTAL|EAST)
			}
			return true
		},
		tryCreatePortalX:function(x,y,z,world){ //weird portals are allowed
			let spread = [], spreadAt = [x,y,z,0], maxSpread = 23, block
			while(spreadAt.length){
				let [sx,sy,sz,i] = spreadAt.splice(0,4)
				spread.push(sx,sy,sz,i)
				if(max(abs(sx-x),abs(sy-y),abs(sz-z)) > maxSpread) return
				block = world.getBlock(sx+1,sy,sz)
				if(!xyArrayHas(spread,spreadAt,sx+1,sy,sz)){
					if(!blockData[block].solid) spreadAt.push(sx+1,sy,sz,i+1)
					else if(block !== blockIds.obsidian) return
				}
				block = world.getBlock(sx-1,sy,sz)
				if(!xyArrayHas(spread,spreadAt,sx-1,sy,sz)){
					if(!blockData[block].solid) spreadAt.push(sx-1,sy,sz,i+1)
					else if(block !== blockIds.obsidian) return
				}
				block = world.getBlock(sx,sy+1,sz)
				if(!xyArrayHas(spread,spreadAt,sx,sy+1,sz)){
					if(!blockData[block].solid) spreadAt.push(sx,sy+1,sz,i+1)
					else if(block !== blockIds.obsidian) return
				}
				block = world.getBlock(sx,sy-1,sz)
				if(!xyArrayHas(spread,spreadAt,sx,sy-1,sz)){
					if(!blockData[block].solid) spreadAt.push(sx,sy-1,sz,i+1)
					else if(block !== blockIds.obsidian) return
				}
			}
			for(let i=0; i<spread.length; i+=4){
				world.setBlock(spread[i],spread[i+1],spread[i+2],blockIds.portal|PORTAL|NORTH)
			}
			return true
		},
		tryCreatePortal:function(x,y,z,world){
			return this.tryCreatePortalZ(x,y,z,world) || this.tryCreatePortalX(x,y,z,world)
		}
	},
	
	{
		name: "endRod",
		Name:"End Rod",
		transparent: true,
		shadow: false,
		lightLevel: 15,
		category:"decoration"
	},
	
	{
		name: "oakWood",
		Name:"Oak Wood",
		textures: "logSide",
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"nature",
		log:true
	},
	{
		name: "acaciaWood",
		Name:"Acacia Wood",
		textures: "acaciaLogSide",
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"nature",
		log:true
	},
	{
		name: "birchWood",
		Name:"Birch Wood",
		textures: "birchLogSide",
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"nature",
		log:true
	},
	{
		name: "darkOakWood",
		Name:"Dark Oak Wood",
		textures: "darkOakLogSide",
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"nature",
		log:true
	},
	{
		name: "jungleWood",
		Name:"Jungle Wood",
		textures: "jungleLogSide",
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"nature",
		log:true
	},
	{
		name: "spruceWood",
		Name:"Spruce Wood",
		textures: "spruceLogSide",
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"nature",
		log:true
	},
	{
		name: "crimsonHyphae",
		textures: "crimsonStemSide",
		stemSound: true,
		hardness:2,
		type:"wood",
		category:"nature"
	},
	{
		name: "warpedHyphae",
		textures: "warpedStemSide",
		stemSound: true,
		hardness:2,
		type:"wood",
		category:"nature"
	},
	
	{
		name: "strippedOakWood",
		Name:"Stripped Oak Wood",
		textures: "strippedOakLog",
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"build"
	},
	{
		name: "strippedAcaciaWood",
		Name:"Stripped Acacia Wood",
		textures: "strippedAcaciaLog",
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"build"
	},
	{
		name: "strippedBirchWood",
		Name:"Stripped Birch Wood",
		textures: "strippedBirchLog",
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"build"
	},
	{
		name: "strippedDarkOakWood",
		Name:"Stripped Dark Oak Wood",
		textures: "strippedDarkOakLog",
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"build"
	},
	{
		name: "strippedJungleWood",
		Name:"Stripped Jungle Wood",
		textures: "strippedJungleLog",
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"build"
	},
	{
		name: "strippedSpruceWood",
		Name:"Stripped Spruce Wood",
		textures: "strippedSpruceLog",
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"build"
	},
	{
		name: "strippedCrimsonHyphae",
		textures: "strippedCrimsonStem",
		stemSound: true,
		hardness:2,
		type:"wood",
		category:"build"
	},
	{
		name: "strippedWarpedHyphae",
		textures: "strippedWarpedStem",
		stemSound: true,
		hardness:2,
		type:"wood",
		category:"build"
	},
	
	{
		name:"oakFenceGate",
		Name:"Oak Fence Gate",
		textures:"oakPlanks",
		fenceGate:true,
		hardness:2,
		woodSound:true,
		type:"wood",
		category:"build"
	},
	{
		name:"acaciaFenceGate",
		Name:"Acacia Fence Gate",
		textures:"acaciaPlanks",
		fenceGate:true,
		hardness:2,
		woodSound:true,
		type:"wood",
		category:"build"
	},
	{
		name:"birchFenceGate",
		Name:"Birch Fence Gate",
		textures:"birchPlanks",
		fenceGate:true,
		hardness:2,
		woodSound:true,
		type:"wood",
		category:"build"
	},
	{
		name:"darkOakFenceGate",
		Name:"Dark Oak Fence Gate",
		textures:"darkOakPlanks",
		fenceGate:true,
		hardness:2,
		woodSound:true,
		type:"wood",
		category:"build"
	},
	{
		name:"jungleFenceGate",
		Name:"Jungle Fence Gate",
		textures:"junglePlanks",
		fenceGate:true,
		hardness:2,
		woodSound:true,
		type:"wood",
		category:"build"
	},
	{
		name:"spruceFenceGate",
		Name:"Spruce Fence Gate",
		textures:"sprucePlanks",
		fenceGate:true,
		hardness:2,
		woodSound:true,
		type:"wood",
		category:"build"
	},
	{
		name:"crimsonFenceGate",
		Name:"Crimson Fence Gate",
		textures:"crimsonPlanks",
		fenceGate:true,
		hardness:2,
		woodSound:true,
		type:"wood",
		category:"build"
	},
	{
		name:"warpedFenceGate",
		Name:"Warped Fence Gate",
		textures:"warpedPlanks",
		fenceGate:true,
		hardness:2,
		woodSound:true,
		type:"wood",
		category:"build"
	},
	
	{ 
		name: "kelp",
		Name:"Kelp",
		flatIcon:true,
		iconTexture:"kelpIcon",
		transparent: true,
		solid: false,
		shadow: false,
		crossShape: true,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			var top = world.getBlock(x,y+1,z)
			var isIt = blockData[top].name === "kelp" || blockData[top].name === "kelpPlant"
			if(isIt){
				world.setBlock(x,y,z,blockIds.kelpPlant | CROSS,false,false,false,false)
			}
		},
		category:"nature"
	},
	{ 
		name: "kelpPlant",
		transparent: true,
		solid: false,
		shadow: false,
		crossShape: true,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			var top = world.getBlock(x,y+1,z)
			var isIt = blockData[top].name === "kelp" || blockData[top].name === "kelpPlant"
			if(!isIt){
				world.setBlock(x,y,z,blockIds.kelp | CROSS,false,false,false,false)
			}
		},
		hidden:true
	},
	
	{
		name:"seagrass",
		Name:"Seagrass",
		iconTexture:"seagrassIcon",
		transparent: true,
		solid: false,
		shadow: false,
		crop:true,
		category:"nature"
	},
	{
		name:"tallSeagrass",
		Name:"Tall Seagrass",
		textures:"tallSeagrassConnected",
		transparent: true,
		solid: false,
		shadow: false,
		tallCrop:true,
		category:"nature"
	},
	
	{
		name:"barrel",
		Name:"Barrel",
		textures:["barrelBottom","barrelTop","barrelSide"],
		texturesOpen:fillTextureArray(["barrelBottom","barrelTopOpen","barrelSide"]),
		texturesSW:fillTextureArray(["barrelSide","barrelSide","barrelTop","barrelSide"]),
		texturesSWOpen:fillTextureArray(["barrelSide","barrelSide","barrelTopOpen","barrelSide"]),
		texturesDown:fillTextureArray(["barrelTop","barrelBottom","barrelSide"]),
		texturesDownOpen:fillTextureArray(["barrelTopOpen","barrelBottom","barrelSide"]),
		woodSound:true,
		barrel:true,
		category:"items",
		tagBits: null,
		hasContents:function(tags){return tags&&tags.contents},
		setContents:function(x,y,z,world){
			let data = {chest:true, contents:new Array(27).fill(0)}
			world.setTags(x, y, z, data,false)
			return data
		},
		onbreak:function(x,y,z, block, data,world){
			if(!(data && data.chest && data.contents)) return
			data = data.contents
			for(var i=0; i<data.length; i++){
				if(data[i]){
					world.addItems(x,y,z,0,0,0,data[i].id, true, data[i].amount, data[i].durability, data[i].customName)
				}
			}
		},
	},
	
	{
		name:"endStoneBricks",
		Name:"End Stone Bricks",
		stoneSound:true,
		category:"build",
		craftSlabs:true, craftStairs:true
	},
	
	{
		name:"beeNest",
		Name:"Bee Nest",
		textures:["beeNestBottom","beeNestTop","beeNestSide","beeNestFront","beeNestSide","beeNestSide"],
		texturesHoney:["beeNestBottom","beeNestTop","beeNestSide","beeNestFrontHoney","beeNestSide","beeNestSide"],
		rotate:true,
		category:"nature"
	},
	{
		name:"beehive",
		Name:"Beehive",
		textures:["beehiveEnd","beehiveEnd","beehiveSide","beehiveFront","beehiveSide","beehiveSide"],
		texturesHoney:["beehiveEnd","beehiveEnd","beehiveSide","beehiveFrontHoney","beehiveSide","beehiveSide"],
		rotate:true,
		category:"items"
	},
	
	{
		name:"honeyBlock",
		Name:"Block of Honey",
		textures:"honeyBlockBottom",
		transparent:true,
		shapeName:"honeyBlock",
		damageResistance:0.8,
		category:"build",
		sticky:true
	},
	{
		name:"honeycomb",
		Name:"Honeycomb",
		item:true,
		category:"items"
	},
	{
		name:"honeycombBlock",
		Name:"Honeycomb Block",
		category:"build"
	},
	
	{
		name:"coarseDirt",
		Name:"Coarse Dirt",
		hardness:1,
		type:"ground",
		category:"nature",
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true,
		digSound: ["dirt.dig1", "dirt.dig2", "dirt.dig3", "dirt.dig4"],
		stepSound: ["dirt.step1", "dirt.step2","dirt.step3","dirt.step4"]
	},
	
	{
		name:"inkSac",
		Name:"Ink Sac",
		item:true,
		category:"items"
	},
	{
		name:"glowInkSac",
		Name:"Glow Ink Sac",
		item:true,
		category:"items"
	},
	
	{
		name:"glowItemFrame",
		Name:"Glow Item Frame",
		transparent:true,
		itemFrame:true,
		flatIcon:true,
		iconTexture:"glowItemFrameIcon",
		category:"items"
	},
	{
		name:"glowLichen",
		Name:"Glow Lichen",
		transparent: true,
		shadow: false,
		wallFlat: true,
		flatIcon:true,
		solid:false,
		lightLevel:7,
		compostChance:0.5,
		category:"nature"
	},
	
	{
		name:"sponge",
		Name:"Sponge",
		wetTexture:new Array(6).fill("wetSponge"),
		category:"items",
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
	},
	
	{
		name:"cutCopper",
		Name:"Cut Copper",
		category:"build",
		craftSlabs:true, craftStairs:true
	},
	{
		name:"exposedCopper",
		Name:"Exposed Block of Copper",
		category:"build",
		craftSlabs:true, craftStairs:true
	},
	{
		name:"exposedCutCopper",
		Name:"Exposed Cut Copper",
		category:"build",
		craftSlabs:true, craftStairs:true
	},
	{
		name:"weatheredCopper",
		Name:"Weathered Block of Copper",
		category:"build",
		craftSlabs:true, craftStairs:true
	},
	{
		name:"weatheredCutCopper",
		Name:"Weathered Cut Copper",
		category:"build",
		craftSlabs:true, craftStairs:true
	},
	{
		name:"oxidizedCopper",
		Name:"Oxidized Block of Copper",
		category:"build",
		craftSlabs:true, craftStairs:true
	},
	{
		name:"oxidizedCutCopper",
		Name:"Oxidized Cut Copper",
		category:"build",
		craftSlabs:true, craftStairs:true
	},
	
	{
		name:"quartzBricks",
		Name:"Quartz Bricks",
		stoneSound:true,
		category:"build",
		craftSlabs:true, craftStairs:true
	},
	
	{
		name:"campfire",
		Name:"Campfire",
		flatIcon:true,
		iconTexture:"campfire",
		textures: "campfireLogLit",
		campfire:true,
		shadow:false,
		lightLevel:15,
		transparent:true,
		woodSound:true,
		drop:"campfire",
		category:"items",
		damageUp:2,
		burnEnt:true,
		smoothLight:false,
		blastResistance:2,
		hardness:2,
		activate:function(x,y,z,block,ent,world){
			if(ent.burning && block === (this.id | SLAB) && onBoxEnt(x,y,z,1,1,1,ent)){
				world.setBlock(x,y,z,this.id,false,false,false,false)
			}
		}
	},
	{
		name:"soulCampfire",
		Name:"Soul Campfire",
		flatIcon:true,
		iconTexture:"soulCampfire",
		textures: "soulCampfireLogLit",
		campfire:true,
		shadow:false,
		lightLevel:10,
		transparent:true,
		woodSound:true,
		drop:"soulCampfire",
		category:"items",
		damageUp:4,
		burnEnt:true,
		smoothLight:false,
		blastResistance:2,
		hardness:2,
		activate:function(x,y,z,block,ent,world){
			if(ent.burning && block === (this.id | SLAB) && onBoxEnt(x,y,z,1,1,1,ent)){
				world.setBlock(x,y,z,this.id,false,false,false,false)
			}
		}
	},
	
	{
		name:"bambooShoot",
		Name:"Bamboo Shoot",
		textures:"bambooStage0",
		solid: false,
		transparent: true,
		shadow: false,
		crossShape: true,
		liquidBreakable:"drop",
		category:"nature",
		potCross:true,
		randomOffset:true,
	},
	{
		name:"bambooStalk",
		Name:"Bamboo",
		iconTexture:"bamboo",
		flatIcon:true,
		bamboo:true,
		shadow: false,
		potCross:true,
		transparent:true,
		drop:"bambooStalk",
		hardness:1,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			needsSupportingBlocks(x,y,z,b,world)
		},
		liquidBreakable:"drop",
		category:"nature",
		randomOffset:true
	},
	
	{
		name:"chest",
		Name:"Chest",
		textures:/*"christmasChestSide",//*/"chest",//christmas
		transparent:true,
		chest:true,
		tagBits: null,
		hasContents:function(tags){return tags&&tags.contents},
		setContents:function(x,y,z,world){
			let data = {chest:true, contents:new Array(27).fill(0)}
			world.setTags(x, y, z, data,false)
			return data
		},
		onbreak:function(x,y,z, block, data,world){
			if(!(data && data.chest && data.contents)) return
			data = data.contents
			for(var i=0; i<data.length; i++){
				if(data[i]){
					world.addItems(x,y,z,0,0,0,data[i].id, true, data[i].amount, data[i].durability, data[i].customName)
				}
			}
		},
		category:"items"
	},
	{
		name:"boneMeal",
		Name:"Bone \"Meal\"",
		item:true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			item.amount--
			if(blockData[block].grow){
				blockData[block].grow(x,y,z,world)
			}else if(blockData[block].growBonemeal){
				blockData[block].growBonemeal(x,y,z,world)
			}else return true
			world.glint(x,y,z)
		},
		category:"items"
	},
	
	{
		name:"clay",
		Name:"Clay",
		hardness:0.6,
		type:"ground",
		digSound: ["dirt.dig1", "dirt.dig2", "dirt.dig3", "dirt.dig4"],
		stepSound: ["dirt.step1", "dirt.step2","dirt.step3","dirt.step4"],
		drop:"clayBall",
		dropAmount:4,
		category:"nature"
	},
	{
		name:"clayBall",
		Name:"Clay Ball",
		item:true,
		category:"items"
	},
	{
		name:"brick",
		Name:"Brick",
		item:true,
		category:"items"
	},
	
	{
		name:"charcoal",
		Name:"Charcoal",
		item:true,
		category:"items"
	},
	
	{
		name:"appleCore",
		Name:"Apple Core",
		item:true,
		category:"items"
	},
	
	{
		name:"tintedGlass",
		Name:"Tinted Glass",
		transparent: true,
		shadow: true,
		hardness: 0.3,
		type: "glass",
		glassSound: true,
		category:"build"
	},
	
	{
		name:"tomato",
		Name:"Tomato",
		item:true,
		edible:true,
		eatWhenFull: false,
		food: 3,
		saturation: 2,
		eatResult:"tomatoSeeds",
		category:"food"
	},
	{
		name:"tomatoPlant",
		Name:"Tomato Plant",
		textures:new Array(6).fill("tomatoPlantStage0"),
		textures1:new Array(6).fill("tomatoPlantStage1"),
		textures2:new Array(6).fill("tomatoPlantStage2"),
		textures3:new Array(6).fill("tomatoPlantStage3"),
		textures4:new Array(6).fill("tomatoPlantStage4"),
		iconTexture:"tomatoPlantStage3",
		flatIcon:true,
		shadow:false,
		transparent:true,
		solid:false,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			needsSupportingBlocks(x,y,z,b,world)
		},
		category:"nature",
		liquidBreakable:"drop",
		growBonemeal:function(x,y,z,world){
			world.setBlock(x,y,z, this.id|TALLCROSS)
		}
	},
	{
		name:"tomatoSeeds",
		Name:"Tomato Seeds",
		item:true,
		useAs:function(x,y,z,block,face){
			if(!block) return
			if(face === "top" && blockData[block].name === "farmland"){
				return "tomatoPlant"
			}
		},
		category:"nature"
	},
	
	{
		name:"newCactusFruit",
		Name:"New Cactus Fruit",
		solid: false,
		transparent: true,
		shadow: false,
		crossShape: true,
		cactusFruit:true,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			needsSupportingBlocks(x,y,z,b,world)
		},
		compostChance:0.3,
		liquidBreakable:true,
		category:"nature"
	},
	{
		name:"greenCactusFruit",
		Name:"Green Cactus Fruit",
		solid: false,
		transparent: true,
		shadow: false,
		crossShape: true,
		cactusFruit:true,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			needsSupportingBlocks(x,y,z,b,world)
		},
		compostChance:0.4,
		liquidBreakable:true,
		category:"nature"
	},
	{
		name:"redCactusFruit",
		Name:"Red Cactus Fruit",
		solid: false,
		transparent: true,
		shadow: false,
		crossShape: true,
		edible: true,
		eatWhenFull: false,
		food: 2,
		saturation: 1,
		cactusFruit:true,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			needsSupportingBlocks(x,y,z,b,world)
		},
		compostChance:0.5,
		liquidBreakable:true,
		category:"food"
	},
	{
		name:"purpleCactusFruit",
		Name:"Purple Cactus Fruit",
		solid: false,
		transparent: true,
		shadow: false,
		crossShape: true,
		edible: true,
		eatWhenFull: false,
		food: 3,
		saturation: 2,
		cactusFruit:true,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			needsSupportingBlocks(x,y,z,b,world)
		},
		compostChance:0.6,
		liquidBreakable:true,
		category:"food"
	},
	
	{
		name:"cherry",
		Name:"Cherry",
		item:true,
		edible:true,
		eatWhenFull: false,
		food: 1,
		saturation: 1,
		compostChance:0.5,
		category:"food"
	},
	{
		name:"cherryLog",
		Name:"Cherry Log",
		textures:["cherryLogTop","cherryLog"],
		woodSound:true,
		hardness:2,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"nature",
		log:true
	},
	{
		name:"cherryLogSW",
		textures: ["cherryLog","cherryLog","cherryLogTop","cherryLog"],
		rotate: true,
		woodSound:true,
		hidden:true
	},
	{
		name:"greenCherryLeaves", //Before minecraft 1.20 update
		Name:"Green Cherry Leaves",
		transparent: true,
		cullFace:0,
		hardness: 0.2,
		type:"plant2",
		leaves:true,
		drop: function(){
			if(rand() > 0.8){
				let r = floor(rand(3))
				if(r === 0) return "stick"
				else if(r === 1) return "cherrySapling"
				else return "cherry"
			}
		},
		dropSelfWhenSheared:true,
		shearBreakTime:0.05,
		burnChance: 0.2,
		burnTime: 30,
		grassSound: true,
		category:"nature",
		hidden:true
	},
	{
		name:"cherryLeaves",
		Name:"Cherry Leaves",
		transparent: true,
		cullFace:0,
		hardness: 0.2,
		type:"plant2",
		drop: function(){
			if(rand() > 0.8){
				let r = floor(rand(3))
				if(r === 0) return "stick"
				else if(r === 1) return "cherrySapling"
				else if(rand() > 0.5) return "cherry"
			}
		},
		dropSelfWhenSheared:true,
		shearBreakTime:0.05,
		burnChance: 0.2,
		burnTime: 30,
		grassSound: true,
		category:"nature"
	},
	{
		name:"cherrySapling",
		Name:"Cherry Sapling",
		transparent: true,
		shadow: false,
		solid: false,
		crossShape: true,
		potCross: true,
		category:"nature",
		grow: function(x,y,z,world){
			win.serverSaveWorldGen()
			world.getChunk(x,z).spawnCherryTree(x&15,y-1,z&15,x,z,true)
			win.serverRestoreWorldGen()
		}
	},
	{
		name:"cherryWood",
		Name:"Cherry Wood",
		textures: "cherryLog",
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"nature",
		log:true
	},
	
	{
		name:"slingshot",
		Name:"Slingshot",
		item:true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			var pd = p.direction
			world.addEntity(new entities[entityIds.SlingshotShot](p.x,p.y,p.z,pd.x,pd.y,pd.z))
		},
		useAnywhere:true,
		stackSize:1,
		category:"tools"
	},
	
	{
		name:"redstoneTorch",
		Name:"Redstone Torch",
		transparent: true,
		shadow: false,
		redstoneTorch: true,
		lightLevel: 7,
		woodSound:true,
		solid:false,
		flatIcon:true,
		onupdate: function(x,y,z,b,world,sx,sy,sz){
			this.onpowerupdate(x,y,z,null,null,null,null,world)
			
			if(world.getPower(x,y,z) === 16){ //is torch on?
				var b = world.getBlock(x,y+1,z)
				if(b && !blockData[b].transparent){
					world.setBlockPower(x,y+1,z, "strong", "bottom") //torch is under this block
				}
				
				b = world.getBlock(x,y-1,z)
				if(b && blockData[b].carryRedstone){
					world.setPower(x,y-1,z,15,false)
					world.spreadPower(x,y-1,z,15)
				}
			}
		},
		onpowerupdate: function(x,y,z,sx,sy,sz,blockPowerChanged,world){
			var that = this
			world.setTimeout(function(){
				//find block it's attached to
				var me = world.getBlock(x,y,z)
				var ax=x,ay=y,az=z
				var wall = that.id | SLAB
				var wallOff = that.id | STAIR
				switch(me){
					case wall | NORTH:
					case wallOff | NORTH:
						az++
						break
					case wall | SOUTH:
					case wallOff | SOUTH:
						az--
						break
					case wall | EAST:
					case wallOff | EAST:
						ax++
						break
					case wall | WEST:
					case wallOff | WEST:
						ax--
						break
					default:
						ay--
				}
				var block = world.getBlock(ax,ay,az)
				//see if the torch should be on of off
				var on = world.getPower(ax,ay,az) || world.getBlockPower(ax,ay,az,null) ? false : true
				var target = me
				if(on){
					switch(me){
						case wallOff | NORTH:
							target = wall | NORTH
							break
						case wallOff | SOUTH:
							target = wall | SOUTH
							break
						case wallOff | EAST:
							target = wall | EAST
							break
						case wallOff | WEST:
							target = wall | WEST
							break
						case that.id | CROSS:
							target = that.id
					}
				}else{
					switch(me){
						case wall | NORTH:
							target = wallOff | NORTH
							break
						case wall | SOUTH:
							target = wallOff | SOUTH
							break
						case wall | EAST:
							target = wallOff | EAST
							break
						case wall | WEST:
							target = wallOff | WEST
							break
						case that.id:
							target = that.id | CROSS
					}
				}

				//set it
				if(me !== target) {
					world.setBlock(x,y,z,target,false,false,false,false)
					if(on){
						world.setPower(x,y,z,16,false)
						world.spreadPower(x,y,z,16)
					}else{
						world.setPower(x,y,z,0,false)
						world.unspreadPower(x,y,z,16,false)
					}
					
					var b = world.getBlock(x,y+1,z)
					if(b && !blockData[b].transparent){
						world.setBlockPower(x,y+1,z, on ? "strong" : null, "bottom") //torch is under this block
					}
					b = world.getBlock(x,y-1,z)
					if(b && blockData[b].carryRedstone){
						if(on){
							world.setPower(x,y-1,z,15,false)
							world.spreadPower(x,y-1,z,15)
						}else{
							world.unspreadPower(x,y-1,z,15,true)
						}
					}
				}
			},tickTime*2, x,y,z)
		},
		onset:function(x,y,z,world){
			world.setPower(x,y,z,16,false)
			world.spreadPower(x,y,z,16)
		},
		ondelete:function(x,y,z,prevTags,prev,world){
			world.setPower(x,y,z,0,false)
			world.unspreadPower(x,y,z,16,false)
			
			var b = world.getBlock(x,y+1,z)
			if(b && !blockData[b].transparent){
				world.setBlockPower(x,y+1,z, null, "bottom") //torch is under this block
			}
			b = world.getBlock(x,y-1,z)
			if(b && blockData[b].carryRedstone){
				world.unspreadPower(x,y-1,z,15,true)
			}
		},
		category:"redstone"
	},
	{
		name:"redstoneConnector",
		Name:"Block That Redstone Dust Connects To",
		stoneSound:true,
		category:"redstone"
	},
	{
		name:"lever",
		Name:"Lever",
		transparent:true,
		shadow:false,
		solid:false,
		lever:true,
		flatIcon:true,
		onclick:function(x,y,z,world){
			var block = world.getBlock(x,y,z)
			var me = blockData[blockIds.lever]
			var wall = me.id
			var wallOn = me.id | SLAB
			var ax = x, ay = y, az = z
			var dir
			switch(block){
				case wall | NORTH:
				case wallOn | NORTH:
					az++
					dir = "south"
					break
				case wall | SOUTH:
				case wallOn | SOUTH:
					az--
					dir = "north"
					break
				case wall | EAST:
				case wallOn | EAST:
					ax++
					dir = "east"
					break
				case wall | WEST:
				case wallOn | WEST:
					ax--
					dir = "west"
					break
				case me.id | STAIR:
				case me.id | CROSS:
					ay --
					dir = "top"
					break
				case me.id | TALLCROSS:
				case me.id | DOOR:
					ay ++
					dir = "bottom"
					break
			}
			var target, on
			switch(block){
				case wall | NORTH:
					on = true
					target = wallOn | NORTH
					break
				case wall | SOUTH:
					on = true
					target = wallOn | SOUTH
					break
				case wall | EAST:
					on = true
					target = wallOn | EAST
					break
				case wall | WEST:
					on = true
					target = wallOn | WEST
					break
				case wallOn | NORTH:
					on = false
					target = wall | NORTH
					break
				case wallOn | SOUTH:
					on = false
					target = wall | SOUTH
					break
				case wallOn | EAST:
					on = false
					target = wall | EAST
					break
				case wallOn | WEST:
					on = false
					target = wall | WEST
					break
				case me.id | STAIR:
					on = true
					target = me.id | CROSS
					break
				case me.id | CROSS:
					on = false
					target = me.id | STAIR
					break
				case me.id | TALLCROSS:
					on = true
					target = me.id | DOOR
					break
				case me.id | DOOR:
					on = false
					target = me.id | TALLCROSS
					break
			}
			world.setBlock(x,y,z,target)
			if(on){
				world.setPower(x,y,z,16)
				world.spreadPower(x,y,z,15)
			}else{
				world.setPower(x,y,z,0)
				world.unspreadPower(x,y,z,16)
			}
			
			var a = world.getBlock(ax,ay,az)
			if(a && !blockData[a].transparent){
				world.setBlockPower(ax,ay,az,on ? "strong" : null,dir)
			}
		},
		ondelete:function(x,y,z,prevTags,prevBlock,world){
			if(getTagBits(prevTags,"power",this.id)){
				world.unspreadPower(x,y,z,16,false)
				
				var block = prevBlock
				var me = blockData[blockIds.lever]
				var wall = me.id
				var wallOn = me.id | SLAB
				var ax = x, ay = y, az = z
				var dir
				switch(block){
					case wall | NORTH:
					case wallOn | NORTH:
						az++
						dir = "south"
						break
					case wall | SOUTH:
					case wallOn | SOUTH:
						az--
						dir = "north"
						break
					case wall | EAST:
					case wallOn | EAST:
						ax++
						dir = "east"
						break
					case wall | WEST:
					case wallOn | WEST:
						ax--
						dir = "west"
						break
					case me.id | STAIR:
					case me.id | CROSS:
						ay --
						dir = "top"
						break
					case me.id | TALLCROSS:
					case me.id | DOOR:
						ay ++
						dir = "bottom"
						break
				}
				
				var a = world.getBlock(ax,ay,az)
				if(a && !blockData[a].transparent){
					world.setBlockPower(ax,ay,az,null,dir)
				}
			}
		},
		category:"redstone"
	},
	
	{
		name:"repeater",
		Name:"Redstone Repeater",
		flatIcon:true,
		iconTexture:"repeaterIcon",
		repeater:true,
		transparent:true,
		onupdate:function(x,y,z,b,w,sx,sy,sz){
			this.onpowerupdate(x,y,z,null,null,null,null,w)
		},
		ondelete:function(x,y,z,prevTags,prevBlock,world){
			world.unspreadPower(x,y,z,16,false)
			world.setBlockPower(x,y,z+1,null,"south")
			world.setBlockPower(x,y,z-1,null,"north")
			world.setBlockPower(x+1,y,z,null,"east")
			world.setBlockPower(x-1,y,z,null,"west")
		},
		onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,world){
			var fx = x, fy = y, fz = z //from
			var tx = x, ty = y, tz = z //pointing to
			var side //side of block it's pointing to
			var block = world.getBlock(x,y,z)
			var d1 = this.id, d2 = this.id | SLAB, d3 = this.id | STAIR, d4 = this.id | DOOR //delay
			var D1 = this.id | PANE, D2 = this.id | PORTAL, D3 = this.id | WALLFLAT, D4 = this.id | TRAPDOOROPEN //delay for on repeaters
			switch(block){
				case d1 | NORTH:
				case d2 | NORTH:
				case d3 | NORTH:
				case d4 | NORTH:
				case D1 | NORTH:
				case D2 | NORTH:
				case D3 | NORTH:
				case D4 | NORTH:
					fz--
					tz++
					side = "south"
					break
				case d1 | SOUTH:
				case d2 | SOUTH:
				case d3 | SOUTH:
				case d4 | SOUTH:
				case D1 | SOUTH:
				case D2 | SOUTH:
				case D3 | SOUTH:
				case D4 | SOUTH:
					fz++
					tz--
					side = "north"
					break
				case d1 | EAST:
				case d2 | EAST:
				case d3 | EAST:
				case d4 | EAST:
				case D1 | EAST:
				case D2 | EAST:
				case D3 | EAST:
				case D4 | EAST:
					fx--
					tx++
					side = "east"
					break
				case d1 | WEST:
				case d2 | WEST:
				case d3 | WEST:
				case d4 | WEST:
				case D1 | WEST:
				case D2 | WEST:
				case D3 | WEST:
				case D4 | WEST:
					fx++
					tx--
					side = "west"
					break
			}
			if(fx === x && fy === y && fz === z) return console.log("doesn't match up") //doesn't match up
			var delay
			switch(block){
				case d1 | NORTH:
				case d1 | SOUTH:
				case d1 | EAST:
				case d1 | WEST:
				case D1 | NORTH:
				case D1 | SOUTH:
				case D1 | EAST:
				case D1 | WEST:
					delay = 1
					break
				case d2 | NORTH:
				case d2 | SOUTH:
				case d2 | EAST:
				case d2 | WEST:
				case D2 | NORTH:
				case D2 | SOUTH:
				case D2 | EAST:
				case D2 | WEST:
					delay = 2
					break
				case d3 | NORTH:
				case d3 | SOUTH:
				case d3 | EAST:
				case d3 | WEST:
				case D3 | NORTH:
				case D3 | SOUTH:
				case D3 | EAST:
				case D3 | WEST:
					delay = 3
					break
				case d4 | NORTH:
				case d4 | SOUTH:
				case d4 | EAST:
				case d4 | WEST:
				case D4 | NORTH:
				case D4 | SOUTH:
				case D4 | EAST:
				case D4 | WEST:
					delay = 4
					break
			}
			if(!delay) return console.log("delay hasn't been set")
			
			var on = false
			switch(block){ //todo: make it an if loop
				case D1 | NORTH:
				case D2 | NORTH:
				case D3 | NORTH:
				case D4 | NORTH:
				case D1 | SOUTH:
				case D2 | SOUTH:
				case D3 | SOUTH:
				case D4 | SOUTH:
				case D1 | EAST:
				case D2 | EAST:
				case D3 | EAST:
				case D4 | EAST:
				case D1 | WEST:
				case D2 | WEST:
				case D3 | WEST:
				case D4 | WEST:
					on = true
			}

			var tblock = world.getBlock(tx,ty,tz)
			if(tblock && blockData[tblock].carryRedstone){
				if(on){
					if(world.getPower(tx,ty,tz) !== 15){
						world.setPower(tx,ty,tz,15,false)
						world.spreadPower(tx,ty,tz,15)
					}
				}
			}else if(tblock && !blockData[tblock].transparent){
				if(on){
					world.setBlockPower(tx,ty,tz,"strong",side)
				}else{
					world.setBlockPower(tx,ty,tz,null,side)
				}
			}
			
			var shouldBeOn = world.getRepeaterPower(x,y,z,fx,fy,fz) || world.getBlockPower(fx,fy,fz,null) ? true : false
			if(on === shouldBeOn) return
			var t = function(){
				block = world.getBlock(x,y,z)
				var on = world.getRepeaterPower(x,y,z,fx,fy,fz) || world.getBlockPower(fx,fy,fz,null) ? true : false //should it be on?
				var isOn = false
				switch(block){ //todo: make it an if loop
					case D1 | NORTH:
					case D2 | NORTH:
					case D3 | NORTH:
					case D4 | NORTH:
					case D1 | SOUTH:
					case D2 | SOUTH:
					case D3 | SOUTH:
					case D4 | SOUTH:
					case D1 | EAST:
					case D2 | EAST:
					case D3 | EAST:
					case D4 | EAST:
					case D1 | WEST:
					case D2 | WEST:
					case D3 | WEST:
					case D4 | WEST:
						isOn = true
				}
				if(on !== isOn) {
					var target
					var f = "north"
					switch(block){
						case d1 | NORTH:
							target = D1
							break
						case d2 | NORTH:
							target = D2
							break
						case d3 | NORTH:
							target = D3
							break
						case d4 | NORTH:
							target = D4
							break
						case D1 | NORTH:
							target = d1
							break
						case D2 | NORTH:
							target = d2
							break
						case D3 | NORTH:
							target = d3
							break
						case D4 | NORTH:
							target = d4
							break
						case d1 | SOUTH:
							target = D1, f = "south"
							break
						case d2 | SOUTH:
							target = D2, f = "south"
							break
						case d3 | SOUTH:
							target = D3, f = "south"
							break
						case d4 | SOUTH:
							target = D4, f = "south"
							break
						case D1 | SOUTH:
							target = d1, f = "south"
							break
						case D2 | SOUTH:
							target = d2, f = "south"
							break
						case D3 | SOUTH:
							target = d3, f = "south"
							break
						case D4 | SOUTH:
							target = d4, f = "south"
							break
						case d1 | EAST:
							target = D1, f = "east"
							break
						case d2 | EAST:
							target = D2, f = "east"
							break
						case d3 | EAST:
							target = D3, f = "east"
							break
						case d4 | EAST:
							target = D4, f = "east"
							break
						case D1 | EAST:
							target = d1, f = "east"
							break
						case D2 | EAST:
							target = d2, f = "east"
							break
						case D3 | EAST:
							target = d3, f = "east"
							break
						case D4 | EAST:
							target = d4, f = "east"
							break
						case d1 | WEST:
							target = D1, f = "west"
							break
						case d2 | WEST:
							target = D2, f = "west"
							break
						case d3 | WEST:
							target = D3, f = "west"
							break
						case d4 | WEST:
							target = D4, f = "west"
							break
						case D1 | WEST:
							target = d1, f = "west"
							break
						case D2 | WEST:
							target = d2, f = "west"
							break
						case D3 | WEST:
							target = d3, f = "west"
							break
						case D4 | WEST:
							target = d4, f = "west"
							break
					}
					switch(f){
						case "north":
							break
						case "south":
							target |= SOUTH
							break
						case "east":
							target |= EAST
							break
						case "west":
							target |= WEST
					}
					if(block !== target) world.setBlock(x,y,z,target,false,false,false,false)
					
					var tblock = world.getBlock(tx,ty,tz)
					if(on){
						if(tblock && blockData[tblock].carryRedstone){
							if(world.getPower(tx,ty,tz) !== 15){
								world.setPower(tx,ty,tz,15,false)
								world.spreadPower(tx,ty,tz,15)
							}
						}else if(tblock && !blockData[tblock].transparent){
							world.setBlockPower(tx,ty,tz,"strong",side)
						}
					}else{
						if(tblock && blockData[tblock].carryRedstone){
							world.unspreadPower(tx,ty,tz,15,true)
						}else if(tblock && !blockData[tblock].transparent){
							world.setBlockPower(tx,ty,tz,null,side)
						}
					}
				}//end if repeater power changed
			}
			world.setTimeout(t,tickTime*delay*2, x,y,z)
		},
		onclick:function(x,y,z,world){
			var me = blockData[blockIds.repeater]
			var block = world.getBlock(x,y,z)
			var d1 = me.id, d2 = me.id | SLAB, d3 = me.id | STAIR, d4 = me.id | DOOR //delay
			var D1 = me.id | PANE, D2 = me.id | PORTAL, D3 = me.id | WALLFLAT, D4 = me.id | TRAPDOOROPEN //delay for on repeaters
			var target
			switch(block){
				case d1 | NORTH:
					target = d2 | NORTH
					break
				case d2 | NORTH:
					target = d3 | NORTH
					break
				case d3 | NORTH:
					target = d4 | NORTH
					break
				case d4 | NORTH:
					target = d1 | NORTH
					break
				case D1 | NORTH:
					target = D2 | NORTH
					break
				case D2 | NORTH:
					target = D3 | NORTH
					break
				case D3 | NORTH:
					target = D4 | NORTH
					break
				case D4 | NORTH:
					target = D1 | NORTH
					break
				case d1 | SOUTH:
					target = d2 | SOUTH
					break
				case d2 | SOUTH:
					target = d3 | SOUTH
					break
				case d3 | SOUTH:
					target = d4 | SOUTH
					break
				case d4 | SOUTH:
					target = d1 | SOUTH
					break
				case D1 | SOUTH:
					target = D2 | SOUTH
					break
				case D2 | SOUTH:
					target = D3 | SOUTH
					break
				case D3 | SOUTH:
					target = D4 | SOUTH
					break
				case D4 | SOUTH:
					target = D1 | SOUTH
					break
				case d1 | EAST:
					target = d2 | EAST
					break
				case d2 | EAST:
					target = d3 | EAST
					break
				case d3 | EAST:
					target = d4 | EAST
					break
				case d4 | EAST:
					target = d1 | EAST
					break
				case D1 | EAST:
					target = D2 | EAST
					break
				case D2 | EAST:
					target = D3 | EAST
					break
				case D3 | EAST:
					target = D4 | EAST
					break
				case D4 | EAST:
					target = D1 | EAST
					break
				case d1 | WEST:
					target = d2 | WEST
					break
				case d2 | WEST:
					target = d3 | WEST
					break
				case d3 | WEST:
					target = d4 | WEST
					break
				case d4 | WEST:
					target = d1 | WEST
					break
				case D1 | WEST:
					target = D2 | WEST
					break
				case D2 | WEST:
					target = D3 | WEST
					break
				case D3 | WEST:
					target = D4 | WEST
					break
				case D4 | WEST:
					target = D1 | WEST
					break
			}
			world.setBlock(x,y,z,target)
		},
		getFacing:function(x,y,z,world){
			var block = world.getBlock(x,y,z)
			var d1 = this.id, d2 = this.id | SLAB, d3 = this.id | STAIR, d4 = this.id | DOOR //delay
			var D1 = this.id | PANE, D2 = this.id | PORTAL, D3 = this.id | WALLFLAT, D4 = this.id | TRAPDOOROPEN //delay for on repeaters
			var f
			switch(block){
				case d1 | NORTH:
				case d2 | NORTH:
				case d3 | NORTH:
				case d4 | NORTH:
				case D1 | NORTH:
				case D2 | NORTH:
				case D3 | NORTH:
				case D4 | NORTH:
					f = "north"
					break
				case d1 | SOUTH:
				case d2 | SOUTH:
				case d3 | SOUTH:
				case d4 | SOUTH:
				case D1 | SOUTH:
				case D2 | SOUTH:
				case D3 | SOUTH:
				case D4 | SOUTH:
					f = "south"
					break
				case d1 | EAST:
				case d2 | EAST:
				case d3 | EAST:
				case d4 | EAST:
				case D1 | EAST:
				case D2 | EAST:
				case D3 | EAST:
				case D4 | EAST:
					f = "east"
					break
				case d1 | WEST:
				case d2 | WEST:
				case d3 | WEST:
				case d4 | WEST:
				case D1 | WEST:
				case D2 | WEST:
				case D3 | WEST:
				case D4 | WEST:
					f = "west"
					break
			}
			return f
		},
		canHavePower:function(/*repeater*/rx,ry,rz,/*other thing*/x,y,z,world){
			var tx = rx, ty = ry, tz = rz
			var block = world.getBlock(rx,ry,rz)
			var d1 = this.id, d2 = this.id | SLAB, d3 = this.id | STAIR, d4 = this.id | DOOR //delay
			var D1 = this.id | PANE, D2 = this.id | PORTAL, D3 = this.id | WALLFLAT, D4 = this.id | TRAPDOOROPEN //delay for on repeaters
			switch(block){
				case d1 | NORTH:
				case d2 | NORTH:
				case d3 | NORTH:
				case d4 | NORTH:
				case D1 | NORTH:
				case D2 | NORTH:
				case D3 | NORTH:
				case D4 | NORTH:
					tz++
					break
				case d1 | SOUTH:
				case d2 | SOUTH:
				case d3 | SOUTH:
				case d4 | SOUTH:
				case D1 | SOUTH:
				case D2 | SOUTH:
				case D3 | SOUTH:
				case D4 | SOUTH:
					tz--
					break
				case d1 | EAST:
				case d2 | EAST:
				case d3 | EAST:
				case d4 | EAST:
				case D1 | EAST:
				case D2 | EAST:
				case D3 | EAST:
				case D4 | EAST:
					tx++
					break
				case d1 | WEST:
				case d2 | WEST:
				case d3 | WEST:
				case d4 | WEST:
				case D1 | WEST:
				case D2 | WEST:
				case D3 | WEST:
				case D4 | WEST:
					tx--
					break
			}
			
			var on = false
			switch(block){ //todo: make it an if loop
				case D1 | NORTH:
				case D2 | NORTH:
				case D3 | NORTH:
				case D4 | NORTH:
				case D1 | SOUTH:
				case D2 | SOUTH:
				case D3 | SOUTH:
				case D4 | SOUTH:
				case D1 | EAST:
				case D2 | EAST:
				case D3 | EAST:
				case D4 | EAST:
				case D1 | WEST:
				case D2 | WEST:
				case D3 | WEST:
				case D4 | WEST:
					on = true
			}

			if(on && tx === x && ty === y && tz === z){
				return 15
			}
			return 0
		},
		category:"redstone"
	},
	
	{
		name:"piston",
		Name:"Piston",
		textures:["pistonBack","pistonFront","pistonSide"],
		piston:true,
		headSideTexture:"pistonHeadSide",
		frontOpenTexture:"pistonFrontOpen",
		headBackTexture:"pistonFront",
		onpowerupdate: function(x,y,z,sx,sy,sz,blockPowerChanged,world){
			var block = world.getBlock(x,y,z)
			var extended = false, facing, attachedHead = false
			switch(block){
				case this.id:
					facing = "top"
					break
				case this.id | FLIP:
					facing = "bottom"
					break
				case this.id | SLAB | NORTH:
					facing = "north"
					break
				case this.id | SLAB | SOUTH:
					facing = "south"
					break
				case this.id | SLAB | EAST:
					facing = "east"
					break
				case this.id | SLAB | WEST:
					facing = "west"
					break
				case this.id | TALLCROSS:
					facing = "top"
					extended = true
					break
				case this.id | TALLCROSS | FLIP:
					facing = "bottom"
					extended = true
					break
				case this.id | PORTAL | NORTH:
					facing = "north"
					extended = true
					break
				case this.id | PORTAL | SOUTH:
					facing = "south"
					extended = true
					break
				case this.id | PORTAL | EAST:
					facing = "east"
					extended = true
					break
				case this.id | PORTAL | WEST:
					facing = "west"
					extended = true
					break
				default:
					return //parts like piston heads shouldn't do the calculations when power changes
			}
			if(extended){
				switch(facing){
					case "top":
						if(world.getBlock(x,y+1,z) === (this.id | STAIR)) attachedHead = true
						break
					case "bottom":
						if(world.getBlock(x,y-1,z) === (this.id | STAIR | FLIP)) attachedHead = true
						break
					case "north":
						if(world.getBlock(x,y,z-1) === (this.id | DOOR | NORTH)) attachedHead = true
						break
					case "south":
						if(world.getBlock(x,y,z+1) === (this.id | DOOR | SOUTH)) attachedHead = true
						break
					case "east":
						if(world.getBlock(x-1,y,z) === (this.id | DOOR | EAST)) attachedHead = true
						break
					case "west":
						if(world.getBlock(x+1,y,z) === (this.id | DOOR | WEST)) attachedHead = true
						break
				}
			}
			
			var power = world.getRedstonePower(x,y,z) || world.getSurroundingBlockPower(x,y,z)
			if(power && !extended){
				this.extend(x,y,z,facing,world)
			}else if(!power && extended && attachedHead){
				this.retract(x,y,z,facing,world)
			}
		},
		onupdate:function(x,y,z,b,w,sx,sy,sz){ //onupdate is run when placed
			this.onpowerupdate(x,y,z,null,null,null,null,w)
		},
		onbreak:function(x,y,z, prevBlock, prevTags,world){
			//dissapear if it isn't connected (it = piston heads and piston open)
			let tx = x, ty = y, tz = z
			switch(prevBlock){
				case this.id | TALLCROSS:
				case this.id | STAIR | FLIP:
					ty++
					break
				case this.id | TALLCROSS | FLIP:
				case this.id | STAIR:
					ty--
					break
				case this.id | PORTAL | NORTH:
				case this.id | DOOR | SOUTH:
					tz--
					break
				case this.id | PORTAL | SOUTH:
				case this.id | DOOR | NORTH:
					tz++
					break
				case this.id | PORTAL | EAST:
				case this.id | DOOR | WEST:
					tx--
					break
				case this.id | PORTAL | WEST:
				case this.id | DOOR | EAST:
					tx++
					break
				default:
					return //unextended pistons
			}
			world.setBlock(tx,ty,tz,0,false,false,false,false)
		},
		extend:function(x,y,z, facing,world){
			var tx = x, ty = y, tz = z, mx = 0, my = 0, mz = 0
			var head, headCut, open
			switch(facing){
				case "top":
					open = this.id | TALLCROSS
					head = this.id | STAIR
					headCut = this.id | CROSS
					ty ++
					my = 1
					break
				case "bottom":
					open = this.id | TALLCROSS | FLIP
					head = this.id | STAIR | FLIP
					headCut = this.id | CROSS | FLIP
					ty --
					my = -1
					break
				case "north":
					open = this.id | PORTAL | NORTH
					head = this.id | DOOR | NORTH
					headCut = this.id | PANE | NORTH
					tz --
					mz = -1
					break
				case "south":
					open = this.id | PORTAL | SOUTH
					head = this.id | DOOR | SOUTH
					headCut = this.id | PANE | SOUTH
					tz ++
					mz = 1
					break
				case "east":
					open = this.id | PORTAL | EAST
					head = this.id | DOOR | EAST
					headCut = this.id | PANE | EAST
					tx --
					mx = -1
					break
				case "west":
					open = this.id | PORTAL | WEST
					head = this.id | DOOR | WEST
					headCut = this.id | PANE | WEST
					tx ++
					mx = 1
					break
				default:
					return console.log("oh no! piston isn't facing anywhere")
			}
			var push = getPistonPushedBlocks(x,y,z,mx,my,mz,world)
			if(push === false) return
			
			world.setBlock(x,y,z,open,false,false,false,false)
			var e = new entities[entityIds.MovingBlock](headCut,x,y,z,tx,ty,tz, tickTime*2, true)
			e.endAs = head
			world.addEntity(e,false)
			//world.setTimeout(function(){
			//	e.changeBlock(head)
			//}, tickTime*1.5)
			for(var i=0; i<push.length; i+=4){
				var bx = push[i], by = push[i+1], bz = push[i+2]
				var tags = world.getTags(bx,by,bz)
				world.setBlock(bx,by,bz,0,false,false,false,false)
				world.addEntity(new entities[entityIds.MovingBlock](push[i+3],bx,by,bz,bx+mx,by+my,bz+mz, tickTime*2, true, tags),false)
			}
		},
		retract:function(x,y,z, facing,world){
			var tx = x, ty = y, tz = z
			var head, headCut, body
			switch(facing){
				case "top":
					body = this.id
					head = this.id | STAIR
					headCut = this.id | CROSS
					ty ++
					break
				case "bottom":
					body = this.id | FLIP
					head = this.id | STAIR | FLIP
					headCut = this.id | CROSS | FLIP
					ty --
					break
				case "north":
					body = this.id | SLAB | NORTH
					head = this.id | DOOR | NORTH
					headCut = this.id | PANE | NORTH
					tz --
					break
				case "south":
					body = this.id | SLAB | SOUTH
					head = this.id | DOOR | SOUTH
					headCut = this.id | PANE | SOUTH
					tz ++
					break
				case "east":
					body = this.id | SLAB | EAST
					head = this.id | DOOR | EAST
					headCut = this.id | PANE | EAST
					tx --
					break
				case "west":
					body = this.id | SLAB | WEST
					head = this.id | DOOR | WEST
					headCut = this.id | PANE | WEST
					tx ++
					break
				default:
					return console.log("oh no! piston isn't facing anywhere")
			}
			world.setBlock(tx,ty,tz,0,false,false,false,false)
			var e = new entities[entityIds.MovingBlock](head,tx,ty,tz,x,y,z, tickTime*2)
			world.addEntity(e,false)
			//world.setTimeout(function(){
			//	e.changeBlock(headCut)
			//}, tickTime*0.5)
			world.setTimeout(function(){
				world.setBlock(x,y,z,body,false,false,false,false)
			}, tickTime*2)
		},
		category:"redstone"
	},
	
	{
		name:"smoothQuartz",
		Name:"Smooth Quartz Block",
		textures:"quartzBlockBottom",
		stoneSound:true,
		category:"build"
	},
	
	{
		name:"pistonSticky",
		Name:"Sticky Piston",
		textures:["pistonBack","pistonFrontSticky","pistonSide"],
		piston:true,
		headSideTexture:"pistonHeadSide",
		frontOpenTexture:"pistonFrontOpen",
		headBackTexture:"pistonFront",
		category:"redstone",
		onpowerupdate: function(x,y,z,sx,sy,sz,blockPowerChanged,world){
			var block = world.getBlock(x,y,z)
			var extended = false, facing, attachedHead = false
			switch(block){
				case this.id:
					facing = "top"
					break
				case this.id | FLIP:
					facing = "bottom"
					break
				case this.id | SLAB | NORTH:
					facing = "north"
					break
				case this.id | SLAB | SOUTH:
					facing = "south"
					break
				case this.id | SLAB | EAST:
					facing = "east"
					break
				case this.id | SLAB | WEST:
					facing = "west"
					break
				case this.id | TALLCROSS:
					facing = "top"
					extended = true
					break
				case this.id | TALLCROSS | FLIP:
					facing = "bottom"
					extended = true
					break
				case this.id | PORTAL | NORTH:
					facing = "north"
					extended = true
					break
				case this.id | PORTAL | SOUTH:
					facing = "south"
					extended = true
					break
				case this.id | PORTAL | EAST:
					facing = "east"
					extended = true
					break
				case this.id | PORTAL | WEST:
					facing = "west"
					extended = true
					break
				default:
					return //parts like piston heads shouldn't do the calculations when power changes
			}
			if(extended){
				switch(facing){
					case "top":
						if(world.getBlock(x,y+1,z) === (this.id | STAIR)) attachedHead = true
						break
					case "bottom":
						if(world.getBlock(x,y-1,z) === (this.id | STAIR | FLIP)) attachedHead = true
						break
					case "north":
						if(world.getBlock(x,y,z-1) === (this.id | DOOR | NORTH)) attachedHead = true
						break
					case "south":
						if(world.getBlock(x,y,z+1) === (this.id | DOOR | SOUTH)) attachedHead = true
						break
					case "east":
						if(world.getBlock(x-1,y,z) === (this.id | DOOR | EAST)) attachedHead = true
						break
					case "west":
						if(world.getBlock(x+1,y,z) === (this.id | DOOR | WEST)) attachedHead = true
						break
				}
			}
			
			var power = world.getRedstonePower(x,y,z) || world.getSurroundingBlockPower(x,y,z)
			if(power && !extended){
				this.extend(x,y,z,facing,world)
			}else if(!power && extended && attachedHead){
				this.retract(x,y,z,facing,world)
			}
		},
		onupdate:function(x,y,z,b,w,sx,sy,sz){ //onupdate is run when placed
			this.onpowerupdate(x,y,z,null,null,null,null,w)
		},
		onbreak:function(x,y,z, prevBlock, prevTags,world){
			//dissapear if it isn't connected (it = piston heads and piston open)
			let tx = x, ty = y, tz = z
			switch(prevBlock){
				case this.id | TALLCROSS:
				case this.id | STAIR | FLIP:
					ty++
					break
				case this.id | TALLCROSS | FLIP:
				case this.id | STAIR:
					ty--
					break
				case this.id | PORTAL | NORTH:
				case this.id | DOOR | SOUTH:
					tz--
					break
				case this.id | PORTAL | SOUTH:
				case this.id | DOOR | NORTH:
					tz++
					break
				case this.id | PORTAL | EAST:
				case this.id | DOOR | WEST:
					tx--
					break
				case this.id | PORTAL | WEST:
				case this.id | DOOR | EAST:
					tx++
					break
				default:
					return //unextended pistons
			}
			world.setBlock(tx,ty,tz,0,false,false,false,false)
		},
		extend:function(x,y,z, facing,world){
			var tx = x, ty = y, tz = z, mx = 0, my = 0, mz = 0
			var head, headCut, open
			switch(facing){
				case "top":
					open = this.id | TALLCROSS
					head = this.id | STAIR
					headCut = this.id | CROSS
					ty ++
					my = 1
					break
				case "bottom":
					open = this.id | TALLCROSS | FLIP
					head = this.id | STAIR | FLIP
					headCut = this.id | CROSS | FLIP
					ty --
					my = -1
					break
				case "north":
					open = this.id | PORTAL | NORTH
					head = this.id | DOOR | NORTH
					headCut = this.id | PANE | NORTH
					tz --
					mz = -1
					break
				case "south":
					open = this.id | PORTAL | SOUTH
					head = this.id | DOOR | SOUTH
					headCut = this.id | PANE | SOUTH
					tz ++
					mz = 1
					break
				case "east":
					open = this.id | PORTAL | EAST
					head = this.id | DOOR | EAST
					headCut = this.id | PANE | EAST
					tx --
					mx = -1
					break
				case "west":
					open = this.id | PORTAL | WEST
					head = this.id | DOOR | WEST
					headCut = this.id | PANE | WEST
					tx ++
					mx = 1
					break
				default:
					return console.log("oh no! piston isn't facing anywhere")
			}
			var push = getPistonPushedBlocks(x,y,z,mx,my,mz,world)
			if(push === false) return
			
			world.setBlock(x,y,z,open,false,false,false,false)
			var e = new entities[entityIds.MovingBlock](headCut,x,y,z,tx,ty,tz, tickTime*2, true)
			for(var i=0; i<push.length; i+=4){
				var bx = push[i], by = push[i+1], bz = push[i+2]
				var tags = world.getTags(bx,by,bz)
				world.setBlock(bx,by,bz,0,false,false,false,false)
				world.addEntity(new entities[entityIds.MovingBlock](push[i+3],bx,by,bz,bx+mx,by+my,bz+mz, tickTime*2, true, tags),false)
			}
			e.endAs = head
			world.addEntity(e,false)
			//world.setTimeout(function(){
			//	e.changeBlock(head)
			//}, tickTime*1.5)
		},
		retract:function(x,y,z, facing,world){
			var tx = x, ty = y, tz = z, mx = 0, my = 0, mz = 0
			var head, headCut, body
			switch(facing){
				case "top":
					body = this.id
					head = this.id | STAIR
					headCut = this.id | CROSS
					ty ++
					my = 1
					break
				case "bottom":
					body = this.id | FLIP
					head = this.id | STAIR | FLIP
					headCut = this.id | CROSS | FLIP
					ty --
					my = -1
					break
				case "north":
					body = this.id | SLAB | NORTH
					head = this.id | DOOR | NORTH
					headCut = this.id | PANE | NORTH
					tz --
					mz = -1
					break
				case "south":
					body = this.id | SLAB | SOUTH
					head = this.id | DOOR | SOUTH
					headCut = this.id | PANE | SOUTH
					tz ++
					mz = 1
					break
				case "east":
					body = this.id | SLAB | EAST
					head = this.id | DOOR | EAST
					headCut = this.id | PANE | EAST
					tx --
					mx = -1
					break
				case "west":
					body = this.id | SLAB | WEST
					head = this.id | DOOR | WEST
					headCut = this.id | PANE | WEST
					tx ++
					mx = 1
					break
				default:
					return console.log("oh no! piston isn't facing anywhere")
			}
			world.setBlock(tx,ty,tz,0,false,false,false,false)
			var e = new entities[entityIds.MovingBlock](head,tx,ty,tz,x,y,z, tickTime*2)
			world.addEntity(e,false)
			//world.setTimeout(function(){
			//	e.changeBlock(headCut)
			//}, tickTime*0.5)
			world.setTimeout(function(){
				world.setBlock(x,y,z,body,false,false,false,false)
			}, tickTime*2)
			
			var pull = getPistonPulledBlocks(x,y,z,mx,my,mz,world)
			if(pull){
				for(var i=0; i<pull.length; i+=4){
					var bx = pull[i], by = pull[i+1], bz = pull[i+2]
					var tags = world.getTags(bx,by,bz)
					world.setBlock(bx,by,bz,0,false,false,false,false)
					world.addEntity(new entities[entityIds.MovingBlock](pull[i+3],bx,by,bz,bx-mx,by-my,bz-mz, tickTime*2, true, tags),false)
				}
			}
		}
	},
	
	{
		name:"observer",
		Name:"Observer",
		textures:["observerTop","observerTop","observerBack","observerFront","observerSide","observerSide"],
		blastResistance:3.5,
		hardness:3,
		getFacing:function(x,y,z,world){
			var block = world.getBlock(x,y,z)
			var facing
			switch(block){
				case this.id | NORTH:
				case this.id | STAIR | NORTH:
					facing = "north"
					break
				case this.id | SOUTH:
				case this.id | STAIR | SOUTH:
					facing = "south"
					break
				case this.id | EAST:
				case this.id | STAIR | EAST:
					facing = "east"
					break
				case this.id | WEST:
				case this.id | STAIR | WEST:
					facing = "west"
					break
				case this.id | SLAB:
				case this.id | CROSS:
					facing = "bottom"
					break
				case this.id | SLAB | FLIP:
				case this.id | CROSS | FLIP:
					facing = "top"
					break
				default:
					return
			}
			return facing
		},
		detected:function(x,y,z,sx,sy,sz,world, detected = false){ //if detected is true, it will send a signal no matter what
			var block = world.getBlock(x,y,z)
			var facing, tx = 0, ty = 0, tz = 0, onBlock
			switch(block){
				case this.id | NORTH:
					facing = "north"
					tz = -1
					onBlock = this.id | STAIR | NORTH
					break
				case this.id | SOUTH:
					facing = "south"
					tz = 1
					onBlock = this.id | STAIR | SOUTH
					break
				case this.id | EAST:
					facing = "east"
					tx = -1
					onBlock = this.id | STAIR | EAST
					break
				case this.id | WEST:
					facing = "west"
					tx = 1
					onBlock = this.id | STAIR | WEST
					break
				case this.id | SLAB:
					facing = "bottom"
					ty = -1
					onBlock = this.id | CROSS
					break
				case this.id | SLAB | FLIP:
					facing = "top"
					ty = 1
					onBlock = this.id | CROSS | FLIP
					break
				default:
					return
			}
			
			if(!(x+tx === sx && y+ty === sy && z+tz === sz) && !detected) return
			
			world.setTimeout(function(){
				var curBlock = world.getBlock(x,y,z)
				if(!(curBlock && blockData[curBlock].name === "observer")) return
				
				world.setBlock(x,y,z,onBlock, false,true,false,false)
				let blockBehind = world.getBlock(x-tx,y-ty,z-tz)
				if(blockBehind && blockData[blockBehind].carryRedstone){
					world.setPower(x-tx,y-ty,z-tz, 15,false)
					world.spreadPower(x-tx,y-ty,z-tz, 15)
				}
				world.setTimeout(function(){
					let curBlock = world.getBlock(x,y,z)
					if(!(curBlock && blockData[curBlock].name === "observer")) return
					blockBehind = world.getBlock(x-tx,y-ty,z-tz)
					
					world.setBlock(x,y,z,block, false,true,false,false)
					if(blockBehind && blockData[blockBehind].carryRedstone) world.unspreadPower(x-tx,y-ty,z-tz, 15, true)
				}, tickTime*2)
			}, tickTime, x,y,z)
		},
		onupdate:function(x,y,z,block,world,sx,sy,sz){
			this.detected(x,y,z,sx,sy,sz,world,false)
		},
		onset:function(x,y,z,world){
			this.detected(x,y,z,x,y,z,world,true)
		},
		canHavePower:function(rx,ry,rz, x,y,z,world){
			var block = world.getBlock(rx,ry,rz)
			var tx = 0, ty = 0, tz = 0
			switch(block){
				case this.id | STAIR | NORTH:
					tz = -1
					break
				case this.id | STAIR | SOUTH:
					tz = 1
					break
				case this.id | STAIR | EAST:
					tx = -1
					break
				case this.id | STAIR | WEST:
					tx = 1
					break
				case this.id | CROSS:
					ty = -1
					break
				case this.id | CROSS | FLIP:
					ty = 1
					break
				default:
					return
			}
			
			if(rx-tx === x && ry-ty === y && rz-tz === z) return 15
			return 0
		},
		category:"redstone"
	},
	
	{
		name:"string",
		Name:"String",
		item:true,
		category:"items"
	},
	{
		name:"redDye",
		Name:"Red Dye",
		item:true,
		dye:"red",
		category:"items"
	},
	{
		name:"lightGrayDye",
		Name:"Light Gray Dye",
		item:true,
		dye:"lightGray",
		category:"items"
	},
	{
		name:"lightBlueDye",
		Name:"Light Blue Dye",
		item:true,
		dye:"lightBlue",
		category:"items"
	},
	{
		name:"magentaDye",
		Name:"Magenta Dye",
		item:true,
		dye:"magenta",
		category:"items"
	},
	{
		name:"yellowDye",
		Name:"Yellow Dye",
		item:true,
		dye:"yellow",
		category:"items"
	},
	{
		name:"purpleDye",
		Name:"Purple Dye",
		item:true,
		dye:"purple",
		category:"items"
	},
	{
		name:"orangeDye",
		Name:"Orange Dye",
		item:true,
		dye:"orange",
		category:"items"
	},
	{
		name:"whiteDye",
		Name:"White Dye",
		item:true,
		dye:"white",
		category:"items"
	},
	{
		name:"greenDye",
		Name:"Green Dye",
		item:true,
		dye:"green",
		category:"items"
	},
	{
		name:"brownDye",
		Name:"Brown Dye",
		item:true,
		dye:"brown",
		category:"items"
	},
	{
		name:"blackDye",
		Name:"Black Dye",
		item:true,
		dye:"black",
		category:"items"
	},
	{
		name:"pinkDye",
		Name:"Pink Dye",
		item:true,
		dye:"pink",
		category:"items"
	},
	{
		name:"limeDye",
		Name:"Lime Dye",
		item:true,
		dye:"lime",
		category:"items"
	},
	{
		name:"grayDye",
		Name:"Gray Dye",
		item:true,
		dye:"gray",
		category:"items"
	},
	{
		name:"cyanDye",
		Name:"Cyan Dye",
		item:true,
		dye:"cyan",
		category:"items"
	},
	{
		name:"blueDye",
		Name:"Blue Dye",
		item:true,
		dye:"blue",
		category:"items"
	},
	{
		name:"endPortal",
		flatIcon:true,
		solid:false,
		transparent:true,
		blastResistance: 3600000,
		lightLevel:15,
		pistonPush:false,
		pistonPull:false,
		hidden:true,
		drop:"air",
		serverontouch: function(x,y,z,ent){
			let nx, ny, nz
			if(ent.dimension === ""){
				nx = round(rand(-64,64))
				nz = round(rand(-64,64))
				ny = ent.y
			}else{
				let spawn = ent.spawnPoint || ent.world.world.spawnPoint
				nx = spawn.x
				ny = spawn.y
				nz = spawn.z
			}
			ent.tp(nx,ny,nz,ent.dimension === "end" ? "" : "end")
			ent.doingPortal = blockIds.endPortal
			ent.world.playSound(x,y,z,"portal.travel")
			if(ent.type === "Player"){
				ent.addAchievment("Into the End")
				if(ent.dimension === "" && !ent.didEndPoem && !ent.cheats){
					ent.didEndPoem = true
					ent.connection.send({type:"doEndPoem"})
				}
			}
		},
		doneLoading:function(p,world){
			if(p.dimension === "end"){
				let ny
				ny = world.getSolidTop(round(p.x),round(p.z))+0.5+p.height*0.5
				if(ny < 25) ny = 25
				p.tp(p.x,ny,p.z)
				if(!world.getBlock(p.x,floor(ny-p.height*0.5),p.z,p.dimension)){
					world.setBlock(p.x,floor(ny-p.height*0.5),p.z,blockIds.obsidian)
				}
			}
		}
	},
	{
		name:"thatch",
		Name:"Thatch",
		type:"plant2",
		burnChance: 0.2,
		burnTime: 20,
		compostChance:0.85,
		category:"build"
	},
	
	{
		name:"pearlescentFroglight",
		Name:"Pearlescent Froglight",
		textures:["pearlescentFroglightTop","pearlescentFroglightSide"],
		lightLevel:15,
		shadow:false,
		category:"nature"
	},
	{
		name:"verdantFroglight",
		Name:"Verdant Froglight",
		textures:["verdantFroglightTop","verdantFroglightSide"],
		lightLevel:15,
		shadow:false,
		category:"nature"
	},
	{
		name:"ochreFroglight",
		Name:"Ochre Froglight",
		textures:["ochreFroglightTop","ochreFroglightSide"],
		lightLevel:15,
		shadow:false,
		category:"nature"
	},
	{
		name:"mangroveLeaves",
		Name:"Mangrove Leaves",
		transparent: true,
		cullFace:0,
		hardness: 0.2,
		type:"plant2",
		leaves:true,
		drop: function(){
			if(rand() > 0.8){
				let r = floor(rand(3))
				if(r === 0) return "stick"
				else if(r === 1) return ""//mangrove propagule here
			}
		},
		dropSelfWhenSheared:true,
		shearBreakTime:0.05,
		burnChance: 0.2,
		burnTime: 30,
		grassSound: true,
		category:"nature",
		tint:leafTint,
		biomeTintTop:true,
		biomeTintBottom:true,
		biomeTintEast:true,
		biomeTintWest:true,
		biomeTintNorth:true,
		biomeTintSouth:true,
		invTint:[146/255, 198/255, 72/255],
	},
	{
		name:"mangroveLog",
		Name:"Mangrove Log",
		textures:["mangroveLogTop","mangroveLog"],
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"nature",
		log:true
	},
	{
		name:"strippedMangroveLog",
		Name:"Stripped Mangrove Log",
		textures:["strippedMangroveLogTop","strippedMangroveLog"],
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"build",
		log:true
	},
	{
		name:"mangroveLogSW",
		textures: ["mangroveLog","mangroveLog","mangroveLogTop","mangroveLog"],
		SW: true, woodSound:true, hidden:true
	},
	{
		name:"strippedMangroveLogSW",
		textures: ["strippedMangroveLog","strippedMangroveLog","strippedMangroveLogTop","strippedMangroveLog"],
		SW: true, woodSound:true, hidden:true
	},
	{name:"mangrovePlanks", Name:"Mangrove Planks", type:"wood", category:"build",hardness:2, woodSound:true, burnChance:0.1, burnTime:40},
	{ 
		name: "mangroveDoor",
		Name:"Mangrove Door",
		transparent: true,
		shadow: false,
		textures: "mangroveDoorConnected",
		door:true,
		woodSound:true,
		hardness:3,
		type:"wood",
		category:"build"
	},
	{ 
		name: "mangroveTrapdoor",
		Name:"Mangrove Trapdoor",
		transparent: true,
		trapdoor: true,
		woodSound: true,
		category:"build"
	},
	{
		name:"mangroveButton",
		Name: "Mangrove Button",
		textures:"mangrovePlanks",
		button:true,
		transparent: true,
		shadow:false,
		category:"redstone"
	},
	{
		name: "mangrovePressurePlate",
		Name: "Mangrove Pressure Plate",
		textures: "mangrovePlanks",
		pressurePlate: true,
		hardness:0.5,
		type:"wood",
		category:"redstone"
	},
	{
		name:"mangroveFenceGate",
		Name:"Mangrove Fence Gate",
		textures:"mangrovePlanks",
		fenceGate:true,
		hardness:2,
		woodSound:true,
		type:"wood",
		category:"build"
	},
	{
		name:"mangroveRoots",
		textures:["mangroveRootsTop","mangroveRootsSide"],
		transparent:true,
		type:"wood",
		hardness:0.7,
		blastResistance:0.7,
		cullFace:0,
		compostChance:0.3,
		category:"nature"
	},
	{
		name:"muddyMangroveRoots",
		textures:["muddyMangroveRootsTop","muddyMangroveRootsSide"],
		type:"wood",
		hardness:0.7,
		blastResistance:0.7,
		category:"nature"
	},
	{
		name: "mangroveWood",
		Name:"Mangrove Wood",
		textures: "mangroveLog",
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"nature",
		log:true
	},
	{
		name: "strippedMangroveWood",
		Name:"Stripped Mangrove Wood",
		textures: "strippedMangroveLog",
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"build"
	},
	{
		name:"mud",
		Name:"Mud",
		hardness:0.5,
		blastResistance:0.5,
		type:"ground",
		digSound: ["mud.break1", "mud.break2", "mud.break3", "mud.break4", "mud.break5", "mud.break6"],
		stepSound: ["mud.step1", "mud.step2","mud.step3","mud.step4","mud.step5","mud.step6"],
		category:"nature"
	},
	{
		name:"mudBricks",
		Name:"Mud Bricks",
		category:"build",
		hardness:1.5,
	},
	{
		name:"packedMud",
		Name:"Packed Mud",
		randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true,
		category:"build",
		hardness:1
	},
	{
		name:"reinforcedDeepslate",
		textures:["reinforcedDeepslateBottom","reinforcedDeepslateTop","reinforcedDeepslateSide"],
		blastResistance:1200,
		hardness:55,
		pistonPush:false,
		pistonPull:false,
		category:"build"
	},
	
	{
		name:"redRedstoneLamp",
		Name:"Red Redstone Lamp",
		textures:"redstoneLamp",
		onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,world){
			var power = world.getRedstonePower(x,y,z) || world.getSurroundingBlockPower(x,y,z)
			var block = this.id
			if(power){
				block = this.id | SLAB
			}
			if(world.getBlock(x,y,z) !== block) world.setBlock(x,y,z,block,false,false,false,false)
		},
		onset:function(x,y,z,world){
			this.onpowerupdate(x,y,z,null,null,null,null,world)
		},
		coloredRedstoneLamp:true,
		category:"redstone"
	},
	{
		name:"yellowRedstoneLamp",
		Name:"Yellow Redstone Lamp",
		textures:"redstoneLamp",
		onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,world){
			var power = world.getRedstonePower(x,y,z) || world.getSurroundingBlockPower(x,y,z)
			var block = this.id
			if(power){
				block = this.id | SLAB
			}
			if(world.getBlock(x,y,z) !== block) world.setBlock(x,y,z,block,false,false,false,false)
		},
		onset:function(x,y,z,world){
			this.onpowerupdate(x,y,z,null,null,null,null,world)
		},
		coloredRedstoneLamp:true,
		category:"redstone"
	},
	{
		name:"greenRedstoneLamp",
		Name:"Green Redstone Lamp",
		textures:"redstoneLamp",
		onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,world){
			var power = world.getRedstonePower(x,y,z) || world.getSurroundingBlockPower(x,y,z)
			var block = this.id
			if(power){
				block = this.id | SLAB
			}
			if(world.getBlock(x,y,z) !== block) world.setBlock(x,y,z,block,false,false,false,false)
		},
		onset:function(x,y,z,world){
			this.onpowerupdate(x,y,z,null,null,null,null,world)
		},
		coloredRedstoneLamp:true,
		category:"redstone"
	},
	{
		name:"blueRedstoneLamp",
		Name:"Blue Redstone Lamp",
		textures:"redstoneLamp",
		onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,world){
			var power = world.getRedstonePower(x,y,z) || world.getSurroundingBlockPower(x,y,z)
			var block = this.id
			if(power){
				block = this.id | SLAB
			}
			if(world.getBlock(x,y,z) !== block) world.setBlock(x,y,z,block,false,false,false,false)
		},
		onset:function(x,y,z,world){
			this.onpowerupdate(x,y,z,null,null,null,null,world)
		},
		coloredRedstoneLamp:true,
		category:"redstone"
	},
	
	{
		name:"soulFire",
		fire:true,
		damage:2,
		burnEnt:true,
		transparent:true,
		shade:false,
		shadow:false,
		solid:false,
		lightLevel:15,
		ambientSound:"fire.fire",
		temperature:20,
		smoothLight:false,
		hidden:true,
		noHitbox:true,
		getAttached:function(x,y,z,block,getBlockOnly,world){
			var ax = x, ay = y, az = z
			switch(block){
				case this.id:
					ay--
					break
				case this.id | STAIR:
					ay++
					break
				case this.id | SLAB | NORTH:
					az++
					break
				case this.id | SLAB | SOUTH:
					az--
					break
				case this.id | SLAB | EAST:
					ax++
					break
				case this.id | SLAB | WEST:
					ax--
					break
			}
			var attached = world.getBlock(ax,ay,az)
			if(getBlockOnly) return attached
			else return [attached,ax,ay,az]
		},
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			var block = this.getAttached(x,y,z,b,true,world)
			if(!block || !blockData[block].canHaveSoulFire) world.setBlock(x,y,z,0,false,false,false,false)
		},
	},
	
	{
		name:"sweetBerries",
		Name:"Sweet Berries (they're spiky)",
		item:true,
		edible:true,
		food:4,
		saturation: 1.2,
		eatResult: "stick",
		useAs: "sweetBerryBush",
		compostChance:0.3,
		category:"food"
	},
	{
		name:"sweetBerryBush",
		textures:"sweetBerryBushStage0",
		textures1:new Array(6).fill("sweetBerryBushStage1"),
		textures2:new Array(6).fill("sweetBerryBushStage2"),
		textures3:new Array(6).fill("sweetBerryBushStage3"),
		flatIcon:true,
		solid: false,
		transparent: true,
		shadow: false,
		smoothLight:false,
		hidden:true,
		drop:"sweetBerries",
		liquidBreakable:"drop",
		category:"nature"
	},
	{
		name:"smallDripleaf",
		Name:"Small Dripleaf",
		textures:"smallDripleafStemBottom",
		shapeName:"smallDripleaf",
		solid: false,
		transparent: true,
		shadow: false,
		smoothLight:false,
		liquidBreakable:"drop",
		category:"nature"
	},
	{
		name:"bigDripleaf",
		Name:"Big Dripleaf",
		textures:"bigDripleafStem",
		shapeName:"bigDripleaf",
		crossShape:true,
		transparent: true,
		shadow: false,
		smoothLight:false,
		liquidBreakable:"drop",
		onupdate:function(x,y,z,block,world,sx,sy,sz){
			var me = blockIds.bigDripleaf
			var top = world.getBlock(x,y+1,z)
			var isIt = top === me || top === (me | CROSS)
			if(block === me && isIt){
				world.setBlock(x,y,z,me | CROSS,false,false,false,false)
			}else if(block === (me | CROSS) && !isIt){
				world.setBlock(x,y,z,me,false,false,false,false)
			}
		},
		category:"nature"
	},
	
	{
		name:"orGate",
		Name:"OR Gate",
		textures:["smoothStone","orGate","smoothStone"],
		shapeName:"logicGate",
		transparent: true,
		shadow: false,
		logicGate:true,
		shouldBeOn:function(x,y,z,px,pz,world){
			return (world.getRepeaterPower(x,y,z,x-pz,y,z-px) || world.getBlockPower(x-pz,y,z-px,null)
							|| world.getRepeaterPower(x,y,z,x+pz,y,z+px) || world.getBlockPower(x+pz,y,z+px,null)) ? true : false
		},
		category:"redstone"
	},
	{
		name:"andGate",
		Name:"AND Gate",
		textures:["smoothStone","andGate","smoothStone"],
		shapeName:"logicGate",
		transparent: true,
		shadow: false,
		logicGate:true,
		shouldBeOn:function(x,y,z,px,pz,world){
			return ((world.getRepeaterPower(x,y,z,x-pz,y,z-px) || world.getBlockPower(x-pz,y,z-px,null))
							&& (world.getRepeaterPower(x,y,z,x+pz,y,z+px) || world.getBlockPower(x+pz,y,z+px,null))) ? true : false
		},
		category:"redstone"
	},
	{
		name:"notGate",
		Name:"NOT Gate",
		textures:["smoothStone","notGate","smoothStone"],
		shapeName:"logicGate",
		transparent: true,
		shadow: false,
		logicGate:true,
		shouldBeOn:function(x,y,z,px,pz,world){
			return !(world.getRepeaterPower(x,y,z,x-px,y,z-pz) || world.getBlockPower(x-px,y,z-pz,null)) ? true : false
		},
		category:"redstone"
	},
	{
		name:"xorGate",
		Name:"XOR Gate",
		textures:["smoothStone","xorGate","smoothStone"],
		shapeName:"logicGate",
		transparent: true,
		shadow: false,
		logicGate:true,
		shouldBeOn:function(x,y,z,px,pz,world){
			var a = world.getRepeaterPower(x,y,z,x-pz,y,z-px) || world.getBlockPower(x-pz,y,z-px,null)
			var b = world.getRepeaterPower(x,y,z,x+pz,y,z+px) || world.getBlockPower(x+pz,y,z+px,null)
			return ((a||b)&&!(a&&b)) ? true : false
		},
		category:"redstone"
	},
	
	{
		name:"dripstoneBlock",
		Name:"Dripstone Block",
		type:"rock1",
		hardness:1.5,
		blastResistance:1,
		randomRotate:"flip",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true,
		category:"nature"
	},
	{
		name:"pointedDripstone",
		Name:"Sharp Dripstone",
		flatIcon:true,
		iconTexture:"pointedDripstone",
		transparent: true,
		shadow: false,
		hardness:1.5,
		blastResistance:3,
		type:"rock1",
		drop:"pointedDripstone",
		pointing:function(x,y,z,world){
			var b = world.getBlock(x,y,z)
			if(blockData[b].name === this.name) return (b & FLIP) === FLIP ? -1 : 1
		},
		onupdate:function(x,y,z,block,world,sx,sy,sz){
			var down = (block & FLIP) === FLIP
			var pointing = down ? -1 : 1
			if(down){
				var attached = world.getBlock(x,y+1,z)
				if(world.world.settings.blocksFall && (!attached || !blockData[attached].solid)){
					world.setBlock(x,y,z, 0, false,false,false,false)
					world.addEntity(new entities[entityIds.BlockEntity](block, x,y,z),false)
					return
				}
			}else{
				if(needsSupportingBlocks(x,y,z, this.id,world)) return
			}
			
			var target = down ? this.id | FLIP : this.id
			if(this.pointing(x,y+pointing,z,world) === pointing && this.pointing(x,y+pointing*2,z,world) !== pointing) target |= CROSS //frustum
			else if(this.pointing(x,y+pointing,z,world) === pointing && !this.pointing(x,y-pointing,z,world)) target |= SLAB //base
			else if(this.pointing(x,y+pointing,z,world) === pointing) target |= STAIR //middle
			else if(this.pointing(x,y+pointing,z,world) === -pointing) target |= TALLCROSS //tip merge
			
			if(block !== target) world.setBlock(x,y,z,target,false,false,false,false)
		},
		spawnUpdate:function(x,y,z,block,world){
			let down = (block & FLIP) === FLIP
			let pointing = down ? -1 : 1
			let target = down ? this.id | FLIP : this.id
			if(this.pointing(x,y+pointing,z,world) === pointing && this.pointing(x,y+pointing*2,z,world) !== pointing) target |= CROSS //frustum
			else if(this.pointing(x,y+pointing,z,world) === pointing && !this.pointing(x,y-pointing,z,world)) target |= SLAB //base
			else if(this.pointing(x,y+pointing,z,world) === pointing) target |= STAIR //middle
			else if(this.pointing(x,y+pointing,z,world) === -pointing) target |= TALLCROSS //tip merge
			
			if(block !== target) world.spawnBlock(x,y,z,target, true)
		},
		category:"nature",
		randomOffset:true,
	},
	{
		name:"oakSign",
		Name:"Oak sign",
		textures:"oakPlanks",
		poleTop:"logTop",
		poleSide:"logSide",
		iconTexture:"oakSign",
		flatIcon:true,
		sign:true,
		hardness:1,
		woodSound:true,
		type:"wood",
		category:"decoration"
	},
	{
		name:"birchSign",
		Name:"Birch Sign",
		textures:"birchPlanks",
		poleTop:"birchLogTop",
		poleSide:"birchLogSide",
		iconTexture:"birchSign",
		flatIcon:true,
		sign:true,
		hardness:1,
		woodSound:true,
		type:"wood",
		category:"decoration"
	},
	{
		name:"acaciaSign",
		Name:"Acacia Sign",
		textures:"acaciaPlanks",
		poleTop:"acaciaLogTop",
		poleSide:"acaciaLogSide",
		iconTexture:"acaciaSign",
		flatIcon:true,
		sign:true,
		hardness:1,
		woodSound:true,
		type:"wood",
		category:"decoration"
	},
	{
		name:"jungleSign",
		Name:"Jungle Sign",
		textures:"junglePlanks",
		poleTop:"jungleLogTop",
		poleSide:"jungleLogSide",
		iconTexture:"jungleSign",
		flatIcon:true,
		sign:true,
		hardness:1,
		woodSound:true,
		type:"wood",
		category:"decoration"
	},
	{
		name:"spruceSign",
		Name:"Spruce Sign",
		textures:"sprucePlanks",
		poleTop:"spruceLogTop",
		poleSide:"spruceLogSide",
		iconTexture:"spruceSign",
		flatIcon:true,
		sign:true,
		hardness:1,
		woodSound:true,
		type:"wood",
		category:"decoration"
	},
	{
		name:"darkOakSign",
		Name:"Dark Oak Sign",
		textures:"darkOakPlanks",
		poleTop:"darkOakLogTop",
		poleSide:"darkOakLogSide",
		iconTexture:"darkOakSign",
		flatIcon:true,
		sign:true,
		hardness:1,
		woodSound:true,
		type:"wood",
		color:[0.85,0.7,0.2],
		category:"decoration"
	},
	{
		name:"mangroveSign",
		Name:"Mangrove Sign",
		textures:"mangrovePlanks",
		poleTop:"mangroveLogTop",
		poleSide:"mangroveLog",
		iconTexture:"mangroveSign",
		flatIcon:true,
		sign:true,
		hardness:1,
		woodSound:true,
		type:"wood",
		category:"decoration"
	},
	{
		name:"composter",
		Name:"Make bonemeal",
		textures:"composter",
		transparent:true,
		blastResistance:0.6,
		hardness:0.6,
		woodSound:true,
		type:"wood",
		getLevel:function(block){
			var id = this.id
			switch(block){
				case id:
					return 0
				case id | SLAB:
					return 1
				case id | STAIR:
					return 2
				case id | CROSS:
					return 3
				case id | TALLCROSS:
					return 4
				case id | DOOR:
					return 5
				case id | TORCH:
					return 6
				case id | LANTERN:
					return 7
			}
		},
		onclick:function(x,y,z,world,p,holdObj){
			if(!holdObj || !blockData[holdObj.id].compostChance) return true
			let id = blockIds.composter
			let target = id
			let block = world.getBlock(x,y,z)
			let add = rand() <= blockData[holdObj.id].compostChance
			switch(block){
				case id:
					target |= SLAB
					break
				case id | SLAB:
					target |= STAIR
					break
				case id | STAIR:
					target |= CROSS
					break
				case id | CROSS:
					target |= TALLCROSS
					break
				case id | TALLCROSS:
					target |= DOOR
					break
				case id | DOOR:
					target |= TORCH
					break
				case id | TORCH:
					target |= LANTERN
					break
				case id | LANTERN:
					if(add) world.addItems(x,y,z+0.5,0,0,0,blockIds.boneMeal,true, 1)
			}
			holdObj.amount--
			if(add) world.setBlock(x,y,z,target)
			world.glint(x,y,z)
		},
		category:"items"
	},
	{
		name:"cocoaBeans",
		Name:"Cocoa Beans",
		item:true,
		useAs:"cocoa",
		category:"items"
	},
	{
		name:"cocoa",
		textures:"cocoaStage0",
		hardness:0.2,
		blastResistance:3,
		transparent:true,
		shadow:false,
		drop:"cocoaBeans",
		woodSound:true,
		hidden:true,
		liquidBreakable:"drop"
	},
	{
		name:"cookie",
		Name:"Cookie",
		item:true,
		edible: true,
		food: 2,
		saturation: 0.4,
		compostChance:0.85,
		category:"food"
	},
	{
		name:"pumpkinPie",
		Name:"Pumpkin Pie",
		item:true,
		edible: true,
		food: 8,
		saturation: 4.8,
		compostChance:1,
		category:"food"
	},
	{
		name:"rawChicken",
		Name:"Raw Chicken",
		item:true,
		edible: true,
		food: 2,
		saturation: 1.2,
		category:"food"
	},
	{
		name:"cookedChicken",
		Name:"Cooked Chicken",
		item:true,
		edible: true,
		food: 6,
		saturation: 7.2,
		category:"food"
	},
	{
		name:"rawCod",
		Name:"Raw Cod",
		item:true,
		edible: true,
		food: 2,
		saturation: 0.4,
		category:"food"
	},
	{
		name:"cookedCod",
		Name:"Cooked Cod",
		item:true,
		edible: true,
		food: 5,
		saturation: 6,
		category:"food"
	},
	{
		name:"rawMutton",
		Name:"Raw Mutton",
		item:true,
		edible: true,
		food: 2,
		saturation: 1.2,
		category:"food"
	},
	{
		name:"cookedMutton",
		Name:"Cooked Mutton",
		item:true,
		edible: true,
		food: 6,
		saturation: 9.6,
		category:"food"
	},
	{
		name:"rawPorkchop",
		Name:"Raw Porkchop",
		item:true,
		edible: true,
		food: 3,
		saturation: 1.8,
		category:"food"
	},
	{
		name:"cookedPorkchop",
		Name:"Cooked Porkchop",
		item:true,
		edible: true,
		food: 8,
		saturation: 12.8,
		category:"food"
	},
	{
		name:"rawRabbit",
		Name:"Raw Rabbit",
		item:true,
		edible: true,
		food: 3,
		saturation: 1.8,
		category:"food"
	},
	{
		name:"cookedRabbit",
		Name:"Cooked Rabbit",
		item:true,
		edible: true,
		food: 5,
		saturation: 6,
		category:"food"
	},
	{
		name:"rawSalmon",
		Name:"Raw Salmon",
		item:true,
		edible: true,
		food: 2,
		saturation: 0.4,
		category:"food"
	},
	{
		name:"cookedSalmon",
		Name:"Cooked Salmon",
		item:true,
		edible: true,
		food: 6,
		saturation: 9.6,
		category:"food"
	},
	{
		name:"tropicalFish",
		Name:"Tropical Fish",
		item:true,
		edible: true,
		food: 1,
		saturation: 0.2,
		category:"food"
	},
	{
		name:"beetroot",
		Name:"Beetroot",
		item:true,
		edible: true,
		food: 1,
		saturation: 1.2,
		compostChance:0.65,
		category:"food"
	},
	{
		name:"beetrootSoup",
		Name:"Beetroot Soup",
		item:true,
		edible: true,
		food: 7.2,
		saturation: 13.2,
		eatResult:"bowl",
		category:"food",
	},
	{
		name:"carrot",
		Name:"Carrot",
		item:true,
		edible: true,
		food: 3,
		saturation: 3.6,
		compostChance:0.65,
		useAs:function(x,y,z,block,face){
			if(!block) return
			if(face === "top" && blockData[block].name === "farmland") return "carrots"
		},
		category:"food"
	},
	{
		name:"goldenCarrot",
		Name:"Golden Carrot",
		item:true,
		edible: true,
		food: 6,
		saturation: 14.4,
		category:"food"
	},
	{
		name:"rabbitStew",
		Name:"Rabbit Stew",
		item:true,
		edible: true,
		food: 10,
		saturation: 12,
		category:"food"
	},
	{
		name:"goldenApple",
		Name:"Golden Apple",
		item:true,
		edible: true,
		food: 4,
		saturation: 9.6,
		category:"food",
		rarity:"rare"
	},
	{
		name:"rawBeef",
		Name:"Raw Beef",
		item:true,
		edible: true,
		food: 3,
		saturation: 1.8,
		category:"food"
	},
	{
		name:"cookedBeef",
		Name:"stake cooked befe",
		item:true,
		edible: true,
		food: 8,
		saturation: 12.8,
		category:"food"
	},
	{
		name:"potato",
		Name:"Potato",
		item:true,
		edible: true,
		food: 1,
		saturation: 0.6,
		compostChance:0.85,
		useAs:function(x,y,z,block,face){
			if(!block) return
			if(face === "top" && blockData[block].name === "farmland") return "potatoes"
		},
		category:"food",
		growBonemeal:function(x,y,z,world){
			world.setBlock(x,y,z, this.id|CROSS)
		}
	},
	{
		name:"bakedPotato",
		Name:"Baked Potato",
		item:true,
		edible: true,
		food: 5,
		saturation: 6,
		compostChance:0.85,
		category:"food"
	},
	{
		name:"sugar",
		Name:"Sugar",
		item:true,
		category:"items"
	},
	{
		name:"milkBucket",
		Name:"Milk Bucket",
		item:true,
		category:"items"
	},
	{
		name:"beetrootSeeds",
		Name:"Beetroot Seeds",
		item:true,
		useAs:function(x,y,z,block,face){
			if(!block) return
			if(face === "top" && blockData[block].name === "farmland") return "beetroots"
		},
		category:"items"
	},
	{
		name:"beetroots",
		textures:"beetrootsStage0",
		textures1:new Array(6).fill("beetrootsStage1"),
		textures2:new Array(6).fill("beetrootsStage2"),
		textures3:new Array(6).fill("beetrootsStage3"),
		transparent: true,
		shadow: false,
		solid: false,
		crop: true,
		drop:"beetrootSeeds",
		hidden:true,
		liquidBreakable:"drop",
		growBonemeal:function(x,y,z,world){
			world.setBlock(x,y,z, this.id|CROSS)
		}
	},
	{
		name:"potatoes",
		textures:"potatoesStage0",
		textures1:new Array(6).fill("potatoesStage1"),
		textures2:new Array(6).fill("potatoesStage2"),
		textures3:new Array(6).fill("potatoesStage3"),
		transparent: true,
		shadow: false,
		solid: false,
		crop: true,
		drop:"potato",
		hidden:true,
		liquidBreakable:"drop"
	},
	{
		name:"carrots",
		textures:"carrotsStage0",
		textures1:new Array(6).fill("carrotsStage1"),
		textures2:new Array(6).fill("carrotsStage2"),
		textures3:new Array(6).fill("carrotsStage3"),
		transparent: true,
		shadow: false,
		solid: false,
		crop: true,
		drop:"carrot",
		hidden:true,
		liquidBreakable:"drop",
		growBonemeal:function(x,y,z,world){
			world.setBlock(x,y,z, this.id|CROSS)
		}
	},
	
	{
		name:"mudPie",
		Name:"Mud Pie",
		item:true,
		edible: true,
		food: 1,
		saturation: 1,
		category:"food"
	},
	{
		name:"purpleGrapes",
		Name:"Purple Grapes",
		item:true,
		edible: true,
		food: 3,
		saturation: 3,
		category:"food"
	},
	{
		name:"greenGrapes",
		Name:"Green Grapes",
		item:true,
		edible: true,
		food: 3,
		saturation: 3,
		category:"food"
	},
	{
		name:"oakChair",
		Name:"Oak Chair",
		textures:"oakPlanks",
		chair:true,
		transparent:true,
		shadow:false,
		onclientclick:sit,
		category:"items"
	},
	
	{
		name:"lightGrayBed",
		Name:"Light Gray Bed",
		textures: "lightGrayBed",
		iconTexture: "lightGrayBedIcon",
		flatIcon: true,
		transparent: true,
		bed: true,
		bounciness: 0.6,
		category:"items"
	},
	{
		name:"lightBlueBed",
		Name:"Light Blue Bed",
		textures: "lightBlueBed",
		iconTexture: "lightBlueBedIcon",
		flatIcon: true,
		transparent: true,
		bed: true,
		bounciness: 0.6,
		category:"items"
	},
	{
		name:"magentaBed",
		Name:"Magenta Bed",
		textures: "magentaBed",
		iconTexture: "magentaBedIcon",
		flatIcon: true,
		transparent: true,
		bed: true,
		bounciness: 0.6,
		category:"items"
	},
	{
		name:"yellowBed",
		Name:"Yellow Bed",
		textures: "yellowBed",
		iconTexture: "yellowBedIcon",
		flatIcon: true,
		transparent: true,
		bed: true,
		bounciness: 0.6,
		category:"items"
	},
	{
		name:"purpleBed",
		Name:"Purple Bed",
		textures: "purpleBed",
		iconTexture: "purpleBedIcon",
		flatIcon: true,
		transparent: true,
		bed: true,
		bounciness: 0.6,
		category:"items"
	},
	{
		name:"orangeBed",
		Name:"Orange Bed",
		textures: "orangeBed",
		iconTexture: "orangeBedIcon",
		flatIcon: true,
		transparent: true,
		bed: true,
		bounciness: 0.6,
		category:"items"
	},
	{
		name:"whiteBed",
		Name:"White Bed",
		textures: "whiteBed",
		iconTexture: "whiteBedIcon",
		flatIcon: true,
		transparent: true,
		bed: true,
		bounciness: 0.6,
		category:"items"
	},
	{
		name:"greenBed",
		Name:"Green Bed",
		textures: "greenBed",
		iconTexture: "greenBedIcon",
		flatIcon: true,
		transparent: true,
		bed: true,
		bounciness: 0.6,
		category:"items"
	},
	{
		name:"brownBed",
		Name:"Brown Bed",
		textures: "brownBed",
		iconTexture: "brownBedIcon",
		flatIcon: true,
		transparent: true,
		bed: true,
		bounciness: 0.6,
		category:"items"
	},
	{
		name:"blackBed",
		Name:"Black Bed",
		textures: "blackBed",
		iconTexture: "blackBedIcon",
		flatIcon: true,
		transparent: true,
		bed: true,
		bounciness: 0.6,
		category:"items"
	},
	{
		name:"pinkBed",
		Name:"Pink Bed",
		textures: "pinkBed",
		iconTexture: "pinkBedIcon",
		flatIcon: true,
		transparent: true,
		bed: true,
		bounciness: 0.6,
		category:"items"
	},
	{
		name:"limeBed",
		Name:"Lime Bed",
		textures: "limeBed",
		iconTexture: "limeBedIcon",
		flatIcon: true,
		transparent: true,
		bed: true,
		bounciness: 0.6,
		category:"items"
	},
	{
		name:"grayBed",
		Name:"Gray Bed",
		textures: "grayBed",
		iconTexture: "grayBedIcon",
		flatIcon: true,
		transparent: true,
		bed: true,
		bounciness: 0.6,
		category:"items"
	},
	{
		name:"cyanBed",
		Name:"Cyan Bed",
		textures: "cyanBed",
		iconTexture: "cyanBedIcon",
		flatIcon: true,
		transparent: true,
		bed: true,
		bounciness: 0.6,
		category:"items"
	},
	{
		name:"blueBed",
		Name:"Blue Bed",
		textures: "blueBed",
		iconTexture: "blueBedIcon",
		flatIcon: true,
		transparent: true,
		bed: true,
		bounciness: 0.6,
		category:"items"
	},
	{
		name:"quicksand",
		Name:"Quicksand",
		quicksand:true,
		solid:false,
		category:"nature"
	},
	{
		name:"bow",
		Name:"Bow",
		pullTextures:["bow","bowPulling0","bowPulling1","bowPulling2"],
		useAnywhere:true,
		item:true,
		stackSize:1,
		category:"tools"
	},
	{
		name:"arrow",
		Name:"Arrow",
		textures:"arrowIcon",
		item:true,
		category:"items"
	},
	{
		name:"glisteringMelonSlice",
		Name:"Slice of Watermelon With Unedible Gold",
		item:true,
		category:"items"
	},
	{
		name:"untnt",
		Name:"UnTNT",
		textures:["untntBottom","untntTop","untnt"],
		explode:function(x,y,z,how,world){
			world.setBlock(x,y,z,0,false,false,false,false)
			var e = new entities[entityIds.PrimedUnTNT](x,y,z)
			world.addEntity(e,false)
			world.playSound(x,y,z, "random.fuse")
			switch(how){
				case "explosion":
					e.timeLimit = rand(10,30)
			}
		},
		burnChance:0.6,
		onburn:function(x,y,z,world){
			this.explode(x,y,z,null,world)
		},
		category:"redstone"
	},
	{
		name:"crimsonSign",
		Name:"Crimson Sign",
		textures:"crimsonPlanks",
		poleTop:"crimsonStemTop",
		poleSide:"crimsonStemSide",
		iconTexture:"crimsonSign",
		flatIcon:true,
		sign:true,
		hardness:1,
		woodSound:true,
		type:"wood",
		category:"decoration"
	},
	{
		name:"warpedSign",
		Name:"Warped Sign",
		textures:"warpedPlanks",
		poleTop:"warpedStemTop",
		poleSide:"warpedStemSide",
		iconTexture:"warpedSign",
		flatIcon:true,
		sign:true,
		hardness:1,
		woodSound:true,
		type:"wood",
		category:"decoration"
	},
	{
		name:"dropper",
		Name:"Dropper",
		textures:["furnaceTop","furnaceTop","furnaceSide","dropperFront","furnaceSide","furnaceSide"],
		upTextures:fillTextureArray(["furnaceTop","dropperFrontVertical","furnaceTop"]),
		downTextures:fillTextureArray(["dropperFrontVertical","furnaceTop","furnaceTop"]),
		stoneSound:true,
		category:"redstone",
		tagBits: null,
		hasContents:function(tags){return tags&&tags.contents},
		setContents:function(x,y,z,world){
			let data = {dispenser:true, contents:new Array(9).fill(0)}
			world.setTags(x, y, z, data,false)
			return data
		},
		onbreak:function(x,y,z, block, data,world){
			if(!(data && data.dispenser && data.contents)) return
			data = data.contents
			for(var i=0; i<data.length; i++){
				if(data[i]){
					world.addItems(x,y,z,0,0,0,data[i].id, true, data[i].amount, data[i].durability, data[i].customName)
				}
			}
		},
		onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,world){
			var block = world.getBlock(x,y,z)
			var power = world.getRedstonePower(x,y,z) || world.getSurroundingBlockPower(x,y,z)
			var tags = world.getTags(x,y,z)
			var on = tags && tags.on || false
			if(power !== on) {
				world.setTagByName(x,y,z,"on",power,false)
				if(power){
					var me = this
					world.setTimeout(function(){
						world.playSound(x,y,z, "click")
						if(!tags || !tags.contents) return
						var items = tags.contents.filter(r => r)
						var idx = floor(rand(items.length))
						if(!items[idx]) return
						idx = tags.contents.indexOf(items[idx]), items = tags.contents
						var vx = 0, vy = 0, vz = 0, ix = x, iy = y, iz = z, tx = x, ty = y, tz = z
						switch(block){
							case me.id | NORTH:
								vz = -0.25
								iz -= 0.75
								tz--
								break
							case me.id | SOUTH:
								vz = 0.25
								iz += 0.75
								tz++
								break
							case me.id | EAST:
								vx = -0.25
								ix -= 0.75
								tx--
								break
							case me.id | WEST:
								vx = 0.25
								ix += 0.75
								tx++
								break
							case me.id | SLAB:
								vy = 0.25
								iy += 0.75
								ty++
								break
							case me.id | STAIR:
								vy = -0.25
								iy -= 0.75
								ty--
								break
						}
						if(!putItemInContainer(tx,ty,tz,items[idx].id,items[idx].durability,items[idx].customName,false,world)){
							world.addItems(ix,iy,iz,vx,vy,vz,items[idx].id, false, 1, items[idx].durability, items[idx].customName)
						}
						items[idx].amount--
						if(items[idx].amount <= 0) items[idx] = 0
						world.setTags(x,y,z,tags,false)
					},tickTime*4, x,y,z)
				}
			}
		},
		onset:function(x,y,z,world){
			this.onpowerupdate(x,y,z,null,null,null,null,world)
		},
	},
	{
		name:"dispenser",
		Name:"Dispenser",
		textures:["furnaceTop","furnaceTop","furnaceSide","dispenserFront","furnaceSide","furnaceSide"],
		upTextures:fillTextureArray(["furnaceTop","dispenserFrontVertical","furnaceTop"]),
		downTextures:fillTextureArray(["dispenserFrontVertical","furnaceTop","furnaceTop"]),
		stoneSound:true,
		category:"redstone",
		hardness:3.5,
		type:"rock2",
		tagBits: null,
		hasContents:function(tags){return tags&&tags.contents},
		setContents:function(x,y,z,world){
			let data = {dispenser:true, contents:new Array(9).fill(0)}
			world.setTags(x, y, z, data,false)
			return data
		},
		onbreak:function(x,y,z, block, data,world){
			if(!(data && data.dispenser && data.contents)) return
			data = data.contents
			for(var i=0; i<data.length; i++){
				if(data[i]){
					world.addItems(x,y,z,0,0,0,data[i].id, true, data[i].amount, data[i].durability, data[i].customName)
				}
			}
		},
		onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,world){
			var block = world.getBlock(x,y,z)
			var power = world.getRedstonePower(x,y,z) || world.getSurroundingBlockPower(x,y,z)
			var tags = world.getTags(x,y,z)
			var on = tags && tags.on || false
			if(power !== on) {
				world.setTagByName(x,y,z,"on",power,false)
				if(power){
					var me = this
					world.setTimeout(function(){
						world.playSound(x,y,z, "click")
						if(!tags || !tags.contents) return
						var items = tags.contents.filter(r => r)
						var idx = floor(rand(items.length))
						if(!items[idx]) return
						idx = tags.contents.indexOf(items[idx]), items = tags.contents
						var vx = 0, vy = 0, vz = 0, ix = x, iy = y, iz = z
						switch(block){
							case me.id | NORTH:
								vz = -0.25
								iz--
								break
							case me.id | SOUTH:
								vz = 0.25
								iz++
								break
							case me.id | EAST:
								vx = -0.25
								ix--
								break
							case me.id | WEST:
								vx = 0.25
								ix++
								break
							case me.id | SLAB:
								vy = 0.25
								iy++
								break
							case me.id | STAIR:
								vy = -0.25
								iy--
								break
						}
						var front = world.getBlock(ix,iy,iz)
						if(front && blockData[front].solid) return
						var data = blockData[items[idx].id]
						var minus = true
						if(data.name === "arrow") world.addEntity(new entities[entityIds.Arrow](ix,iy,iz,vx*4,vy*4,vz*4),false)
						else if(data.name === "boneMeal") data.serveronuse(ix,iy,iz, front, world,"",items[idx],{}), minus = false
						else if(data.name === "snowball") world.addEntity(new entities[entityIds.Snowball](ix,iy,iz,vx*4,vy*4,vz*4),false)
						else if(data.name === "egg") world.addEntity(new entities[entityIds.Egg](ix,iy,iz,vx*4,vy*4,vz*4),false)
						else if(data.name === "bucket"){
							var set = false
							if(front === blockIds.Water) set = true, items[idx].id = blockIds.waterBucket
							if(front === blockIds.Lava) set = true, items[idx].id = blockIds.lavaBucket
							if(front === blockIds.powderSnow) set = true, items[idx].id = blockIds.powderSnowBucket
							if(front === blockIds.oil) set = true, items[idx].id = blockIds.oilBucket
							world.setBlock(ix,iy,iz,0,false,false,false,false)
							minus = false
						}else if(data.name === "waterBucket") world.setBlock(ix,iy,iz,blockIds.Water,false,false,false,false), items[idx].id = blockIds.bucket, minus = false
						else if(data.name === "lavaBucket") world.setBlock(ix,iy,iz,blockIds.Lava,false,false,false,false), items[idx].id = blockIds.bucket, minus = false
						else if(data.name === "powderSnowBucket") world.setBlock(ix,iy,iz,blockIds.powderSnow,false,false,false,false), items[idx].id = blockIds.bucket, minus = false
						else if(data.name === "oilBucket") world.setBlock(ix,iy,iz,blockIds.oil,false,false,false,false), items[idx].id = blockIds.bucket, minus = false
						else if(data.name === "tnt") data.explode(ix,iy,iz,null,world)
						else if(data.item) world.addItems(ix,iy,iz,vx,vy,vz,items[idx].id, false, 1, items[idx].durability, items[idx].customName)
						else world.setBlock(ix,iy,iz,items[idx].id,false,false,false,false)
						if(minus) items[idx].amount--
						if(items[idx].amount <= 0) items[idx] = 0
						world.setTags(x,y,z,tags,false)
					},tickTime*4, x,y,z)
				}
			}
		},
		onset:function(x,y,z,world){
			this.onpowerupdate(x,y,z,null,null,null,null,world)
		},
	},
	{
		name:"hopper",
		Name:"Hopper",
		textures:"hopper",
		flatIcon:true,
		iconTexture:"hopperIcon",
		blastResistance:4.8,
		transparent:true,
		hardness:3,
		type:"metal2",
		stoneSound:true,
		category:"redstone",
		tagBits: null,
		hasContents:function(tags){return tags&&tags.contents},
		setContents:function(x,y,z,world){
			let data = {hopper:true, contents:new Array(5).fill(0)}
			world.setTags(x, y, z, data,false)
			return data
		},
		onbreak:function(x,y,z, block, data,world){
			if(!(data && data.hopper && data.contents)) return
			data = data.contents
			for(var i=0; i<data.length; i++){
				if(data[i]){
					world.addItems(x,y,z,0,0,0,data[i].id, true, data[i].amount, data[i].durability, data[i].customName)
				}
			}
		},
		pushItem:function(x,y,z,tags,world){
			var tx = x, ty = y, tz = z, top, dx = 0, dy = 0, dz = 0
			switch(world.getBlock(x,y,z)){
				case this.id:
					ty--
					dy = -1
					top = true
					break
				case this.id | SLAB | NORTH:
					tz++
					dz = 1
					break
				case this.id | SLAB | SOUTH:
					tz--
					dz = -1
					break
				case this.id | SLAB | EAST:
					tx++
					dx = 1
					break
				case this.id | SLAB | WEST:
					tx--
					dx = -1
					break
			}
			var to = world.getBlock(tx,ty,tz)
			for(var i=0; i<tags.contents.length; i++){
				var item = tags.contents[i]
				if(!item || !item.id) continue
				var put
				if(!to || !blockData[to].solid){
					world.addItems(x+dx*0.625,y+dy*0.625,z+dz*0.625,dx/8,dy/8,dz/8,item.id, false, 1, item.durability, item.customName)
					put = true
				}else if(blockData[to].name === "furnace"){
					var toTags = world.getTags(tx,ty,tz), toTagName
					if(!toTags) toTags = blockData[to].setContents(tx,ty,tz,this.world)
					if(top) toTagName = "input"
					else toTagName = "fuel"
					var toTag = toTags[toTagName]
					if(!toTag){
						toTag = {id:item.id,amount:1,durability:item.durability,customName:item.customName}
						put = true
					}else if(toTag.id === item.id && (!toTag.customName && !item.customName || toTag.customName === item.customName) && toTag.amount < blockData[toTag.id].stackSize){
						toTag.amount++
						put = true
					}
					if(put){
						toTags[toTagName] = toTag
						world.setTags(tx,ty,tz,toTags,false)
					}
				}else if(putItemInContainer(tx,ty,tz,item.id,item.durability,item.customName,false,world)){
					put = true
				}
				if(put){
					item.amount--
					if(!item.amount) tags.contents[i] = 0
					return true
				}
			}
		},
		pullItem:function(x,y,z,myTags,world){
			var block = world.getBlock(x,y+1,z)
			var tags = world.getTags(x,y+1,z)
			if(!blockData[block].hasContents || !blockData[block].hasContents(tags)) return
			if(blockData[block].name === "furnace"){
				var item = tags.output
				if(item && item.id){
					if(!putItemInContainer(x,y,z,item.id,item.durability,item.customName,true,world)) return
					item.amount--
					if(!item.amount) tags.output = 0
					world.tagsChanged(x,y,z,tags,false)
					return true
				}
			}else if(tags.contents) for(var i=0; i<tags.contents.length; i++){
				var item = tags.contents[i]
				if(item && item.id){
					if(!putItemInContainer(x,y,z,item.id,item.durability,item.customName,true,world)) return
					item.amount--
					if(!item.amount) tags.contents[i] = 0
					world.tagsChanged(x,y,z,tags,false)
					return true
				}
			}
		},
		update:function(x,y,z,world){
			if(this.isLocked(x,y,z,world)) return
			var tags = world.getTags(x,y,z)
			if(!tags) tags = this.setContents(x,y,z,world)
			var u = false
			if(this.pushItem(x,y,z,tags,world)) u = true
			if(this.pullItem(x,y,z,tags,world)) u = true
			if(u) world.setTags(x,y,z,tags,false)
		},
		onupdate:function(x,y,z,block,world,sx,sy,sz){
			var me = this
			var t = () => me.update(x,y,z,world)
			world.setTimeout(t, tickTime*8, x,y,z)
		},
		onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,world){
			this.onupdate(x,y,z,null,world,sx,sy,sz,world)
		},
		ontagsupdate:function(x,y,z,tags,world){
			this.onupdate(x,y,z,null,world,null,null,null,world)
		},
		isLocked:function(x,y,z,world){
			return world.getRedstonePower(x,y,z) || world.getSurroundingBlockPower(x,y,z)
		},
		itemOnTop(x,y,z,ent){
			let world = ent.world
			if(this.isLocked(x,y,z,world)) return
			var amount = ent.amount
			while(amount){
				if(!putItemInContainer(x,y,z,ent.block,ent.durability,ent.name,false,world)) break
				amount--
			}
			return amount
		}
	},
	{
		name:"target",
		Name:"Target",
		textures:["targetTop","targetSide"],
		hardness:0.5,
		blastResistance:0.5,
		burnChance: 0.2,
		burnTime: 20,
		category:"redstone",
		grassSound: true,
		type:"plant2",
		cornerDist:sqrt(0.75),
		sideDist:0.5,
		projectileHit:function(x,y,z,ent){
			let world = ent.world
			var dist = dist3(ent.x+ent.direction.x/2,ent.y+ent.direction.y/2,ent.z+ent.direction.z/2,x,y,z)
			var power = round(map(dist,this.sideDist,this.cornerDist,15,0))
			world.setPower(x,y,z,power,false)
			world.spreadPower(x,y,z,power)
			world.setTimeout(function(){
				world.setPower(x,y,z,0,false)
				world.unspreadPower(x,y,z,power,false)
			},tickTime*8, x,y,z)
		}
	},
	{
		name:"comparator",
		Name:"Redstone Comparator",
		transparent:true,
		flatIcon:true,
		iconTexture:"comparatorIcon",
		category:"redstone",
		tagBits:{
			output:[0,4]
		},
		on:function(x,y,z,dx,dy,dz,subtract,world){
			var fx = x-dx, fy = y-dy, fz = z-dz
			var backPower = min(max(world.getRepeaterPower(x,y,z,fx,fy,fz),ceil((getContainerFullness(fx,fy,fz,world) || 0)*15)),15)
			if(world.getBlockPower(fx,fy,fz,null)) backPower = 15
			var sidePower = min(max(world.getRepeaterPower(x,y,z,x-dz,y-dy,z-dx),world.getRepeaterPower(x,y,z,x+dz,y-dy,z+dx)),15)
			if(subtract) return max(backPower - sidePower, 0)
			else return backPower * (sidePower <= backPower)
		},
		onupdate:function(x,y,z,b,w,sx,sy,sz){
			this.onpowerupdate(x,y,z,null,null,null,null,w)
		},
		ontagsupdate:function(x,y,z,tags,world){
			this.onpowerupdate(x,y,z,null,null,null,null,world)
		},
		ondelete:function(x,y,z,prevTags,prevBlock,world){
			world.unspreadPower(x,y,z,16)
			world.setBlockPower(x,y,z+1,null,"south")
			world.setBlockPower(x,y,z-1,null,"north")
			world.setBlockPower(x+1,y,z,null,"east")
			world.setBlockPower(x-1,y,z,null,"west")
		},
		onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,world){
			var dx = 0, dy = 0, dz = 0 //direction
			var side //side of block it's pointing to
			var block = world.getBlock(x,y,z)
			var offCompare = this.id, onCompare = this.id | SLAB, offSubtract = this.id | STAIR, onSubtract = this.id | DOOR
			var subtractMode
			switch(block){
				case offSubtract | NORTH:
				case onSubtract | NORTH:
					subtractMode = true
				case offCompare | NORTH:
				case onCompare | NORTH:
					dz = 1
					side = "south"
					break
				case offSubtract | SOUTH:
				case onSubtract | SOUTH:
					subtractMode = true
				case offCompare | SOUTH:
				case onCompare | SOUTH:
					dz = -1
					side = "north"
					break
				case offSubtract | EAST:
				case onSubtract | EAST:
					subtractMode = true
				case offCompare | EAST:
				case onCompare | EAST:
					dx = 1
					side = "east"
					break
				case offSubtract | WEST:
				case onSubtract | WEST:
					subtractMode = true
				case offCompare | WEST:
				case onCompare | WEST:
					dx = -1
					side = "west"
					break
			}
			if(!dx && !dy && !dz) return console.log("doesn't match up") //doesn't match up
			
			var tx = x+dx, ty = y+dy, tz = z+dz
			var output = world.getTagByName(x,y,z,"output") || 0
			var power = this.on(x,y,z,dx,dy,dz,subtractMode,world)
			var tblock = world.getBlock(tx,ty,tz)
			if(tblock && blockData[tblock].carryRedstone){
				if(output){
					var frontPower = world.getPower(tx,ty,tz)
					if(output < frontPower){
						world.unspreadPower(tx,ty,tz,frontPower,true)
					}else if(output > frontPower){
						world.setPower(tx,ty,tz,output,false)
						world.spreadPower(tx,ty,tz,output)
					}
				}
			}
			
			if(power === output) return
			var me = this
			var t = function(){
				block = world.getBlock(x,y,z)
				power = me.on(x,y,z,dx,dy,dz,subtractMode,world)
				output = world.getTagByName(x,y,z,"output") || 0
				if(power !== output) {
					world.setTagByName(x,y,z,"output",power,false)
					var on = false
					switch(block){
						case onSubtract | NORTH:
						case onCompare | NORTH:
						case onSubtract | SOUTH:
						case onCompare | SOUTH:
						case onSubtract | EAST:
						case onCompare | EAST:
						case onSubtract | WEST:
						case onCompare | WEST:
							on = true
					}
					if((power ? true : false) !== on){
						var target
						switch(block){
							case offCompare | NORTH:
								target = onCompare | NORTH
								break
							case onCompare | NORTH:
								target = offCompare | NORTH
								break
							case offSubtract | NORTH:
								target = onSubtract | NORTH
								break
							case onSubtract | NORTH:
								target = offSubtract | NORTH
								break
							case offCompare | SOUTH:
								target = onCompare | SOUTH
								break
							case onCompare | SOUTH:
								target = offCompare | SOUTH
								break
							case offSubtract | SOUTH:
								target = onSubtract | SOUTH
								break
							case onSubtract | SOUTH:
								target = offSubtract | SOUTH
								break
							case offCompare | EAST:
								target = onCompare | EAST
								break
							case onCompare | EAST:
								target = offCompare | EAST
								break
							case offSubtract | EAST:
								target = onSubtract | EAST
								break
							case onSubtract | EAST:
								target = offSubtract | EAST
								break
							case offCompare | WEST:
								target = onCompare | WEST
								break
							case onCompare | WEST:
								target = offCompare | WEST
								break
							case offSubtract | WEST:
								target = onSubtract | WEST
								break
							case onSubtract | WEST:
								target = offSubtract | WEST
								break
						}
						if(block !== target) world.setBlock(x,y,z,target,false,false,false,true)
					}
					
					var tblock = world.getBlock(tx,ty,tz)
					if(power){
						if(tblock && blockData[tblock].carryRedstone){
							var frontPower = world.getPower(tx,ty,tz)
							if(power < frontPower){
								world.unspreadPower(tx,ty,tz,frontPower,true)
							}else if(power > frontPower){
								world.setPower(tx,ty,tz,power,false)
								world.spreadPower(tx,ty,tz,power)
							}
						}
					}else{
						if(tblock && blockData[tblock].carryRedstone){
							world.unspreadPower(tx,ty,tz,output,true)
						}
					}
				}//end if power changed
			}
			world.setTimeout(t,tickTime*2, x,y,z)
		},
		onclick:function(x,y,z,world){
			var me = blockData[blockIds.comparator]
			var block = world.getBlock(x,y,z)
			var off = me.id, on = me.id | SLAB, offSubtract = me.id | STAIR, onSubtract = me.id | DOOR
			var target
			switch(block){
				case off | NORTH:
					target = offSubtract | NORTH
					break
				case on | NORTH:
					target = onSubtract | NORTH
					break
				case offSubtract | NORTH:
					target = off | NORTH
					break
				case onSubtract | NORTH:
					target = on | NORTH
					break
				case off | SOUTH:
					target = offSubtract | SOUTH
					break
				case on | SOUTH:
					target = onSubtract | SOUTH
					break
				case offSubtract | SOUTH:
					target = off | SOUTH
					break
				case onSubtract | SOUTH:
					target = on | SOUTH
					break
				case off | EAST:
					target = offSubtract | EAST
					break
				case on | EAST:
					target = onSubtract | EAST
					break
				case offSubtract | EAST:
					target = off | EAST
					break
				case onSubtract | EAST:
					target = on | EAST
					break
				case off | WEST:
					target = offSubtract | WEST
					break
				case on | WEST:
					target = onSubtract | WEST
					break
				case offSubtract | WEST:
					target = off | WEST
					break
				case onSubtract | WEST:
					target = on | WEST
					break
			}
			world.setBlock(x,y,z,target,false,false,false,true)
		},
		getFacing:function(x,y,z,world){
			var block = world.getBlock(x,y,z)
			var off = this.id, on = this.id | SLAB, offSubtract = this.id | STAIR, onSubtract = this.id | DOOR
			var f
			switch(block){
				case off | NORTH:
				case on | NORTH:
				case offSubtract | NORTH:
				case onSubtract | NORTH:
					f = "north"
					break
				case off | SOUTH:
				case on | SOUTH:
				case offSubtract | SOUTH:
				case onSubtract | SOUTH:
					f = "south"
					break
				case off | EAST:
				case on | EAST:
				case offSubtract | EAST:
				case onSubtract | EAST:
					f = "east"
					break
				case off | WEST:
				case on | WEST:
				case offSubtract | WEST:
				case onSubtract | WEST:
					f = "west"
					break
			}
			return f
		},
		canHavePower:function(/*this*/rx,ry,rz,/*other thing*/x,y,z,world){
			var tx = rx, ty = ry, tz = rz
			var block = world.getBlock(rx,ry,rz)
			var off = this.id, on = this.id | SLAB, offSubtract = this.id | STAIR, onSubtract = this.id | DOOR
			switch(block){
				case offSubtract | NORTH:
				case onSubtract | NORTH:
				case off | NORTH:
				case on | NORTH:
					tz++
					break
				case offSubtract | SOUTH:
				case onSubtract | SOUTH:
				case off | SOUTH:
				case on | SOUTH:
					tz--
					break
				case offSubtract | EAST:
				case onSubtract | EAST:
				case off | EAST:
				case on | EAST:
					tx++
					break
				case offSubtract | WEST:
				case onSubtract | WEST:
				case off | WEST:
				case on | WEST:
					tx--
					break
			}
			
			if(tx === x && ty === y && tz === z){
				return world.getTagByName(rx,ry,rz,"output") || 0
			}
			return 0
		}
	},
	
	{
		name:"acaciaChair",
		Name:"Acacia Chair",
		textures:"acaciaPlanks",
		chair:true,
		transparent:true,
		shadow:false,
		onclientclick:sit,
		category:"items"
	},
	{
		name:"birchChair",
		Name:"Birch Chair",
		textures:"birchPlanks",
		chair:true,
		transparent:true,
		shadow:false,
		onclientclick:sit,
		category:"items"
	},
	{
		name:"jungleChair",
		Name:"Jungle Chair",
		textures:"junglePlanks",
		chair:true,
		transparent:true,
		shadow:false,
		onclientclick:sit,
		category:"items"
	},
	{
		name:"darkOakChair",
		Name:"Dark Oak Chair",
		textures:"darkOakPlanks",
		chair:true,
		transparent:true,
		shadow:false,
		onclientclick:sit,
		category:"items"
	},
	{
		name:"spruceChair",
		Name:"Spruce Chair",
		textures:"sprucePlanks",
		chair:true,
		transparent:true,
		shadow:false,
		onclientclick:sit,
		category:"items"
	},
	{
		name:"mangroveChair",
		Name:"Mangrove Chair",
		textures:"mangrovePlanks",
		chair:true,
		transparent:true,
		shadow:false,
		onclientclick:sit,
		category:"items"
	},
	{
		name:"crimsonChair",
		Name:"Crimson Chair",
		textures:"crimsonPlanks",
		chair:true,
		transparent:true,
		shadow:false,
		onclientclick:sit,
		category:"items"
	},
	{
		name:"warpedChair",
		Name:"Warped Chair",
		textures:"warpedPlanks",
		chair:true,
		transparent:true,
		shadow:false,
		onclientclick:sit,
		category:"items"
	},
	{
		name:"blackChair",
		Name:"Black Chair",
		textures:"blackWool",
		chair:true,
		transparent:true,
		shadow:false,
		onclientclick:sit,
		category:"items"
	},
	{
		name: "spawnCreeper",
		item: true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			let pos = movePositionByFace(face,x,y,z)
			let ent = new entities[entityIds.Creeper](pos[0],pos[1],pos[2])
			if(item.customName) ent.name = item.customName
			world.addEntity(ent)
			item.amount--
		},
		spawnMob: function(x,y,z,world){
			world.addEntity(new entities[entityIds.Creeper](x,y,z),false)
		},
		category:"items"
	},
	{
		name:"gunpowder",
		Name:"Gray exploding stuff",
		item:true
	},
	{
		name:"rottenFlesh",
		Name:"Rotten Flesh",
		item:true
	},
	{
		name: "spawnSheep",
		item: true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			let pos = movePositionByFace(face,x,y,z)
			let ent = new entities[entityIds.Sheep](pos[0],pos[1],pos[2])
			if(item.customName) ent.name = item.customName
			world.addEntity(ent)
			item.amount--
		},
		spawnMob: function(x,y,z,world){
			world.addEntity(new entities[entityIds.Sheep](x,y,z),false)
		},
		category:"items"
	},
	{
		name: "spawnChicken",
		item: true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			let pos = movePositionByFace(face,x,y,z)
			let ent = new entities[entityIds.Chicken](pos[0],pos[1],pos[2])
			if(item.customName) ent.name = item.customName
			world.addEntity(ent)
			item.amount--
		},
		spawnMob: function(x,y,z,world){
			world.addEntity(new entities[entityIds.Chicken](x,y,z),false)
		},
		category:"items"
	},
	{
		name:"feather",
		Name:"Feather",
		item:true
	},
	{
		name: "spawnZombie",
		item: true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			let pos = movePositionByFace(face,x,y,z)
			let ent = new entities[entityIds.Zombie](pos[0],pos[1],pos[2])
			if(item.customName) ent.name = item.customName
			world.addEntity(ent)
			item.amount--
		},
		spawnMob: function(x,y,z,world){
			world.addEntity(new entities[entityIds.Zombie](x,y,z),false)
		},
		category:"items"
	},
	{
		name: "spawnSkeleton",
		item: true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			let pos = movePositionByFace(face,x,y,z)
			let ent = new entities[entityIds.Skeleton](pos[0],pos[1],pos[2])
			if(item.customName) ent.name = item.customName
			world.addEntity(ent)
			item.amount--
		},
		spawnMob: function(x,y,z,world){
			world.addEntity(new entities[entityIds.Skeleton](x,y,z),false)
		},
		category:"items"
	},
	{
		name: "bone",
		Name: "Bone",
		item: true,
		category:"items"
	},
	{
		name:"spawner",
		Name:"Mob Spawner",
		transparent:true,
		blastResistance:5,
		hardness:5,
		drop:"air",
		experience:15,
		tagBits:null,
		tick:function(block,x,y,z,world){
			let spawn = world.getTagByName(x,y,z,"spawn")
			if(spawn){
				world.sendAll({
					type:"particles", particleType:"flameCube",
					x,y,z,dimension:world.dimension, amount: 20
				})
				for(let i=0; i<10; i++){
					let sx = x+round(rand(-4.5,4))
					let sy = y+round(rand(-1.5,1.5))
					let sz = z+round(rand(-4.5,4))
					let block = world.getBlock(sx,sy,sz)
					if(blockData[block].transparent){
						blockData[spawn].spawnMob(sx,sy,sz,world)
						break
					}
				}
			}
		},
		onclick:function(x,y,z,world,p){
			if(p.holding && blockData[p.holding].spawnMob){
				world.setTagByName(x,y,z,"spawn",p.holding)
				world.sendAll({
					type:"particles", particleType:"flameCube",
					x,y,z,dimension:world.dimension, amount: 30
				})
			}else return true
		}
	},
	{
		name:"daylightDetector",
		Name:"Daylight detector",
		textures:["daylightDetectorSide","daylightDetectorTop","daylightDetectorSide"],
		invertedTextures:fillTextureArray(["daylightDetectorSide","daylightDetectorInvertedTop","daylightDetectorSide"]),
		transparent:true,
		blastResistance:0.2,
		hardness:0.2,
		woodSound:true,
		onclick:function(x,y,z,world){
			let block = world.getBlock(x,y,z)
			let me = blockData[blockIds.daylightDetector]
			if(block === (me.id | SLAB)) block = me.id
			else block = me.id | SLAB
			world.setBlock(x,y,z,block)
		},
		tick:function(block,x,y,z,world){
			let power = round(world.getLight(x, y, z, 0)*world.world.skyLight)
			if(block === (this.id | SLAB)) power = 15 - power
			let prev = world.getPower(x,y,z)
			if(prev !== power){
				world.setPower(x,y,z,power,false)
				if(power){
					if(power < prev){
						world.unspreadPower(x,y,z,prev,false)
					}else if(power > prev){
						world.spreadPower(x,y,z,power)
					}
				}else{
					world.unspreadPower(x,y,z,prev,false)
				}
			}
		},
		onset:function(x,y,z,world){
			this.tick(world.getBlock(x,y,z),x,y,z,world)
		},
		ondelete: function(x,y,z,prevTags,prev,world){
			world.setPower(x,y,z,0)
			world.unspreadPower(x,y,z, 16)
		},
		category:"redstone"
	},
	{
		name:"commandBlock",
		Name:"Command Block",
		textures:["commandBlockBack",'commandBlockFront','commandBlockSide'],
		errorTextures:fillTextureArray(["commandBlockBackError",'commandBlockFrontError','commandBlockSideError']),
		sideTextures:["commandBlockSide","commandBlockSide","commandBlockBack","commandBlockFront","commandBlockSide","commandBlockSide"],
		sideErrorTextures:["commandBlockSideError","commandBlockSideError","commandBlockBackError","commandBlockFrontError","commandBlockSideError","commandBlockSideError"],
		flipTextures:fillTextureArray(["commandBlockFront",'commandBlockBack','commandBlockSide']),
		flipErrorTextures:fillTextureArray(["commandBlockFrontError",'commandBlockBackError','commandBlockSideError']),
		hardness:Infinity,
		commandBlock:true,
		tagBits: null,
		trigger:function(x,y,z,world){
			let data = world.getTagByName(x,y,z,"data")
			let running = world.getTagByName(x,y,z,"running")
			if(data && !running){
				world.setTagByName(x,y,z,"running",true,false)
				runCmd(data,{x,y,z,dimension:world.dimension},world.world,true, output => {
					let outputHTML = "none"
					outputHTML = ""
					for(let i=0; i<output.length; i+=2){
						if(i) outputHTML += "<br>"
						outputHTML += Messages.format(output[i])
					}
					world.setTagByName(x,y,z,"output",outputHTML,false)
					let target
					let block = world.getBlock(x,y,z)
					switch(block){
						case this.id:
						case this.id | FLIP:
							target = this.id
							break
						case this.id | SLAB | NORTH:
						case this.id | SLAB | FLIP | NORTH:
							target = this.id | SLAB | NORTH
							break
						case this.id | SLAB | SOUTH:
						case this.id | SLAB | FLIP | SOUTH:
							target = this.id | SLAB | SOUTH
							break
						case this.id | SLAB | EAST:
						case this.id | SLAB | FLIP | EAST:
							target = this.id | SLAB | EAST
							break
						case this.id | SLAB | WEST:
						case this.id | SLAB | FLIP | WEST:
							target = this.id | SLAB | WEST
							break
						case this.id | STAIR:
						case this.id | STAIR | FLIP:
							target = this.id | STAIR
							break
					}
					if(output && output[output.length-1] === "error") target |= FLIP
					if(block !== target) world.setBlock(x,y,z,target,false,false,false,true)
				}).then(() => world.setTagByName(x,y,z,"running",false,false))
			}
		},
		onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,world){
			var power = world.getRedstonePower(x,y,z) || world.getSurroundingBlockPower(x,y,z) ? true : false
			var on = world.getTagByName(x,y,z,"on") || false
			if(power !== on) {
				world.setTagByName(x,y,z,"on",power,false)
				if(power){
					this.trigger(x,y,z,world)
				}
			}
		},
		rarity:"epic",
		category:"redstone"
	},
	{
		name:"spiderEye",
		item:true,
		category:"items"
	},
	{
		name: "spawnSpider",
		item: true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			let pos = movePositionByFace(face,x,y,z)
			let ent = new entities[entityIds.Spider](pos[0],pos[1],pos[2])
			if(item.customName) ent.name = item.customName
			world.addEntity(ent)
			item.amount--
		},
		spawnMob: function(x,y,z,world){
			world.addEntity(new entities[entityIds.Spider](x,y,z),false)
		},
		category:"items"
	},
	{
		name: "spawnCaveSpider",
		item: true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			let pos = movePositionByFace(face,x,y,z)
			let ent = new entities[entityIds.Spider](pos[0],pos[1],pos[2],true)
			if(item.customName) ent.name = item.customName
			world.addEntity(ent)
			item.amount--
		},
		spawnMob: function(x,y,z,world){
			world.addEntity(new entities[entityIds.Spider](x,y,z,true),false)
		},
		category:"items"
	},
	{
		name: "spawnWolf",
		item: true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			let pos = movePositionByFace(face,x,y,z)
			let ent = new entities[entityIds.Wolf](pos[0],pos[1],pos[2])
			if(item.customName) ent.name = item.customName
			world.addEntity(ent)
			item.amount--
		},
		spawnMob: function(x,y,z,world){
			world.addEntity(new entities[entityIds.Wolf](x,y,z),false)
		},
		category:"items"
	},
	{
		name:"nameTag",
		Name:"Name Tag",
		item:true,
		onserverentityuse:function(ent,holding){
			if(ent.mob && holding.customName){
				ent.name = holding.customName
				ent.world.sendEntityPos(ent)
				holding.amount--
			}
		}
	},
	{
		name:"blazeRod",
		Name:"Blaze Rod",
		item:true
	},
	{
		name:"blazePowder",
		Name:"Blaze Powder",
		item:true
	},
	{
		name: "spawnBlaze",
		item: true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			let pos = movePositionByFace(face,x,y,z)
			let ent = new entities[entityIds.Blaze](pos[0],pos[1],pos[2])
			if(item.customName) ent.name = item.customName
			world.addEntity(ent)
			item.amount--
		},
		spawnMob: function(x,y,z,world){
			world.addEntity(new entities[entityIds.Blaze](x,y,z),false)
		},
		category:"items"
	},
	{
		name:"fireCharge",
		item:true
	},
	{
		name: "spawnEnderDragon",
		item: true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			let pos = movePositionByFace(face,x,y,z)
			let ent = new entities[entityIds.EnderDragon](pos[0],pos[1],pos[2])
			world.addEntity(ent)
			item.amount--
		},
		spawnMob: function(x,y,z,world){
			world.addEntity(new entities[entityIds.EnderDragon](x,y,z),false)
		},
		category:"items",
		hidden:true
	},
	{
		name:"debugStick",
		item:true,
		hidden:true,
		serveronuse: function(x,y,z, block,world,face,item,p,blockMode){
			if(blockMode === CUBE) this.useGetTags(x,y,z, block, world)
			else if(blockMode === SLAB) this.useChangeBlockState(x,y,z, block, world)
			else if(blockMode === STAIR) this.useChangeBlockRotation(x,y,z, block, world)
		},
		useGetTags: (x,y,z, block, world) => {
			let tags = world.getTags(x,y,z)
			let str = "§dDEBUG<br>"
			if(block && blockData[block].tagBits){
				for(let i in blockData[block].tagBits){
					str += i+": "+getTagBits(tags,i,block)+"<br>"
				}
			}else str += JSON.stringify(tags)
			Messages.add(str)
		},
		useChangeBlockState: (x,y,z, block, world) => {
			if(!block) return
			let base = block&(isCube|ROTATION)
			let states = [
				CUBE,SLAB,STAIR,CROSS,TALLCROSS,DOOR,TORCH,LANTERN,LANTERNHANG,BEACON,
				CACTUS,PANE,PORTAL,WALLFLAT,TRAPDOOR,TRAPDOOROPEN,FENCE,WALLPOST,
				BUTTON,CHAIN,POT,POTCROSS,CORNERSTAIRIN,CORNERSTAIROUT,VERTICALSLAB
			]
			let state = block&isState//remove id and rotation, leaving block state
			let idx = states.indexOf(state)
			do{
				idx++
				if(idx >= states.length) idx = 0
				state = states[idx]
			}while(!blockData[block|state])
			world.setBlock(x,y,z,base|state,false,true,false,true)
		},
		useChangeBlockRotation: (x,y,z, block, world) => {
			if(!block) return
			let base = block&(~ROTATION)&(~FLIP)
			let states = [
				NORTH,SOUTH,EAST,WEST,
				NORTH|FLIP,SOUTH|FLIP,EAST|FLIP,WEST|FLIP
			]
			let state = block&(ROTATION|FLIP)
			let idx = states.indexOf(state)
			do{
				idx++
				if(idx >= states.length) idx = 0
				state = states[idx]
			}while(!blockData[block|state])
			world.setBlock(x,y,z,base|state,false,true,false,true)
		}
	},
	{
		name: "oil",
		textures:"oil",
		transparent: true,
		liquid: true,
		solid:false,
		shadow: false,
		blastResistance:100,
		hidden:true,
		drop:"air",
		burnChance: 1,
		burnTime: 15,
		density:0.1,
		inLiquid:3,
		getLevelDifference:function(level,dimension){return level-2},
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			if(!world.world.settings.blocksFall) return
			var me = this
			world.setTimeout(() => me.flow(x,y,z,world), tickTime*5, x,y,z)
		},
		getY:function(x,y,z){
			var block = world.getBlock(x,y,z)
			return (min((this.getLevel(block) || (block ? 8 : 0))*2,14.5)/16)-0.5
		},
	},
	{
		name: "oilBucket",
		Name:"Oil Bucket",
		item: true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			if(p.survival) item.id = blockIds.bucket
			var pos = movePositionByFace(face,x,y,z)
			world.setBlock(pos[0],pos[1],pos[2],blockIds.oil)
		},
		stackSize: 1,
		category:"items"
	},
	{ name: "silverBlock", Name:"Block of Silver", hardness:5, type:"metal2",category:"build", stoneSound:true},
	{ name: "limestone", Name:"Limestone", type:"rock1",category:"nature", hardness:1.25, blastResistance:0.8, stoneSound:true, randomRotate:"flip",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true},
	{
		name: "spawnEnderman",
		item: true,
		serveronuse: (x,y,z, block,world,face,item,p) => {
			let pos = movePositionByFace(face,x,y,z)
			let ent = new entities[entityIds.Enderman](pos[0],pos[1],pos[2])
			if(item.customName) ent.name = item.customName
			world.addEntity(ent)
			item.amount--
		},
		spawnMob: function(x,y,z,world){
			world.addEntity(new entities[entityIds.Enderman](x,y,z),false)
		},
		category:"items"
	},
	{
		name:"bambooBlock",
		Name:"Block of Bamboo",
		textures:["bambooBlockTop","bambooBlock"],
		hardness:2,
		woodSound:true,
		type:"wood",
		category:"nature",
		burnChance:0.1,
		burnTime:50,
		log:true
	},
	{
		name:"bambooBlockSW",
		textures: ["bambooBlock","bambooBlock","bambooBlockTop","bambooBlock"],
		SW: true, hidden:true
	},
	{
		name:"strippedBambooBlock",
		Name:"Stripped Block of Bamboo",
		textures:["strippedBambooBlockTop","strippedBambooBlock"],
		hardness:2,
		woodSound:true,
		type:"wood",
		category:"nature",
		burnChance:0.1,
		burnTime:50,
		log:true
	},
	{
		name:"strippedBambooBlockSW",
		textures: ["strippedBambooBlock","strippedBambooBlock","strippedBambooBlockTop","strippedBambooBlock"],
		SW: true, hidden:true
	},
	{ name: "bambooPlanks", Name:"Bamboo Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40},
	{ name: "bambooMosaic", Name:"Bamboo Mosaic", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40},
	{
		name:"bambooButton",
		Name: "Bamboo Button",
		textures:"bambooPlanks",
		button:true,
		transparent: true,
		shadow:false,
		category:"redstone"
	},
	{ 
		name: "bambooDoor",
		Name:"Bamboo Door",
		transparent: true,
		shadow: false,
		textures: "bambooDoorConnected",
		door:true,
		woodSound:true,
		hardness:3,
		type:"wood",
		category:"build"
	},
	{
		name:"bambooFenceGate",
		Name:"Bamboo Fence Gate",
		textures:"bambooPlanks",
		fenceGate:true,
		hardness:2,
		woodSound:true,
		type:"wood",
		category:"build"
	},
	{
		name: "bambooPressurePlate",
		Name: "Bamboo Pressure Plate",
		textures: "bambooPlanks",
		pressurePlate: true,
		hardness:0.5,
		type:"wood",
		category:"redstone"
	},
	{
		name:"bambooSign",
		Name:"Bamboo sign",
		textures:"bambooPlanks",
		poleTop:"bambooBlockTop",
		poleSide:"bambooBlock",
		iconTexture:"bambooSign",
		flatIcon:true,
		sign:true,
		hardness:1,
		woodSound:true,
		type:"wood",
		category:"decoration"
	},
	{ 
		name: "bambooTrapdoor",
		Name:"Bamboo Trapdoor",
		transparent: true,
		trapdoor: true,
		woodSound: true,
		category:"build"
	},
	{
		name:"strippedCherryLog",
		Name:"Stripped Cherry Log",
		textures:["strippedCherryLogTop","strippedCherryLog"],
		woodSound:true,
		hardness:2,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"nature"
	},
	{
		name:"strippedCherryLogSW",
		textures: ["strippedCherryLog","strippedCherryLog","strippedCherryLogTop","strippedCherryLog"],
		SW: true, hidden:true
	},
	{ name: "cherryPlanks", Name:"Cherry Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40},
	{
		name:"cherryButton",
		Name: "Cherry Button",
		textures:"cherryPlanks",
		button:true,
		transparent: true,
		shadow:false,
		category:"redstone"
	},
	{ 
		name: "cherryDoor",
		Name:"Cherry Door",
		transparent: true,
		shadow: false,
		textures: "cherryDoorConnected",
		door:true,
		woodSound:true,
		hardness:3,
		type:"wood",
		category:"build"
	},
	{
		name:"cherryFenceGate",
		Name:"Cherry Fence Gate",
		textures:"cherryPlanks",
		fenceGate:true,
		hardness:2,
		woodSound:true,
		type:"wood",
		category:"build"
	},
	{
		name: "cherryPressurePlate",
		Name: "Cherry Pressure Plate",
		textures: "cherryPlanks",
		pressurePlate: true,
		hardness:0.5,
		type:"wood",
		category:"redstone"
	},
	{
		name:"cherrySign",
		Name:"Cherry sign",
		textures:"cherryPlanks",
		poleTop:"cherryLogTop",
		poleSide:"cherryLog",
		iconTexture:"cherrySign",
		flatIcon:true,
		sign:true,
		hardness:1,
		woodSound:true,
		type:"wood",
		category:"decoration"
	},
	{ 
		name: "cherryTrapdoor",
		Name:"Cherry Trapdoor",
		transparent: true,
		trapdoor: true,
		woodSound: true,
		category:"build"
	},
	{
		name:"cherryChair",
		Name:"Cherry Chair",
		textures:"cherryPlanks",
		chair:true,
		transparent:true,
		shadow:false,
		onclientclick:sit,
		category:"items"
	},
	{
		name:"bambooChair",
		Name:"Bamboo Chair",
		textures:"bambooPlanks",
		chair:true,
		transparent:true,
		shadow:false,
		onclientclick:sit,
		category:"items"
	},
	{
		name: "suspicousSand",
		Name:"Suspicois Sand",
		textures:"suspiciousSand0",
		hardness:0.25, blastResistance:0.5,
		onupdate: function(x,y,z,b,world,sx,sy,sz){
			fall(x,y,z,b,world,false)
		},
		ongetexploded:function(x,y,z,b,world){
			fall(x,y,z,b,world,true)
		},
		drop:"air"
	},
	{
		name: "suspicousGravel",
		Name:"Suspicous Gravel",
		textures:"suspiciousGravel0",
		hardness:0.25, blastResistance:0.5,
		onupdate: function(x,y,z,b,world,sx,sy,sz){
			fall(x,y,z,b,world,false)
		},
		ongetexploded:function(x,y,z,b,world){
			fall(x,y,z,b,world,true)
		},
		drop:"air"
	},
	{
		name:"pitcherPlant",
		Name:"Pitcher Plant",
		shapeName:"pitcherPlant",
		flatIcon:true,
		solid: false,
		transparent: true,
		shadow: false,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature"
	},
	{
		name:"pitcherPod",
		Name:"Pitcher Pod",
		item:true,
		useAs:function(x,y,z,block,face){
			if(!block) return
			if(face === "top" && blockData[block].name === "farmland") return "pitcherCrop"
		},
		category:"items"
	},
	{
		name:"pitcherCrop",
		textures:"pitcherCropSide",
		textures1:new Array(6).fill("pitcherCropBottomStage1"),
		textures2:new Array(6).fill("pitcherCropBottomStage2"),
		textures3:new Array(6).fill("pitcherCropBottomStage3"),
		textures4:new Array(6).fill("pitcherCropBottomStage4"),
		transparent: true,
		shadow: false,
		solid: false,
		drop:"pitcherPod",
		hidden:true,
		liquidBreakable:"drop"
	},
	{
		name: "torchflower",
		Name:"\"Torch\" flower",
		textures1:new Array(6).fill("torchflowerCropStage0"),
		textures2:new Array(6).fill("torchflowerCropStage1"),
		drop:"torchflowerSeeds",
		solid: false,
		transparent: true,
		shadow: false,
		potCross: true,
		crossShape: true,
		compostChance:0.65,
		liquidBreakable:"drop",
		category:"nature",
		randomOffset:true
	},
	{
		name:"torchflowerSeeds",
		Name:"Torchflower seeds",
		item:true,
		useAs:function(x,y,z,block,face){
			return blockIds.torchflower|SLAB
		},
		category:"items"
	},
	{
		name:"driedOakLeaves",
		Name:"Dried Oak Leaves",
		thickTexture:"driedOakLeavesThick",
		hardness:0.1,
		drop:"air",
		category:"nature",
		grassSound: true,
		transparent:true,
		shadow:false,
		solid:false,
		groundLeaves:true
	},
	{
		name:"driedBirchLeaves",
		Name:"Dried Birch Leaves",
		hardness:0.1,
		drop:"air",
		category:"nature",
		grassSound: true,
		transparent:true,
		shadow:false,
		solid:false,
		groundLeaves:true
	},
	{
		name:"driedSpruceLeaves",
		Name:"Dried Spruce Leaves",
		hardness:0.1,
		drop:"air",
		category:"nature",
		grassSound: true,
		transparent:true,
		shadow:false,
		solid:false,
		groundLeaves:true,
		randomRotate:true,
		randomRotateTop:true,
		randomRotateBottom:true,
	},
	{
		name:"strippedCherryWood",
		Name:"Stripped Cherry Wood",
		textures: "strippedCherryLog",
		hardness:2,
		woodSound:true,
		type:"wood",
		burnChance:0.1,
		burnTime:50,
		category:"nature",
		log:true
	},
	{
		name:"pinkPetals",
		Name:"Pink flowers",
		textures:["pinkPetalsFlower","pinkPetalsStem"],
		iconTexture:"pinkPetals",
		flowerbed:true,
		solid: false,
		transparent: true,
		shadow: false,
		liquidBreakable:"drop",
		category:"nature",
		randomRotateOnSpawn:true,
		onclick:function(x,y,z,world,p,holdObj){
			if(holdObj && (holdObj.id&isCube) === this.id){
				let block = world.getBlock(x,y,z), target, rot = block&ROTATION
				switch(block & (~ROTATION)){
					case this.id:
						target = this.id | SLAB
						break
					case this.id|SLAB:
						target = this.id | STAIR
						break
					case this.id|STAIR:
						target = this.id | DOOR
						break
				}
				if(target) world.setBlock(x,y,z,target|rot)
				else return true
			}
		},
		tint:grassTint,
		biomeTintEast:true,
		biomeTintWest:true,
		biomeTintNorth:true,
		biomeTintSouth:true,
	},
	{
		name:"lilyPad",
		Name:"Lily Pad",
		transparent:true,
		shadow:false,
		shapeName:"flat",
		flatIcon:true,
		liquidBreakable:"drop",
		category:"nature",
		type:"plant2",
		randomRotate:true,
		randomRotateTop:true,
		randomRotateBottom:true,
		allHitbox: true
	},
	{
		name:"lightPanel",
		Name:"Light Panel",
		transparent:true,
		shadow:false,
		shapeName:"ceilingPanel",
		lightLevel:15,
		category:"build",
		glassSound:true,
		flatIcon:true
	},
	
	{
		name:"bambooLeaves",
		Name: "Bamboo Leaves",
		transparent: true,
		cullFace:0,
		hardness: 0.2,
		type:"plant2",
		leaves:true,
		dropSelfWhenSheared:true,
		shearBreakTime:0.05,
		burnChance: 0.2,
		burnTime: 30,
		compostChance:0.3,
		grassSound: true,
		category:"nature",
		drop: function(){
			if(rand() > 0.8){
				let r = floor(rand(2))
				if(r === 0) return "stick"
				else if(r === 1) return "bambooShoot"
			}
		},
	},
	{
		name:"driedBambooLeaves",
		Name:"Dried Bamboo Leaves",
		hardness:0.1,
		drop:"air",
		category:"nature",
		grassSound: true,
		transparent:true,
		shadow:false,
		solid:false,
		groundLeaves:true,
		randomRotate:true,
		randomRotateTop:true,
		randomRotateBottom:true,
	},
	{
		name:"groundBerries",
		Name:"Ground Berries",
		textures:["groundBerries","groundBerriesStem"],
		hardness:0.1,
		category:"nature",
		grassSound: true,
		transparent:true,
		shadow:false,
		solid:false,
		shapeName:"groundBush",
		randomRotateOnSpawn:true,
		tint:leafTint,
		biomeTintBottom:true,
		biomeTintTop:true,
		invTint: [leafColor.r,leafColor.g,leafColor.b],
		randomSmallHeight:true,
		randomRotateOnSpawn:true
	},
	{
		name:"brainCoralBlock",
		Name:"Sponge-like Coral Block",
		category:"nature",
		coralBlock:true
	},
	{
		name:"bubbleCoralBlock",
		Name:"Bubble Coral Block",
		category:"nature",
		coralBlock:true
	},
	{
		name:"fireCoralBlock",
		Name:"Fire Coral Block",
		category:"nature",
		coralBlock:true
	},
	{
		name:"hornCoralBlock",
		Name:"Horn Coral Block",
		category:"nature",
		coralBlock:true
	},
	{
		name:"tubeCoralBlock",
		Name:"Tube Coral Block",
		category:"nature",
		coralBlock:true
	},
	{
		name:"brainCoral",
		Name:"Sponge-like Coral (standing)",
		category:"nature",
		coral:true,
		transparent:true,
		solid:false,
		shadow:false,
		potCross:true,
		wetgrassSound:true
	},
	{
		name:"bubbleCoral",
		Name:"Bubble Coral (standing)",
		category:"nature",
		coral:true,
		transparent:true,
		solid:false,
		shadow:false,
		potCross:true,
		wetgrassSound:true
	},
	{
		name:"fireCoral",
		Name:"Fire Coral (standing)",
		category:"nature",
		coral:true,
		transparent:true,
		solid:false,
		shadow:false,
		potCross:true,
		wetgrassSound:true
	},
	{
		name:"hornCoral",
		Name:"Horn Coral (standing)",
		category:"nature",
		coral:true,
		transparent:true,
		solid:false,
		shadow:false,
		potCross:true,
		wetgrassSound:true
	},
	{
		name:"tubeCoral",
		Name:"Tube Coral (standing)",
		category:"nature",
		coral:true,
		transparent:true,
		solid:false,
		shadow:false,
		potCross:true,
		wetgrassSound:true
	},
	{
		name:"brainCoralFan",
		Name:"Sponge-like Coral Fan",
		category:"nature",
		coralFan:true,
		transparent:true,
		solid:false,
		shadow:false,
		wetgrassSound:true
	},
	{
		name:"bubbleCoralFan",
		Name:"Bubble Coral Fan",
		category:"nature",
		coralFan:true,
		transparent:true,
		solid:false,
		shadow:false,
		wetgrassSound:true
	},
	{
		name:"fireCoralFan",
		Name:"Fire Coral Fan",
		category:"nature",
		coralFan:true,
		transparent:true,
		solid:false,
		shadow:false,
		wetgrassSound:true
	},
	{
		name:"hornCoralFan",
		Name:"Horn Coral Fan",
		category:"nature",
		coralFan:true,
		transparent:true,
		solid:false,
		shadow:false,
		wetgrassSound:true
	},
	{
		name:"tubeCoralFan",
		Name:"Tube Coral Fan",
		category:"nature",
		coralFan:true,
		transparent:true,
		solid:false,
		shadow:false,
		wetgrassSound:true
	},
	{
		name:"minecart",
		Name:"Minecart",
		textures:"minecartIcon",
		item:true,
		category:"redstone",
		serveronuse: (x,y,z, block,world,face,item,p) => {
			let pos = movePositionByFace(face,x,y,z)
			let ent = new entities[entityIds.Minecart](pos[0],pos[1],pos[2])
			world.addEntity(ent)
		},
	},
	{
		name:"rail",
		Name:"Rail",
		transparent:true,
		shadow:false,
		solid:false,
		blastResistance:0.7,
		hardness:0.7,
		rail:true,
		category:"redstone",
		flatIcon:true,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			this.railonupdate(x,y,z,b,world)
		},
	},
	{
		name:"poweredRail",
		Name:"Powered Rail",
		transparent:true,
		shadow:false,
		solid:false,
		blastResistance:0.7,
		hardness:0.7,
		rail:true,
		category:"redstone",
		flatIcon:true,
		carryRedstone:true,
		onupdate:function(x,y,z,b,world,sx,sy,sz){
			let on = world.getTagByName(x,y,z,"power")
			if(on && !(b&FLIP)){
				b |= FLIP
				world.setBlock(x,y,z,b,false,false,false,true)
			}else if(!on && (b&FLIP)){
				b &= ~FLIP
				world.setBlock(x,y,z,b,false,false,false,true)
			}
			this.railonupdate(x,y,z,b,world)
		},
		onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,world){
			this.onupdate(x,y,z,world.getBlock(x,y,z),world,sx,sy,sz)
		}
	},
	{
		name:"cornPlant",
		textures:"cornStage0",
		textures1:new Array(6).fill("cornStage1"),
		textures2:new Array(6).fill("cornStage2"),
		textures3:new Array(6).fill("cornStage3"),
		textures4:new Array(6).fill("cornStage4"),
		textures5:new Array(6).fill("cornStage5"),
		transparent: true,
		shadow: false,
		solid: false,
		drop:"corn",
		hidden:true,
		liquidBreakable:"drop",
		growBonemeal:function(x,y,z,world){
			world.setBlock(x,y,z, this.id|DOOR)
		}
	},
	{
		name:"corn",
		Name:"Corn",
		item:true,
		edible: true,
		food: 3,
		saturation: 2,
		compostChance:0.85,
		useAs:function(x,y,z,block,face){
			if(!block) return
			if(face === "top" && blockData[block].name === "farmland") return "cornPlant"
		},
		category:"food"
	},
	{
		name:"popcornBowl",
		Name:"Bowl of Popcorn",
		item:true,
		edible: true,
		food: 4,
		saturation: 2,
		eatResult:"bowl",
		category:"food"
	},
	{
		name:"dirtPath",
		_1PixLower:true,
		textures: ["dirt","dirtPathTop","dirtPathSide","dirtPathSide","dirtPathSide","dirtPathSide"],
		solid: true,
		transparent: true,
		cullFace: "same",
	}
];
const BLOCK_COUNT = blockData.length
console.log(BLOCK_COUNT," blocks on server side")
win.BLOCK_COUNT = BLOCK_COUNT, win.blockData = blockData
win.emptyFunc = function(){}

let blockIds = {}
win.blockIds = blockIds
let generateBlockIds = {
	grass:true, dirt:true, stone: true, gravel: true,
	snowBlock: true, snow: true, packedIce:true, ice:true,
	Water: true, powderSnow: true, mud:true,
	coarseDirt:true, podzol: true,
	sand: true, bedrock: true, deepslate: true,
	sandstone: true, limestone: true,
	mycelium: true, redSand: true, rootedDirt:true,
	redSandstone: true, calcite: true,
	terracotta: true, lightGrayTerracotta: true, whiteTerracotta: true, yellowTerracotta: true, orangeTerracotta: true,
	glass: true,//for testing without shadows
	orangeConcrete:true,glowstone:true//also for testing
} //blocks that can be naturally generated
function initBlockData(){
	const stoneDigSound = ["stone.dig1", "stone.dig2", "stone.dig3", "stone.dig4"],
			stoneStepSound = ["stone.step1", "stone.step2","stone.step3","stone.step4","stone.step5","stone.step6"],
			woodDigSound = ["wood.dig1", "wood.dig2", "wood.dig3", "wood.dig4"],
			woodStepSound = ["wood.step1", "wood.step2","wood.step3","wood.step4","wood.step5","wood.step6"],
			clothDigSound = ["cloth.dig1", "cloth.dig2", "cloth.dig3", "cloth.dig4"],
			clothStepSound = ["cloth.step1", "cloth.step2","cloth.step3","cloth.step4"],
			glassDigSound = ["glass.dig1", "glass.dig2", "glass.dig3"],
			nyliumDigSound = ["nylium.dig1", "nylium.dig2", "nylium.dig3", "nylium.dig4", "nylium.dig5", "nylium.dig6"],
			nyliumStepSound = ["nylium.step1", "nylium.step2","nylium.step3","nylium.step4","nylium.step5","nylium.step6"],
			stemDigSound = ["stem.dig1", "stem.dig2", "stem.dig3", "stem.dig4", "stem.dig5", "stem.dig6"],
			stemStepSound = ["stem.step1", "stem.step2","stem.step3","stem.step4","stem.step5","stem.step6"],
			basaltDigSound = ["basalt.dig1", "basalt.dig2", "basalt.dig3", "basalt.dig4", "basalt.dig5"],
			basaltStepSound = ["basalt.step1", "basalt.step2","basalt.step3","basalt.step4","basalt.step5","basalt.step6"],
			rootDigSound = ["roots.dig1", "roots.dig2", "roots.dig3", "roots.dig4", "roots.dig5", "roots.dig6"],
			rootStepSound = ["roots.step1", "roots.step2","roots.step3","roots.step4","roots.step5","roots.step6"],
			amethystPlaceSound = ["amethyst.place1","amethyst.place2","amethyst.place3","amethyst.place4"],
			amethystDigSound = ["amethyst.dig1","amethyst.dig2","amethyst.dig3","amethyst.dig4"],
			amethystStepSound = (function(){var arr=[]; for(var i=0; i<14; i++){arr.push("amethyst.step"+(i+1))};return arr})(),
			amethystClusterPlaceSound = ["amethyst_cluster.place1", "amethyst_cluster.place2", "amethyst_cluster.place3", "amethyst_cluster.place4"],
			amethystClusterDigSound = ["amethyst_cluster.dig1", "amethyst_cluster.dig2", "amethyst_cluster.dig3", "amethyst_cluster.dig4"],
			deepslatePlaceSound = ["deepslate.place1","deepslate.place2","deepslate.place3","deepslate.place4","deepslate.place5","deepslate.place6"],
			deepslateStepSound = ["deepslate.step1","deepslate.step2","deepslate.step3","deepslate.step4","deepslate.step5","deepslate.step6"],
			deepslateDigSound = ["deepslate.dig1","deepslate.dig2","deepslate.dig3","deepslate.dig4"],
			deepslateBricksPlaceSound = [1,2,3,4,5,6].map(v => "deepslate_bricks.place"+v),
			deepslateBricksStepSound = [1,2,3,4,5].map(v => "deepslate_bricks.step"+v),
			grassDigSound = ["grass.dig1", "grass.dig2", "grass.dig3", "grass.dig4"],
			grassStepSound = ["grass.step1", "grass.step2","grass.step3","grass.step4","grass.step5","grass.step6"],
			coralDigSound = ["coral.dig1","coral.dig2","coral.dig3","coral.dig4"],
			coralStepSound = ["coral.step1","coral.step2","coral.step3","coral.step4","coral.step5","coral.step6"],
			wetgrassDigSound = ["wetgrass.dig1","wetgrass.dig2","wetgrass.dig3","wetgrass.dig4"],
			wetgrassStepSound = ["wetgrass.step1","wetgrass.step2","wetgrass.step3","wetgrass.step4","wetgrass.step5","wetgrass.step6"]
	const defaultTagBits = {
		power:[15,5], //extra for power level 16 (power sources)
		blockPowerNorth:[20,2],
		blockPowerSouth:[22,2],
		blockPowerEast:[24,2],
		blockPowerWest:[26,2],
		blockPowerTop:[28,2],
		blockPowerBottom:[30,2],
	} /*
	tag bits have a index and a count
	if tagBits is set to null
	- it stores it as a properties of an object,
	otherwise
	- it stores it in specific bits in a number
	*/
	// Set defaults on blockData
	for (let i = 1; i < BLOCK_COUNT; ++i) {
		const data = blockData[i];
		data.id = i;

		if ( !("textures" in data) ) {
			data.textures = new Array(6).fill(data.name);
		} else if (typeof data.textures === "string") {
			data.textures = new Array(6).fill(data.textures);
		} else {
			const { textures } = data;

			if (textures.length === 3) {
				textures[3] = textures[2];
				textures[4] = textures[2];
				textures[5] = textures[2];
			} else if (textures.length === 2) {
				// Top and bottom are the first texture, sides are the second.
				textures[2] = textures[1];
				textures[3] = textures[2];
				textures[4] = textures[2];
				textures[5] = textures[2];
				textures[1] = textures[0];
			}else if(textures.length === 4){
        textures[4] = textures[5] = textures[3]
        textures[3] = textures[2]
      }
		}

		data.transparent = data.transparent || false
		
		data.shadow = data.shadow !== undefined ? data.shadow : true
		data.shade = data.shade !== undefined ? data.shade : true
		data.smoothLight = data.smoothLight !== undefined ? data.smoothLight : true //if smoothLight is false, it also needs to be transparent

		data.lightLevel = data.lightLevel || 0
		
		if(data.solid === undefined)data.solid = true
		
		//data.breakTime = data.breakTime ? data.breakTime*1000 : 0 //time for breaking, changed to hardness
		data.hardness = data.hardness || 0
		
		if(data.dropAmount === undefined) data.dropAmount = 1
		if(data.leaves && data.decreaseLight === undefined) data.decreaseLight = 1

		if(data.flatIcon === undefined && (data.item || data.edible || data.crossShape || data.tallcrossShape || data.sideCross || data.ladder || data.torch || data.door || data.lantern || data.chain || data.sunflower || data.pane || data.fire || data.crop || data.tallCrop || data.groundLeaves || data.flowerbed || data.coral || data.coralFan)) data.flatIcon = true
    if(data.door) data.iconTexture = data.name
		if(data.crossShape || data.tallcrossShape || data.sideCross || data.ladder || data.torch || data.lantern || data.chain || data.sunflower || data.crop || data.tallCrop) data.smoothLight = false
		if(data.item){
			data.transparent = true
			data.shadow = false
		}
		
		if(data.liquid) data.noHitbox = true
		
		if(!data.stackSize)data.stackSize = 64
		if(data.pickaxe){
			data.stackSize = 1
			data.attackTime = 20/1.2
		}
		if(data.sword){
			data.stackSize = 1
			data.attackTime = 20/1.6
		}
		if(data.shovel){
			data.stackSize = 1
			data.attackTime = 20/1
		}
		if(data.axe || data.hoe){
			data.stackSize = 1
		}
		data.tool = data.tool || data.pickaxe || data.sword || data.shovel || data.axe || data.hoe
		
		if(data.attackSpeed) data.attackTime = 20/data.attackSpeed

		if(data.tagBits !== null){
			if(data.tagBits) Object.assign(data.tagBits,defaultTagBits)
			else data.tagBits = defaultTagBits
		}
		
		if(data.stoneSound){
			data.digSound = stoneDigSound
			data.stepSound = stoneStepSound
		}
		if(data.woodSound){
			data.digSound = woodDigSound
			data.stepSound = woodStepSound
		}
		if(data.clothSound){
			data.digSound = clothDigSound
			data.stepSound = clothStepSound
		}
		if(data.glassSound){
			data.digSound = glassDigSound
			data.placeSound = stoneDigSound
		}
		if(data.nyliumSound){
			data.digSound = nyliumDigSound
			data.stepSound = nyliumStepSound
		}
		if(data.stemSound){
			data.digSound = stemDigSound
			data.stepSound = stemStepSound
		}
		if(data.basaltSound){
			data.digSound = basaltDigSound
			data.stepSound = basaltStepSound
		}
		if(data.rootSound){
			data.digSound = rootDigSound
			data.stepSound = rootStepSound
		}
		if(data.amethystSound){
			data.placeSound = amethystPlaceSound
			data.digSound = amethystDigSound
			data.stepSound = amethystStepSound
		}
		if(data.amethystClusterSound){
			data.placeSound = amethystClusterPlaceSound
			data.digSound = amethystClusterDigSound
		}
		if(data.deepslateSound){
			data.placeSound = deepslatePlaceSound
			data.digSound = deepslateDigSound
			data.stepSound = deepslateStepSound
		}
		if(data.deepslateBricksSound){
			data.placeSound = deepslateBricksPlaceSound
			data.stepSound = deepslateBricksStepSound
		}
		if(data.grassSound){
			data.digSound = grassDigSound
			data.stepSound = grassStepSound
		}
		if(data.coralBlock){
			data.digSound = coralDigSound
      data.stepSound = coralStepSound
		}
		if(data.wetgrassSound){
			data.digSound = wetgrassDigSound
      data.stepSound = wetgrassStepSound
		}
		
		data.Name = data.Name || data.name
		
		data.pistonPush = data.pistonPush !== undefined ? data.pistonPush : true
		data.pistonPull = data.pistonPull !== undefined ? data.pistonPull : true

		if(breakTypes[data.type]) data.harvestTools = breakTypes[data.type]
		if(handBreakable.includes(data.type)) data.harvestTools = true
	}

  blockData.forEach(block => {
    blockIds[block.name] = block.id
    if(block.SW && block.name.includes("SW")){
      let unSw = block.name.replace("SW",'')
      if(blockIds[unSw]){
        block.drop = unSw
        let obj = blockData[blockIds[unSw]]
        block.hardness = obj.hardness
        block.type = obj.type
        block.burnChance = obj.burnChance
        block.burnTime = obj.burnTime
				block.log = obj.log
				obj.swId = block.id
      }
    }
		if(generateBlockIds[block.name]) generateBlockIds[block.name] = block.id
  })
	for(let b in breakTypes){
		for(let i=0; i<breakTypes[b].length; i++){
			breakTypes[b][i] = blockIds[breakTypes[b][i]]
		}
	}

	//fill the crafts that have less than 9 items. Ex: "thing" => "thing,air,air..."
	let arr, arr2 = new Array(9)
	for(let i in crafts){
		arr = i.split(",")
		for(let j = 0; j<9; j++){
			if(arr[j]){
				arr[j] = getBlockId(arr[j])
			}else{
				arr.push(0)
			}
		}
		
		crafts[i].id = getBlockId(crafts[i].name)
		if(crafts[i].amount === undefined) crafts[i].amount = 1
		craftArrays[arr.join(",")] = arr.slice()
		crafts[arr.join(",")] = crafts[i]
		
		//shaped recipes
		if(crafts[i].shaped){
			var craft2 = Object.assign({},crafts[i])
			craft2.hidden = true
			var xSpace = 3, ySpace = 3
			//find how much empty space there is
			for(var x=2; x>=0; x--){
				var a = arr[x]
				var b = arr[x+3]
				var c = arr[x+6]
				if(a||b||c){
					xSpace = x
					break
				}
			}
			for(var y=2; y>=0; y--){
				var a = arr[y*3]
				var b = arr[(y*3)+1]
				var c = arr[(y*3)+2]
				if(a||b||c){
					ySpace = y
					break
				}
			}
			
			var offsetX = -1, offsetY = -1
			for(var x = xSpace; x<3; x++){
				offsetX ++
				for(var y = ySpace; y<3; y++){
					offsetY ++
					if(x === xSpace && y === ySpace) continue
					arr2.fill(0)
					for(var x2 = 0; x2<3; x2++){
						for(var y2 = 0; y2<3; y2++){
							var b = arr[x2+(y2*3)]
							if(b){
								var bx = x2 + offsetX
								var by = y2 + offsetY
								arr2[bx+(by*3)] = b
							}
						}
					}
					crafts[arr2.join(",")] = craft2
					craftArrays[arr2.join(",")] = arr2.slice()
				}
				offsetY = -1
			}
		}
		
		delete crafts[i]
	}
	win.crafts = crafts
	for(let i in craftTypes){
		for(let j=0; j<craftTypes[i].length; j++){
			craftTypes[i][j] = getBlockId(craftTypes[i][j])
		}
	}

	for(let i in smelts){
		smelts[i].id = blockIds[smelts[i].name]
		if(blockIds[i]){
			smelts[blockIds[i]] = smelts[i]
			delete smelts[i]
		}
	}
	for(let i in smeltFuel){
		smeltFuel[i].operations = smeltFuel[i].time / 10
		smeltFuel[i].ops = smeltFuel[i].operations / smeltFuel[i].time //operations per seconds
		if(blockIds[i]){
			smeltFuel[blockIds[i]] = smeltFuel[i]
			delete smeltFuel[i]
		}
	}
	win.smelts = smelts; win.smeltFuel = smeltFuel
}

const breakTypes = {
	plant: "axe",
	wood: "axe",
	metal1: "pickaxe",
	metal2: ["stonePickaxe","ironPickaxe","diamondPickaxe","netheritePickaxe"],
	metal3: ["ironPickaxe","diamondPickaxe","netheritePickaxe"],
	metal4: ["diamondPickaxe","netheritePickaxe"],
	rock1: "pickaxe",
	rock2: ["stonePickaxe","ironPickaxe","diamondPickaxe","netheritePickaxe"],
	rock3: ["ironPickaxe","diamondPickaxe","netheritePickaxe"],
	rock4: ["diamondPickaxe","netheritePickaxe"],
	ground: "shovel",
	plant2: "hoe",
	//wool:"air"
}
win.breakTypes = breakTypes
const handBreakable = [
	"plant","wood","plant2","ground","wool"
]
win.handBreakable = handBreakable
var allPickaxes = ["woodenPickaxe","stonePickaxe","ironPickaxe","diamondPickaxe","netheritePickaxe","goldenPickaxe"]
var allShovels = ["woodenShovel","stoneShovel","ironShovel","diamondShovel","netheriteShovel","goldenShovel"]
for(var b in breakTypes){
	var t = breakTypes[b]
	if(t === "pickaxe"){
		breakTypes[b] = allPickaxes
	}else if(t === "shovel"){
		breakTypes[b] = allShovels
	}else if(typeof t === "string"){
		breakTypes[b] = []
	}
}
const crafts = {
	"oakLog": {name:"oakPlanks", amount:4, shapeless: true},
	"acaciaLog": {name:"acaciaPlanks", amount:4, shapeless: true},
	"birchLog": {name:"birchPlanks", amount:4, shapeless: true},
	"darkOakLog": {name:"darkOakPlanks", amount:4, shapeless: true},
	"jungleLog": {name:"junglePlanks", amount:4, shapeless: true},
	"spruceLog": {name:"sprucePlanks", amount:4, shapeless: true},
	"mangroveLog": {name:"mangrovePlanks", amount:4, shapeless:true},
	"cherryLog": {name:"cherryPlanks", amount:4, shapeless:true},
	"_planks,air,air,_planks": {name:"stick", amount:4, shaped:true},
	"oakPlanks,oakPlanks,air,oakPlanks,oakPlanks,air,oakPlanks,oakPlanks":{name:"oakDoor", amount:3},
	"acaciaPlanks,acaciaPlanks,air,acaciaPlanks,acaciaPlanks,air,acaciaPlanks,acaciaPlanks":{name:"acaciaDoor", amount:3},
	"birchPlanks,birchPlanks,air,birchPlanks,birchPlanks,air,birchPlanks,birchPlanks":{name:"birchDoor", amount:3},
	"darkOakPlanks,darkOakPlanks,air,darkOakPlanks,darkOakPlanks,air,darkOakPlanks,darkOakPlanks":{name:"darkOakDoor", amount:3},
	"junglePlanks,junglePlanks,air,junglePlanks,junglePlanks,air,junglePlanks,junglePlanks":{name:"jungleDoor", amount:3},
	"sprucePlanks,sprucePlanks,air,sprucePlanks,sprucePlanks,air,sprucePlanks,sprucePlanks":{name:"spruceDoor", amount:3},
	"mangrovePlanks,mangrovePlanks,air,mangrovePlanks,mangrovePlanks,air,mangrovePlanks,mangrovePlanks":{name:"mangroveDoor", amount:3},
	"warpedPlanks,warpedPlanks,air,warpedPlanks,warpedPlanks,air,warpedPlanks,warpedPlanks":{name:"warpedDoor", amount:3},
	"crimsonPlanks,crimsonPlanks,air,crimsonPlanks,crimsonPlanks,air,crimsonPlanks,crimsonPlanks,air":{name:"crimsonDoor",amount:3},
	"bambooPlanks,bambooPlanks,air,bambooPlanks,bambooPlanks,air,bambooPlanks,bambooPlanks":{name:"bambooDoor", amount:3},
	"cherryPlanks,cherryPlanks,air,cherryPlanks,cherryPlanks,air,cherryPlanks,cherryPlanks":{name:"cherryDoor", amount:3},
	"ironIngot,ironIngot,air,ironIngot,ironIngot,air,ironIngot,ironIngot,air":{name:"ironDoor",amount:3},
	"oakPlanks,oakPlanks,oakPlanks,oakPlanks,oakPlanks,oakPlanks":{name:"oakTrapdoor", amount:2},
	"birchPlanks,birchPlanks,birchPlanks,birchPlanks,birchPlanks,birchPlanks":{name:"birchTrapdoor", amount:2},
	"darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks":{name:"darkOakTrapdoor", amount:2},
	"junglePlanks,junglePlanks,junglePlanks,junglePlanks,junglePlanks,junglePlanks":{name:"jungleTrapdoor", amount:2},
	"sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks":{name:"spruceTrapdoor", amount:2},
	"acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks":{name:"acaciaTrapdoor", amount:2},
	"mangrovePlanks,mangrovePlanks,mangrovePlanks,mangrovePlanks,mangrovePlanks,mangrovePlanks":{name:"mangroveTrapdoor", amount:2},
	"warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks":{name:"warpedTrapdoor", amount:2},
	"crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks":{name:"crimsonTrapdoor", amount:2},
	"ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot":{name:"ironTrapdoor", amount:2},
	"bambooPlanks,bambooPlanks,bambooPlanks,bambooPlanks,bambooPlanks,bambooPlanks":{name:"bambooTrapdoor", amount:2},
	"cherryPlanks,cherryPlanks,cherryPlanks,cherryPlanks,cherryPlanks,cherryPlanks":{name:"cherryTrapdoor", amount:2},
	"redWool,redWool,redWool,_planks,_planks,_planks":{name:"redBed"},
	"_planks,_planks,air,_planks,_planks":{name:"craftingTable",shaped:true},
	"coal,air,air,stick":{name:"torch",amount:4,shaped:true},
	"coal,air,air,stick,air,air,soulSand":{name:"soulTorch",amount:4,shaped:true},
	"charcoal,air,air,stick":{name:"torch",amount:4,shaped:true},
	"charcoal,air,air,stick,air,air,soulSand":{name:"soulTorch",amount:4,shaped:true},
	"coal,coal,coal,coal,coal,coal,coal,coal,coal":{name:"coalBlock"},
	"ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot":{name:"ironBlock"},
	"goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot":{name:"goldBlock"},
	"diamond,diamond,diamond,diamond,diamond,diamond,diamond,diamond,diamond":{name:"diamondBlock"},
	"lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli":{name:"lapisBlock"},
	"emerald,emerald,emerald,emerald,emerald,emerald,emerald,emerald,emerald":{name:"emeraldBlock"},
	"_planks,_planks,_planks,air,stick,air,air,stick":{name:"woodenPickaxe"},
	"_stone,_stone,_stone,air,stick,air,air,stick":{name:"stonePickaxe"},
	"ironIngot,ironIngot,ironIngot,air,stick,air,air,stick":{name:"ironPickaxe"},
	"goldIngot,goldIngot,goldIngot,air,stick,air,air,stick":{name:"goldenPickaxe"},
	"diamond,diamond,diamond,air,stick,air,air,stick":{name:"diamondPickaxe"},
	"ironIngot,air,air,air,flint": {name:"flintAndSteel"},
	"air,_planks,air,air,_planks,air,air,stick": {name:"woodenSword"},
	"air,_stone,air,air,_stone,air,air,stick": {name:"stoneSword"},
	"air,ironIngot,air,air,ironIngot,air,air,stick": {name:"ironSword"},
	"air,goldIngot,air,air,goldIngot,air,air,stick": {name:"goldenSword"},
	"air,diamond,air,air,diamond,air,air,stick": {name:"diamondSword"},
	"air,air,air,snowBlock,snowBlock,snowBlock": {name:"snow", amount:6},
	"snowball,snowball,air,snowball,snowball": {name:"snowBlock"},
	"ironIngot,air,ironIngot,air,ironIngot":{name:"bucket"},
	"_stone,_stone,_stone,_stone,air,_stone,_stone,_stone,_stone":{name:"furnace"},
	"wheat,wheat,wheat":{name:"bread"},
	"_planks,air,air,stick,air,air,stick":{name:"woodenShovel"},
	"_stone,air,air,stick,air,air,stick":{name:"stoneShovel"},
	"ironIngot,air,air,stick,air,air,stick":{name:"ironShovel"},
	"goldIngot,air,air,stick,air,air,stick":{name:"goldenShovel"},
	"diamond,air,air,stick,air,air,stick":{name:"diamondShovel"},
	"_planks,_planks,air,_planks,stick,air,air,stick":{name:"woodenAxe"},
	"_stone,_stone,air,_stone,stick,air,air,stick":{name:"stoneAxe"},
	"ironIngot,ironIngot,air,ironIngot,stick,air,air,stick":{name:"ironAxe"},
	"goldIngot,goldIngot,air,goldIngot,stick,air,air,stick":{name:"goldenAxe"},
	"diamond,diamond,air,diamond,stick,air,air,stick":{name:"diamondAxe"},
	"birchPlanks,birchPlanks":{name:"birchPressurePlate",shapeless:true},
	"oakPlanks,oakPlanks":{name:"oakPressurePlate",shapeless:true},
	"junglePlanks,junglePlanks":{name:"junglePressurePlate",shapeless:true},
	"sprucePlanks,sprucePlanks":{name:"sprucePressurePlate",shapeless:true},
	"darkOakPlanks,darkOakPlanks":{name:"darkOakPressurePlate",shapeless:true},
	"acaciaPlanks,acaciaPlanks":{name:"acaciaPressurePlate",shapeless:true},
	"mangrovePlanks,mangrovePlanks":{name:"mangrovePressurePlate",shapeless:true},
	"warpedPlanks,warpedPlanks":{name:"warpedPressurePlate",shapeless:true},
	"crimsonPlanks,crimsonPlanks":{name:"crimsonPressurePlate",shapeless:true},
	"stone,stone":{name:"stonePressurePlate",shapeless:true},
	"polishedBlackstone,polishedBlackstone":{name:"polishedBlackstone",shapeless:true},
	"goldIngot,goldIngot":{name:"lightWeightedPressurePlate",shapeless:true},
	"ironIngot,ironIngot":{name:"heavyWeightedPressurePlate",shapeless:true},
	"bambooPlanks,bambooPlanks":{name:"bambooPressurePlate",shapeless:true},
	"cherryPlanks,cherryPlanks":{name:"cherryPressurePlate",shapeless:true},
	"strippedOakLog": {name:"oakPlanks", amount:4, shapeless: true},
	"strippedAcaciaLog": {name:"acaciaPlanks", amount:4, shapeless: true},
	"strippedBirchLog": {name:"birchPlanks", amount:4, shapeless: true},
	"strippedDarkOakLog": {name:"darkOakPlanks", amount:4, shapeless: true},
	"strippedJungleLog": {name:"junglePlanks", amount:4, shapeless: true},
	"strippedSpruceLog": {name:"sprucePlanks", amount:4, shapeless: true},
	"strippedMangroveLog": {name:"mangrovePlanks", amount:4, shapeless: true},
	"strippedCherryLog": {name:"cherryPlanks", amount:4, shapeless: true},
	"warpedStem": {name:"warpedPlanks", amount:4, shapeless: true},
	"crimsonStem":{name:"crimsonPlanks", amount:4, shapeless: true},
	"strippedWarpedStem": {name:"warpedPlanks", amount:4, shapeless: true},
	"strippedCrimsonStem":{name:"crimsonPlanks", amount:4, shapeless: true},
	"warpedPlanks,air,air,warpedPlanks": {name:"stick", amount:4},
	"crimsonPlanks,air,air,crimsonPlanks": {name:"stick", amount:4},
	"stone":{name:"stoneButton", shapeless: true},
	"oakPlanks":{name:"oakButton", shapeless: true},
	"birchPlanks":{name:"birchButton", shapeless: true},
	"darkOakPlanks":{name:"darkOakButton", shapeless: true},
	"acaciaPlanks":{name:"acaciaButton", shapeless: true},
	"sprucePlanks":{name:"spruceButton", shapeless: true},
	"junglePlanks":{name:"jungleButton", shapeless: true},
	"mangrovePlanks":{name:"mangroveButton", shapeless: true},
	"warpedPlanks":{name:"warpedButton", shapeless: true},
	"crimsonPlanks":{name:"crimsonButton", shapeless: true},
	"polishedBlackstone":{name:"polishedBlackstoneButton", shapeless:true},
	"bambooPlanks":{name:"bambooButton", shapeless: true},
	"cherryPlanks":{name:"cherryButton", shapeless: true},
	"ironBlock": {name:"ironIngot",amount:9,shapeless:true},
	"goldBlock": {name:"goldIngot",amount:9,shapeless:true},
	"coalBlock": {name:"coal",amount:9,shapeless:true},
	"emeraldBlock": {name:"emerald",amount:9,shapeless:true},
	"diamondBlock": {name:"diamond",amount:9,shapeless:true},
	"copperIngot,copperIngot,copperIngot,copperIngot,copperIngot,copperIngot,copperIngot,copperIngot,copperIngot":{name:"copperBlock"},
	"copperBlock": {name:"copperIngot",amount:9,shapeless:true},
	"_planks,_planks,air,air,stick,air,air,stick":{name:"woodenHoe"},
	"_stone,_stone,air,air,stick,air,air,stick":{name:"stoneHoe"},
	"ironIngot,ironIngot,air,air,stick,air,air,stick":{name:"ironHoe"},
	"goldIngot,goldIngot,air,air,stick,air,air,stick":{name:"goldenHoe"},
	"diamond,diamond,air,air,stick,air,air,stick":{name:"diamondHoe"},
	"rawIron,rawIron,rawIron,rawIron,rawIron,rawIron,rawIron,rawIron,rawIron":{name:"rawIronBlock"},
	"rawGold,rawGold,rawGold,rawGold,rawGold,rawGold,rawGold,rawGold,rawGold":{name:"rawGoldBlock"},
	"rawCopper,rawCopper,rawCopper,rawCopper,rawCopper,rawCopper,rawCopper,rawCopper,rawCopper":{name:"rawCopperBlock"},
	"rawIronBlock":{name:"rawIron",amount:9,shapeless:true},
	"rawGoldBlock":{name:"rawGold",amount:9,shapeless:true},
	"rawCopperBlock":{name:"rawCopper",amount:9,shapeless:true},
	"netheriteScrap,netheriteScrap,netheriteScrap,netheriteScrap,goldIngot,goldIngot,goldIngot,goldIngot":{name:"netheriteIngot"},
	"netheriteIngot,netheriteIngot,netheriteIngot,air,stick,air,air,stick":{name:"netheritePickaxe"},
	"netheriteIngot,air,air,netheriteIngot,air,air,stick":{name:"netheriteSword"},
	"netheriteIngot,air,air,stick,air,air,stick":{name:"netheriteShovel"},
	"netheriteIngot,netheriteIngot,air,netheriteIngot,stick,air,air,stick":{name:"netheriteAxe"},
	"netheriteIngot,netheriteIngot,air,air,stick,air,air,stick":{name:"netheriteHoe"},
	"netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot":{name:"netheriteBlock"},
	"netheriteBlock":{name:"netheriteIngot",amount:9,shapeless:true},
	"wheat,wheat,wheat,wheat,wheat,wheat,wheat,wheat,wheat":{name:"hayBlock"},
	"hayBlock":{name:"wheat",amount:9,shapeless:true},
	"ironIngot":{name:"ironNugget",amount:9,shapeless:true},
	"goldIngot":{name:"goldNugget",amount:9,shapeless:true},
	"ironNugget,ironNugget,ironNugget,ironNugget,ironNugget,ironNugget,ironNugget,ironNugget,ironNugget":{name:"ironIngot"},
	"goldNugget,goldNugget,goldNugget,goldNugget,goldNugget,goldNugget,goldNugget,goldNugget,goldNugget":{name:"goldIngot"},
	"ironNugget,ironNugget,ironNugget,ironNugget,torch,ironNugget,ironNugget,ironNugget,ironNugget":{name:"lantern"},
	"stick,air,stick,stick,stick,stick,stick,air,stick":{name:"ladder",amount:3},
	"ironNugget,air,air,ironIngot,air,air,ironNugget":{name:"chain"},
	"stone,stone,air,stone,stone":{name:"stoneBricks",amount:4},
	"stoneBricks,vine":{name:"mossyStoneBricks",shapeless:true},
	"cobblestone,vine":{name:"mossyCobble",shapeless:true},
	"chiseledStoneBricks,chiseledStoneBricks,chiseledStoneBricks,chiseledStoneBricks,netheriteIngot,chiseledStoneBricks,chiseledStoneBricks,chiseledStoneBricks,chiseledStoneBricks":{name:"lodestone"},
	"_planks,_planks,_planks,_planks,redstone,_planks,_planks,_planks,_planks":{name:"noteBlock"},
	"_planks,_planks,_planks,_planks,diamond,_planks,_planks,_planks,_planks":{name:"jukebox"},
	"ironIngot,ironIngot,ironIngot,ironIngot,furnace,ironIngot,smoothStone,smoothStone,smoothStone":{name:"blastFurnace"},
	"air,_log,air,_log,furnace,_log,air,_log":{name:"smoker"},
	"carvedPumpkin,torch":{name:"jackOLantern",shapeless:true},
	"air,ironIngot,air,ironIngot":{name:"shears"},
	"melonSlice":{name:"melonSeeds",shapeless:true},
	"melonSlice,melonSlice,melonSlice,melonSlice,melonSlice,melonSlice,melonSlice,melonSlice,melonSlice":{name:"melon"},
	"redstone,redstone,redstone,redstone,redstone,redstone,redstone,redstone,redstone":{name:"redstoneBlock"},
	"redstoneBlock":{name:"redstone",amount:9,shapeless:true},
	"air,redstone,air,redstone,glowstone,redstone,air,redstone":{name:"redstoneLamp"},
	"glowstoneDust,glowstoneDust,air,glowstoneDust,glowstoneDust":{name:"glowstone"},
	"cobblestone,quartz,air,quartz,cobblestone":{name:"diorite",amount:2,shaped:true},
	"diorite,diorite,air,diorite,diorite":{name:"polishedDiorite",amount:4,shaped:true},
	"cobblestone,diorite":{name:"andesite",amount:2,shapeless:true},
	"andesite,andesite,air,andesite,andesite":{name:"polishedAndesite",amount:4,shaped:true},
	"diorite,quartz":{name:"granite",shapeless:true},
	"granite,granite,air,granite,granite":{name:"polishedGranite",amount:4,shaped:true},
	"amethystShard,air,air,copperIngot,air,air,copperIngot":{name:"spyglass",shaped:true},
	"_planks,air,_planks,air,_planks":{name:"bowl",amount:4,shaped:true},
	"redMushroom,brownMushroom,bowl":{name:"mushroomStew",shapeless:true},
	"egg,noodles,wheatSeeds,bowl":{name:"ramen",shapeless:true},
	"wheat,egg,wheat":{name:"noodles",shaped:true},
	"endStone,endStone,air,endStone,endStone":{name:"endStoneBricks",amount:4,shaped:true},
	"dirt,gravel,air,gravel,dirt":{name:"coarseDirt",amount:4,shaped:true},
	"itemFrame,glowInkSac":{name:"glowItemFrame",shapeless:true},
	"copperBlock,copperBlock,air,copperBlock,copperBlock":{name:"cutCopper",amount:4,shaped:true},
	"air,stick,air,stick,coal,stick,_log,_log,_log":{name:"campfire"},
	"air,stick,air,stick,soulSand,stick,_log,_log,_log":{name:"soulCampfire"},
	"_planks,_planks,_planks,_planks,air,_planks,_planks,_planks,_planks":{name:"chest"},
	"clayBall,clayBall,air,clayBall,clayBall":{name:"clay",shaped:true},
	"brick,brick,air,brick,brick":{name:"bricks",shaped:true},
	"brick,air,brick,air,brick":{name:"flowerPot",shaped:true},
	"air,amethystShard,air,amethystShard,glass,amethystShard,air,amethystShard":{name:"tintedGlass",amount:2},
	"redstone,air,air,stick":{name:"redstoneTorch",shaped:true},
	"stick,air,air,_stone":{name:"lever",shaped:true},
	"_planks,_planks,_planks,_stone,ironIngot,_stone,_stone,redstone,_stone":{name:"piston"},
	"_stone,_stone,_stone,redstone,redstone,quartz,_stone,_stone,_stone":{name:"observer"},
	"string,string,air,string,string": {name:"whiteWool"},

	"poppy": {name:"redDye", shapeless: true},
	"redTulip": {name:"redDye", shapeless: true},
	"roseBush": {name:"redDye", shapeless: true,amount:2},
	"sunflower": {name:"yellowDye", shapeless: true,amount:2},
	"dandelion": {name:"yellowDye", shapeless: true},
	"boneMeal":{name:"whiteDye",shapeless:true},
	"lilyOftheValley":{name:"whiteDye",shapeless:true},
	"azureBluet":{name:"lightGrayDye",shapeless:true},
	"oxeyeDaisy":{name:"lightGrayDye",shapeless:true},
	"whiteTulip":{name:"lightGrayDye",shapeless:true},
	"whiteDye,whiteDye,blackDye":{name:"lightGrayDye",amount:3,shapeless:true},
	"grayDye,whiteDye":{name:"lightGrayDye",amount:2,shapeless:true},
	"blackDye,whiteDye":{name:"grayDye",amount:2,shapeless:true},
	"witherRose":{name:"blackDye",shapeless:true},
	"inkSac":{name:"blackDye",shapeless:true},
	"redDye,yellowDye":{name:"orangeDye",amount:2,shapeless:true},
	"orangeTulip":{name:"orangeDye",shapeless:true},
	"greenDye,whiteDye":{name:"limeDye",amount:2,shapeless:true},
	"blueOrchid":{name:"lightBlueDye",shapeless:true},
	"whiteDye,blueDye":{name:"lightBlueDye",amount:2,shapeless:true},
	"blueDye,greenDye":{name:"cyanDye",amount:2,shapeless:true},
	"lapisLazuli":{name:"blueDye",shapeless:true},
	"cornFlower":{name:"blueDye",shapeless:true},
	"redDye,blueDye":{name:"purpleDye",amount:2,shapeless:true},
	"purpleDye,pinkDye":{name:"magentaDye",amount:2,shapeless:true},
	"redDye,blueDye,whiteDye":{name:"magentaDye",amount:3,shapeless:true},
	"redDye,blueDye,pinkDye":{name:"magentaDye",amount:3,shapeless:true},
	"allium":{name:"magentaDye",shapeless:true},
	"lilac":{name:"magentaDye",amount:2,shapeless:true},
	"redDye,whiteDye":{name:"pinkDye",amount:2,shapeless:true},
	"pinkTulip":{name:"pinkDye",shapeless:true},
	"peony":{name:"pinkDye",amount:2,shapeless:true},
	"pinkPetals":{name:"pinkDye",shapeless:true},
	
	"wheat,wheat,air,wheat,wheat":{name:"thatch",shaped:true},
	"mud,mangroveRoots":{name:"muddyMangroveRoots",shapeless:true},
	"mud,wheat":{name:"packedMud",shapeless:true},
	"packedMud,packedMud,air,packedMud,packedMud":{name:"mudBricks",shaped:true},
	"pointedDripstone,pointedDripstone,air,pointedDripstone,pointedDripstone":{name:"dripstoneBlock",shaped:true},
	"oakPlanks,oakPlanks,oakPlanks,oakPlanks,oakPlanks,oakPlanks,air,stick":{name:"oakSign",amount:3},
	"birchPlanks,birchPlanks,birchPlanks,birchPlanks,birchPlanks,birchPlanks,air,stick":{name:"birchSign",amount:3},
	"acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks,air,stick":{name:"acaciaSign",amount:3},
	"junglePlanks,junglePlanks,junglePlanks,junglePlanks,junglePlanks,junglePlanks,air,stick":{name:"jungleSign",amount:3},
	"sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks,air,stick":{name:"spruceSign",amount:3},
	"darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks,air,stick":{name:"darkOakSign",amount:3},
	"mangrovePlanks,mangrovePlanks,mangrovePlanks,mangrovePlanks,mangrovePlanks,mangrovePlanks,air,stick":{name:"mangroveSign",amount:3},
	"warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks,air,stick":{name:"warpedSign",amount:3},
	"crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks,air,stick":{name:"crimsonSign",amount:3},
	"bambooPlanks,bambooPlanks,bambooPlanks,bambooPlanks,bambooPlanks,bambooPlanks,air,stick":{name:"bambooSign",amount:3},
	"cherryPlanks,cherryPlanks,cherryPlanks,cherryPlanks,cherryPlanks,cherryPlanks,air,stick":{name:"cherrySign",amount:3},
	"_planksSlabs,air,_planksSlabs,_planksSlabs,air,_planksSlabs,_planksSlabs,_planksSlabs,_planksSlabs":{name:"composter"},
	"cocoaBeans":{name:"brownDye",shapeless:true},
	"wheat,cocoaBeans,wheat":{name:"cookie",shapeless:true,amount:8},
	"pumpkin,sugar,egg":{name:"pumpkinPie",shapeless:true},
	"beetroot":{name:"redDye",shapeless:true},
	"beetroot,beetroot,beetroot,beetroot,beetroot,beetroot,air,bowl":{name:"beetrootSoup"},
	"goldNugget,goldNugget,goldNugget,goldNugget,carrot,goldNugget,goldNugget,goldNugget,goldNugget":{name:"goldenCarrot"},
	"cookedRabbit,carrot,bakedPotato,redMushroom,bowl":{name:"rabbitStew",shapeless:true},
	"cookedRabbit,carrot,bakedPotato,brownMushroom,bowl":{name:"rabbitStew",shapeless:true},
	"goldIngot,goldIngot,goldIngot,goldIngot,apple,goldIngot,goldIngot,goldIngot,goldIngot":{name:"goldenApple"},
	"dirt,waterBucket":{name:"mud",shapeless:true,replace:{waterBucket:"bucket"}},
	"waterBucket,air,air,lavaBucket":{name:"obsidian",shaped:true,replace:{waterBucket:"bucket",lavaBucket:"bucket"}},
	"waterBucket,lavaBucket":{name:"cobblestone",shapeless:true,replace:{waterBucket:"bucket",lavaBucket:"bucket"}},
	"carrot,dirt,mud":{name:"mudPie",shapeless:true},
	"ironBlock,ironBlock,ironBlock,air,ironIngot,air,ironIngot,ironIngot,ironIngot":{name:"anvil"},
	"air,stick,string,stick,air,string,air,stick,string":{name:"bow"},
	"redstoneLamp,redDye":{name:"redRedstoneLamp",shapeless:true},
	"redstoneLamp,yellowDye":{name:"yellowRedstoneLamp",shapeless:true},
	"redstoneLamp,greenDye":{name:"greenRedstoneLamp",shapeless:true},
	"redstoneLamp,blueDye":{name:"blueRedstoneLamp",shapeless:true},
	"goldNugget,goldNugget,goldNugget,goldNugget,melonSlice,goldNugget,goldNugget,goldNugget,goldNugget":{name:"glisteringMelonSlice"},

	"lightGrayWool,lightGrayWool,lightGrayWool,_planks,_planks,_planks":{name:"lightGrayBed"},
	"lightBlueWool,lightBlueWool,lightBlueWool,_planks,_planks,_planks":{name:"lightBlueBed"},
	"magentaWool,magentaWool,magentaWool,_planks,_planks,_planks":{name:"magentaBed"},
	"yellowWool,yellowWool,yellowWool,_planks,_planks,_planks":{name:"yellowBed"},
	"purpleWool,purpleWool,purpleWool,_planks,_planks,_planks":{name:"purpleBed"},
	"orangeWool,orangeWool,orangeWool,_planks,_planks,_planks":{name:"orangeBed"},
	"whiteWool,whiteWool,whiteWool,_planks,_planks,_planks":{name:"whiteBed"},
	"greenWool,greenWool,greenWool,_planks,_planks,_planks":{name:"greenBed"},
	"brownWool,brownWool,brownWool,_planks,_planks,_planks":{name:"brownBed"},
	"blackWool,blackWool,blackWool,_planks,_planks,_planks":{name:"blackBed"},
	"pinkWool,pinkWool,pinkWool,_planks,_planks,_planks":{name:"pinkBed"},
	"limeWool,limeWool,limeWool,_planks,_planks,_planks":{name:"limeBed"},
	"grayWool,grayWool,grayWool,_planks,_planks,_planks":{name:"grayBed"},
	"cyanWool,cyanWool,cyanWool,_planks,_planks,_planks":{name:"cyanBed"},
	"blueWool,blueWool,blueWool,_planks,_planks,_planks":{name:"blueBed"},
	"oakPlanks,air,air,oakPlanks,oakPlanks,air,stick,stick":{name:"oakChair",shaped:true},
	"acaciaPlanks,air,air,acaciaPlanks,acaciaPlanks,air,stick,stick":{name:"acaciaChair",shaped:true},
	"birchPlanks,air,air,birchPlanks,birchPlanks,air,stick,stick":{name:"birchChair",shaped:true},
	"junglePlanks,air,air,junglePlanks,junglePlanks,air,stick,stick":{name:"jungleChair",shaped:true},
	"sprucePlanks,air,air,sprucePlanks,sprucePlanks,air,stick,stick":{name:"spruceChair",shaped:true},
	"darkOakPlanks,air,air,darkOakPlanks,darkOakPlanks,air,stick,stick":{name:"darkOakChair",shaped:true},
	"mangrovePlanks,air,air,mangrovePlanks,mangrovePlanks,air,stick,stick":{name:"mangroveChair",shaped:true},
	"warpedPlanks,air,air,warpedPlanks,warpedPlanks,air,stick,stick":{name:"warpedChair",shaped:true},
	"crimsonPlanks,air,air,crimsonPlanks,crimsonPlanks,air,stick,stick":{name:"crimsonChair",shaped:true},
	"blackWool,air,air,blackWool,blackWool,air,stick,stick":{name:"blackChair",shaped:true},
	"cherryPlanks,air,air,cherryPlanks,cherryPlanks,air,stick,stick":{name:"cherryChair",shaped:true},
	"bambooPlanks,air,air,bambooPlanks,bambooPlanks,air,stick,stick":{name:"bambooChair",shaped:true},

	"_stone,_stone,_stone,_stone,air,_stone,_stone,redstone,_stone":{name:"dropper"},
	"_stone,_stone,_stone,_stone,bow,_stone,_stone,redstone,_stone":{name:"dispenser"},
	"ironIngot,air,ironIngot,ironIngot,chest,ironIngot,air,ironIngot":{name:"hopper"},
	"air,redstone,air,redstone,hayBlock,redstone,air,redstone":{name:"target"},
	"air,redstoneTorch,air,redstoneTorch,quartz,redstoneTorch,stone,stone,stone":{name:"comparator"},
	"redstone,lapisLazuli,redstone":{name:"blueRedstone",amount:2,shaped:true},
	"gunpowder,sand,gunpowder,sand,gunpowder,sand,gunpowder,sand,gunpowder":{name:"tnt"},
	"gunpowder,redSand,gunpowder,redSand,gunpowder,redSand,gunpowder,redSand,gunpowder":{name:"tnt"},
	"flint,air,air,stick,air,air,feather":{name:"arrow",shaped:true,amount:4},
	"redstoneTorch,redstone,redstoneTorch,stone,stone,stone":{name:"repeater"},
	"bone":{name:"boneMeal",amount:3,shapeless:true},
	"glass,glass,glass,quartz,quartz,quartz,_planks,_planks,_planks":{name:"daylightDetector",amount:3},
	"blazeRod":{name:"blazePowder",amount:2,shapeless:true},
	"ice,ice,ice,ice,ice,ice,ice,ice,ice":{name:"packedIce"},
	"packedIce,packedIce,packedIce,packedIce,packedIce,packedIce,packedIce,packedIce,packedIce":{name:"blueIce"},
	"blazePowder,enderPearl":{name:"eyeOfEnder"},
	"bambooStalk,bambooStalk,bambooStalk,bambooStalk,bambooStalk,bambooStalk,bambooStalk,bambooStalk,bambooStalk":{name:"bambooBlock"},
	"bambooBlock":{name:"bambooPlanks",amount:2,shapeless:true},
	"strippedBambooBlock":{name:"bambooPlanks",amount:2,shapeless:true},
	"waterBucket,sand":{name:"quicksand",shapeless:true,replace:{waterBucket:"bucket"}},
	"glass,glass,glass,glass,glass,glass":{name:"glassPane",shaped:true,amount:48},
	"ironIngot,air,ironIngot,ironIngot,ironIngot,ironIngot":{name:"minecart",shaped:true},
	"ironIngot,air,ironIngot,ironIngot,stick,ironIngot,ironIngot,air,ironIngot":{name:"rail",amount:16},
	"goldIngot,air,goldIngot,goldIngot,stick,goldIngot,goldIngot,redstone,goldIngot":{name:"poweredRail",amount:16},
	"corn,bowl":{name:"popcornBowl",shapeless:true}
}
for (let i = 1; i < BLOCK_COUNT; ++i){
	const block = blockData[i]
	if(block.craftSlabs){
		crafts[block.name+","+block.name+","+block.name] = {name:block.name+"|SLAB",amount:6,shaped:true}
	}
	if(block.craftStairs){
		crafts[block.name+",air,air,"+block.name+","+block.name+",air,"+block.name+","+block.name+","+block.name] = {name:block.name+"|STAIR",amount:4}
	}
	if(block.name.endsWith("Wool")){
		let c = block.name.replace("Wool","")
		crafts[block.name+","+block.name] = {name:c+"Carpet",shaped:true,amount:32}
	}else if(block.name.endsWith("Dye")){
		let c = block.name.replace("Dye","")
		crafts["whiteWool,"+block.name] = {name:c+"Wool",shapeless:true}
		crafts["terracotta,terracotta,terracotta,terracotta,"+block.name+",terracotta,terracotta,terracotta,terracotta"] = {name:c+"Terracotta", amount:8, shapeless:true}
		crafts["glass,glass,glass,glass,"+block.name+",glass,glass,glass,glass"] = {name:c+"StainedGlass", amount:8, shapeless:true}
		crafts["glassPane,glassPane,glassPane,glassPane,"+block.name+",glassPane,glassPane,glassPane,glassPane"] = {name:c+"StainedGlassPane", amount:8, shapeless:true}
	}else if(block.name.endsWith("StainedGlass")){
		crafts[block.name+","+block.name+","+block.name+","+block.name+","+block.name+","+block.name] = {name:block.name+"Pane",shaped:true,amount:48}
	}
}
//replace anything in crafts starting with _
const craftTypes = {
	_planks: ["oakPlanks","birchPlanks","sprucePlanks","junglePlanks","darkOakPlanks","acaciaPlanks","mangrovePlanks","crimsonPlanks","warpedPlanks","cherryPlanks","bambooPlanks","bambooMosaic"],
	_planksSlabs: ["oakPlanks|SLAB","birchPlanks|SLAB","sprucePlanks|SLAB","junglePlanks|SLAB","darkOakPlanks|SLAB","acaciaPlanks|SLAB","mangrovePlanks|SLAB","crimsonPlanks|SLAB","warpedPlanks|SLAB","cherryPlanks|SLAB","bambooPlanks|SLAB","bambooMosaic|SLAB"],
	_stone: ["stone","cobblestone","deepslate","cobbledDeepslate","blackstone","limestone"],
	_log: ["oakLog","birchLog","spruceLog","jungleLog","darkOakLog","acaciaLog","mangroveLog","crimsonStem","warpedStem","cherryLog","bambooBlock"],
	_strippedLog: ["strippedOakLog","strippedBirchLog","strippedSpruceLog","strippedJungleLog","strippedDarkOakLog","strippedAcaciaLog","strippedMangroveLog","strippedCrimsonStem","strippedWarpedStem","strippedCherryLog","strippedBambooBlock"],
}
win.craftTypes = craftTypes
let smelts = {
	rawIron: {name:"ironIngot", time:200, xp:0.7},
	rawCopper: {name:"copperIngot", time:200, xp:0.7},
	rawGold: {name:"goldIngot", time:200, xp:1},
	sand: {name:"glass",time:200,xp:0.1, furnace:true},//furnace propertie means it can only be smelted in furnace
	cobblestone: {name:"stone",time:200,xp:0.1, furnace:true},
	stone: {name:"smoothStone", time:200, xp:0.1, furnace:true},
	stoneBricks: {name:"crackedStoneBricks",time:200,xp:0.1, furnace:true},
	clay: {name:"terracotta",time:200,xp:0.35},
	clayBall: {name:"brick",time:200,xp:0.3},
	ancientDebris: {name:"netheriteScrap", time:200, xp:1},
	cactus: {name:"greenDye", time:200, xp:0.1},
	rawChicken: {name:"cookedChicken",time:200,xp:0.35},
	rawBeef: {name:"cookedBeef",time:200,xp:0.35},
	rawCod: {name:"cookedCod",time:200,xp:0.35},
	rawMutton: {name:"cookedMutton",time:200,xp:0.35},
	rawPorkchop: {name:"cookedPorkchop",time:200,xp:0.35},
	rawRabbit: {name:"cookedRabbit",time:200,xp:0.35},
	rawSalmon: {name:"cookedSalmon",time:200,xp:0.35},
	potato: {name:"cookedPotato",time:200,xp:0.35},
	_log: {name:"charcoal",time:200,xp:0.15},
	_strippedLog: {name:"charcoal",time:200,xp:0.15}
}
let smeltFuel = { //time is in seconds
	_log: {time:15},
	_planks: {time:15},
	
	coal: {time:80},
	stick: {time:5},
	coalBlock: {time:690},
	lavaBucket: {time:1000},
	blazeRod: {time:120},
	charcoal: {time:80},
	bambooStalk: {time:2.5}
}

let craftArrays = {}
win.craftArrays = craftArrays
function checkCraftType(a,b){
	return craftTypes[a] && craftTypes[a].includes(b) || a === b
}
function getCraft(craft){
	main:for(var i in crafts){
		if(crafts[i].shapeless) continue
		var arr = craftArrays[i]
		for(var j=0; j<arr.length; j++){
			if(!checkCraftType(arr[j], craft[j])) continue main
		}
		return i
	}
}
function shapelessCraft(craft) {
	/*let arr2 = craft;
	arr2.sort(function(a, b) {
		return a - b;
	});
	let arr = [];
	for(let i in crafts) {
		if(!crafts[i].shapeless) continue;

		arr = i.split(",");
		arr.sort(function(a, b) {
			return a - b;
		});
		let comp = arr.map(num => Number(num));
		if(arrayValues(comp,arr2)) {
			return i;
		}
	}*/
	main:for(var i in crafts){
		if(!crafts[i].shapeless) continue
		var arr = craft.slice()
		var arr2 = craftArrays[i]
		remover:for(var j of arr2){ //remove the ones that exist for this recipe
			for(var k=0; k<arr.length; k++){
				if(checkCraftType(j,arr[k])){
					arr.splice(k,1)
					continue remover
				}
			}
			continue main //recipe doesn't have this item
		}
		if(!arr.length) return i
	}
}
function getBlockId(name){
	if(typeof name === "number" || name.startsWith("_")) return name
	let first = name.indexOf("|")
	let id = blockIds[first === -1 ? name : name.substring(0, first)]
	if(id===undefined)debugger
	if(name.endsWith("|SLAB")) id |= SLAB
	if(name.endsWith("|STAIR")) id |= STAIR
	return id
}
const achievementTypes = [
	//dont change order, because it may cause problems with loading
	{
		name:"Taking Inventory",
		score: 10,
		description:"Open your inventory"
	},
	{
		name:"Getting Wood",
		score:10,
		description:"Punch a tree until a block of wood pops out."
	},
	{
		name:"Benchmaking",
		score:10,
		description:"Craft a Crafting Table with four blocks of wooden planks."
	},
	{
		name:"Time to Mine!",
		score:10,
		description:"Use planks and sticks to make a pickaxe."
	},
	{
		name:"Getting an Upgrade",
		score:15,
		description:"Construct a better pickaxe."
	},
	{
		name:"Bake Bread",
		score:15,
		description:"Turn wheat into bread."
	},
	{
		name:"Time to Strike!",
		score:10,
		description:"Use planks and sticks to make a sword."
	},
	{
		name:"DIAMONDS!",
		score:20,
		description:"Acquire diamonds with your iron tools."
	},
	{
		name:"Diamonds to you!", //how is this possible to code???
		score:15,
		description:"Throw diamonds at another player."
	},
	{
		name:"Time to Farm!",
		score:10,
		description:"Make a Hoe."
	},
	{
		name:"Time to plant tomatoes!",
		score:10,
		description:"Get tomato seeds from Tall Grass."
	},
	{
		name:"Into the Nether",
		score:20,
		description:"Go into the Nether."
	},
	{
		name:"Hidden In The Depths",
		score:20,
		description:"Get Ancient Debris"
	},
	{
		name:"Into the End",
		score:20,
		description:"Go into the End."
	},
	{
		name:"get a hot stick",
		score:20,
		description:"get a blaze rod"
	},
	{
		name:"Make a bed",
		score:10,
		description:"Make a bed"
	}
]
const achievmentIds = {}
for(let i=0; i<achievementTypes.length; i++){
	achievmentIds[achievementTypes[i].name] = i
	achievementTypes[i].id = i
}
win.achievmentIds = achievmentIds, win.achievementTypes = achievementTypes

//add something to inventory
function newInvItem(p, id, durability, name){
	//look for empty slot
	let {inventory} = p
	for(let i=0; i<inventory.hotbar.length; i++){
		if(inventory.hotbar[i] && inventory.hotbar[i].id === id && (!inventory.hotbar[i].customName && !name || inventory.hotbar[i].customName === name) && inventory.hotbar[i].amount < blockData[inventory.hotbar[i].id].stackSize){
			inventory.hotbar[i].amount ++
			return true
		}
	}
	for(let i=0; i<inventory.main.length; i++){
		if(inventory.main[i] && inventory.main[i].id === id && (!inventory.main[i].customName && !name || inventory.main[i].customName === name) && inventory.main[i].amount < blockData[inventory.main[i].id].stackSize){
			inventory.main[i].amount ++;
			return true
		}
	}
	for(let i=0; i<inventory.hotbar.length; i++){
		if(!inventory.hotbar[i]){
			inventory.hotbar[i] = {id:id, amount:1, durability:durability, customName:name}
			if(i === inventory.hotbarSlot){
				inventory.showName = 1.5
			}
			return true
		}
	}
	for(let i=0; i<inventory.main.length; i++){
		if(!inventory.main[i]){
			inventory.main[i] = {id:id, durability:durability, customName:name, amount:1}
			return true
		}
	}
	return false
}
function minusOneItem(p,id){
	let {inventory} = p
	for(let i=0; i<inventory.hotbar.length; i++){
		if(inventory.hotbar[i] && inventory.hotbar[i].id === id){
			if(p.survival){
				inventory.hotbar[i].amount--
				if(!inventory.hotbar[i].amount) inventory.hotbar[i] = null
			}
			return true
		}
	}
	for(let i=0; i<inventory.main.length; i++){
		if(inventory.main[i] && inventory.main[i].id === id){
			if(p.survival){
				inventory.main[i].amount--
				if(!inventory.main[i].amount) inventory.main[i] = null
			}
			return true
		}
	}
	return false
}
function hasItem(p,id){
	let {inventory} = p
	for(let i=0; i<inventory.hotbar.length; i++){
		if(inventory.hotbar[i] && inventory.hotbar[i].id === id){
			return true
		}
	}
	for(let i=0; i<inventory.main.length; i++){
		if(inventory.main[i] && inventory.main[i].id === id){
			return true
		}
	}
	return false
}

/*Format for jigsaw
{
	data:array, Contains the blocks in the pallete of the jigsaw
	pallete:object, Each letter represents a block name
	center:string, The place to connect to the previous jigsaw, must be a letter from data
	newJigsaws:object, Jigsaws to generate connected to current jigsaw, the key is a letter from data, the value is the name of a jigsaw pool
	newJigsawTries:number, optional, Amount of tries to generate a new jigsaw connected to current jigsaw
	onGround:boolean, optional,
	flatOnGround:boolean, optional
}
*/
let jigsaws = {}, jigsawPools = {}
/*Format for structures
{
	type:string, can be simple or compound
	start:array, Jigsaw pool or jigsaw to choose starting jigsaw, randomly chosen
	chance:number, How common is it every structureSpacing blocks
	getY:function, Return y level of starting jigsaw, not needed if all jigsaws are on ground
	maxSize:number, Maximum distance for jigsaws to be from starting jigsaw, Also for determining how far to look for structures
	If type is compound:
		jigsawCount:number, Target amount of jigsaws to generate in structure, actual amount of jigsaws may be lower
		maxTries:number, Maximum tries to generate a jigsaw, will stop generating if amount of jigsaw reaches jigsawCount
}
*/
let structures = []
/*Structure notes
Jigsaws can only have a new jigsaw on the sides, not on top, bottom, or inside.
If a block is undefined in pallete, that block will be ignored.
If a jigsaw is onGround, it can not be more than 16 blocks from center to prevent chunk errors
*/
function addStructures(newJigsaws,newJigsawPools,newStructures){
	Object.assign(jigsaws,newJigsaws)
	Object.assign(jigsawPools,newJigsawPools)
	structures.push(...newStructures)
}
addStructures(
{
	endPortal:{
		data:[
`sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss`,
`sssssssss
s       s
s sssss s
s sllls s
s sllls s
s sllls s
s sssss s
s  sss  s
s  sss  s
s  ttt  s
s       s
sss   sss
sls   sls
ssss!ssss`,
`sssssssss
s       s
s       s
s       s
s       s
s       s
s       s
s  sss  s
s  ttt  s
s       s
s       s
s       s
s       s
sssssssss`,
`sssssssss
s       s
s  ---  s
s (   ) s
s (   ) s
s (   ) s
s  ___  s
s  ttt  s
s       s
s       s
s       s
s       s
s       s
sssssssss`,
`sssssssss
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
sssssssss`,
`sssssssss
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
sssssssss`,
`sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss`,
],
		pallete:{
			s:"stoneBricks",
			"!":"stoneBricks",
			"_":(n,e,s,w)=>random()>0.75?blockIds.endPortalFrame|SLAB|e:blockIds.endPortalFrame|e,
			"-":(n,e,s,w)=>random()>0.75?blockIds.endPortalFrame|SLAB|w:blockIds.endPortalFrame|w,
			"(":(n,e,s,w)=>random()>0.75?blockIds.endPortalFrame|SLAB|s:blockIds.endPortalFrame|s,
			")":(n,e,s,w)=>random()>0.75?blockIds.endPortalFrame|SLAB|n:blockIds.endPortalFrame|n,
			l:"Lava"," ":"air",
			t:(n,e,s,w)=>blockIds.stoneBricks|STAIR|w,
		},
		center:"!",
	},

	
},
{},
[
	{
		type:"simple",
		start:"endPortal",
		chance:0.5,
		maxSize:16,
		getY:(x,z,rnd)=>{
			return 10+Math.round(rnd%16)
		}
	}
]
)

// Village
addStructures(
{
	    villageCenter1:{
	        data:[
`   1
 ccccc
 c   c
1c ! c1
 c   c
 ccccc
   1`,
`

  EeN
  nls
  SwW
`,
`


   l`,
`


   l`,
`

  qqq
  qlq
  qqq`,
`

  qqq
  qqq
  qqq`
            ],
            pallete:{
							c:"cobblestone",
							l:"oakLog",
							q:"oakLeaves",
							n:(n,e,s,w) => blockIds.cobblestone|STAIR|n,
	            e:(n,e,s,w) => blockIds.cobblestone|STAIR|e,
	            s:(n,e,s,w) => blockIds.cobblestone|STAIR|s,
	            w:(n,e,s,w) => blockIds.cobblestone|STAIR|w
            },
            newJigsaws:{
	            "1":"villagePath"
	        },
	        center:"!",
	        newJigsawTries:8,
	        onGround:true
	    },
	    villageCenter2:{
	        data:[
`  1
 dddd
1d!.d
 d..d1
 dddd
  1`,
`cccccc
cccccc
cc  cc
cc  cc
cccccc
cccccc`,
`
 cccc
 c  c
 c  c
 cccc`,
`
 l  l


 l  l`,
`
 l  l


 l  l`,
`
 cccc
 cccc
 cccc
 cccc`
            ],
            pallete:{"c":"cobblestone",".":"Water","!":"lightBlueWool",l:()=>blockIds.oakPlanks|FENCE},
            newJigsaws:{
	            "1":"villagePath"
	        },
	        center:"!",
	        newJigsawTries:8,
	        onGround:true
	    },
	    villagePath:{
	        data:[
`:bAb:
:bab:
:bab:
:bab:
:bab:
:bab:
:bab:
:bab:
:bab:
:bab:
:bab:
:bab:
:bab:
:bab:
:bab:
2b1b2`//Multiple new jigsaw positions because if only placed in center, new path will overlap with current path
	        ],
	        pallete:{
	            a:"dirtPath",
	            b: (n,e,s,w,x,y,z) => hash(x/2,z/2) > 0.9 ? undefined : "dirtPath",
	            A:"dirtPath","1":"dirtPath"
	        },
	        center:"A",
	        newJigsaws:{
	            "1":"villagePathShort",
	            "2":"villagePath",
	            ":":"villageBuilding"
	        },
	        flatOnGround:true,
	        newJigsawTries:8
	    },
	    villagePathShort:{
	        data:[
`aAa
aaa
aaa
aaa
aaa
aaa
aaa
aaa
aaa
111`
            ],
	        pallete:{a:"dirtPath",A:"dirtPath","1":"dirtPath"},
	        center:"A",
	        newJigsaws:{
	            "1":"villagePath"
	        },
	        flatOnGround:true,
	        newJigsawTries:4
	    },
	    villageHouse1:{
	        data:[
`ldddl
ddddd
ddddd
ddddd
ldddl`,
`lllll
ldddl
ldddl
ldddl
lllll
  !`,
`lcccl
cpppc
cpppc
cpppc
lcccl
  s`,
`lcccl
c---c
c---c
c---c
lc-cl`,
`lcgcl
c---c
g---g
c---c
lc-cl`,
`lcccl
c---c
c---c
c---c
lcccl`,
`ppppp
ppppp
ppppp
ppppp
ppppp`
	        ],
	        pallete:{
	            l:"oakLog",c:"cobblestone",
	            p:"oakPlanks","-":"air",
	            g:"glass",
	            d:"dirt",
	            s:(n,e,s,w)=>blockIds.oakPlanks|STAIR|w
	        },
	        center:"!",
	        onGround:true
	    },
	    villageFarm:{
	        data:[
`lllllll
lffwffl
lffwffl
lffwffl
lffwffl
lffwffl
lllllll

   !`
	        ],
	        pallete:{l:"oakLog",f:"brownWool",w:"lightBlueWool"},
	        center:"!",
	        onGround:true
	    },
},
{
		villageCenter:["villageCenter1","villageCenter2"],
		villagePath:["villagePath","villagePathShort","villagePath"],
		villagePathShort:["villagePath","villagePathShort","villagePathShort"],
		villageBuilding:["villageHouse1","villageFarm"]
},
[
	{
		type:"compound",
		start:"villageCenter",
		chance:0.05,
		getY:(x,z,rnd)=>{
				return 0
		},
		maxSize:64,
		jigsawCount:40,
		maxTries:100
	}
]
)

let structureCheckDist = 0
const structureSpacing = 64
for(let s of structures){
		structureCheckDist = Math.max(structureCheckDist,s.maxSize)
		s.start = jigsawPools[s.start] || [s.start]
}
structureCheckDist = Math.ceil(structureCheckDist/16)*16
for(let jn in jigsaws){
	let s = jigsaws[jn]
	let ss = Object.create(s)
	let se = Object.create(s)
	let sw = Object.create(s)
	ss.data = [], se.data = [], sw.data = []
	s.nextJigsawPos = [], ss.nextJigsawPos = [], se.nextJigsawPos = [], sw.nextJigsawPos = []
	s.newJigsaws = s.newJigsaws || {}
	let data = []
	let w=0, h=s.data.length, d=0
	for(let i=0;i<s.data.length;i++){
			let rows = s.data[i].split("\n")
			w = Math.max(w,rows.length)
			for(let j=0;j<rows.length;j++){
					let row = rows[j]
					d = Math.max(d,row.length)
			}
	}
	for(let i=0;i<s.data.length;i++){
		let rows = s.data[i].split("\n")
		for(let j=0;j<rows.length;j++){
				let row = rows[j]
				for(let k=0;k<row.length;k++){
					if(s.pallete[row[k]]){
							data.push(j,i,k,s.pallete[row[k]])
							ss.data.push(w-1-j,i,d-1-k,s.pallete[row[k]])
							se.data.push(k,i,j,s.pallete[row[k]])
							sw.data.push(d-1-k,i,w-1-j,s.pallete[row[k]])
					}
					if(row[k] === s.center){
							s.centerPos = [j,i,k]
							ss.centerPos = [w-1-j,i,d-1-k]
							se.centerPos = [k,i,j]
							sw.centerPos = [d-1-k,i,w-1-j]
					}
					if(s.newJigsaws[row[k]]){
						let newJigsaws = s.newJigsaws[row[k]]
						/*if(!Array.isArray(newJigsaws)){
								tempJigsawArr[0] = newJigsaws
								newJigsaws = tempJigsawArr
						}*/
						for(let nj of jigsawPools[newJigsaws]){ 
								s.nextJigsawPos.push([j,i,k,nj])
								ss.nextJigsawPos.push([w-1-j,i,d-1-k,nj])
								se.nextJigsawPos.push([k,i,j,nj])
								sw.nextJigsawPos.push([d-1-k,i,w-1-j,nj])
						}
					}
			}
		}
	}
	s.data = data
	s.w = w, s.h = h, s.d = d
	ss.w = w, ss.h = h, ss.d = d
	se.w = d, se.h = h, se.d = w
	sw.w = d, sw.h = h, sw.d = w
	s.variants = [s,sw,ss,se]
	s.newJigsawTries = s.nextJigsawPos.length ? (s.newJigsawTries === undefined ? 1 : s.newJigsawTries) : 0
}

function objectify(x, y, z, width, height, textureX, textureY, texXFlip,texYFlip,rotateTex,texW,texH,textureName) {
	return {
		x: x,
		y: y,
		z: z,
		w: width,
		h: height,
		tx: textureX,
		ty: textureY,
		txf: texXFlip,
		tyf: texYFlip,
		rt:rotateTex,
		tw:texW || width,
		th:texH || height,
		t:textureName
	}
}
win.objectify = objectify
function customFace(x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4, tx,ty,tw,th, t){
	tw = tw || 16
	th = th || 16
	return {
		x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4, tx,ty,tw,th,
		t,
		custom:true
	}
}
function generateItemShape(){
	var arr = []
	var bottom = [],
			top = [],
			east = [],
			west = []
	var i
	for(i=0; i<16; i++){
		bottom.push(objectify(0,i,7.5,16,1,0,(16-i)-1))
		top.push(objectify(0,i+1,8.5,16,1,0,16-i-1))
		east.push(objectify(i+1,16,7.5,1,16,(16-i)-1,0))
		west.push(objectify(i,16,8.5,1,16,(16-i)-1,0))
	}
	return [bottom,top,
					[objectify(16, 16, 8.5, 16, 16, 0, 0, true)],[objectify( 0, 16,  7.5, 16, 16, 0, 0)],
				 east,west]
}
function layerShape(h){
	return [
		[objectify(0,0,0,16,16,0,0)],
		[objectify(0,h,16,16,16,0,0)],
		[objectify(16, h, 16, 16, h, 0, 16-h)],
		[objectify( 0, h,  0, 16, h, 0, 16-h)],
		[objectify(16, h,  0, 16, h, 0, 16-h)],
		[objectify( 0, h, 16, 16, h, 0, 16-h)]
	]
}
function liquidLayerShape(h){
	return [
		[objectify(0,0,0,16,16,0,0),objectify(16,0,0,-16,16,16,0, false,false,false,null,null, "in")],
		[objectify(0,h,16,16,16,0,0),objectify(16,h,16,-16,16,16,0, false,false,false,null,null, "in")],
		[objectify(16, h, 16, 16, h, 0, 16-h),objectify( 0, h, 16, -16, h, 16, 16-h, false,false,false,null,null, "in")],
		[objectify( 0, h,  0, 16, h, 0, 16-h),objectify(16, h,  0, -16, h, 16, 16-h, false,false,false,null,null, "in")],
		[objectify(16, h,  0, 16, h, 0, 16-h),objectify(16, h, 16, -16, h, 16, 16-h, false,false,false,null,null, "in")],
		[objectify( 0, h, 16, 16, h, 0, 16-h),objectify( 0, h,  0, -16, h, 16, 16-h, false,false,false,null,null, "in")]
	]
}

function generateRepeater(delay = 1, on = false){
	on = on ? 16 : 0
	let torch = on ? "redstoneTorch" : "redstoneTorchOff"
	let arr = [
		[objectify(0,0,0,16,16,0,0,false,false,null,null,null,"smoothStone")],
		[objectify(0,2,16,16,16,on,0),objectify(7,7,14,2,2,7,6,false,false,null,null,null,torch),objectify(7,7,12 - delay*2,2,2,7,6,false,false,null,null,null,torch)], //top
		[objectify(16,2,16,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(9,7,14,2,5,7,6,false,false,null,null,null,torch),objectify(9,7,12 - delay*2,2,5,7,6,false,false,null,null,null,torch)], //north
		[objectify(0,2,0,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(7,7,12,2,5,7,6,false,false,null,null,null,torch),objectify(7,7,10 - delay*2,2,5,7,6,false,false,null,null,null,torch)],  //south
		[objectify(16,2,0,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(9,7,12,2,5,7,6,false,false,null,null,null,torch),objectify(9,7,10 - delay*2,2,5,7,6,false,false,null,null,null,torch)], //east
		[objectify(0,2,16,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(7,7,14,2,5,7,6,false,false,null,null,null,torch),objectify(7,7,12 - delay*2,2,5,7,6,false,false,null,null,null,torch)] //west
	]
	if(on){
		arr[0].push(objectify(6,7,9 - delay*2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[1].push(objectify(6,5,13 - delay*2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[2].push(objectify(10,8,10 - delay*2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[3].push(objectify(6,8,12 - delay*2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[4].push(objectify(7,8,9 - delay*2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[5].push(objectify(9,8,13 - delay*2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		
		arr[0].push(objectify(6,7,11,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[1].push(objectify(6,5,15,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[2].push(objectify(10,8,12,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[3].push(objectify(6,8,14,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[4].push(objectify(7,8,11,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[5].push(objectify(9,8,15,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
	}
	return arr
}
function generateComparator(subtractMode,on){
	on = on ? 16 : 0
	let subtractModeUp = subtractMode ? 1 : 0
	let torchSubtract = subtractMode ? "redstoneTorch" : "redstoneTorchOff"
	let torch = on ? "redstoneTorch" : "redstoneTorchOff"
	let arr = [
		[objectify(0,0,0,16,16,0,0,false,false,null,null,null,"smoothStone")],
		[objectify(0,2,16,16,16,on,0),objectify(7,4+subtractModeUp,14,2,2,7,6,false,false,null,null,null,torchSubtract),objectify(4,7,5,2,2,7,6,false,false,null,null,null,torch),objectify(10,7,5,2,2,7,6,false,false,null,null,null,torch)],
		[objectify(16,2,16,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(9,4+subtractModeUp,14,2,2,7,6,false,false,null,null,null,torchSubtract),objectify(6,7,5,2,5,7,6,false,false,null,null,null,torch),objectify(12,7,5,2,5,7,6,false,false,null,null,null,torch)],
		[objectify(0,2,0,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(7,4+subtractModeUp,12,2,2,7,6,false,false,null,null,null,torchSubtract),objectify(4,7,3,2,5,7,6,false,false,null,null,null,torch),objectify(10,7,3,2,5,7,6,false,false,null,null,null,torch)],
		[objectify(16,2,0,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(9,4+subtractModeUp,12,2,2,7,6,false,false,null,null,null,torchSubtract),objectify(6,7,3,2,5,7,6,false,false,null,null,null,torch),objectify(12,7,3,2,5,7,6,false,false,null,null,null,torch)],
		[objectify(0,2,16,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(7,4+subtractModeUp,14,2,2,7,6,false,false,null,null,null,torchSubtract),objectify(4,7,5,2,5,7,6,false,false,null,null,null,torch),objectify(10,7,5,2,5,7,6,false,false,null,null,null,torch)]
	]
	if(subtractMode){
		arr[0].push(objectify(6,5,11,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[1].push(objectify(6,3,15,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[2].push(objectify(10,6,12,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[3].push(objectify(6,6,14,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[4].push(objectify(7,6,11,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[5].push(objectify(9,6,15,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
	}
	if(on){
		arr[0].push(objectify(3,7,2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[1].push(objectify(3,5,6,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[2].push(objectify(7,8,3,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[3].push(objectify(3,8,5,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[4].push(objectify(4,8,2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[5].push(objectify(6,8,6,4,4,6,5,false,false,null,null,null,"redstoneTorch"))

		arr[0].push(objectify(9,7,2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[1].push(objectify(9,5,6,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[2].push(objectify(13,8,3,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[3].push(objectify(9,8,5,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[4].push(objectify(10,8,2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
		arr[5].push(objectify(12,8,6,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
	}
	return arr
}
function generateRectangleShape(w,h,name){
	const offsetX = -w*8
	let arr = []
	for(let x=0; x<w; x++) for(let y=0; y<h; y++){
		if(!textures[name]) continue
		let t = name+(x+y*w)
		let tex = textureCoords[textureMap[t]]
		arr.push(objectify(x*16+offsetX,y*16,8,16,16,0,0,false,false,false,null,null,t))
	}
	return[[],[],arr,[],[],[]]
}
function generateSpike(verts,x,y,z,tilt,h,t){
	verts[2].push(customFace(2+x,y+h,2+tilt+z, 10+x,y+h,2+tilt+z, 10+x,y,4+z, 2+x,y,4+z, 8,0,8,16,t))
	verts[3].push(customFace(14+x,y+h,2+tilt+z, 6+x,y+h,2+tilt+z, 6+x,y,0+z, 14+x,y,0+z, 8,0,8,16,t))
	verts[4].push(customFace(8+x,y+h,-4+tilt+z, 8+x,y+h,4+tilt+z, 6+x,y,4+z, 6+x,y,-4+z, 8,0,8,16,t))
	verts[5].push(customFace(8+x,y+h,6+tilt+z, 8+x,y+h,tilt+z, 10+x,y,0+z, 10+x,y,8+z, 8,0,8,16,t))
}
function addStem1x1(verts,x,z,h){
	verts[2].push(customFace(x,h,z, x+1,h,z+1, x+1,0,z+1, x,0,z, 0,4,1,h))
	verts[3].push(customFace(x+1,h,z, x,h,z+1, x,0,z+1, x+1,0,z, 0,4,1,h))
	verts[4].push(customFace(x+1,h,z+1, x,h,z, x,0,z, x+1,0,z+1, 0,4,1,h))
	verts[5].push(customFace(x,h,z+1, x+1,h,z, x+1,0,z, x,0,z+1, 0,4,1,h))
	return verts
}
let shapes = {
	/*
		[
			[(-x, -z), (+x, -z), (+x, +z), (-x, +z)], // minX = 0,  minZ = 2,  maxX = 6, maxZ = 8
			[(-x, +z), (+x, +z), (+x, -z), (-x, -z)], // minX = 9,  minZ = 10, maxX = 3, maxZ = 4
			[(+x, +y), (-x, +y), (-x, -y), (+x, -y)], // minX = 6,  minY = 7,  maxX = 0, maxY = 1
			[(-x, +y), (+x, +y), (+x, -y), (-x, -y)], // minX = 9,  minY = 10, maxX = 3, maxY = 4
			[(+y, -z), (+y, +z), (-y, +z), (-y, -z)], // minY = 10, minZ = 11, maxY = 4, maxZ = 5
			[(+y, +z), (+y, -z), (-y, -z), (-y, +z)]  // minY = 7,  minZ = 8,  maxY = 1, maxZ = 2
		]
		*/
	cube: {
		verts: [
			// x, y, z, width, height, textureX, textureY
			// 0, 0, 0 is the corner on the top left of the texture
			[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
			[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
			[objectify(16, 16, 16, 16, 16, 0, 0)], //north
			[objectify( 0, 16,  0, 16, 16, 0, 0)], //south
			[objectify(16, 16,  0, 16, 16, 0, 0)], //east
			[objectify( 0, 16, 16, 16, 16, 0, 0)]  //west
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 3,
			south: 3,
			east: 3,
			west: 3
		},
	},
	rotate: {
		verts: [
			[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
			[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
			[objectify(16, 16, 16, 16, 16, 0, 0)], //north
			[objectify( 0, 16,  0, 16, 16, 0, 0)], //south
			[objectify(16, 16,  0, 16, 16, 0, 0)], //east
			[objectify( 0, 16, 16, 16, 16, 0, 0)]  //west
		],
		rotate: true,
		cull: {
			top: 3,
			bottom: 3,
			north: 3,
			south: 3,
			east: 3,
			west: 3
		},
	},
	flipped:{
		verts: [
			[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
			[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
			[objectify(16, 16, 16, 16, 16, 0, 0, false,true)], //north
			[objectify( 0, 16,  0, 16, 16, 0, 0, false,true)], //south
			[objectify(16, 16,  0, 16, 16, 0, 0, false,true)], //east
			[objectify( 0, 16, 16, 16, 16, 0, 0, false,true)]  //west
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 3,
			south: 3,
			east: 3,
			west: 3
		},
	},
	SW:{
		verts: [
			[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
			[objectify( 0, 16, 16, 16, 16, 0, 0, false,false, 2)], //top
			[objectify(16, 16, 16, 16, 16, 0, 0)], //north
			[objectify( 0, 16,  0, 16, 16, 0, 0)], //south
			[objectify(16, 16,  0, 16, 16, 0, 0, false,false, 1)], //east
			[objectify( 0, 16, 16, 16, 16, 0, 0, false,false, -1)]  //west
		],
		rotate:true,
		cull: {
			top: 3,
			bottom: 3,
			north: 3,
			south: 3,
			east: 3,
			west: 3
		},
	},
	_1PixLower:{
		verts: [
			[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
			[objectify( 0, 15, 16, 16, 16, 0, 0)], //top
			[objectify(16, 15, 16, 16, 15, 0, 1)], //north
			[objectify( 0, 15,  0, 16, 15, 0, 1)], //south
			[objectify(16, 15,  0, 16, 15, 0, 1)], //east
			[objectify( 0, 15, 16, 16, 15, 0, 1)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 3,
			south: 3,
			east: 3,
			west: 3
		},
	},
	none: {
		verts: [[],[],[],[],[],[]],
		hitbox:"cube",
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
	},
	slab: {
		verts: [
			[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
			[objectify( 0, 8, 16, 16, 16, 0, 0)], //top
			[objectify(16, 8, 16, 16, 8, 0, 0)], //north
			[objectify( 0, 8,  0, 16, 8, 0, 0)], //south
			[objectify(16, 8,  0, 16, 8, 0, 0)], //east
			[objectify( 0, 8, 16, 16, 8, 0, 0)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 1,
			south: 1,
			east: 1,
			west: 1
		},
		flip: true
	},
	verticalSlab:{
		verts:[
			[objectify(0,0,8,16,8,0,0)],
			[objectify(0,16,16,16,8,0,0)],
			[objectify(16,16,16,16,16,0,0)],
			[objectify(0,16,8,16,16,0,0)],
			[objectify(16,16,8,8,16,0,0)],
			[objectify(0,16,16,8,16,0,0)]
		],
		cull: {
			top: 1,
			bottom: 1,
			north: 3,
			south: 0,
			east: 1,
			west: 1
		},
		rotate: true
	},
	stair: {
		verts: [
			[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
			[objectify( 0, 8,  8, 16, 8, 0, 8), objectify( 0, 16,  16, 16, 8, 0, 0)], //top
			[objectify(16, 16, 16, 16, 16, 0, 0)], //north
			[objectify( 0, 8,  0, 16, 8, 0, 0), objectify( 0, 16,  8, 16, 8, 0, 0)], //south
			[objectify(16, 8, 0, 8, 8, 8, 0), objectify(16, 16, 8, 8, 16, 0, 0)], //east
			[objectify( 0, 8, 8, 8, 8, 0, 0), objectify( 0, 16, 16, 8, 16, 8, 0)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 3,
			south: 0,
			east: 0,
			west: 0
		},
		flip: true,
		rotate: true
	},
	stairCornerOut: {
		verts: [
			[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
			[objectify( 0, 8,  16, 16, 16, 0, 0), objectify( 0, 16,  16, 8, 8, 0, 0)], //top
			[objectify(8, 16, 16, 8, 8, 0, 0), objectify(16, 8, 16, 16, 8, 0, 0)], //north
			[objectify( 0, 8,  0, 16, 8, 0, 0), objectify( 0, 16,  8, 8, 8, 0, 0)], //south
			[objectify(16, 8, 0, 16, 8, 0, 0), objectify(8, 8, 8, 8, 16, 0, 0)], //east
			[objectify( 0, 8, 8, 8, 8, 0, 0), objectify( 0, 16, 16, 8, 16, 8, 0)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 3,
			south: 0,
			east: 0,
			west: 0
		},
		flip: true,
		rotate: true
	},
	stairCornerIn: {
		verts: [
			[objectify(0,0,0,16,16,0,0)],
			[objectify(8,8,8,8,8,0,0),objectify(0,16,16,16,8,0,0),objectify(0,16,8,8,8,0,0)],
			[objectify(16,16,16,16,16,0,0)],
			[objectify(8,16,8,8,8,0,0),objectify(0,16,0,8,8,0,0),objectify(0,8,0,16,8,0,0)],
			[objectify(8,16,0,8,8,0,0),objectify(16,16,8,8,8,0,0),objectify(16,8,0,16,8,0,0)],
			[objectify(0,16,16,16,16,0,0)]
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 3,
			south: 0,
			east: 0,
			west: 0
		},
		flip: true,
		rotate: true
	},
	cross: {
		verts: [
			[], //bottom
			[], //top
			[customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 0,0)], //north
			[customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 0,0)], //south
			[customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 0,0)], //east
			[customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 0,0)]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox: "cube"
	},
	sideCross: {
		verts: [
			[], //bottom
			[], //top
			[customFace(2,2,16, 14,14,16, 14,14,0, 2,2,0, 0,16,16,-16)], //north
			[customFace(14,2,16, 2,14,16, 2,14,0, 14,2,0, 0,16,16,-16)], //south
			[customFace(14,14,16, 2,2,16, 2,2,0, 14,14,0, 0,16,16,-16)], //east
			[customFace(2,14,16, 14,2,16, 14,2,0, 2,14,0, 0,16,16,-16)]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true,
		hitbox: "cube"
	},
	bottomCross: {
		verts: [
			[], //bottom
			[], //top
			[customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 0,16,16,-16)], //north
			[customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 0,16,16,-16)], //south
			[customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 0,16,16,-16)], //east
			[customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 0,16,16,-16)]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		size: 6,
		hitbox: "cube"
	},
	tallCross: {
		verts: [
			[], //bottom
			[], //top
			[customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 16,0),customFace(2,32,2, 14,32,14, 14,16,14, 2,16,2, 0,0)], //north
			[customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 16,0),customFace(14,32,2, 2,32,14, 2,16,14, 14,16,2, 0,0)], //south
			[customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 16,0),customFace(14,32,14, 2,32,2, 2,16,2, 14,16,14, 0,0)], //east
			[customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 16,0),customFace(2,32,14, 14,32,2, 14,16,2, 2,16,14, 0,0)]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"tallCube"
	},
	door: {
		verts: [
			[objectify( 0,  0,  0, 16, 3, 16, 0, false,false,false,null,2)], //bottom
			[objectify( 0, 16, 3, 16, 3, 16, 0),objectify( 0, 32, 3, 16, 3, 0, 0, false,false,false,null,2)], //top
			[objectify(16, 16, 3, 16, 16, 16, 0),objectify(16, 32, 3, 16, 16, 0, 0)], //north
			[objectify(0, 32, 0, 16, 16, 0, 0, true),objectify(0, 16, 0, 16, 16, 16, 0, true)], //south
			[objectify(16, 16,  0, 3, 16, 16, 0, false,false,false,2),objectify(16, 32,  0, 3, 16, 0, 0, false,false,false,2)], //east
			[objectify( 0, 16, 3, 3, 16, 16, 0, false,false,false,2),objectify( 0, 32, 3, 3, 16, 0, 0, false,false,false,2)]  //west
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true
	},
	torchHitbox:{
		verts:[
			[objectify( 7,  0,  7, 2, 2, 7, 14)], //bottom
			[objectify( 7, 10, 9, 2, 2, 7, 6)], //top
			[objectify(9, 10, 9, 2, 10, 7, 6)], //north
			[objectify( 7, 10,  7, 2, 10, 7, 6)], //south
			[objectify(9, 10,  7, 2, 10, 7, 6)], //east
			[objectify( 7, 10, 9, 2, 10, 7, 6)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
	},
	torch: {
		verts: [
			[objectify( 7,  0,  7, 2, 2, 7, 14)], //bottom
			[objectify( 7, 10, 9, 2, 2, 7, 6)], //top
			[objectify(16, 16, 9, 16, 16, 0, 0)], //north
			[objectify( 0, 16,  7, 16, 16, 0, 0)], //south
			[objectify(9, 16,  0, 16, 16, 0, 0)], //east
			[objectify( 7, 16, 16, 16, 16, 0, 0)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"torchHitbox"
	},
	wallTorch: {
		verts: [
			[customFace(9,4,17, 7,4,17, 7,3,15, 9,3,15, 7,14,2,2)],
			[customFace(9,13,11, 7,13,11, 7,14,13, 9,14,13, 7,6,2,2)],
			[customFace(16,20,10.6, 0,20,10.6, 0,4,17, 16,4,17, 0,0,16,16)], //north
			[customFace(0,19,8.6, 16,19,8.6, 16,3,15, 0,3,15, 0,0,16,16)], //south
			[customFace(9,15.5,1.6, 9,23.5,17.6, 9,7.5,24, 9,-0.5,8, 0,0,16,16)], //east
			[customFace(7,23.5,17.6, 7,15.5,1.6, 7,-0.5,8, 7,7.5,24, 0,0,16,16)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true
	},
	lantern: {
		verts: [
			[objectify(5,  0, 5, 6, 6, 0, 9)], //bottom
			[objectify(6, 9, 10, 4, 4, 1, 10),objectify(5, 7, 11, 6, 6, 0, 9)], //top
			[objectify(10, 9, 10, 4, 2, 1, 0),objectify(11, 7, 11, 6, 7, 0, 2),objectify(9.5, 11, 8, 3, 2, 11, 10)], //north
			[objectify(6, 9, 6, 4, 2, 1, 0),objectify(5, 7, 5, 6, 7, 0, 2),objectify(6.5, 11, 8, 3, 2, 11, 10)], //south
			[objectify(10, 9, 6, 4, 2, 1, 0),objectify(11, 7, 5, 6, 7, 0, 2)], //east
			[objectify(6, 9, 10, 4, 2, 1, 0),objectify(5, 7, 11, 6, 7, 0, 2)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		texVerts: [],
		varients: [],
		buffer: null,
		size: 6,
	},
	lanternHang: {
		verts: [
			[objectify(5,  0, 5, 6, 6, 0, 9)], //bottom
			[objectify(6, 9, 10, 4, 4, 1, 10),objectify(5, 7, 11, 6, 6, 0, 9)], //top
			[objectify(10, 9, 10, 4, 2, 1, 0),objectify(11, 7, 11, 6, 7, 0, 2),objectify(9.5, 11, 8, 3, 2, 11, 10),objectify(9.5, 16, 8, 3, 3, 11, 2)], //north
			[objectify(6, 9, 6, 4, 2, 1, 0),objectify(5, 7, 5, 6, 7, 0, 2),objectify(6.5, 11, 8, 3, 2, 11, 10),objectify(6.5, 16, 8, 3, 3, 11, 2)], //south
			[objectify(10, 9, 6, 4, 2, 1, 0),objectify(11, 7, 5, 6, 7, 0, 2),objectify(8, 14, 6.5, 3, 4, 11, 1)], //east
			[objectify(6, 9, 10, 4, 2, 1, 0),objectify(5, 7, 11, 6, 7, 0, 2),objectify(8, 14, 9.5, 3, 4, 11, 1)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		texVerts: [],
		varients: [],
		buffer: null,
		size: 6,
	},
	beacon: {
		verts: [
			[objectify( 0, 0,  0, 16, 16, 0, 0,null,null,null,null,null,"glass"),objectify( 2, 0.001, 2, 12, 12, 0, 0,null,null,null,null,null,"obsidian")], //bottom
			[objectify( 3, 13, 13, 10, 10, 3, 3),objectify( 0,  16,  16, 16, 16, 0, 0,null,null,null,null,null,"glass"),objectify( 2, 3, 14, 12, 12, 0, 3,null,null,null,null,null,"obsidian")], //top
			[objectify(13, 13, 13, 10, 10, 3, 3),objectify( 16, 16,  16, 16, 16, 0, 0,null,null,null,null,null,"glass"),objectify(14, 3, 14, 12, 3,  0, 3,null,null,null,null,null,"obsidian")], //north
			[objectify( 3, 13,  3, 10, 10, 3, 3),objectify( 0,  16,  0,  16, 16, 0, 0,null,null,null,null,null,"glass"),objectify(2,  3, 2,  12, 3,  0, 3,null,null,null,null,null,"obsidian")], //south
			[objectify(13, 13,  3, 10, 10, 3, 3),objectify( 16, 16,  0,  16, 16, 0, 0,null,null,null,null,null,"glass"),objectify(14, 3, 2,  12, 3,  0, 3,null,null,null,null,null,"obsidian")], //east
			[objectify( 3, 13, 13, 10, 10, 3, 3),objectify( 0,  16,  16, 16, 16, 0, 0,null,null,null,null,null,"glass"),objectify(2,  3, 14, 12, 3,  0, 3,null,null,null,null,null,"obsidian")]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		size: 6,
	},
	cactus: {
		verts: [
			[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
			[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
			[objectify(16, 16, 15, 16, 16, 0, 0)], //north
			[objectify( 0, 16,  1, 16, 16, 0, 0)], //south
			[objectify(15, 16,  0, 16, 16, 0, 0)], //east
			[objectify( 1, 16, 16, 16, 16, 0, 0)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox: "cube"
	},
	pane: {
		verts: [
			[objectify( 0,  0,  7, 16, 2, 0, 7)], //bottom
			[objectify( 0, 16, 9, 16, 2, 0, 7)], //top
			[objectify(16, 16, 9, 16, 16, 0, 0)], //north
			[objectify( 0, 16,  7, 16, 16, 0, 0)], //south
			[objectify(16, 16, 7, 2, 16, 7, 0)], //east
			[objectify(0, 16, 9, 2, 16, 7, 0)]  //west
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 0,
			south: 0,
			east: 3,
			west: 3
		},
		rotate: true
	},
	horizontalPane: {
		verts:[
			[objectify(0,7,0,16,16,0,0)],
			[objectify(0,9,16,16,16,0,0)],
			[objectify(16,9,16,16,2,0,7)],
			[objectify(0,9,0,16,2,0,7)],
			[objectify(16,9,0,16,2,0,7)],
			[objectify(0,9,16,16,2,0,7)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 3,
			south: 3,
			east: 3,
			west: 3
		},
	},
	portal: {
		verts: [
			[objectify(0, 0, 7, 16, 2, 0, 0)],
			[objectify(0, 16, 9, 16, 2, 0, 0)],
			[objectify(16, 16, 9, 16, 16, 0, 0)],
			[objectify(0, 16, 7, 16, 16, 0, 0)],
			[objectify(16, 16, 7, 2, 16, 0, 0)],
			[objectify(0, 16, 9, 2, 16, 0, 0)]
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 0,
			south: 0,
			east: 3,
			west: 3
		},
		rotate: true
	},
	trapdoor: {
		verts: [
			[objectify(0, 0, 0, 16, 16, 0, 0)], //bottom
			[objectify(0, 3, 16, 16, 16, 0, 0)], //top
			[objectify(16, 3, 16, 16, 3, 0, 0)], //north
			[objectify(0, 3, 0, 16, 3, 0, 0)], //south
			[objectify(16, 3, 0, 16, 3, 0, 0)], //east
			[objectify(0, 3, 16, 16, 3, 0, 0)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true,
		flip: true
	},
	trapdoorOpen: {
		verts: [
			[objectify(0, 0, 13, 16, 3, 0, 0)], //bottom
			[objectify(0, 16, 16, 16, 3, 0, 0)], //top
			[objectify(16, 16, 16, 16, 16, 0, 0)], //north
			[objectify(0, 16, 13, 16, 16, 0, 0)], //south
			[objectify(16, 16, 13, 3, 16, 0, 0)], //east
			[objectify(0, 16, 16, 3, 16, 0, 0)]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 3,
			south: 3,
			east: 3,
			west: 3
		},
		size: 6,
		rotate: true
	},
	wallFlat: {
		verts: [
			// x, y, z, width, height, textureX, textureY
			// 0, 0, 0 is the corner on the top left of the texture
			[objectify(0, 0, 0, 0, 0, 0, 0)], //bottom
			[objectify(0, 16, 16, 0, 0, 0, 0)], //top
			[objectify(16, 16, 16, 16, 16, 0, 0)], //north
			[objectify(0, 16,  15, 16, 16, 0, 0)], //south
			[objectify(0, 0,  0, 0, 0, 0, 0)], //east
			[objectify(0, 0, 16, 0, 0, 0, 0)]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true
	},
	fence: {
		verts: [
			[objectify(6, 0, 6, 4, 4, 0, 1)], //bottom
			[objectify(6, 16, 10, 4, 4, 0, 1)], //top
			[objectify(10, 16, 10, 4, 16, 6, 0)], //north
			[objectify(6, 16, 6, 4, 16, 6, 0)], //south
			[objectify(10, 16, 6, 4, 16, 6, 0)], //east
			[objectify(6, 16, 10, 4, 16, 6, 0)]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		size: 6,
	},
	wallpost: {
		verts: [
			// x, y, z, width, height, textureX, textureY
			// 0, 0, 0 is the corner on the top left of the texture
			[objectify(4, 0, 4, 8, 8, 4, 4)], //bottom
			[objectify(4, 16, 12, 8, 8, 4, 4)], //top
			[objectify(12, 16, 12, 8, 16, 4, 0)], //north
			[objectify(4, 16, 4, 8, 16, 4, 0)], //south
			[objectify(12, 16, 4, 8, 16, 4, 0)], //east
			[objectify(4, 16, 12, 8, 16, 4, 0)]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		size: 6
	},
	wall: {
		verts: [
			// x, y, z, width, height, textureX, textureY
			// 0, 0, 0 is the corner on the top left of the texture
			[objectify(4, 0, 4, 8, 8, 4, 4),objectify(5, 0, 12, 6, 4, 5, 10)], //bottom
			[objectify(4, 16, 12, 8, 8, 4, 4),objectify(5, 16, 16, 6, 4, 5, 10)], //top
			[objectify(12, 16, 12, 8, 16, 4, 0),objectify(11, 16, 16, 6, 16, 5, 0)], //north
			[objectify(4, 16, 4, 8, 16, 4, 0)], //south
			[objectify(12, 16, 4, 8, 16, 4, 0),objectify(11, 16, 12, 4, 16, 12, 0)], //east
			[objectify(4, 16, 12, 8, 16, 4, 0),objectify(5, 16, 16, 4, 16, 12, 0)]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true
	},
	wallu: {
		verts: [
			// x, y, z, width, height, textureX, textureY
			// 0, 0, 0 is the corner on the top left of the texture
			[objectify(4, 0, 4, 8, 8, 4, 4),objectify(5, 0, 12, 6, 4, 5, 10)], //bottom
			[objectify(4, 16, 12, 8, 8, 4, 4),objectify(5, 13, 16, 6, 4, 5, 10)], //top
			[objectify(12, 16, 12, 8, 16, 4, 0),objectify(11, 13, 16, 6, 13, 5, 3)], //north
			[objectify(4, 16, 4, 8, 16, 4, 0)], //south
			[objectify(12, 16, 4, 8, 16, 4, 0),objectify(11, 13, 12, 4, 13, 12, 3)], //east
			[objectify(4, 16, 12, 8, 16, 4, 0),objectify(5, 13, 16, 4, 13, 12, 3)]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true
	},
	fencq: {
		verts: [
			[objectify(6, 0, 6, 4, 4, 0, 1),objectify(10, 12, 7, 6, 2, 0, 2),objectify(10, 6, 7, 6, 2, 0, 2)], //bottom
			[objectify(6, 16, 10, 4, 4, 0, 1),objectify(10, 15, 9, 6, 2, 0, 2),objectify(10, 9, 9, 6, 2, 0, 2)], //top
			[objectify(10, 16, 10, 4, 16, 6, 0),objectify(16, 15, 9, 6, 3, 6, 0),objectify(16, 9, 9, 6, 3, 6, 0)], //north
			[objectify(6, 16, 6, 4, 16, 6, 0),objectify(10, 15, 7, 6, 3, 6, 0),objectify(10, 9, 7, 6, 3, 6, 0)], //south
			[objectify(10, 16, 6, 4, 16, 6, 0)], //east
			[objectify(6, 16, 10, 4, 16, 6, 0)]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true
	},
	fench: {
		verts:[
			[objectify(6,0,6,4,4,0,1),objectify(10,12,7,6,2,0,2),objectify(10,6,7,6,2,0,2),objectify(0,12,7,6,2,0,0),objectify(0,6,7,6,2,0,0)],
			[objectify(6,16,10,4,4,0,1),objectify(10,15,9,6,2,0,2),objectify(10,9,9,6,2,0,2),objectify(0,15,9,6,2,0,0),objectify(0,9,9,6,2,0,0)],
			[objectify(10,16,10,4,16,6,0),objectify(16,15,9,6,3,6,0),objectify(16,9,9,6,3,6,0),objectify(6,15,9,6,3,0,0),objectify(6,9,9,6,3,0,0)],
			[objectify(6,16,6,4,16,6,0),objectify(10,15,7,6,3,6,0),objectify(10,9,7,6,3,6,0),objectify(0,15,7,6,3,0,0),objectify(0,9,7,6,3,0,0)],
			[objectify(10,16,6,4,16,6,0)],
			[objectify(6,16,10,4,16,6,0)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true
	},
	button: {
		verts: [
			[objectify(5, 6, 14, 6, 2, 5, 6)], //bottom
			[objectify(5, 10, 16, 6, 2, 5, 6)], //top
			[objectify(11, 10, 16, 6, 4, 5, 6)], //north
			[objectify(5, 10, 14, 6, 4, 5, 6)], //south
			[objectify(11, 10, 14, 2, 4, 5, 6)], //east
			[objectify(5, 10, 16, 2, 4, 5, 6)]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true
	},
	chain: {
		verts: [
			[objectify(8, 0, 8, 0.5, 0.5, 0, 0)], //bottom
			[objectify(8, 16, 8, 0.5, 0.5, 0, 0)], //top
			[objectify(9.5, 16, 8, 3, 16, 3, 0)], //north
			[objectify(6.5, 16, 8, 3, 16, 3, 0)], //south
			[objectify(8, 16, 6.5, 3, 16, 0, 0)], //east
			[objectify(8, 16, 9.5, 3, 16, 0, 0)] //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		size: 6,
	},
	pot: {
		verts: [
			[objectify(5, 0, 5, 6, 6, 5, 10)], //bottom
			[objectify(5, 6, 11, 6, 6, 5, 5), objectify(6, 4, 10, 4, 4, -16, 0)], //top
			[objectify(11, 6, 11, 6, 6, 5, 10), objectify(11, 6, 6, 6, 6, 5, 10)], //north
			[objectify(5, 6, 5, 6, 6, 5, 10), objectify(5, 6, 10, 6, 6, 5, 10)], //south
			[objectify(11, 6, 5, 6, 6, 5, 10), objectify(6, 6, 5, 6, 6, 5, 10)], //east
			[objectify(5, 6, 11, 6, 6, 5, 10), objectify(10, 6, 11, 6, 6, 5, 10)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		size: 6,
	},
	potCross: {
		verts: [
			[], //bottom
			[], //top
			[customFace(2,4,2, 14,4,14, 14,-12,14, 2,-12,2, 0,0)], //north
			[customFace(14,4,2, 2,4,14, 2,-12,14, 14,-12,2, 0,0)], //south
			[customFace(14,4,14, 2,4,2, 2,-12,2, 14,-12,14, 0,0)], //east
			[customFace(2,4,14, 14,4,2, 14,-12,2, 2,-12,14, 0,0)]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		size: 6
	},
	carpet: {
		verts: [
			[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
			[objectify( 0, 1, 16, 16, 16, 0, 0)], //top
			[objectify(16, 1, 16, 16, 1, 0, 0)], //north
			[objectify( 0, 1,  0, 16, 1, 0, 0)], //south
			[objectify(16, 1,  0, 16, 1, 0, 0)], //east
			[objectify( 0, 1, 16, 16, 1, 0, 0)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 1,
			south: 1,
			east: 1,
			west: 1
		}
	},
	wallCarpet:{
		verts:[
			[objectify(0,0,15,16,1,0,0)],
			[objectify(0,16,16,16,1,0,0)],
			[objectify(16,16,16,16,16,0,0)],
			[objectify(0,16,15,16,16,0,0)],
			[objectify(16,16,15,1,16,0,0)],
			[objectify(0,16,16,1,16,0,0)]
		],
		cull: {
			top: 1,
			bottom: 1,
			north: 3,
			south: 0,
			east: 1,
			west: 1
		},
		rotate:true
	},
	bed: {
		verts: [
			[objectify( 0, 3,  0, 16, 16, 96, 0),objectify( 0, 3,  16, 16, 16, 96, 0),
			objectify(0, 0, 0, 3,3,  38,0),
			objectify(13, 0, 29, 3,3,38,0),
			objectify(0, 0, 29, 3,3, 38,0),
			objectify(13, 0, 0, 3,3, 38,0)], //bottom
			[objectify( 0, 9, 32, 16, 16, 16, 0),objectify( 0, 9, 16, 16, 16, 0, 0)], //top
			[objectify(16, 9, 32, 16, 6, 80, 6),
			objectify(3, 3, 3, 3,3,  38,3),
			objectify(16, 3, 32, 3,3,32,3),
			objectify(3, 3, 32, 3,3, 35,3),
			objectify(16, 3, 3, 3,3, 41,3)], //north
			[objectify( 0, 9,  0, 16, 6, 80, 0),
			objectify(0, 3, 0, 3,3,  32,3),
			objectify(13, 3, 29, 3,3,38,3),
			objectify(0, 3, 29, 3,3, 41,3),
			objectify(13, 3, 0, 3,3, 35,3)], //south
			[objectify( 16, 9,  0, 16, 6, 48, 0),objectify( 16, 9,  16, 16, 6, 64, 0),
			objectify(3, 3, 0, 3,3,  41,3),
			objectify(16, 3, 29, 3,3,35,3),
			objectify(3, 3, 29, 3,3, 38,3),
			objectify(16, 3, 0, 3,3, 32,3)], //east
			[objectify( 0, 9, 32, 16, 6, 64, 6),objectify( 0, 9, 16, 16, 6, 48, 6),
			objectify(0, 3, 3, 3,3,  35,3),
			objectify(13, 3, 32, 3,3,41,3),
			objectify(0, 3, 32, 3,3, 32,3),
			objectify(13, 3, 3, 3,3, 38,3)]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 3,
			south: 3,
			east: 3,
			west: 3
		},
		rotate: true
	},
	cactusPot: {
		verts: [
			[], //bottom
			[objectify( 6, 1, 10, 4,  4, 6, 6)], //top
			[objectify(10, 1, 10, 4, 11, 6, 0)], //north
			[objectify( 6, 1,  6, 4, 11, 6, 0)], //south
			[objectify(10, 1,  6, 4, 11, 6, 0)], //east
			[objectify( 6, 1, 10, 4, 11, 6, 0)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		size: 6
	},
	crop: {
		verts: [
			[objectify(0,0,0,0,0,0,0)],
			[objectify(0,0,0,0,0,0,0)],
			[objectify(16,16,4,16,16,0,0),objectify(16,16,12,16,16,0,0)],
			[objectify(0,16,12,16,16,0,0),objectify(0,16,4,16,16,0,0)],
			[objectify(4,16,0,16,16,0,0),objectify(12,16,0,16,16,0,0)],
			[objectify(12,16,16,16,16,0,0),objectify(4,16,16,16,16,0,0)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		varients: []
	},
	anvil: {
		verts: [
			[objectify(2,0,2,12,12,0,0),objectify(0,10,3,16,10,0,0)],
			[objectify(2,4,14,12,12,0,0),objectify(3,5,12,10,8,0,0),objectify(0,16,13,16,10,16,3)],
			[objectify(14,4,14,12,4,0,0),objectify(16,16,13,16,6,0,0),objectify(13,5,12,10,1,0,0),objectify(12,10,11,8,5,0,0)],
			[objectify(2,4,2,12,4,0,0),objectify(0,16,3,16,6,0,0),objectify(3,5,4,10,1,0,0),objectify(4,10,5,8,5,0,0)],
			[objectify(14,4,2,12,4,0,0),objectify(16,16,3,10,6,0,0),objectify(13,5,4,8,1,0,0),objectify(12,10,5,6,5,0,0)],
			[objectify(2,4,14,12,4,0,0),objectify(0,16,13,10,6,0,0),objectify(3,5,12,8,1,0,0),objectify(4,10,11,6,5,0,0)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true
	},
	/*liquid: {
		verts: [
			[objectify( 0,  0,  0, 16, 16, 0, 0), objectify(16, 0, 0, -16, 16, 16, 0)], //bottom
			[objectify( 0, 16, 16, 16, 16, 0, 0), objectify(16, 16, 16, -16, 16, 16, 0)], //top
			[objectify(16, 16, 16, 16, 16, 0, 0), objectify(0, 16, 16, -16, 16, 16, 0)], //north
			[objectify( 0, 16,  0, 16, 16, 0, 0), objectify(16, 16, 0, -16, 16, 16, 0)], //south
			[objectify(16, 16,  0, 16, 16, 0, 0), objectify(16, 16, 16, -16, 16, 16, 0)], //east
			[objectify( 0, 16, 16, 16, 16, 0, 0), objectify(0, 16, 0, -16, 16, 16, 0)]  //west
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 3,
			south: 3,
			east: 3,
			west: 3
		}
	},
	liquidSurface: {
		verts: [
			[objectify( 0,    0,  0, 16,   16, 0, 0), objectify(16, 0, 0, -16, 16, 16, 0)], //bottom
			[objectify( 0, 14.5, 16, 16,   16, 0, 0), objectify(16, 14.5, 16, -16, 16, 16, 0)], //top
			[objectify(16, 14.5, 16, 16, 14.5, 0, 0), objectify(0, 14.5, 16, -16, 14.5, 16, 0)], //north
			[objectify( 0, 14.5,  0, 16, 14.5, 0, 0), objectify(16, 14.5, 0, -16, 14.5, 16, 0)], //south
			[objectify(16, 14.5,  0, 16, 14.5, 0, 0), objectify(16, 14.5, 16, -16, 14.5, 16, 0)], //east
			[objectify( 0, 14.5, 16, 16, 14.5, 0, 0), objectify(0, 14.5, 0, -16, 14.5, 16, 0)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 3,
			south: 3,
			east: 3,
			west: 3
		}
	},*/
	sporeBlossom: {
		verts: [
			[objectify( 1, 15.9, 1, 14, 14, -15, 1)], //bottom
			[objectify( 1, 15.9, 15, 14, 14, -15, 1)], //top
			[customFace(0,15.9,8, 16,15.9,8, 16,11.1,-8, 0,11.1,-8, 16,16,-16,-16), customFace(16,15.9,8, 0,15.9,8, 0,11.1,-8, 16,11.1,-8, 16,16,-16,-16)],
			[customFace(0,15.9,8, 16,15.9,8, 16,11.1,24, 0,11.1,24, 16,16,-16,-16), customFace(16,15.9,8, 0,15.9,8, 0,11.1,24, 16,11.1,24, 16,16,-16,-16)], //southobjectify( 0, 16,  0, 16, 16, 0, 0)
			[customFace(8,15.9,0, 8,15.9,16, -8,11.1,16, -8,11.1,0, 16,16,-16,-16), customFace(8,15.9,16, 8,15.9,0, -8,11.1,0, -8,11.1,16, 16,16,-16,-16)],
			[customFace(8,15.9,0, 8,15.9,16, 24,11.1,16, 24,11.1,0, 16,16,-16,-16), customFace(8,15.9,16, 8,15.9,0, 24,11.1,0, 24,11.1,16, 16,16,-16,-16)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
	},
	azalea: {
		verts: [
			[objectify( 0,  8,  0, 16, 16, 0, 0)], //bottom
			[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
			[objectify(16, 16, 16, 16, 16, 0, 0),customFace(0,16,0, 16,16,16, 16,0,16, 0,0,0, 16,0)], //north
			[objectify( 0, 16,  0, 16, 16, 0, 0),customFace(16,16,0, 0,16,16, 0,0,16, 16,0,0, 16,0)], //south
			[objectify(16, 16,  0, 16, 16, 0, 0),customFace(16,16,16, 0,16,0, 0,0,0, 16,0,16, 16,0)], //east
			[objectify( 0, 16, 16, 16, 16, 0, 0),customFace(0,16,16, 16,16,0, 16,0,0, 0,0,16, 16,0)]  //west
		],
		cull: {
			top: 3,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	azaleaPot: {
		verts: [
			[objectify( 4,  -7,  4, 8, 8, 4, 4)], //bottom
			[objectify( 4, -1, 12, 8, 8, 4, 4)], //top
			[objectify(12, -1, 12, 8, 11, 4, 5),customFace(4,-1,4, 12,-1,12, 12,-12,12, 4,-12,4, 20,5,8,11)], //north
			[objectify( 4, -1,  4, 8, 11, 4, 5),customFace(12,-1,4, 4,-1,12, 4,-12,12, 12,-12,4, 20,5,8,11)], //south
			[objectify(12, -1,  4, 8, 11, 4, 5),customFace(12,-1,12, 4,-1,4, 4,-12,4, 12,-12,12, 20,5,8,11)], //east
			[objectify( 4, -1, 12, 8, 11, 4, 5),customFace(4,-1,12, 12,-1,4, 12,-12,4, 4,-12,12, 20,5,8,11)]  //west
		],
		cull: {
			top: 3,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		size: 6
	},
	sunflower: {
		verts: [
			[customFace(0,34,7, 16,34,7, 16,18,11, 0,18,11, 0,0)], //bottom
			[customFace(16,34,7, 0,34,7, 0,18,11, 16,18,11, 0,0)], //top
			[customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 16,0),customFace(2,32,2, 14,32,14, 14,16,14, 2,16,2, 0,0)], //north
			[customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 16,0),customFace(14,32,2, 2,32,14, 2,16,14, 14,16,2, 0,0)], //south
			[customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 16,0),customFace(14,32,14, 2,32,2, 2,16,2, 14,16,14, 0,0)], //east
			[customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 16,0),customFace(2,32,14, 14,32,2, 14,16,2, 2,16,14, 0,0)]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"tallCube"
	},
	cake:{
		verts: [
			[objectify(1,0,1,14,14,1,1)],
			[objectify(1,8,15,14,14,1,1)],
			[objectify(15,8,15,14,8,1,8)],
			[objectify(1,8,1,14,8,1,8)],
			[objectify(15,8,1,14,8,1,8)],
			[objectify(1,8,15,14,8,1,8)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	stonecutter:{
		verts:[
			[objectify(0,0,0,16,16,0,0)],
			[objectify(0,9,16,16,16,0,0)],
			[objectify(16,9,16,16,9,0,7),objectify(16,16,8,16,7,16,9)],
			[objectify(0,9,0,16,9,0,7),objectify(0,16,8,16,7,16,9)],
			[objectify(16,9,0,16,9,0,7)],
			[objectify(0,9,16,16,9,0,7)]
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	itemFrame:{
		verts: [
			[objectify(2,2,15,12,1,-16,0),objectify(3,13,15,10,1,-16,0)],
			[objectify(2,14,16,12,1,-16,0),objectify(3,3,16,10,1,-16,0)],
			[objectify(14,14,16,12,12,-16,0)],
			[objectify(3,13,15.5,10,10,3,3),objectify(2,14,15,11,1,-14,2),objectify(13,14,15,1,11,-3,2),objectify(3,3,15,11,1,-13,13),objectify(2,13,15,1,11,-14,3)],
			[objectify(14,14,15,1,12,-16,0),objectify(3,13,15,1,10,-16,0)],
			[objectify(2,14,16,1,12,-16,0),objectify(13,13,16,1,10,-16,0)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 3,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true
	},
	endPortalFrame:{
		verts: [
			[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
			[objectify( 0, 13, 16, 16, 16, 0, 0)], //top
			[objectify(16, 13, 16, 16, 13, 0, 3)], //north
			[objectify( 0, 13,  0, 16, 13, 0, 3)], //south
			[objectify(16, 13,  0, 16, 13, 0, 3)], //east
			[objectify( 0, 13, 16, 16, 13, 0, 3)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true
	},
	endPortalFrameWithEyeOfEnder: {
		verts: [
			[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
			[objectify( 0, 13, 16, 16, 16, 0, 0), objectify( 4, 16, 12, 8, 8, 36, 4)], //top
			[objectify(16, 13, 16, 16, 13, 0, 3), objectify( 12, 16, 12, 8, 3, 20, 0)], //north
			[objectify( 0, 13,  0, 16, 13, 0, 3), objectify( 4, 16, 4, 8, 3, 20, 0)], //south
			[objectify(16, 13,  0, 16, 13, 0, 3), objectify( 12, 16, 4, 8, 3, 20, 0)], //east
			[objectify( 0, 13, 16, 16, 13, 0, 3), objectify( 4, 16, 12, 8, 3, 20, 0)]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true
	},
	
	fire: {
		verts: [
			[], //bottom
			[], //top
			[customFace(16,22.4,15.5, 0,22.4,15.5, 0,0,16, 16,0,16, 0,0), customFace(0,22.4,15.5, 16,22.4,15.5, 16,0,16, 0,0,16, 0,0), customFace(0,20,12, 16,20,12, 16,0,0, 0,0,0, 0,0), customFace(16,20,12, 0,20,12, 0,0,0, 16,0,0, 0,0)], //north
			[customFace(16,22.4,0.5, 0,22.4,0.5, 0,0,0, 16,0,0, 0,0), customFace(0,22.4,0.5, 16,22.4,0.5, 16,0,0, 0,0,0, 0,0), customFace(16,20,4, 0,20,4, 0,0,16, 16,0,16, 0,0), customFace(0,20,4, 16,20,4, 16,0,16, 0,0,16, 0,0)], //south
			[customFace(15.5,22.4,16, 15.5,22.4,0, 16,0,0, 16,0,16, 0,0), customFace(15.5,22.4,0, 15.5,22.4,16, 16,0,16, 16,0,0, 0,0), customFace(12,20,0, 12,20,16, 0,0,16, 0,0,0, 0,0), customFace(12,20,16, 12,20,0, 0,0,0, 0,0,16, 0,0)], //east
			[customFace(0.5,22.4,16, 0.5,22.4,0, 0,0,0, 0,0,16, 0,0), customFace(0.5,22.4,0, 0.5,22.4,16, 0,0,16, 0,0,0, 0,0), customFace(4,20,0, 4,20,16, 16,0,16, 16,0,0, 0,0), customFace(4,20,16, 4,20,0, 16,0,0, 16,0,16, 0,0)]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"cube"
	},
	sideFire:{
		verts:[
			[],
			[],
			[customFace(16,22.4,14, 0,22.4,14, 0,0,16, 16,0,16, 0,0)],
			[customFace(0,22.4,14, 16,22.4,14, 16,0,16, 0,0,16, 0,0)],
			[],
			[]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true,
		hitbox:"cube"
	},
	bottomFire:{
		verts:[
			[customFace(0,12,0, 16,12,0, 16,16,16, 0,16,16, 0,0),customFace(16,12,16, 0,12,16, 0,16,0, 16,16,0, 0,0), customFace(16,12,0, 16,12,16, 0,16,16, 0,16,0, 0,0),customFace(0,12,16, 0,12,0, 16,16,0, 16,16,16, 0,0)],
			[customFace(16,12,0, 0,12,0, 0,16,16, 16,16,16, 0,0),customFace(0,12,16, 16,12,16, 16,16,0, 0,16,0, 0,0), customFace(0,12,0, 0,12,16, 16,16,16, 16,16,0, 0,0),customFace(16,12,16, 16,12,0, 0,16,0, 0,16,16, 0,0)],
			[],
			[],
			[],
			[]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"cube"
	},
	
	endRod: {
		verts: [
			[objectify( 6, 0,  6, 4, 4, 2, 4)], //bottom
			[objectify( 7, 16, 9, 2, 2, 2, 0),objectify(6, 1,  10, 4, 4, 2, 4)], //top
			[objectify(9, 16, 9, 2, 15, 0, 0),objectify(10, 1, 10, 4, 1, 2, 2)], //north
			[objectify(7, 16, 7, 2, 15, 0, 0),objectify(6, 1,  6, 4, 1, 2, 2)], //south
			[objectify(9, 16, 7, 2, 15, 0, 0),objectify(10, 1, 6, 4, 1, 2, 2)], //east
			[objectify(7, 16, 9, 2, 15, 0, 0),objectify(6, 1, 10, 4, 1, 2, 2)]  //west
		],
		cull: {
			top: 0,
			bottom: 1,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		flip: true,
	},
	endRodSW: {
		verts: [
			[objectify(7, 7, 0, 2, 15, 0, 0),objectify(6, 6,  15, 4, 1, 2, 4)], //bottom
			[objectify(7, 9, 15, 2, 15, 0, 0),objectify(6, 10, 16, 4, 1, 2, 4)], //top
			[objectify(10, 10, 16, 4, 4, 2, 4)], //north
			[objectify( 7, 9, 0, 2, 2, 2, 0),objectify(6, 10,  15, 4, 4, 2, 2)], //south
			[objectify(9, 9, 0, 15, 2, 16, 14),objectify(10, 10, 15, 1, 4, 2, 2)], //east
			[objectify(7, 9, 15, 15, 2, 16, 14),objectify(6, 10, 16, 1, 4, 2, 2)]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 1,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true,
	},
	
	door2: {
		verts: [
			[objectify(0,0,13,16,3,16,0, false,false,false,null,2)],
			[objectify(0,32,16,16,3,16,0, false,false,false,null,2)],
			[objectify(16,32,16,16,16,0,0),objectify(16,16,16,16,16,16,0)],
			[objectify(0,32,13,16,16,0,0, true),objectify(0,16,13,16,16,16,0, true)],
			[objectify(16,32,13,3,16,13,0, false,false,false,2),objectify(16,16,13,3,16,29,0, false,false,false,2)],
			[objectify(0,32,16,3,16,0,0, false,false,false,2),objectify(0,16,16,3,16,16,0, false,false,false,2)]
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true
	},
	
	fenceGate: {
		verts: [
			[objectify(0,5,7,2,2,0,1),objectify(2,12,7,12,2,0,2),objectify(2,6,7,12,2,0,2),objectify(14,5,7,2,2,0,0)],
			[objectify(0,16,9,2,2,0,1),objectify(2,15,9,12,2,0,2),objectify(2,9,9,12,2,0,2),objectify(14,16,9,2,2,0,0)],
			[objectify(2,16,9,2,11,0,0),objectify(14,15,9,12,3,2,1),objectify(14,9,9,12,3,2,7),objectify(16,16,9,2,11,14,0),objectify(10,12,9,4,3,6,4)],
			[objectify(0,16,7,2,11,14,0),objectify(2,15,7,12,3,2,1),objectify(2,9,7,12,3,2,7),objectify(14,16,7,2,11,2,0),objectify(6,12,7,4,3,6,4)],
			[objectify(2,16,7,2,11,6,0),objectify(10,12,7,2,3,0,0),objectify(16,16,7,2,11,0,0)],
			[objectify(0,16,9,2,11,6,0),objectify(14,16,9,2,11,0,0),objectify(6,12,9,2,3,0,0)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		flip: false,
		rotate: true
	},
	fenceGateWall: {
		verts: [
			[objectify(0,2,7,2,2,0,1),objectify(2,9,7,12,2,0,2),objectify(2,3,7,12,2,0,2),objectify(14,2,7,2,2,0,0)],
			[objectify(0,13,9,2,2,0,1),objectify(2,12,9,12,2,0,2),objectify(2,6,9,12,2,0,2),objectify(14,13,9,2,2,0,0)],
			[objectify(2,13,9,2,11,0,0),objectify(14,12,9,12,3,2,1),objectify(14,6,9,12,3,2,7),objectify(16,13,9,2,11,14,0),objectify(10,9,9,4,3,6,4)],
			[objectify(0,13,7,2,11,14,0),objectify(2,12,7,12,3,2,1),objectify(2,6,7,12,3,2,7),objectify(14,13,7,2,11,2,0),objectify(6,9,7,4,3,6,4)],
			[objectify(2,13,7,2,11,6,0),objectify(10,9,7,2,3,0,0),objectify(16,13,7,2,11,0,0)],
			[objectify(0,13,9,2,11,6,0),objectify(14,13,9,2,11,0,0),objectify(6,9,9,2,3,0,0)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		flip: false,
		rotate: true
	},
	fenceGateOpen: {
		verts: [
			[objectify(0,5,7,2,2,0,1),objectify(14,12,9,2,6,0,2),objectify(14,6,9,2,6,0,2),objectify(14,5,7,2,2,0,0),objectify(0,12,9,2,6,0,0),objectify(0,6,9,2,6,0,0)],
			[objectify(0,16,9,2,2,0,1),objectify(14,15,15,2,6,0,2),objectify(14,9,15,2,6,0,2),objectify(14,16,9,2,2,0,0),objectify(0,15,15,2,6,0,0),objectify(0,9,15,2,6,0,0)],
			[objectify(2,16,9,2,11,0,0),objectify(16,15,15,2,9,2,1),objectify(2,15,15,2,9,2,7),objectify(16,16,9,2,11,14,0)],
			[objectify(0,16,7,2,11,14,0),objectify(14,12,13,2,3,2,1),objectify(0,12,13,2,3,2,7),objectify(14,16,7,2,11,2,0)],
			[objectify(2,16,7,2,11,6,0),objectify(2,12,13,2,3,6,4),objectify(16,16,7,2,11,6,4),objectify(16,12,13,2,3,0,0),objectify(16,15,9,6,3,2,1),objectify(2,15,9,6,3,2,1),objectify(16,9,9,6,3,2,7),objectify(2,9,9,6,3,2,7)],
			[objectify(0,16,9,2,11,6,0),objectify(14,16,9,2,11,0,0),objectify(14,12,15,2,3,6,4),objectify(0,12,15,2,3,6,4),objectify(0,15,15,6,3,0,1),objectify(0,9,15,6,3,2,7),objectify(14,15,15,6,3,2,1),objectify(14,9,15,6,3,2,7)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		flip: false,
		rotate: true
	},
	fenceGateWallOpen: {
		verts: [
			[objectify(0,2,7,2,2,0,1),objectify(14,9,9,2,6,0,2),objectify(14,3,9,2,6,0,2),objectify(14,2,7,2,2,0,0),objectify(0,9,9,2,6,0,0),objectify(0,3,9,2,6,0,0)],
			[objectify(0,13,9,2,2,0,1),objectify(14,12,15,2,6,0,2),objectify(14,6,15,2,6,0,2),objectify(14,13,9,2,2,0,0),objectify(0,12,15,2,6,0,0),objectify(0,6,15,2,6,0,0)],
			[objectify(2,13,9,2,11,0,0),objectify(16,12,15,2,9,2,1),objectify(2,12,15,2,9,2,7),objectify(16,13,9,2,11,14,0)],
			[objectify(0,13,7,2,11,14,0),objectify(14,9,13,2,3,2,1),objectify(0,9,13,2,3,2,7),objectify(14,13,7,2,11,2,0)],
			[objectify(2,13,7,2,11,6,0),objectify(2,9,13,2,3,6,4),objectify(16,13,7,2,11,6,4),objectify(16,9,13,2,3,0,0),objectify(16,12,9,6,3,2,1),objectify(2,12,9,6,3,2,1),objectify(16,6,9,6,3,2,7),objectify(2,6,9,6,3,2,7)],
			[objectify(0,13,9,2,11,6,0),objectify(14,13,9,2,11,0,0),objectify(14,9,15,2,3,6,4),objectify(0,9,15,2,3,6,4),objectify(0,12,15,6,3,0,1),objectify(0,6,15,6,3,2,7),objectify(14,12,15,6,3,2,1),objectify(14,6,15,6,3,2,7)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		flip: false,
		rotate: true
	},
	
	tallCrop: {
		verts: [
			[],
			[],
			[objectify(16,32,4,16,16,0,0),objectify(16,32,12,16,16,0,0),objectify(16,16,4,16,16,16,0),objectify(16,16,12,16,16,16,0)],
			[objectify(0,32,12,16,16,0,0),objectify(0,32,4,16,16,0,0),objectify(0,16,12,16,16,16,0),objectify(0,16,4,16,16,16,0)],
			[objectify(4,32,0,16,16,0,0),objectify(12,32,0,16,16,0,0),objectify(4,16,0,16,16,16,0),objectify(12,16,0,16,16,16,0)],
			[objectify(12,32,16,16,16,0,0),objectify(4,32,16,16,16,0,0),objectify(12,16,16,16,16,16,0),objectify(4,16,16,16,16,16,0)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		varients: []
	},
	
	chainSW: {
		verts: [
			[objectify(6.5,8,0,3,16,0,0)],
			[objectify(6.5,8,16,3,16,0,0)],
			[],
			[],
			[objectify(8,9.5,0,16,3,0,3)],
			[objectify(8,9.5,16,16,3,0,3)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true
	},
	
	campfire:{
		verts: [
			[objectify(1,0,0,4,16,16,0,false,false,1),objectify(11,0,0,4,16,16,0,false,false,1),objectify(0,3,1,16,4,0,4),objectify(0,3,11,16,4,0,4),objectify(5,0,0,6,16,16,10,false,false,1)],
			[objectify(1,4,16,4,16,16,0,false,false,1),objectify(11,4,16,4,16,16,0,false,false,1),objectify(0,7,5,16,4,16,0),objectify(0,7,15,16,4,16,0),objectify(5,1,16,6,16,0,10,false,false,1)],
			[objectify(5,4,16,4,4,16,4),objectify(15,4,16,4,4,16,4),objectify(16,7,5,16,4,0,0),objectify(16,7,15,16,4,0,0),objectify(11,1,16,6,1,0,15), customFace(0,16,0, 16,16,16, 16,0,16, 0,0,0, 32,0)],
			[objectify(1,4,0,4,4,16,4),objectify(11,4,0,4,4,16,4),objectify(0,7,1,16,4,0,0),objectify(0,7,11,16,4,0,0),objectify(5,1,0,6,1,0,15), customFace(16,16,0, 0,16,16, 0,0,16, 16,0,0, 32,0)],
			[objectify(15,4,0,16,4,16,0),objectify(5,4,0,16,4,0,0),objectify(16,7,1,4,4,16,4),objectify(16,7,11,4,4,16,4), customFace(16,16,16, 0,16,0, 0,0,0, 16,0,16, 32,0)],
			[objectify(11,4,16,16,4,0,0),objectify(1,4,16,16,4,16,0),objectify(0,7,5,4,4,16,4),objectify(0,7,15,4,4,16,4), customFace(0,16,16, 16,16,0, 16,0,0, 0,0,16, 32,0)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"slab"
	},
	campfireUnlit:{
		verts:[
			[objectify(1,0,0,4,16,16,0,false,false,1),objectify(11,0,0,4,16,16,0,false,false,1),objectify(0,3,1,16,4,16,0),objectify(0,3,11,16,4,16,0),objectify(5,0,0,6,16,16,10,false,false,1)],
			[objectify(1,4,16,4,16,16,0,false,false,1),objectify(11,4,16,4,16,16,0,false,false,1),objectify(0,7,5,16,4,16,0),objectify(0,7,15,16,4,16,0),objectify(5,1,16,6,16,16,10,false,false,1)],
			[objectify(5,4,16,4,4,16,4),objectify(15,4,16,4,4,16,4),objectify(16,7,5,16,4,16,0),objectify(16,7,15,16,4,16,0),objectify(11,1,16,6,1,0,15)],
			[objectify(1,4,0,4,4,16,4),objectify(11,4,0,4,4,16,4),objectify(0,7,1,16,4,16,0),objectify(0,7,11,16,4,16,0),objectify(5,1,0,6,1,0,15)],
			[objectify(15,4,0,16,4,16,0),objectify(5,4,0,16,4,16,0),objectify(16,7,1,4,4,16,4),objectify(16,7,11,4,4,16,4)],
			[objectify(11,4,16,16,4,16,0),objectify(1,4,16,16,4,16,0),objectify(0,7,5,4,4,16,4),objectify(0,7,15,4,4,16,4)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"slab"
	},
	
	bamboo:{
		verts:[
			[objectify(6.5,0,6.5,3,3,13,4)],
			[objectify(6.5,16,9.5,3,3,13,0)],
			[objectify(9.5,16,9.5,3,16,0,0)],
			[objectify(6.5,16,6.5,3,16,0,0)],
			[objectify(9.5,16,6.5,3,16,0,0)],
			[objectify(6.5,16,9.5,3,16,0,0)]
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"cube"
	},
	bambooSmallLeaf:{
		verts: [
			[objectify(6.5,0,6.5,3,3,13,4)],
			[objectify(6.5,16,9.5,3,3,13,0)],
			[objectify(9.5,16,9.5,3,16,0,0),objectify(16,16,8,16,16,48,0)],
			[objectify(6.5,16,6.5,3,16,0,0),objectify(0,16,8,16,16,48,0)],
			[objectify(9.5,16,6.5,3,16,0,0),objectify(8,16,0,16,16,48,0)],
			[objectify(6.5,16,9.5,3,16,0,0),objectify(8,16,16,16,16,48,0)]
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"cube"
	},
	bambooBigLeaf:{
		verts:[
			[objectify(6.5,0,6.5,3,3,13,4)],
			[objectify(6.5,16,9.5,3,3,13,0)],
			[objectify(9.5,16,9.5,3,16,0,0),objectify(16,16,8,16,16,32,0)],
			[objectify(6.5,16,6.5,3,16,0,0),objectify(0,16,8,16,16,32,0)],
			[objectify(9.5,16,6.5,3,16,0,0),objectify(8,16,0,16,16,32,0)],
			[objectify(6.5,16,9.5,3,16,0,0),objectify(8,16,16,16,16,32,0)]
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"cube"
	},
	bambooYoung:{
		verts:[
			[objectify(7,0,7,2,2,13,4)],
			[objectify(7,16,9,2,2,13,0)],
			[objectify(9,16,9,2,16,0,0)],
			[objectify(7,16,7,2,16,0,0)],
			[objectify(9,16,7,2,16,0,0)],
			[objectify(7,16,9,2,16,0,0)]
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"cube"
	},
	bambooYoungLeaf:{
		verts:[
			[objectify(7,0,7,2,2,13,4)],
			[objectify(7,16,9,2,2,13,0)],
			[objectify(9,16,9,2,16,0,0),objectify(16,16,8,16,16,48,0)],
			[objectify(7,16,7,2,16,0,0),objectify(0,16,8,16,16,48,0)],
			[objectify(9,16,7,2,16,0,0),objectify(8,16,0,16,16,48,0)],
			[objectify(7,16,9,2,16,0,0),objectify(8,16,16,16,16,48,0)]
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"cube"
	},
	bambooPot:{
		verts:[
			[],
			[objectify(7,0,9,2,2,13,0)],
			[objectify(9,0,9,2,16,0,0),objectify(16,0,8,16,16,16,0)],
			[objectify(7,0,7,2,16,0,0),objectify(0,0,8,16,16,16,0, true)],
			[objectify(9,0,7,2,16,0,0)],
			[objectify(7,0,9,2,16,0,0)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
	},
	chest:{
		verts:[
			[objectify(1,0,1,14,14,48,0),objectify(7,7,0,2,1,67,0)],
			[objectify(1,14,15,14,14,32,0),objectify(7,11,1,2,1,65,0)],
			[objectify(15,14,15,14,4,16,0),objectify(15,10,15,14,10,16,5),objectify(9,11,1,2,4,64,1)],
			[objectify(1,14,1,14,4,0,0),objectify(1,10,1,14,10,0,5),objectify(7,11,0,2,4,67,1)],
			[objectify(15,14,1,14,4,16,0),objectify(15,10,1,14,10,16,5),objectify(9,11,0,1,4,69,1)],
			[objectify(1,14,15,14,4,16,0),objectify(1,10,15,14,10,16,5),objectify(7,11,1,1,4,66,1)]
		],
		/*[
			[objectify(1,0,1,14,14,32,0),objectify(7,7,0,2,1,51,0)],
			[objectify(1,14,15,14,14,32,0),objectify(7,11,1,2,1,63,0)],
			[objectify(15,14,15,14,4,16,0),objectify(15,10,15,14,10,16,5),objectify(9,11,1,2,4,48,1)],
			[objectify(1,14,1,14,4,0,0),objectify(1,10,1,14,10,0,5),objectify(7,11,0,2,4,46,1)],
			[objectify(15,14,1,14,4,16,0),objectify(15,10,1,14,10,16,5),objectify(9,11,0,1,4,48,1)],
			[objectify(1,14,15,14,4,16,0),objectify(1,10,15,14,10,16,5),objectify(7,11,1,1,4,46,1)]
		]*/
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true
	},
	pressurePlate:{
		verts:[
			[objectify(1,0,1,14,14,1,1)],
			[objectify(1,1,15,14,14,1,1)],
			[objectify(15,1,15,14,1,0,0)],
			[objectify(1,1,1,14,1,0,0)],
			[objectify(15,1,1,14,1,0,0)],
			[objectify(1,1,15,14,1,0,0)]
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
	},
	pressurePlateActive:{
		verts:[
			[objectify(1,0,1,14,14,1,1)],
			[objectify(1,0.5,15,14,14,1,1)],
			[objectify(15,0.5,15,14,0.5,0,0)],
			[objectify(1,0.5,1,14,0.5,0,0)],
			[objectify(15,0.5,1,14,0.5,0,0)],
			[objectify(1,0.5,15,14,0.5,0,0)]
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	redstoneDust:{
		verts:[
			[objectify(0,0.25,0,16,16,0,0,false,true)],
			[objectify(0,0.25,16,16,16,0,0)],
			[objectify(16, 16,  0.25, 16, 16, 0, 0, false,false,false,null,null, "north"), objectify(16, 16,  15.75, 16, 16, 0, 0, false,false,false,null,null, "south")],
			[objectify( 0, 16, 15.75, 16, 16, 0, 0, false,false,false,null,null, "south"), objectify( 0, 16, 0.25, 16, 16, 0, 0, false,false,false,null,null, "north")],
			[objectify( 0.25, 16,  0, 16, 16, 0, 0, false,false,false,null,null, "east"), objectify( 15.75, 16,  0, 16, 16, 0, 0, false,false,false,null,null, "west")],
			[objectify(15.75, 16, 16, 16, 16, 0, 0, false,false,false,null,null, "west"), objectify(0.25, 16, 16, 16, 16, 0, 0, false,false,false,null,null, "east")]
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"carpet"
	},
	redstoneDustRotate:{
		verts:[
			[objectify(0,0.25,0,16,16,0,0,false,true)],
			[objectify(0,0.25,16,16,16,0,0)],
			[objectify(16, 16,  0.25, 16, 16, 0, 0, false,false,false,null,null, "north"), objectify(16, 16,  15.75, 16, 16, 0, 0, false,false,false,null,null, "south")],
			[objectify( 0, 16, 15.75, 16, 16, 0, 0, false,false,false,null,null, "south"), objectify( 0, 16, 0.25, 16, 16, 0, 0, false,false,false,null,null, "north")],
			[objectify( 0.25, 16,  0, 16, 16, 0, 0, false,false,false,null,null, "east"), objectify( 15.75, 16,  0, 16, 16, 0, 0, false,false,false,null,null, "west")],
			[objectify(15.75, 16, 16, 16, 16, 0, 0, false,false,false,null,null, "west"), objectify(0.25, 16, 16, 16, 16, 0, 0, false,false,false,null,null, "east")]
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true,
		hitbox:"carpet"
	},
	redstoneTorch:{
		verts:[
			[objectify(7,0,7,2,2,7,14),objectify(6,10,6,4,4,6,5)],
			[objectify(7,10,9,2,2,7,6),objectify(6,8,10,4,4,6,5)],
			[objectify(9,10,9,2,10,7,6),objectify(10,11,7,4,4,6,5)],
			[objectify(7,10,7,2,10,7,6),objectify(6,11,9,4,4,6,5)],
			[objectify(9,10,7,2,10,7,6),objectify(7,11,6,4,4,6,5)],
			[objectify(7,10,9,2,10,7,6),objectify(9,11,10,4,4,6,5)]
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	redstoneWallTorch:{
		verts: [
			[customFace(9,4,17, 7,4,17, 7,3,15, 9,3,15, 7,14,2,2),customFace(6,12.5,10, 10,12.5,10, 10,14.5,14, 6,14.5,14, 6,5,4,4)],
			[customFace(9,13,11, 7,13,11, 7,14,13, 9,14,13, 7,6,2,2),customFace(10,10.5,10.8, 6,10.5,10.8, 6,12.5,14.8, 10,12.5,14.8, 6,5,4,4)],
			[customFace(9,14,13, 7,14,13, 7,4,17, 9,4,17, 7,6,2,10),customFace(10,14,10.6, 6,14,10.6, 6,10,12.2, 10,10,12.2, 6,5,4,4)], //north
			[customFace(7,13,11, 9,13,11, 9,3,15, 7,3,15, 7,6,2,10),customFace(6,15,12.6, 10,15,12.6, 10,11,14.2, 6,11,14.2, 6,5,4,4)], //south
			[customFace(9,13,11, 9,14,13, 9,4,17, 9,3,15, 7,6,2,10),customFace(7,13.5,9.6, 7,15.5,13.6, 7,11.5,15.2, 7,9.5,11.2, 6,5,4,4)], //east
			[customFace(7,14,13, 7,13,11, 7,3,15, 7,4,17, 7,6,2,10),customFace(9,15.5,13.6, 9,13.5,9.6, 9,9.5,11.2, 9,11.5,15.2, 6,5,4,4)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true
	},
	leverWall:{
		verts:[
			[objectify(5,4,13,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,12,7, 9,12,7, 9,8.45,15, 7,8.45,15, 7,6,2,10)],
			[objectify(5,12,16,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,13.5,8, 7,13.5,8, 7,10,16, 9,10,16, 7,6,2,10)],
			[objectify(11,12,16,6,8,0,0,null,null,null,null,null,"cobblestone")],
			[objectify(5,12,13,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,13.5,8, 9,13.5,8, 9,12,7, 7,12,7, 7,6,2,2)],
			[objectify(11,12,13,3,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,12,7, 9,13.5,8, 9,10,16, 9,8.45,15, 7,6,2,10)],
			[objectify(5,12,16,3,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,13.5,8, 7,12,7, 7,8.45,15, 7,10,16, 7,6,2,10)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 3,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true
	},
	leverWallOn:{
		verts:[
			[objectify(5,4,13,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,2.5,8, 9,2.5,8, 9,6,16, 7,6,16, 7,6,2,10)],
			[objectify(5,12,16,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,4,7, 7,4,7, 7,7.55,15, 9,7.55,15, 7,6,2,10)],
			[objectify(11,12,16,6,8,0,0,null,null,null,null,null,"cobblestone")],
			[objectify(5,12,13,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,2.5,8, 7,2.5,8, 7,4,7, 9,4,7, 7,6,2,2)],
			[objectify(11,12,13,3,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,2.5,8, 9,4,7, 9,7.55,15, 9,6,16, 7,6,2,10)],
			[objectify(5,12,16,3,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,4,7, 7,2.5,8, 7,6,16, 7,7.55,15, 7,6,2,10)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 3,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true
	},
	leverFloor:{
		verts:[
			[objectify(5,0,4,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,8,13.5, 7,8,13.5, 7,0,10, 9,0,10, 7,6,2,10)],
			[objectify(5,3,12,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,9,12, 9,9,12, 9,1,8.45, 7,1,8.45, 7,6,2,10)],
			[objectify(11,3,12,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,8,13.5, 9,8,13.5, 9,9,12, 7,9,12, 7,6,2,2)],
			[objectify(5,3,4,6,3,0,0,null,null,null,null,null,"cobblestone")],
			[objectify(11,3,4,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,9,12, 9,8,13.5, 9,0,10, 9,1,8.45, 7,6,2,10)],
			[objectify(5,3,12,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,8,13.5, 7,9,12, 7,1,8.45, 7,0,10, 7,6,2,10)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
	},
	leverFloorOn:{
		verts:[
			[objectify(5,0,4,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,8,2.5, 9,8,2.5, 9,0,6, 7,0,6, 7,6,2,10)],
			[objectify(5,3,12,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,9,4, 7,9,4, 7,1,7.55, 9,1,7.55, 7,6,2,10)],
			[objectify(11,3,12,6,3,0,0,null,null,null,null,null,"cobblestone")],
			[objectify(5,3,4,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,8,2.5, 7,8,2.5, 7,9,4, 9,9,4, 7,6,2,2)],
			[objectify(11,3,4,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,8,2.5, 9,9,4, 9,1,7.55, 9,0,6, 7,6,2,10)],
			[objectify(5,3,12,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,9,4, 7,8,2.5, 7,0,6, 7,1,7.55, 7,6,2,10)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
	},
	leverCeil:{
		verts:[
			[objectify(5,13,4,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,7,12, 7,7,12, 7,15,8.45, 9,15,8.45, 7,6,2,10)],
			[objectify(5,16,12,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,8,13.5, 9,8,13.5, 9,16,10, 7,16,10, 7,6,2,10)],
			[objectify(11,16,12,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,8,13.5, 7,8,13.5, 7,7,12, 9,7,12, 7,6,2,2)],
			[objectify(5,16,4,6,3,0,0,null,null,null,null,null,"cobblestone")],
			[objectify(11,16,4,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,8,13.5, 9,7,12, 9,15,8.45, 9,16,10, 7,6,2,10)],
			[objectify(5,16,12,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,7,12, 7,8,13.5, 7,16,10, 7,15,8.45, 7,6,2,10)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
	},
	leverCeilOn:{
		verts:[
			[objectify(5,13,4,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,7,4, 9,7,4, 9,15,7.55, 7,15,7.55, 7,6,2,10)],
			[objectify(5,16,12,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,8,2.5, 7,8,2.5, 7,16,6, 9,16,6, 7,6,2,10)],
			[objectify(11,16,12,6,3,0,0,null,null,null,null,null,"cobblestone")],
			[objectify(5,16,4,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,8,2.5, 9,8,2.5, 9,7,4, 7,7,4, 7,6,2,2)],
			[objectify(11,16,4,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,7,4, 9,8,2.5, 9,16,6, 9,15,7.55, 7,6,2,10)],
			[objectify(5,16,12,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,8,2.5, 7,7,4, 7,15,7.55, 7,16,6, 7,6,2,10)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
	},
	buttonPushed:{
		verts:[
			[objectify(5,6,15,6,1,5,6)],
			[objectify(5,10,16,6,1,5,6)],
			[objectify(11,10,16,6,4,5,6)],
			[objectify(5,10,15,6,4,5,6)],
			[objectify(11,10,15,1,4,5,6)],
			[objectify(5,10,16,1,4,5,6)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true
	},
	repeater1:{
		verts:generateRepeater(),
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true
	},
	repeater2:{
		verts:generateRepeater(2),
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true
	},
	repeater3:{
		verts:generateRepeater(3),
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true
	},
	repeater4:{
		verts:generateRepeater(4),
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true
	},
	repeaterOn1:{
		verts:generateRepeater(1,true),
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true
	},
	repeaterOn2:{
		verts:generateRepeater(2,true),
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true
	},
	repeaterOn3:{
		verts:generateRepeater(3,true),
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true
	},
	repeaterOn4:{
		verts:generateRepeater(4,true),
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate: true
	},
	
	//the piston shapes come from https://minekhan-testing.lukep0wers.repl.co
	pistonOpen: {
		verts: [
			[objectify(0,0,0,16,16,0,0)], //bottom
			[objectify(0,12,16,16,16,0,0)], //top
			[objectify(16,12,16,16,12,0,4)], //north
			[objectify(0,12,0,16,12,0,4)], //south
			[objectify(16,12,0,16,12,0,4)], //east
			[objectify(0,12,16,16,12,0,4)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	pistonOpenFlipped: {
		verts: [
			[objectify(0,4,0,16,16,0,0, false,true)],
			[objectify(0,16,16,16,16,0,0, false,true)],
			[objectify(16,16,16,16,12,0,4, false,true)],
			[objectify(0,16,0,16,12,0,4, false,true)],
			[objectify(16,16,0,16,12,0,4, false,true)],
			[objectify(0,16,16,16,12,0,4, false,true)]
		],
		cull: {
			top: 3,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	pistonOpenSW: {
		verts: [
			[objectify(0,0,4,16,12,0,4)],
			[objectify(0,16,16,16,12,0,4, false,false,2)],
			[objectify(16,16,16,16,16,0,0)],
			[objectify(0,16,4,16,16,0,0)],
			[objectify(16,16,4,12,16,0,4, false,false,1)],
			[objectify(0,16,16,12,16,0,4, false,false,-1)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 3,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true
	},
	pistonHead: {
		verts: [
			[objectify(0,12,0,16,16,0,0)], //b
			[objectify(0,16,16,16,16,0,0)], //t
			[objectify(16,16,16,16,4,0,0), objectify(10,12,10,4,12,6,4), objectify(10,0,10,4,4,6,9)], //n
			[objectify(0,16,0,16,4,0,0), objectify(6,12,6,4,12,6,4), objectify(6,0,6,4,4,6,9)], //s
			[objectify(16,16,0,16,4,0,0), objectify(10,12,6,4,12,6,4), objectify(10,0,6,4,4,6,9)], //e
			[objectify(0,16,16,16,4,0,0), objectify(6,12,10,4,12,6,4), objectify(6,0,10,4,4,6,9)] //w
		],
		cull: {
			top: 3,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	pistonHeadFlipped: {
		verts: [
			[objectify(0,0,0,16,16,0,0)], //b
			[objectify(0,4,16,16,16,0,0)], //t
			[objectify(16,4,16,16,4,0,0), objectify(10,20,10,4,12,6,4), objectify(10,8,10,4,4,6,9)], //n
			[objectify(0,4,0,16,4,0,0), objectify(6,20,6,4,12,6,4), objectify(6,8,6,4,4,6,9)], //s
			[objectify(16,4,0,16,4,0,0), objectify(10,20,6,4,12,6,4), objectify(10,8,6,4,4,6,9)], //e
			[objectify(0,4,16,16,4,0,0), objectify(6,20,10,4,12,6,4), objectify(6,8,10,4,4,6,9)] //w
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	pistonHeadSW: {
		verts: [
			[objectify(0,0,0,16,4,0,0),objectify(6,6,4,4,12,6,4),objectify(6,6,16,4,4,6,9)],
			[objectify(0,16,4,16,4,0,0),objectify(6,10,16,4,12,6,4, false,true),objectify(6,10,20,4,4,6,9, false,true)],
			[objectify(16,16,4,16,16,0,0)],
			[objectify(0,16,0,16,16,0,0)],
			[objectify(16,16,0,4,16,0,0, false,false,true),objectify(10,10,4,12,4,6,4, false,false,1),objectify(10,10,16,4,4,6,9, false,false,1)],
			[objectify(0,16,4,4,16,0,0, false,false,true),objectify(6,10,16,12,4,6,4, false,false,-1),objectify(6,10,20,4,4,6,9, false,false,-1)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 3,
			east: 0,
			west: 0
		},
		rotate:true
	},
	pistonHeadCut: {
		verts: [
			[objectify(0,12,0,16,16,0,0)], //b
			[objectify(0,16,16,16,16,0,0)], //t
			[objectify(16,16,16,16,4,0,0), objectify(10,12,10,4,12,6,4)], //n
			[objectify(0,16,0,16,4,0,0), objectify(6,12,6,4,12,6,4)], //s
			[objectify(16,16,0,16,4,0,0), objectify(10,12,6,4,12,6,4)], //e
			[objectify(0,16,16,16,4,0,0), objectify(6,12,10,4,12,6,4)] //w
		],
		cull: {
			top: 3,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	pistonHeadCutFlipped: {
		verts: [
			[objectify(0,0,0,16,16,0,0)], //b
			[objectify(0,4,16,16,16,0,0)], //t
			[objectify(16,4,16,16,4,0,0), objectify(10,16,10,4,12,6,4)], //n
			[objectify(0,4,0,16,4,0,0), objectify(6,16,6,4,12,6,4)], //s
			[objectify(16,4,0,16,4,0,0), objectify(10,16,6,4,12,6,4)], //e
			[objectify(0,4,16,16,4,0,0), objectify(6,16,10,4,12,6,4)] //w
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	pistonHeadCutSW: {
		verts: [
			[objectify(0,0,0,16,4,0,0),objectify(6,6,4,4,12,6,4)],
			[objectify(0,16,4,16,4,0,0),objectify(6,10,16,4,12,6,4, false,true)],
			[objectify(16,16,4,16,16,0,0)],
			[objectify(0,16,0,16,16,0,0)],
			[objectify(16,16,0,4,16,0,0, false,false,true),objectify(10,10,4,12,4,6,4, false,false,1)],
			[objectify(0,16,4,4,16,0,0, false,false,true),objectify(6,10,16,12,4,6,4, false,false,-1)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 3,
			east: 0,
			west: 0
		},
		rotate:true
	},
	slimeBlock:{
		verts: [
			[objectify( 0,  0,  0, 16, 16, 0, 0), objectify( 3,  3,  3, 10, 10, 3, 3)], //bottom
			[objectify( 0, 16, 16, 16, 16, 0, 0), objectify( 3, 13, 13, 10, 10, 3, 3)], //top
			[objectify(16, 16, 16, 16, 16, 0, 0), objectify(13, 13, 13, 10, 10, 3, 3)], //north
			[objectify( 0, 16,  0, 16, 16, 0, 0), objectify( 3, 13,  3, 10, 10, 3, 3)], //south
			[objectify(16, 16,  0, 16, 16, 0, 0), objectify(13, 13,  3, 10, 10, 3, 3)], //east
			[objectify( 0, 16, 16, 16, 16, 0, 0), objectify( 3, 13, 13, 10, 10, 3, 3)]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
	},
	honeyBlock:{
		verts: [
			[objectify( 0,  0,  0, 16, 16, 0, 0), objectify( 1,  1,  1, 14, 14, 1, 1)], //bottom
			[objectify( 0, 16, 16, 16, 16, 0, 0), objectify( 1, 15, 15, 14, 14, -31, 1)], //top
			[objectify(16, 16, 16, 16, 16, 0, 0), objectify(15, 15, 15, 14, 14, -15, 1)], //north
			[objectify( 0, 16,  0, 16, 16, 0, 0), objectify( 1, 15,  1, 14, 14, -15, 1)], //south
			[objectify(16, 16,  0, 16, 16, 0, 0), objectify(15, 15,  1, 14, 14, -15, 1)], //east
			[objectify( 0, 16, 16, 16, 16, 0, 0), objectify( 1, 15, 15, 14, 14, -15, 1)]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
	},
	stairCornerOut: {
		verts: [
			[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
			[objectify( 0, 8,  16, 16, 16, 0, 0), objectify( 0, 16,  16, 8, 8, 0, 0)], //top
			[objectify(8, 16, 16, 8, 8, 0, 0), objectify(16, 8, 16, 16, 8, 0, 0)], //north
			[objectify( 0, 8,  0, 16, 8, 0, 0), objectify( 0, 16,  8, 8, 8, 0, 0)], //south
			[objectify(16, 8, 0, 16, 8, 0, 0), objectify(8, 16, 8, 8, 16, 0, 0)], //east
			[objectify( 0, 8, 8, 8, 8, 0, 0), objectify( 0, 16, 16, 8, 16, 8, 0)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 3,
			south: 0,
			east: 0,
			west: 0
		},
		flip: true,
		rotate: true
	},
	stairCornerIn: {
		verts: [
			[objectify(0,0,0,16,16,0,0)],
			[objectify(8,8,8,8,8,0,0),objectify(0,16,16,16,8,0,0),objectify(0,16,8,8,8,0,0)],
			[objectify(16,16,16,16,16,0,0)],
			[objectify(8,16,8,8,8,0,0),objectify(0,16,0,8,8,0,0),objectify(0,8,0,16,8,0,0)],
			[objectify(8,16,0,8,8,0,0),objectify(16,16,8,8,8,0,0),objectify(16,8,0,16,8,0,0)],
			[objectify(0,16,16,16,16,0,0)]
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 3,
			south: 0,
			east: 0,
			west: 0
		},
		flip: true,
		rotate: true
	},
	endPortal: {
		verts: [
			[objectify( 0, 8,  0, 16, 16, 0, 0)], //bottom
			[objectify( 0, 8, 16, 16, 16, 0, 0)], //top
			[], //north
			[], //south
			[], //east
			[]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 3,
			south: 3,
			east: 3,
			west: 3
		},
	},
	smallDripleaf:{
		verts:[
			[objectify(8,21,8,7,7,48,0,false,false,-1),objectify(1,26,1,7,7,48,0,false,false,1),objectify(1,30,8,7,7,48,0,false,false,2)],
			[objectify(8,21,15,7,7,48,0,true,false,-1),objectify(1,26,8,7,7,48,0,true,false,1),objectify(1,30,15,7,7,48,0,true)],
			[objectify(15,21,15,7,1,32,0),objectify(8,26,8,7,1,32,0),objectify(8,30,15,7,1,32,0),customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 0,0),customFace(2,32,2, 14,32,14, 14,16,14, 2,16,2, 16,0)],
			[objectify(8,21,8,7,1,32,0),objectify(1,26,1,7,1,32,0),objectify(1,30,8,7,1,32,0),customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 0,0),customFace(14,32,2, 2,32,14, 2,16,14, 14,16,2, 16,0)],
			[objectify(15,21,8,7,1,32,0),objectify(8,26,1,7,1,32,0),objectify(8,30,8,7,1,32,0),customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 0,0),customFace(14,32,14, 2,32,2, 2,16,2, 14,16,14, 16,0)],
			[objectify(8,21,15,7,1,32,0),objectify(1,26,8,7,1,32,0),objectify(1,30,15,7,1,32,0),customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 0,0),customFace(2,32,14, 14,32,2, 14,16,2, 2,16,14, 16,0)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true,
		hitbox:"tallCube"
	},
	bigDripleaf:{
		verts:[
			[objectify(0,15,0,16,16,32,0)],
			[objectify(0,15,16,16,16,32,0,false,true)],
			[objectify(16,15,0,16,4,48,0),customFace(2,15,2, 14,15,14, 14,0,14, 2,0,2, 0,0)],
			[objectify(0,15,0,16,4,48,0),customFace(14,15,2, 2,15,14, 2,0,14, 14,0,2, 0,0)],
			[objectify(0,15,0,16,4,16,0,true),objectify(16,15,0,16,4,16,0),customFace(14,15,14, 2,15,2, 2,0,2, 14,0,14, 0,0)],
			[objectify(0,15,16,16,4,16,0),objectify(16,15,16,16,4,16,0),customFace(2,15,14, 14,15,2, 14,0,2, 2,0,14, 0,0)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true,
		hitbox:"cube"
	},
	logicGate:{
		verts:[
			[objectify(0,0,0,16,16,0,0)],
			[objectify(0,2,16,16,16,0,0)],
			[objectify(16,2,16,16,2,0,2)],
			[objectify(0,2,0,16,2,0,2)],
			[objectify(16,2,0,16,2,0,14)],
			[objectify(0,2,16,16,2,0,14)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true
	},
	sign:{
		verts:[
			[objectify(-4,14,7,16,2,0,0),objectify(7,0,7,2,2,7,7, false,false,null,null,null,"poleTop"),objectify(12,14,7,8,2,0,0)],
			[objectify(-4,26,9,16,2,0,0),objectify(12,26,9,8,2,0,0)],
			[objectify(20,26,9,16,12,0,0),objectify(9,14,9,2,14,0,0, false,false,null,null,null,"poleSide"),objectify(4,26,9,8,12,0,0)],
			[objectify(-4,26,7,16,12,0,0),objectify(7,14,7,2,14,0,0, false,false,null,null,null,"poleSide"),objectify(12,26,7,8,12,0,0)],
			[objectify(20,26,7,2,12,0,0),objectify(9,14,7,2,14,0,0, false,false,null,null,null,"poleSide")],
			[objectify(-4,26,9,2,12,0,0),objectify(7,14,9,2,14,0,0, false,false,null,null,null,"poleSide")]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
	},
	wallSign:{
		verts:[
			[objectify(-4,6,16.7,16,2,0,0),objectify(12,6,16.7,8,2,0,0)],
			[objectify(-4,18,18.7,16,2,0,0),objectify(12,18,18.7,8,2,0,0)],
			[objectify(20,18,18.7,16,12,0,0),objectify(4,18,18.7,8,12,0,0)],
			[objectify(-4,18,16.7,16,12,0,0),objectify(12,18,16.7,8,12,0,0)],
			[objectify(20,18,16.7,2,12,0,0)],
			[objectify(-4,18,18.7,2,12,0,0)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
	},
	composter:{
		verts:[
			[objectify(0,0,0,16,16,16,0)],
			[objectify(0,2,16,16,16,16,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
			[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
			[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
			[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
			[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	composter2:{
		verts:[
			[objectify(0,0,0,16,16,16,0)],
			[objectify(0,4,16,16,16,0,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
			[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
			[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
			[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
			[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	composter3:{
		verts:[
			[objectify(0,0,0,16,16,16,0)],
			[objectify(0,6,16,16,16,0,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
			[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
			[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
			[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
			[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	composter4:{
		verts:[
			[objectify(0,0,0,16,16,16,0)],
			[objectify(0,8,16,16,16,0,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
			[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
			[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
			[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
			[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	composter5:{
		verts:[
			[objectify(0,0,0,16,16,16,0)],
			[objectify(0,10,16,16,16,0,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
			[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
			[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
			[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
			[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	composter6:{
		verts:[
			[objectify(0,0,0,16,16,16,0)],
			[objectify(0,12,16,16,16,0,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
			[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
			[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
			[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
			[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	composter7:{
		verts:[
			[objectify(0,0,0,16,16,16,0)],
			[objectify(0,14,16,16,16,0,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
			[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
			[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
			[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
			[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	composter8:{
		verts:[
			[objectify(0,0,0,16,16,16,0)],
			[objectify(0,15,16,16,16,32,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
			[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
			[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
			[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
			[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	cocoaStage0:{
		verts:[
			[objectify(6,7,11,4,4,0,0)],
			[objectify(6,12,15,4,4,0,0)],
			[objectify(10,12,15,4,5,11,4)],
			[objectify(6,12,11,4,5,11,4)],
			[objectify(10,12,11,4,5,11,4),objectify(8,16,12,4,4,12,0,true)],
			[objectify(6,12,15,4,5,11,4),objectify(8,16,16,4,4,12,0)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 3,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true
	},
	cocoaStage1:{
		verts:[
			[objectify(5,5,9,6,6,0,0)],
			[objectify(5,12,15,6,6,0,0)],
			[objectify(11,12,15,6,7,9,4)],
			[objectify(5,12,9,6,7,9,4)],
			[objectify(11,12,9,6,7,9,4),objectify(8,16,12,4,4,12,0,true)],
			[objectify(5,12,15,6,7,9,4),objectify(8,16,16,4,4,12,0)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 3,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true
	},
	cocoaStage2:{
		verts:[
			[objectify(4,3,7,8,8,0,0)],
			[objectify(4,12,15,8,8,0,0)],
			[objectify(12,12,15,8,9,8,4)],
			[objectify(4,12,7,8,9,8,4)],
			[objectify(12,12,7,8,9,8,4),objectify(8,16,12,4,4,12,0,true)],
			[objectify(4,12,15,8,9,8,4),objectify(8,16,16,4,4,12,0)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 3,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true
	},
	chair:{
		verts:[
			[objectify(3,6,0,10,16,0,0),objectify(3,0,14,2,2,0,0),objectify(11,0,14,2,2,0,0),objectify(3,0,0,2,2,0,0),objectify(11,0,0,2,2,0,0)],
			[objectify(3,8,16,10,16,0,0),objectify(3,24,16,10,2,0,0)],
			[objectify(13,8,16,10,2,0,0),objectify(5,6,16,2,6,0,0),objectify(13,6,16,2,6,0,0),objectify(5,6,2,2,6,0,0),objectify(13,6,2,2,6,0,0),objectify(13,24,16,10,16,0,0)],
			[objectify(3,8,0,10,2,0,0),objectify(3,6,14,2,6,0,0),objectify(11,6,14,2,6,0,0),objectify(3,6,0,2,6,0,0),objectify(11,6,0,2,6,0,0),objectify(3,24,14,10,16,0,0)],
			[objectify(13,8,0,16,2,0,0),objectify(5,6,0,2,6,0,0),objectify(13,6,0,2,6,0,0),objectify(5,6,14,2,6,0,0),objectify(13,6,14,2,6,0,0),objectify(13,24,14,2,16,0,0)],
			[objectify(3,8,16,16,2,0,0),objectify(3,6,2,2,6,0,0),objectify(3,6,16,2,6,0,0),objectify(11,6,2,2,6,0,0),objectify(11,6,16,2,6,0,0),objectify(3,24,16,2,16,0,0)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true
	},
	arrow:{
		verts:[
			[objectify(5.5,8,0,5,16,0,0, false,false,true)],
			[objectify(5.5,8,16,5,16,0,0, false,true,true)],
			[],
			[objectify(5.5,10.5,1,5,5,0,5)],
			[objectify(8,10.5,0,16,5,0,0, true)],
			[objectify(8,10.5,16,16,5,0,0)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	spyglass:{
		verts:[
			[objectify(6.9,2.4,6.9,2.2,2.2,0,0, false,false,false,2,2)],
			[objectify(6.9,8.6,9.1,2.2,2.2,0,5, false,false,false,2,2),objectify(7,13.5,9,2,2,0,13)],
			[objectify(9.1,8.6,9.1,2.2,6.2,0,7, false,false,false,2,6),objectify(9,13.5,9,2,5,0,2)],
			[objectify(6.9,8.6,6.9,2.2,6.2,0,7, false,false,false,2,6),objectify(7,13.5,7,2,5,0,2)],
			[objectify(9.1,8.6,6.9,2.2,6.2,0,7, false,false,false,2,6),objectify(9,13.5,7,2,5,0,2)],
			[objectify(6.9,8.6,9.1,2.2,6.2,0,7, false,false,false,2,6),objectify(7,13.5,9,2,5,0,2)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	hopper:{
		verts:[
			[objectify(0,10,0,16,16,0,0),objectify(4,4,4,8,8,4,4),objectify(6,0,6,4,4,6,6)],
			[objectify(0,16,16,13,3,35,0),objectify(0,10,16,16,16,0,0),objectify(3,16,3,13,3,32,13),objectify(0,16,13,3,13,45,3),objectify(13,16,16,3,13,32,0)],
			[objectify(16,16,16,16,6,16,0),objectify(12,10,12,8,6,20,6),objectify(10,4,10,4,4,22,12),objectify(13,16,3,10,6,19,0)],
			[objectify(0,16,0,16,6,16,0),objectify(4,10,4,8,6,20,6),objectify(6,4,6,4,4,22,12),objectify(3,16,13,10,6,19,0)],
			[objectify(16,16,0,16,6,16,0),objectify(12,10,4,8,6,20,6),objectify(10,4,6,4,4,22,12),objectify(3,16,3,10,6,19,0)],
			[objectify(0,16,16,16,6,16,0),objectify(4,10,12,8,6,20,6),objectify(6,4,10,4,4,22,12),objectify(13,16,13,10,6,19,0)]
		],
		cull: {
			top: 3,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	},
	hopperWall:{
		verts:[
			[objectify(0,10,0,16,16,0,0),objectify(4,4,4,8,8,4,4),objectify(6,4,12,4,4,6,6)],
			[objectify(0,16,16,13,3,35,0),objectify(0,10,16,16,16,0,0),objectify(3,16,3,13,3,32,13),objectify(0,16,13,3,13,45,3),objectify(13,16,16,3,13,32,0),objectify(6,8,16,4,4,22,12)],
			[objectify(16,16,16,16,6,16,0),objectify(12,10,12,8,6,20,6),objectify(13,16,3,10,6,19,0),objectify(10,8,16,4,4,22,12)],
			[objectify(0,16,0,16,6,16,0),objectify(4,10,4,8,6,20,6),objectify(3,16,13,10,6,19,0)],
			[objectify(16,16,0,16,6,16,0),objectify(12,10,4,8,6,20,6),objectify(10,8,12,4,4,22,12),objectify(3,16,3,10,6,19,0)],
			[objectify(0,16,16,16,6,16,0),objectify(4,10,12,8,6,20,6),objectify(6,8,16,4,4,22,12),objectify(13,16,13,10,6,19,0)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true
	},
	comparator:{
		verts:generateComparator(),
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true
	},
	comparatorOn:{
		verts:generateComparator(false,true),
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true
	},
	comparatorSubtract:{
		verts:generateComparator(true),
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true
	},
	comparatorSubtractOn:{
		verts:generateComparator(true,true),
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		rotate:true
	},
	daylightDetector:{
		verts:[
			[objectify(0,0,0,16,16,0,0)],
			[objectify(0,6,16,16,16,0,0)],
			[objectify(16,6,16,16,6,0,0)],
			[objectify(0,6,0,16,6,0,0)],
			[objectify(16,6,0,16,6,0,0)],
			[objectify(0,6,16,16,6,0,0)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
	},
	pitcherPlant:{
		verts:[
			[], //bottom
			[], //top
			[customFace(2,11,2, 14,11,14, 14,-5,14, 2,-5,2, 0,0,16,16,"pitcherCropBottomStage4"),customFace(2,29,2, 14,29,14, 14,11,14, 2,11,2, 0,0,16,16,"pitcherCropTopStage4")], //north
			[customFace(14,11,2, 2,11,14, 2,-5,14, 14,-5,2, 0,0,16,16,"pitcherCropBottomStage4"),customFace(14,29,2, 2,29,14, 2,11,14, 14,11,2, 0,0,16,16,"pitcherCropTopStage4")], //south
			[customFace(14,11,14, 2,11,2, 2,-5,2, 14,-5,14, 0,0,16,16,"pitcherCropBottomStage4"),customFace(14,29,14, 2,29,2, 2,11,2, 14,11,14, 0,0,16,16,"pitcherCropTopStage4")], //east
			[customFace(2,11,14, 14,11,2, 14,-5,2, 2,-5,14, 0,0,16,16,"pitcherCropBottomStage4"),customFace(2,29,14, 14,29,2, 14,11,2, 2,11,14, 0,0,16,16,"pitcherCropTopStage4")]  //west
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
	},
	pitcherCropStage0:{
		verts:[
			[objectify(5,0,5,6,6,5,5,null,null,null,null,null,"pitcherCropBottom")],
			[objectify(5,4,11,6,6,5,5,null,null,null,null,null,"pitcherCropTop")],
			[objectify(11,4,11,6,4,3,10,null,null,null,null,null,"pitcherCropSide")],
			[objectify(5,4,5,6,4,3,10,null,null,null,null,null,"pitcherCropSide")],
			[objectify(11,4,5,6,4,3,10,null,null,null,null,null,"pitcherCropSide")],
			[objectify(5,4,11,6,4,3,10,null,null,null,null,null,"pitcherCropSide")]
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"slab"
	},
	pitcherCropStage1:{
		verts:[
			[objectify(3,0,3,10,10,3,3,null,null,null,null,null,"pitcherCropBottom")],
			[objectify(3,6,13,10,10,3,3,null,null,null,null,null,"pitcherCropTop")],
			[objectify(13,6,13,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(2,22,2, 14,22,14, 14,6,14, 2,6,2, 0,0)],
			[objectify(3,6,3,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(14,22,2, 2,22,14, 2,6,14, 14,6,2, 0,0)],
			[objectify(13,6,3,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(14,22,14, 2,22,2, 2,6,2, 14,6,14, 0,0)],
			[objectify(3,6,13,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(2,22,14, 14,22,2, 14,6,2, 2,6,14, 0,0)]
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"cube"
	},
	pitcherCropStage3:{
		verts:[
			[objectify(3,0,3,10,10,3,3,null,null,null,null,null,"pitcherCropBottom")],
			[objectify(3,6,13,10,10,3,3,null,null,null,null,null,"pitcherCropTop")],
			[objectify(13,6,13,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(2,17,2, 14,17,14, 14,1,14, 2,1,2, 0,0),customFace(2,33,2, 14,33,14, 14,17,14, 2,17,2, 16,0)],
			[objectify(3,6,3,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(14,17,2, 2,17,14, 2,1,14, 14,1,2, 0,0),customFace(14,33,2, 2,33,14, 2,17,14, 14,17,2, 16,0)],
			[objectify(13,6,3,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(14,17,14, 2,17,2, 2,1,2, 14,1,14, 0,0),customFace(14,33,14, 2,33,2, 2,17,2, 14,17,14, 16,0)],
			[objectify(3,6,13,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(2,17,14, 14,17,2, 14,1,2, 2,1,14, 0,0),customFace(2,33,14, 14,33,2, 14,17,2, 2,17,14, 16,0)]
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"tallCube"
	},
	flat:{
		verts:[
			[objectify(0,0.25,0,16,16,0,0,false,true)],
			[objectify(0,0.25,16,16,16,0,0)],
			[],[],[],[]
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"carpet"
	},
	flowerbed1:{
		verts:addStem1x1(addStem1x1(addStem1x1([
			[objectify(8,3,8,8,8,0,0,false,true)],
			[objectify(8,3,16,8,8,0,0)],
			[],[],[],[]
		],
		11,14,3),
		14,10,3),
		9,9,3),
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"layer2",
		rotate:true
	},
	flowerbed2:{
		verts:addStem1x1(addStem1x1(addStem1x1([
			[objectify(8,3,0,8,16,0,0,false,true)],
			[objectify(8,3,16,8,16,0,0)],
			[],[],[],[]
		],
		11,14,3),
		14,10,3),
		9,9,3),
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"layer2",
		rotate:true
	},
	flowerbed3:{
		verts:addStem1x1(addStem1x1(addStem1x1(addStem1x1(addStem1x1(addStem1x1([
			[objectify(8,3,0,8,16,0,0,false,true),objectify(0,2,0,8,8,8,8,false,true)],
			[objectify(8,3,16,8,16,0,0),objectify(0,2,8,8,8,8,8)],
			[],[],[],[]
		],
		11,14,3),
		14,10,3),
		9,9,3),
		6,6,2),
		3.5,1.5,2),
		1,5,2),
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"layer2",
		rotate:true
	},
	flowerbed4:{
		verts:addStem1x1(addStem1x1(addStem1x1(addStem1x1(addStem1x1(addStem1x1([
			[objectify(8,3,0,8,16,0,0,false,true),objectify(0,2,0,8,16,8,0,false,true)],
			[objectify(8,3,16,8,16,0,0),objectify(0,2,16,8,16,8,0)],
			[],[],[],[]
		],
		11,14,3),
		14,10,3),
		9,9,3),
		6,6,2),
		3.5,1.5,2),
		1,5,2),
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"layer2",
		rotate:true
	},
	fern:{
		verts:[
			[],[],
			[customFace(16,10,0, 0,10,0, 0,0,8, 16,0,8, 0,0),customFace(0,10,0, 16,10,0, 16,0,8, 0,0,8, 16,0, -16)],
			[customFace(0,10,14, 16,10,14, 16,0,8, 0,0,8, 0,0),customFace(16,10,14, 0,10,14, 0,0,8, 16,0,8, 16,0, -16)],
			[customFace(2,10,0, 2,10,16, 8,0,16, 8,0,0, 0,0),customFace(2,10,16, 2,10,0, 8,0,0, 8,0,16, 16,0, -16)],
			[customFace(12,10,16, 12,10,0, 8,0,0, 8,0,16, 0,0),customFace(12,10,0, 12,10,16, 8,0,16, 8,0,0, 16,0, -16)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"cube",
		rotate:true
	},
	ceilingPanel: {
		verts: [
			[objectify(0, 13, 0, 16, 16, 0, 0)], //bottom
			[objectify(0, 16, 16, 16, 16, 0, 0)], //top
			[objectify(16, 16, 16, 16, 3, 0, 0)], //north
			[objectify(0, 16, 0, 16, 3, 0, 0)], //south
			[objectify(16, 16, 0, 16, 3, 0, 0)], //east
			[objectify(0, 16, 16, 16, 3, 0, 0)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 3,
			south: 3,
			east: 3,
			west: 3
		},
		rotate: true
	},
	groundBush:{
		verts:addStem1x1(addStem1x1(addStem1x1([
			[objectify(0,2,0,16,16,0,0,false,true,-1), objectify(0,5,0,16,16,0,0,false,true,2), objectify(0,8,0,16,16,0,0,false,true,1)],
			[objectify(0,2,16,16,16,0,0,false,false,1),objectify(0,5,16,16,16,0,0,false,false,2),objectify(0,8,16,16,16,0,0,false,false,-1)],
			[],[],[],[]
		],
		5,2,8),
		12,5,5),
		9,14,8),
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"slab",
		rotate:true
	},
	coralFan:{
		verts:[
			[],[],
			[customFace(16,9,-6, 0,9,-6, 0,0,8, 16,0,8, 0,0),customFace(0,9,-6, 16,9,-6, 16,0,8, 0,0,8, 16,0, -16)],
			[customFace(0,9,22, 16,9,22, 16,0,8, 0,0,8, 0,0),customFace(16,9,22, 0,9,22, 0,0,8, 16,0,8, 16,0, -16)],
			[customFace(-6,9,0, -6,9,16, 8,0,16, 8,0,0, 0,0),customFace(-6,9,16, -6,9,0, 8,0,0, 8,0,16, 16,0, -16)],
			[customFace(22,9,16, 22,9,0, 8,0,0, 8,0,16, 0,0),customFace(22,9,0, 22,9,16, 8,0,16, 8,0,0, 16,0, -16)]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"cube"
	},
	coralWallFan:{
		verts:[
			[],
			[
			customFace(16,16,-3.8, 0,16,-3.8, 0,7,16, 16,7,16, 0,0),customFace(0,16,-3.8, 16,16,-3.8, 16,7,16, 0,7,16, 16,0, -16),
			customFace(16,0,-3.8, 0,0,-3.8, 0,9,16, 16,9,16, 0,0),customFace(0,0,-3.8, 16,0,-3.8, 16,9,16, 0,9,16, 16,0, -16)],
			[],[],[],[]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"cube",
		rotate:true
	},
	rail:{
		verts:[
			[objectify(0,1,0,16,16,0,0,false,true)],
			[objectify(0,1,16,16,16,0,0)],
			[],
			[],
			[],
			[]
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"carpet",
		rotate:true
	},
	railDiagonal:{
		verts:[
			[customFace(16,17,16, 0,17,16, 0,1,0, 16,1,0, 0,0)],
			[customFace(0,17,16, 16,17,16, 16,1,0, 0,1,0, 0,0)],
			[],
			[],
			[],
			[]
		],
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
		hitbox:"cube",
		rotate:true
	},
	
	item: {
		verts: generateItemShape(),
		cull: {
			top: 0,
			bottom: 0,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		},
	},
	sun:{
		verts:[
			[],[],[],
			[
				/*objectify(-8,8,8,16,16,0,0),
				objectify(8,8,8,16,16,16,0),
				objectify(-8,24,8,16,16,32,0),
				objectify(8,24,8,16,16,48,0),*/
				objectify(0,16,8,16,16,0,0)
			],
			[],[]
		]
	},
	/*moon:{
		verts:[
			[],[],[],
			[
				objectify(8,24,8,16,16,0,0),
				objectify(-8,24,8,16,16,16,0),
				objectify(8,8,8,16,16,32,0),
				objectify(-8,8,8,16,16,48,0),
			],
			[],[]
		]
	},*/
	playerBody:{
		verts:[
			[objectify(4,2,6,8,4,28,16),objectify(3.75,1.75,5.75,8.5,4.5,28,32,false,false,false,8,4)],
			[objectify(4,14,10,8,4,20,16),objectify(3.75,14.25,10.25,8.5,4.5,20,32,false,false,false,8,4)],
			[objectify(12,14,10,8,12,20,20),objectify(12.25,14.25,10.25,8.5,12.5,20,36,false,false,false,8,12)],
			[objectify(4,14,6,8,12,32,20),objectify(3.75,14.25,5.75,8.5,12.5,32,36,false,false,false,8,12)],
			[objectify(12,14,6,4,12,28,20),objectify(12.25,14.25,5.75,4.5,12.5,28,36,false,false,false,4,12)],
			[objectify(4,14,10,4,12,16,20),objectify(3.75,14.25,10.25,4.5,12.5,16,36,false,false,false,4,12)]
		]
	},
	playerHead:{
		verts:[
			[objectify(4,8,4,8,8,16,0),objectify(3.75,7.75,3.75,8.5,8.5,48,0,false,false,false,8,8)],
			[objectify(4,16,12,8,8,8,0),objectify(3.75,16.25,12.25,8.5,8.5,40,0,false,false,false,8,8)],
			[objectify(12,16,12,8,8,8,8),objectify(12.25,16.25,12.25,8.5,8.5,40,8,false,false,false,8,8)],
			[objectify(4,16,4,8,8,24,8),objectify(3.75,16.25,3.75,8.5,8.5,56,8,false,false,false,8,8)],
			[objectify(12,16,4,8,8,16,8),objectify(12.25,16.25,3.75,8.5,8.5,48,8,false,false,false,8,8)],
			[objectify(4,16,12,8,8,0,8),objectify(3.75,16.25,12.25,8.5,8.5,32,8,false,false,false,8,8)]
		]
	},
	playerLeftArm:{
		verts:[
			[objectify(8,-4,6,4,4,40,48),objectify(7.75,-4.25,5.75,4.5,4.5,56,48, false,false,false,4,4)],
			[objectify(8,8,10,4,4,36,48),objectify(7.75,8.25,10.25,4.5,4.5,52,48, false,false,false,4,4)],
			[objectify(12,8,10,4,12,36,53),objectify(12.25,8.25,10.25,4.5,12.5,52,52, false,false,false,4,12)],
			[objectify(8,8,6,4,12,44,52),objectify(7.75,8.25,5.75,4.5,12.5,60,52, false,false,false,4,12)],
			[objectify(12,8,6,4,12,32,52),objectify(12.25,8.25,5.75,4.5,12.5,48,52, false,false,false,4,12)],
			[objectify(8,8,10,4,12,40,52),objectify(7.75,8.25,10.25,4.5,12.5,56,52, false,false,false,4,12)]
		]
	},
	playerRightArm:{
		verts:[
			[objectify(4,-4,6,4,4,48,16),objectify(3.75,-4.25,5.75,4.5,4.5,48,32, false,false,false,4,4)],
			[objectify(4,8,10,4,4,44,16),objectify(3.75,8.25,10.25,4.5,4.5,44,32, false,false,false,4,4)],
			[objectify(8,8,10,4,12,44,20),objectify(8.25,8.25,10.25,4.5,12.5,44,36, false,false,false,4,12)],
			[objectify(4,8,6,4,12,52,20),objectify(3.75,8.25,5.75,4.5,12.5,52,36, false,false,false,4,12)],
			[objectify(8,8,6,4,12,40,20),objectify(8.25,8.25,5.75,4.5,12.5,40,36, false,false,false,4,12)],
			[objectify(4,8,10,4,12,48,20),objectify(3.75,8.25,10.25,4.5,12.5,48,36, false,false,false,4,12)]
		]
	},
	playerLeftLeg:{
		verts:[
			[objectify(6,-4,6,4,4,24,48),objectify(5.75,-4.25,5.75,4.5,4.5,8,48, false,false,false,4,4)],
			[objectify(6,8,10,4,4,20,48),objectify(5.75,8.25,10.25,4.5,4.5,4,48, false,false,false,4,4)],
			[objectify(10,8,10,4,12,20,52),objectify(10.25,8.25,10.25,4.5,12.5,4,52, false,false,false,4,12)],
			[objectify(6,8,6,4,12,28,52),objectify(5.75,8.25,5.75,4.5,12.5,12,52, false,false,false,4,12)],
			[objectify(10,8,6,4,12,24,52),objectify(10.25,8.25,5.75,4.5,12.5,0,52, false,false,false,4,12)],
			[objectify(6,8,10,4,12,16,52),objectify(5.75,8.25,10.25,4.5,12.5,8,52, false,false,false,4,12)]
		]
	},
	playerRightLeg:{
		verts:[
			[objectify(6,-4,6,4,4,8,16),objectify(5.75,-4.25,5.75,4.5,4.5,8,32, false,false,false,4,4)],
			[objectify(6,8,10,4,4,4,16),objectify(5.75,8.25,10.25,4.5,4.5,4,32, false,false,false,4,4)],
			[objectify(10,8,10,4,12,4,20),objectify(10.25,8.25,10.25,4.5,12.5,4,36, false,false,false,4,12)],
			[objectify(6,8,6,4,12,12,20),objectify(5.75,8.25,5.75,4.5,12.5,12,36, false,false,false,4,12)],
			[objectify(10,8,6,4,12,8,20),objectify(10.25,8.25,5.75,4.5,12.5,0,36, false,false,false,4,12)],
			[objectify(6,8,10,4,12,0,20),objectify(5.75,8.25,10.25,4.5,12.5,8,36, false,false,false,4,12)]
		]
	},
	cape:{
		verts:[
			[objectify(3,-8,8,10,1,11,0)],
			[objectify(3,8,9,10,1,1,0)],
			[objectify(13,8,9,10,16,11,1)],
			[objectify(3,8,8,10,16,1,1)],
			[objectify(13,8,8,1,16,0,1)],
			[objectify(3,8,9,1,16,21,1)]
		]
	},
	/*cube2: {
		verts: [
			[objectify(0,0,0,16,16,0,0),objectify(8,4,8,16,16,0,0)],
			[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0)],
			[objectify(16,16,16,16,16,0,0),objectify(24,20,24,16,16,0,0)],
			[objectify(0,16,0,16,16,0,0),objectify(8,20,8,16,16,0,0)],
			[objectify(16,16,0,16,16,0,0),objectify(24,20,8,16,16,0,0)],
			[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0)]
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 3,
			south: 3,
			east: 3,
			west: 3
		},
	},
	cube3: {
		verts: [
			[objectify(0,0,0,16,16,0,0),objectify(8,4,8,16,16,0,0),objectify(-8,8,-8,16,16,0,0)],
			[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0)],
			[objectify(16,16,16,16,16,0,0),objectify(24,20,24,16,16,0,0),objectify(8,24,8,16,16,0,0)],
			[objectify(0,16,0,16,16,0,0),objectify(8,20,8,16,16,0,0),objectify(-8,24,-8,16,16,0,0)],
			[objectify(16,16,0,16,16,0,0),objectify(24,20,8,16,16,0,0),objectify(8,24,-8,16,16,0,0)],
			[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0)]
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 3,
			south: 3,
			east: 3,
			west: 3
		},
	},
	cube4: {
		verts: [
			[objectify(0,0,0,16,16,0,0),objectify(8,4,8,16,16,0,0),objectify(-8,8,-8,16,16,0,0),objectify(8,-4,-8,16,16,0,0)],
			[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0),objectify(8,12,8,16,16,0,0)],
			[objectify(16,16,16,16,16,0,0),objectify(24,20,24,16,16,0,0),objectify(8,24,8,16,16,0,0),objectify(24,12,8,16,16,0,0)],
			[objectify(0,16,0,16,16,0,0),objectify(8,20,8,16,16,0,0),objectify(-8,24,-8,16,16,0,0),objectify(8,12,-8,16,16,0,0)],
			[objectify(16,16,0,16,16,0,0),objectify(24,20,8,16,16,0,0),objectify(8,24,-8,16,16,0,0),objectify(24,12,-8,16,16,0,0)],
			[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0),objectify(8,12,8,16,16,0,0)]
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 3,
			south: 3,
			east: 3,
			west: 3
		}
	},
	cube5:{
		verts:[
			[objectify(0,0,0,16,16,0,0),objectify(8,4,8,16,16,0,0),objectify(-8,8,-8,16,16,0,0),objectify(8,-4,-8,16,16,0,0),objectify(16,8,0,16,16,0,0)],
			[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0),objectify(8,12,8,16,16,0,0),objectify(16,24,16,16,16,0,0)],
			[objectify(16,16,16,16,16,0,0),objectify(24,20,24,16,16,0,0),objectify(8,24,8,16,16,0,0),objectify(24,12,8,16,16,0,0),objectify(32,24,16,16,16,0,0)],
			[objectify(0,16,0,16,16,0,0),objectify(8,20,8,16,16,0,0),objectify(-8,24,-8,16,16,0,0),objectify(8,12,-8,16,16,0,0),objectify(16,24,0,16,16,0,0)],
			[objectify(16,16,0,16,16,0,0),objectify(24,20,8,16,16,0,0),objectify(8,24,-8,16,16,0,0),objectify(24,12,-8,16,16,0,0),objectify(32,24,0,16,16,0,0)],
			[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0),objectify(8,12,8,16,16,0,0),objectify(16,24,16,16,16,0,0)]
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 3,
			south: 3,
			east: 3,
			west: 3
		}
	},*/
	tallCube:{
		verts: [
			[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
			[objectify( 0, 32, 16, 16, 16, 0, 0)], //top
			[objectify(16, 32, 16, 16, 32, 0, 0)], //north
			[objectify( 0, 32,  0, 16, 32, 0, 0)], //south
			[objectify(16, 32,  0, 16, 32, 0, 0)], //east
			[objectify( 0, 32, 16, 16, 32, 0, 0)]  //west
		],
	},
	entityFire: {
		verts: [
			/*[], //bottom
			[], //top
			[customFace(0,16,0, 16,16,16, 16,0,16, 0,0,0, 0,0), objectify(16, 16,  8, 16, 16, 0, 0)], //north
			[customFace(16,16,0, 0,16,16, 0,0,16, 16,0,0, 0,0), objectify(0,  16,  8, 16, 16, 0, 0)], //south
			[customFace(16,16,16, 0,16,0, 0,0,0, 16,0,16, 0,0), objectify(8,  16,  0, 16, 16, 0, 0)], //east
			[customFace(0,16,16, 16,16,0, 16,0,0, 0,0,16, 0,0), objectify(8,  16, 16, 16, 16, 0, 0)]  //west*/
			[],
			[],
			[objectify(16,20,8, 16,20, 0,0, false,false,false, 16,16),objectify(14,8,8.1, 12,8, 0,0, false,false,false, 16,16)],
			[],
			[],
			[]
		]
	},
	cowBody: {
		/*verts: [
			// x, y, z, width, height, textureX, textureY
			// 0, 0, 0 is the corner on the top left of the texture
			[objectify( 0,  0,  0, 16, 16, 0, 0), objectify(16,  8,  4,  8,  8,  0,  0)], //bottom
			[objectify( 0, 12, 16, 16, 16, 0, 0), objectify(16, 16, 12,  8,  8,  0,  0)], //top
			[objectify(16, 12, 16, 16, 12, 0, 4), objectify(24, 16, 12,  8,  8, 16,  0)], //north
			[objectify( 0, 12,  0, 16, 12, 0, 4), objectify(16, 16,  4,  8,  8, 16,  0)], //south
			[objectify(16, 12,  0, 16, 12, 0, 4), objectify(24, 16,  4,  8,  8, 16,  0)], //east
			[objectify( 0, 12, 16, 16, 12, 0, 4), objectify(16, 16, 12,  8,  8, 16,  0)]  //west
		],*/
		verts: [
			[objectify(2,0,-1,12,18,28,14,false,false,2),objectify(6,-1,0,4,4,53,2)],
			[objectify(2,10,17,12,18,50,14)],
			[objectify(14,10,17,12,10,28,4),objectify(10,0,4,4,1,53,0)],
			[objectify(2,10,-1,12,10,40,4,true),objectify(6,0,0,4,1,57,0)],
			[objectify(14,10,-1,18,10,40,14,false,false,-1)],
			[objectify(2,10,17,18,10,18,14,false,false,1)]
		],
		texWidth:64,
		texHeight:32
	},
	cowLeg:{
		verts:[
			[objectify(6,-4,6,4,4,8,16)],
			[objectify(6,8,10,4,4,4,16)],
			[objectify(10,8,10,4,12,4,20)],
			[objectify(6,8,6,4,12,12,20)],
			[objectify(10,8,6,4,12,8,20)],
			[objectify(6,8,10,4,12,0,20)]
		],
		texWidth:64,
		texHeight:32
	},
	cowHead:{
		verts:[
			[objectify(4,4,8,8,6,14,0),objectify(3,11,11,1,1,24,0),objectify(12,11,11,1,1,24,0)],
			[objectify(4,12,14,8,6,6,0),objectify(3,13,12,1,1,23,0),objectify(12,13,12,1,1,23,0)],
			[objectify(12,12,14,8,8,6,6),objectify(4,13,12,1,2,23,1),objectify(13,13,12,1,2,23,1)],
			[objectify(4,12,8,8,8,20,6),objectify(3,13,11,1,2,24,1),objectify(12,13,11,1,2,24,1)],
			[objectify(12,12,8,6,8,14,6),objectify(4,13,11,1,2,22,1),objectify(12,13,11,1,2,22,1)],
			[objectify(4,12,14,6,8,0,6),objectify(3,13,12,1,2,24,1),objectify(13,13,12,1,2,24,1)]
		],
		texWidth:64,
		texHeight:32
	},
	pigBody:{
		verts:[
			[objectify(3,0,0,10,16,36,16,false,false,2)],
			[objectify(3,8,16,10,16,54,16)],
			[objectify(13,8,16,10,8,36,8)],
			[objectify(3,8,0,10,8,46,8)],
			[objectify(13,8,0,16,8,44,16,false,false,-1)],
			[objectify(3,8,16,16,8,28,16,false,false,1)]
		],
		texWidth:64,
		texHeight:32
	},
	pigLeg:{
		verts:[
			[objectify(6,2,6,4,4,8,16)],
			[objectify(6,8,10,4,4,4,16)],
			[objectify(10,8,10,4,6,4,20)],
			[objectify(6,8,6,4,6,12,20)],
			[objectify(10,8,6,4,6,8,20)],
			[objectify(6,8,10,4,6,0,20)]
		],
		texWidth:64,
		texHeight:32
	},
	pigHead:{
		verts:[
			[objectify(4,4,4,8,8,16,0),objectify(6,5,12,4,1,21,16)],
			[objectify(4,12,12,8,8,8,0),objectify(6,8,13,4,1,17,16)],
			[objectify(12,12,12,8,8,8,8),objectify(10,8,13,4,3,17,17)],
			[objectify(4,12,4,8,8,24,8)],
			[objectify(12,12,4,8,8,16,8),objectify(10,8,12,1,3,21,17)],
			[objectify(4,12,12,8,8,0,8),objectify(6,8,13,1,3,16,17)]
		],
		texWidth:64,
		texHeight:32
	},
	creeperHead:{
		verts:[
			[objectify(4,4,4,8,8,16,0)],
			[objectify(4,12,12,8,8,8,0)],
			[objectify(12,12,12,8,8,8,8)],
			[objectify(4,12,4,8,8,24,8)],
			[objectify(12,12,4,8,8,16,8)],
			[objectify(4,12,12,8,8,0,8)]
		],
		texWidth:64,
		texHeight:32
	},
	creeperBody:{
		verts:[
			[objectify(4,2,6,8,4,20,16)],
			[objectify(4,14,10,8,4,28,16)],
			[objectify(12,14,10,8,12,20,20)],
			[objectify(4,14,6,8,12,32,20)],
			[objectify(12,14,6,4,12,16,20)],
			[objectify(4,14,10,4,12,28,20)]
		],
		texWidth:64,
		texHeight:32
	},
	sheepBody:{
		verts:[
			[objectify(4,5,0,8,16,34+64,14,false,false,2)],
			[objectify(4,11,16,8,16,48+64,14)],
			[objectify(12,11,16,8,6,34+64,8)],
			[objectify(4,11,0,8,6,42+64,8,true)],
			[objectify(12,11,0,16,6,42+64,14,false,false,-1)],
			[objectify(4,11,16,16,6,28+64,14,false,false,1)]
		],
		texWidth:64,
		texHeight:32
	},
	sheepLeg:{
		verts:[
			[objectify(6,-4,6,4,4,8+64,16)],
			[objectify(6,8,10,4,4,4+64,16)],
			[objectify(10,8,10,4,12,4+64,20)],
			[objectify(6,8,6,4,12,12+64,20)],
			[objectify(10,8,6,4,12,0+64,20)],
			[objectify(6,8,10,4,12,8+64,20)]
		],
		texWidth:64,
		texHeight:32
	},
	sheepHead:{
		verts:[
			[objectify(5,5,4,6,8,14+64,0)],
			[objectify(5,11,12,6,8,8+64,0)],
			[objectify(11,11,12,6,6,8+64,8)],
			[objectify(5,11,4,6,6,22+64,8)],
			[objectify(11,11,4,8,6,14+64,8)],
			[objectify(5,11,12,8,6,0+64,8)]
		],
		texWidth:64,
		texHeight:32
	},
	sheepBodyFur:{
		verts:[
			[objectify(1.5,2,-3,13,21,34,14,false,false,2,8,16)],
			[objectify(1.5,12,18,13,21,48,14,false,false,0,8,16)],
			[objectify(14.5,12,18,13,10,34,8,false,false,0,8,6)],
			[objectify(1.5,12,-3,13,10,42,8,true,false,0,8,6)],
			[objectify(14.5,12,-3,21,10,42,14,false,false,-1,16,6)],
			[objectify(1.5,12,18,21,10,28,14,false,false,1,16,6)]
		],
		texWidth:64,
		texHeight:32
	},
	sheepLegFur:{
		verts:[
			[objectify(6,-4,6,4,4,8+64,16),objectify(5,2,5,6,6,8,16,false,false,0,4,4)],
			[objectify(5,10,11,6,6,4,16,false,false,0,4,4)],
			[objectify(10,8,10,4,12,4+64,20),objectify(11,10,11,6,8,4,20,false,false,0,4,6)],
			[objectify(6,8,6,4,12,12+64,20),objectify(5,10,5,6,8,12,20,false,false,0,4,6)],
			[objectify(10,8,6,4,12,0+64,20),objectify(11,10,5,6,8,0,20,false,false,0,4,6)],
			[objectify(6,8,10,4,12,8+64,20),objectify(5,10,11,6,8,8,20,false,false,0,4,6)]
		],
		texWidth:64,
		texHeight:32
	},
	sheepHeadFur:{
		verts:[
			[objectify(5,5,4,6,8,14+64,0),objectify(4,4,2.75,8,8,12,0,false,false,0,6,6)],
			[objectify(5,11,12,6,8,8+64,0),objectify(4,12,10.75,8,8,6,0,false,false,0,6,6)],
			[objectify(11,11,12,6,6,8+64,8),objectify(12,12,10.75,8,8,6,6,false,false,0,6,6)],
			[objectify(5,11,4,6,6,22+64,8),objectify(4,12,2.75,8,8,18,6,false,false,0,6,6)],
			[objectify(11,11,4,8,6,14+64,8),objectify(12,12,2.75,8,8,12,6,false,false,0,6,6)],
			[objectify(5,11,12,8,6,0+64,8),objectify(4,12,10.75,8,8,0,6,false,false,0,6,6)]
		],
		texWidth:64,
		texHeight:32
	},
	chickenBody:{
		verts:[
			[objectify(5,5,4,6,8,6,15,false,false,2)],
			[objectify(5,11,12,6,8,20,15)],
			[objectify(11,11,12,6,6,6,9)],
			[objectify(5,11,4,6,6,12,9,true)],
			[objectify(11,11,4,8,6,12,15,false,false,-1)],
			[objectify(5,11,12,8,6,0,15,false,false,1)]
		],
		texWidth:64,
		texHeight:32
	},
	chickenWing:{
		verts:[
			[objectify(7.5,4,5,1,6,30,13,false,false,2)],
			[objectify(7.5,8,11,1,6,31,13)],
			[objectify(8.5,8,11,1,4,37,19)],
			[objectify(7.5,8,5,1,4,30,19,true)],
			[objectify(8.5,8,5,6,4,31,19,true)],
			[objectify(7.5,8,11,6,4,24,19,true)]
		],
		texWidth:64,
		texHeight:32
	},
	chickenLeg:{
		verts:[
			[],
			[objectify(6.5,3.1,9.5,3,3,32,0,false,true)],
			[objectify(8.5,8,6.5,1,5,36,3)],
			[],
			[],
			[]
		],
		texWidth:64,
		texHeight:32
	},
	chickenHead:{
		verts:[
			[objectify(6,5,6.5,4,3,7,0),objectify(6,7,9.5,4,2,20,0),objectify(7,5,9.5,2,1,18,4)],
			[objectify(6,11,9.5,4,3,3,0),objectify(6,9,11.5,4,2,16,0)],
			[objectify(10,11,9.5,4,6,3,3),objectify(10,9,11.5,4,2,16,2),objectify(9,7,10.5,2,2,16,6)],
			[objectify(6,11,6.5,4,6,10,3)],
			[objectify(10,11,6.5,3,6,7,3),objectify(10,9,9.5,2,2,14,2),objectify(9,7,9.5,1,2,18,6)],
			[objectify(6,11,9.5,3,6,0,3),objectify(6,9,11.5,2,2,20,2),objectify(7,7,10.5,1,2,20,6)]
		],
		texWidth:64,
		texHeight:32
	},
	zombieBody:{
		verts:[
			[objectify(4,2,6,8,4,28,16)],
			[objectify(4,14,10,8,4,20,16)],
			[objectify(12,14,10,8,12,20,20)],
			[objectify(4,14,6,8,12,32,20)],
			[objectify(12,14,6,4,12,28,20)],
			[objectify(4,14,10,4,12,16,20)]
		],
		texWidth:64,
		texHeight:64
	},
	zombieLeg:{
		verts:[
			[objectify(6,-4,6,4,4,8,16)],
			[objectify(6,8,10,4,4,4,16)],
			[objectify(10,8,10,4,12,4,20)],
			[objectify(6,8,6,4,12,12,20)],
			[objectify(10,8,6,4,12,8,20)],
			[objectify(6,8,10,4,12,0,20)]
		],
		texWidth:64,
		texHeight:64
	},
	zombieArm:{
		verts:[
			[objectify(6,-4,6,4,4,48,16)],
			[objectify(6,8,10,4,4,44,16)],
			[objectify(10,8,10,4,12,44,20)],
			[objectify(6,8,6,4,12,52,20)],
			[objectify(10,8,6,4,12,48,20)],
			[objectify(6,8,10,4,12,40,20)]
		],
		texWidth:64,
		texHeight:64
	},
	zombieHead:{
		verts:[
			[objectify(4,4,4,8,8,16,0)],
			[objectify(4,12,12,8,8,8,0)],
			[objectify(12,12,12,8,8,8,8)],
			[objectify(4,12,4,8,8,24,8)],
			[objectify(12,12,4,8,8,16,8)],
			[objectify(4,12,12,8,8,0,8)]
		],
		texWidth:64,
		texHeight:64
	},
	skeletonBody:{
		verts:[
			[objectify(4,2,6,8,4,28,16)],
			[objectify(4,14,10,8,4,20,16)],
			[objectify(12,14,10,8,12,20,20)],
			[objectify(4,14,6,8,12,32,20)],
			[objectify(12,14,6,4,12,28,20)],
			[objectify(4,14,10,4,12,16,20)]
		],
		texWidth:64,
		texHeight:32
	},
	skeletonLeg:{
		verts:[
			[objectify(7,-4,7,2,2,2,16)],
			[objectify(7,8,9,2,2,4,16)],
			[objectify(9,8,9,2,12,2,18)],
			[objectify(7,8,7,2,12,6,18)],
			[objectify(9,8,7,2,12,4,18)],
			[objectify(7,8,9,2,12,0,18)]
		],
		texWidth:64,
		texHeight:32
	},
	skeletonArm:{
		verts:[
			[objectify(7,-4,7,2,2,44,16)],
			[objectify(7,8,9,2,2,42,16)],
			[objectify(9,8,9,2,12,44,18)],
			[objectify(7,8,7,2,12,48,18)],
			[objectify(9,8,7,2,12,46,18)],
			[objectify(7,8,9,2,12,42,18)]
		],
		texWidth:64,
		texHeight:32
	},
	spiderBody:{
		verts:[
			[objectify(3,4,-7,10,12,22,12,false,false,2),objectify(5,5,5,6,6,12,0)],
			[objectify(3,12,5,10,12,12,12),objectify(5,11,11,6,6,6,0)],
			[objectify(13,12,5,10,8,12,24),objectify(11,11,11,6,6,6,6)],
			[objectify(3,12,-7,10,8,34,24)],
			[objectify(13,12,-7,12,8,22,24),objectify(11,11,5,6,6,12,6)],
			[objectify(3,12,5,12,8,0,24),objectify(5,11,11,6,6,0,6)]
		],
		texWidth:64,
		texHeight:32
	},
	spiderHead:{
		verts:[
			[objectify(4,4,4,8,8,48,4)],
			[objectify(4,12,12,8,8,40,4)],
			[objectify(12,12,12,8,8,40,12)],
			[objectify(4,12,4,8,8,56,12)],
			[objectify(12,12,4,8,8,48,12)],
			[objectify(4,12,12,8,8,32,12)]
		],
		texWidth:64,
		texHeight:32
	},
	spiderLeg:{
		verts:[
			[objectify(7,7,8,2,16,36,0,false,false,1)],
			[objectify(7,9,24,2,16,20,0,false,false,1)],
			[objectify(9,9,24,2,2,36,2)],
			[objectify(7,9,8,2,2,18,2)],
			[objectify(9,9,8,16,2,20,2)],
			[objectify(7,9,24,16,2,18,2)]
		],
		texWidth:64,
		texHeight:32
	},
	wolfBody:{
		verts:[
			[objectify(5,5,0,6,9,24,20),objectify(4,4.5,9,8,6,28,7)],
			[objectify(5,11,9,6,9,36,20),objectify(4,11.5,15,8,6,43,7)],
			[objectify(12,11.5,15,8,7,36,0)],
			[objectify(5,11,0,6,6,30,14),objectify(4,11.5,9,8,7,28,0)],
			[objectify(11,11,0,9,6,18,20,false,false,-1),objectify(12,11.5,9,6,7,21,7,false,false,-1)],
			[objectify(5,11,9,9,6,30,20,false,false,1),objectify(4,11.5,15,6,7,36,7,false,false,1)]
		],
		texWidth:64,
		texHeight:32
	},
	wolfLeg:{
		verts:[
			[objectify(7,0,7,2,2,4,18)],
			[objectify(7,8,9,2,2,2,18)],
			[objectify(9,8,9,2,8,2,20)],
			[objectify(7,8,7,2,8,6,20)],
			[objectify(9,8,7,2,8,4,20)],
			[objectify(7,8,9,2,8,0,20)]
		],
		texWidth:64,
		texHeight:32
	},
	wolfHead:{
		verts:[
			[objectify(5,5,5,6,3,10,0),objectify(6.5,5,8,3,3,7,11)],
			[objectify(5,11,8,6,3,4,0),objectify(6.5,8,11,3,3,4,11,false,false,2),objectify(5,13,6,2,1,17,14),objectify(9,13,6,2,1,17,14)],
			[objectify(11,11,8,6,6,4,4),objectify(9.5,8,11,3,3,4,14),objectify(7,13,6,2,2,17,15),objectify(11,13,6,2,2,17,15)],
			[objectify(5,11,5,6,6,14,4),objectify(5,13,5,2,2,20,15),objectify(9,13,5,2,2,20,15)],
			[objectify(11,11,5,3,6,10,4),objectify(9.5,8,8,3,3,7,14),objectify(7,13,5,1,2,19,15),objectify(11,13,5,1,2,19,15)],
			[objectify(5,11,8,3,6,1,4),objectify(6.5,8,11,3,3,1,14),objectify(5,13,6,1,2,16,15),objectify(9,13,6,1,2,16,15)]
		],
		texWidth:64,
		texHeight:32
	},
	wolfTail:{
		verts:[
			[objectify(7,0,7,2,2,13,18)],
			[objectify(7,8,9,2,2,11,18)],
			[objectify(9,8,9,2,8,11,20)],
			[objectify(7,8,7,2,8,15,20)],
			[objectify(9,8,7,2,8,13,20)],
			[objectify(7,8,9,2,8,9,20)]
		],
		texWidth:64,
		texHeight:32
	},
	blazeThingy:{
		verts:[
			[objectify(7,0,7,2,2,3,24)],
			[objectify(7,8,9,2,2,3,16)],
			[objectify(9,8,9,2,8,2,18)],
			[objectify(7,8,7,2,8,6,18)],
			[objectify(9,8,7,2,8,4,18)],
			[objectify(7,8,9,2,8,0,18)]
		],
		texWidth:64,
		texHeight:32
	},
	endermanLeg:{
		verts:[
			[objectify(7,-22,7,2,2,58,0)],
			[objectify(7,8,9,2,2,60,0)],
			[objectify(9,8,9,2,30,58,2)],
			[objectify(7,8,7,2,30,62,2)],
			[objectify(9,8,7,2,30,60,2)],
			[objectify(7,8,9,2,30,56,2)]
		],
		texWidth:64,
		texHeight:32
	},
	endermanBody:{
		verts:[
			[objectify(4,2,6,8,4,44,16)],
			[objectify(4,14,10,8,4,36,16)],
			[objectify(12,14,10,8,12,36,20)],
			[objectify(4,14,6,8,12,48,20)],
			[objectify(12,14,6,4,12,4,20)],
			[objectify(4,14,10,4,12,32,20)]
		],
		texWidth:64,
		texHeight:32
	},
	/*enderDragonBody:{
		verts:[
			[objectify(-4,-4,24,16,16,0,0,null,null,null,null,null,"dragon54"),objectify(-4,-4,8,24,16,8,0,null,null,null,null,null,"dragon37"),objectify(-4,-4,-8,24,16,8,0,null,null,null,null,null,"dragon21"),objectify(-4,-4,-24,24,16,8,0,null,null,null,null,null,"dragon5"),objectify(12,-4,24,8,16,8,0,null,null,null,null,null,"dragon53")],
			[objectify(-4,20,40,24,16,0,0,null,null,null,null,null,"dragon4"),objectify(-4,20,24,24,16,0,0,null,null,null,null,null,"dragon20"),objectify(-4,20,8,24,16,0,0,null,null,null,null,null,"dragon36"),objectify(-4,20,-8,24,16,0,0,null,null,null,null,null,"dragon52"),objectify(7,26,34,2,11,8,5,null,null,null,null,null,"dragon62"),objectify(7,26,14,2,11,8,5,null,null,null,null,null,"dragon62"),objectify(7,26,-6,2,11,8,5,null,null,null,null,null,"dragon62"),objectify(7,26,23,2,1,8,0,null,null,null,null,null,"dragon78"),objectify(7,26,3,2,1,8,0,null,null,null,null,null,"dragon78"),objectify(7,26,-17,2,1,8,0,null,null,null,null,null,"dragon78")],
			[objectify(20,20,40,24,24,0,0,null,null,null,null,null,"dragon68"),objectify(9,26,34,2,6,8,1,null,null,null,null,null,"dragon78"),objectify(9,26,14,2,6,8,1,null,null,null,null,null,"dragon78"),objectify(9,26,-6,2,6,8,1,null,null,null,null,null,"dragon78")],
			[objectify(-4,20,-24,24,24,8,0,null,null,null,null,null,"dragon73"),objectify(7,26,22,2,6,6,1,null,null,null,null,null,"dragon79"),objectify(7,26,2,2,6,6,1,null,null,null,null,null,"dragon79"),objectify(7,26,-18,2,6,6,1,null,null,null,null,null,"dragon79")],
			[objectify(20,20,16,24,24,8,0,null,null,null,null,null,"dragon69"),objectify(20,20,-24,40,24,0,0,null,null,null,null,null,"dragon71"),objectify(9,26,22,12,6,12,1,null,null,null,null,null,"dragon77"),objectify(9,26,2,12,6,12,1,null,null,null,null,null,"dragon77"),objectify(9,26,-18,12,6,12,1,null,null,null,null,null,"dragon77")],
			[objectify(-4,20,40,64,24,0,0,null,null,null,null,null,"dragon64"),objectify(7,26,34,12,6,10,1,null,null,null,null,null,"dragon78"),objectify(7,26,14,12,6,10,1,null,null,null,null,null,"dragon78"),objectify(7,26,-6,12,6,10,1,null,null,null,null,null,"dragon78")]
		]
	},*/
	//better shapes for ender dragon
	enderDragonBody:{
		verts:(function(){
			let verts = [
				[objectify(-4,-4,24,16,16,0,0,null,null,null,null,null,"dragonScales"),objectify(-4,-4,8,16,16,0,0,null,null,null,null,null,"dragonScales"),objectify(-4,-4,-8,16,16,0,0,null,null,null,null,null,"dragonScales"),objectify(-4,-4,-24,16,16,0,0,null,null,null,null,null,"dragonScales"),objectify(12,-4,24,8,16,0,0,null,null,null,null,null,"dragonScales"),objectify(12,-4,8,8,16,0,0,null,null,null,null,null,"dragonScales"),objectify(12,-4,-8,8,16,0,0,null,null,null,null,null,"dragonScales"),objectify(12,-4,-24,8,16,0,0,null,null,null,null,null,"dragonScales")],
				[objectify(4,20,40,16,16,0,0,null,null,null,null,null,"dragonScales"),objectify(4,20,24,16,16,0,0,null,null,null,null,null,"dragon20"),objectify(4,20,8,16,16,0,0,null,null,null,null,null,"dragonScales"),objectify(4,20,-8,16,16,0,0,null,null,null,null,null,"dragonScales"),objectify(-4,20,40,8,16,0,0,null,null,null,null,null,"dragonScales"),objectify(-4,20,24,8,16,0,0,null,null,null,null,null,"dragonScales"),objectify(-4,20,8,8,16,0,0,null,null,null,null,null,"dragonScales"),objectify(-4,20,-8,8,16,0,0,null,null,null,null,null,"dragonScales")],
				[objectify(20,20,40,24,24,0,0,null,null,null,null,null,"dragon68")],
				[objectify(-4,20,-24,24,24,8,0,null,null,null,null,null,"dragon73")],
				[objectify(20,20,24,16,16,0,0,null,null,null,null,null,"dragonScales"),objectify(20,4,24,16,8,0,0,null,null,null,null,null,"dragonScales"),objectify(20,20,8,16,16,0,0,null,null,null,null,null,"dragonScales"),objectify(20,4,8,16,8,0,0,null,null,null,null,null,"dragonScales"),objectify(20,20,-8,16,16,0,0,null,null,null,null,null,"dragonScales"),objectify(20,4,-8,16,8,0,0,null,null,null,null,null,"dragonScales"),objectify(20,20,-24,16,16,0,0,null,null,null,null,null,"dragonScales"),objectify(20,4,-24,16,8,0,0,null,null,null,null,null,"dragonScales")],
				[objectify(-4,20,40,16,16,0,0,null,null,null,null,null,"dragonScales"),objectify(-4,4,40,16,8,0,0,null,null,null,null,null,"dragonScales"),objectify(-4,20,24,16,16,0,0,null,null,null,null,null,"dragonScales"),objectify(-4,4,24,16,8,0,0,null,null,null,null,null,"dragonScales"),objectify(-4,20,8,16,16,0,0,null,null,null,null,null,"dragonScales"),objectify(-4,4,8,16,8,0,0,null,null,null,null,null,"dragonScales"),objectify(-4,20,-8,16,16,0,0,null,null,null,null,null,"dragonScales"),objectify(-4,4,-8,16,8,0,0,null,null,null,null,null,"dragonScales")]
			]
			for(let i=-24;i<=24;i+=6) generateSpike(verts,0,20,i, 14,12,"dragonSpike")
			return verts
		})()
	},
	enderDragonNeck:{
		verts:(function(){
			let verts = [
				[objectify( 0,  0,  0, 16, 16, 0, 0,null,null,null,null,null,"dragonScales")], //bottom
				[objectify( 0, 16, 16, 16, 16, 0, 0,null,null,null,null,null,"dragonScales")], //top
				[objectify(16, 16, 16, 16, 16, 0, 0,null,null,null,null,null,"dragonScales")], //north
				[objectify( 0, 16,  0, 16, 16, 0, 0,null,null,null,null,null,"dragonScales")], //south
				[objectify(16, 16,  0, 16, 16, 0, 0,null,null,null,null,null,"dragonScales")], //east
				[objectify( 0, 16, 16, 16, 16, 0, 0,null,null,null,null,null,"dragonScales")]  //west
			]
			generateSpike(verts,0,16,0, 14,12,"dragonSpike")
			return verts
		})()
	},
	enderDragonTail:{
		verts:[
			[objectify( 0,  0,  0, 16, 16, 0, 0,null,null,null,null,null,"dragonScales")], //bottom
			[objectify( 0, 16, 16, 16, 16, 0, 0,null,null,null,null,null,"dragonScales")], //top
			[objectify(16, 16, 16, 16, 16, 0, 0,null,null,null,null,null,"dragonScales")], //north
			[objectify( 0, 16,  0, 16, 16, 0, 0,null,null,null,null,null,"dragonScales")], //south
			[objectify(16, 16,  0, 16, 16, 0, 0,null,null,null,null,null,"dragonScales")], //east
			[objectify( 0, 16, 16, 16, 16, 0, 0,null,null,null,null,null,"dragonScales")]  //west
		]
	},
	enderDragonHead:{
		verts:[
			[objectify(0,0,0,16,2,0,14,null,null,null,null,null,"dragon25"),objectify(0,0,2,16,14,0,0,null,null,null,null,null,"dragon41"),objectify(2,4,16,12,4,12,12,null,null,null,null,null,"dragon44"),objectify(2,4,20,12,12,12,0,null,null,null,null,null,"dragon60")],
			[objectify(0,16,16,16,2,0,14,null,null,null,null,null,"dragon24"),objectify(0,16,14,16,14,0,0,null,null,null,null,null,"dragon40"),objectify(11,20,14,2,6,8,0,null,null,null,null,null,"dragon0"),objectify(3,20,14,2,6,8,0,null,null,null,null,null,"dragon0"),objectify(2,9,32,12,4,0,12,null,null,null,null,null,"dragon44"),objectify(2,9,28,12,12,0,0,null,null,null,null,null,"dragon60"),objectify(4,11,31,2,4,4,0,null,null,null,null,null,"dragon7"),objectify(10,11,31,2,4,4,0,null,null,null,null,null,"dragon7")],
			[objectify(16,16,16,16,2,0,14,null,null,null,null,null,"dragon40"),objectify(16,14,16,16,14,0,0,null,null,null,null,null,"dragon56"),objectify(13,20,14,2,4,6,6,null,null,null,null,null,"dragon0"),objectify(5,20,14,2,4,6,6,null,null,null,null,null,"dragon0"),objectify(14,9,32,12,4,0,12,null,null,null,null,null,"dragon60"),objectify(14,5,32,12,1,0,0,null,null,null,null,null,"dragon76"),objectify(6,11,31,2,2,4,4,null,null,null,null,null,"dragon7"),objectify(12,11,31,2,2,4,4,null,null,null,null,null,"dragon7")],
			[objectify(0,16,0,16,2,0,14,null,null,null,null,null,"dragon42"),objectify(0,14,0,16,14,0,0,null,null,null,null,null,"dragon58"),objectify(11,20,8,2,4,14,6,null,null,null,null,null,"dragon0"),objectify(3,20,8,2,4,14,6,null,null,null,null,null,"dragon0"),objectify(4,11,27,2,2,4,14,null,null,null,null,null,"dragon7"),objectify(10,11,27,2,2,4,14,null,null,null,null,null,"dragon7")],
			[objectify(16,16,0,16,2,0,14,null,null,null,null,null,"dragon41"),objectify(16,14,0,16,14,0,0,null,null,null,null,null,"dragon57"),objectify(13,20,8,6,4,8,6,null,null,null,null,null,"dragon0"),objectify(5,20,8,6,4,8,6,null,null,null,null,null,"dragon0"),objectify(14,9,16,16,4,12,12,null,null,null,null,null,"dragon60"),objectify(14,5,16,16,1,12,12,null,null,null,null,null,"dragon76"),objectify(12,11,27,4,2,6,4,null,null,null,null,null,"dragon7"),objectify(6,11,27,4,2,6,4,null,null,null,null,null,"dragon7")],
			[objectify(0,16,16,16,2,0,14,null,null,null,null,null,"dragon39"),objectify(0,14,16,16,14,0,0,null,null,null,null,null,"dragon55"),objectify(3,20,14,6,4,0,6,null,null,null,null,null,"dragon0"),objectify(11,20,14,6,4,0,6,null,null,null,null,null,"dragon0"),objectify(2,9,32,16,4,0,12,null,null,null,null,null,"dragon59"),objectify(2,5,32,16,1,0,0,null,null,null,null,null,"dragon75"),objectify(4,11,31,4,2,0,4,null,null,null,null,null,"dragon7"),objectify(10,11,31,4,2,0,4,null,null,null,null,null,"dragon7")]
		]
	},
	enderDragonMouthBottom:{
		verts:[
			[objectify(2,4,8,12,15,12,1,null,null,null,null,null,"dragon76"),objectify(2,4,23,12,1,12,0,null,null,null,null,null,"dragon92")],
			[objectify(2,8,24,12,15,0,1,null,null,null,null,null,"dragon76"),objectify(2,8,9,12,1,0,0,null,null,null,null,null,"dragon92")],
			[objectify(14,8,24,12,4,0,1,null,null,null,null,null,"dragon93")],
			[],
			[objectify(14,8,8,16,4,12,1,null,null,null,null,null,"dragon93")],
			[objectify(2,8,24,16,4,0,1,null,null,null,null,null,"dragon92")]
		]
	},

	minecart:{
		verts:[
			[objectify(0,0,-2,16,20,2,12,false,false,1)],
			[objectify(0,10,18,16,2,2,0),objectify(0,10,16,2,16,2,0,false,false,1),objectify(14,10,16,2,16,2,0,false,false,-1),objectify(0,10,0,16,2,2,0,false,false,2),objectify(2,2,16,12,16,26,14,false,false,-1)],
			[objectify(16,10,18,16,8,20,2),objectify(14,10,0,12,8,4,2),objectify(16,2,18,16,2,0,12,false,false,1)],
			[objectify(0,10,-2,16,8,20,2),objectify(2,10,16,12,8,4,2),objectify(0,2,-2,16,2,22,12,false,false,1)],
			[objectify(16,10,0,16,8,20,2),objectify(2,10,0,16,8,2,2),objectify(16,2,-2,20,2,2,10),objectify(16,10,-2,2,8,18,2),objectify(16,10,16,2,8,0,2)],
			[objectify(0,10,16,16,8,20,2),objectify(14,10,16,16,10,2,2),objectify(0,2,18,20,2,22,10),objectify(0,10,18,2,8,18,2),objectify(0,10,0,2,8,0,2)]
		],
		texWidth:64,
		texHeight:32
	},
	blockParticle: {
		verts: [
			[], //bottom
			[], //top
			[objectify( 16, 16, 8, 16, 16, 0, 0)], //north
			[objectify(  0, 16, 8, 16, 16, 0, 0)], //south
			[], //east
			[]  //west
		]
	},
	
	panorama: {
		verts: /*
		(function(){
			var arr = [[],[],[],[],[],[]]
			var data = arr[2]
			var rt = Math.PId/360
			var s = (sin(0)+1)*8, c = (cos(0)+1)*8
			var w = rt/Math.PId*16
			for(var deg=0; deg<Math.PId; deg+=rt){
				var s2 = (sin(deg+rt)+1)*8, c2 = (cos(deg+rt)+1)*8
				var a = (deg+rt) / Math.PId
				data.push(customFace(s,16,c, s2,16,c2, s2,0,c2, s,0,c, (1-a)*16,0,w,16))
				s = s2, c = c2
			}
			return arr
		})()/*/[
			[objectify( 0, 16,  0, 16, 16, 4*16, 0, false,false,2)], //bottom
			[objectify( 0,  0, 16, 16, 16, 5*16, 0, false,false,2)], //top
			[objectify(16, 16,  0, 16, 16, 0*16, 0)], //north
			[objectify( 0, 16, 16, 16, 16, 2*16, 0)], //south
			[objectify( 0, 16,  0, 16, 16, 3*16, 0)], //east
			[objectify(16, 16, 16, 16, 16, 1*16, 0)]  //west
		],
		texWidth:16*6//*/
	}
}
win.shapes = shapes

for(var shape = 0; shape < 8; shape ++){
	shapes["layer"+(shape+1)] = {
		verts: layerShape((shape+1)*2),
		cull: {
			top: 0,
			bottom: 3,
			north: 1,
			south: 1,
			east: 1,
			west: 1
		}
	}
	shapes["liquidLayer"+(shape+1)] = {
		verts: liquidLayerShape((shape+1)*2),
		cull: {
			top: 0,
			bottom: 3,
			north: 0,
			south: 0,
			east: 0,
			west: 0
		}
	}
}

function compareArr(arr, out) {
	let minX = 1000
	let maxX = -1000
	let minY = 1000
	let maxY = -1000
	let minZ = 1000
	let maxZ = -1000
	let num = 0
	for (let i = 0; i < arr.length; i += 3) {
		num = arr[i]
		minX = minX > num ? num : minX
		maxX = maxX < num ? num : maxX
		num = arr[i + 1]
		minY = minY > num ? num : minY
		maxY = maxY < num ? num : maxY
		num = arr[i + 2]
		minZ = minZ > num ? num : minZ
		maxZ = maxZ < num ? num : maxZ
	}
	out[0] = minX
	out[1] = minY
	out[2] = minZ
	out[3] = maxX
	out[4] = maxY
	out[5] = maxZ
	return out
}
function copyArr(a, b) {
	for (let i = 0; i < a.length; i++) {
		b[i] = a[i]
	}
}
function arrayValuesEqual(a1,a2){
	if(a1.length !== a2.length) return false
	let minLen = a1.length
	for(var i=0; i<minLen; i++){
		if(a1[i] !== a2[i]){
			return false
		}
	}
	return true
}
function compareMaps(map1, map2) {//from https://stackoverflow.com/questions/35948335/how-can-i-check-if-two-map-objects-are-equal
	let testVal;
	if (map1.size !== map2.size) {
		return false;
	}
	for (let [key, val] of map1) {
		testVal = map2.get(key);
		// in cases of an undefined value, make sure the key
		// actually exists on the object so there are no false positives
		if (testVal !== val || (testVal === undefined && !map2.has(key))) {
			return false;
		}
	}
	return true;
}

let defaultWorldSettings = {
	tntExplode:true,
	killCmdOff:false,
	dayNightCycle: true,
	blocksFall: true,
	attack: true,
	fireSpreads: true,
	weatherCycle: true,
	mobSpawning: true,
	autosave: true
}
let worldSettingKeys = Object.keys(defaultWorldSettings)
win.defaultWorldSettings = defaultWorldSettings

const {DoubleToIEEE, IEEEToDouble} = (function(){
	let tempArrayBuffer = new ArrayBuffer(8)
	let tempUint32 = new Uint32Array(tempArrayBuffer), tempFloat64 = new Float64Array(tempArrayBuffer)
	return {
		DoubleToIEEE(f) {
			tempFloat64[0] = f
			return tempUint32
		},
		IEEEToDouble(a,b) {
			tempUint32[0] = a
			tempUint32[1] = b
			return tempFloat64[0]
		}
	}
})()
const textEncoder = new TextEncoder(), textDecoder = new TextDecoder()

class BitArrayBuilder {
	//chaning this requires changing server side
	constructor() {
		this.bitLength = 0
		this.data = [] // Byte array
	}
	add(num, bits) {
		if (+num !== +num || +bits !== +bits || +bits < 0) throw new Error("Broken")
		num &= -1 >>> 32 - bits
		if(Math.log2(num) >= bits) throw new Error("too big")
		let index = this.bitLength >>> 3
		let openBits = 8 - (this.bitLength & 7)
		this.bitLength += bits
		while (bits > 0) {
			this.data[index] |= openBits >= bits ? num << openBits - bits : num >>> bits - openBits
			bits -= openBits
			index++
			openBits = 8
		}
		return this // allow chaining like arr.add(x, 16).add(y, 8).add(z, 16)
	}
	addDouble(num){
		let [a,b] = DoubleToIEEE(num)
		this.add(a,32), this.add(b,32)
	}
	addBasicString(str, lenBits = 8){
		this.add(min(str.length,255),lenBits)
		for(let c of str.substring(0,255)) this.add(c.charCodeAt(0),8)
	}
	addString(str,lenBits = 8){
		if(!str.length) return this.add(0,lenBits)
		let arr = textEncoder.encode(str), len = arr.length
		this.add(len,lenBits)
		this.appendArray(arr.subarray(0,len))
	}
	/**
	 * Takes all the bits from another BAB and adds them to this one.
	 * @param {BitArrayBuilder} bab The BAB to append
	 */
	append(bab) {
		// If our bits are already aligned, just add them directly
		if ((this.bitLength & 7) === 0) {
			this.data.push(...bab.data)
			this.bitLength += bab.bitLength
			return
		}

		// Add them 1 at a time, except for the last one
		let bits = bab.bitLength
		let i = 0
		while (bits > 7) {
			this.add(bab.data[i++], 8)
			bits -= 8
		}
		if (bits) {
			this.add(bab.data[i] >>> 8 - bits, bits)
		}
	}
	appendArray(arr){//same as above, but for Uint8Array
		if ((this.bitLength & 7) === 0) {
			this.data.push(...arr)
			this.bitLength += arr.length*8
			return
		}
		for(let i of arr) this.add(i, 8)
	}
	appendInt16Array(arr){//same as above, but for Int16Array
		for(let i of arr) this.add(i, 16)
	}
	get array() {
		return new Uint8Array(this.data)
	}
	/**
	 * @param {Number} num
	 * @returns The number of bits required to hold num
	 */
	static bits(num) {
		return Math.ceil(Math.log2(num))
	}
}
win.BitArrayBuilder = BitArrayBuilder
class BitArrayOverwriter extends BitArrayBuilder{
	constructor(data){
		super()
		this.data = data
	}
	skip(bits){
		this.bitLength += bits
		return this
	}
	overwrite(num, bits){
		if (+num !== +num || +bits !== +bits || +bits < 0) throw new Error("Broken")
		num &= -1 >>> 32 - bits
		if(Math.log2(num) >= bits) throw new Error("too big")
		let index = this.bitLength >>> 3
		let openBits = 8 - (this.bitLength & 7)
		this.bitLength += bits
		while (bits > 0) {
			if(openBits >= bits){
				this.data[index] = (this.data[index] & (~(((1 << bits)-1)<<(openBits - bits)))) | (num << openBits - bits)
			}else{
				this.data[index] = (this.data[index] & (~((1 << openBits)-1))) | (num >>> bits - openBits)
			}
			bits -= openBits
			index++
			openBits = 8
		}
		return this // allow chaining like arr.add(x, 16).add(y, 8).add(z, 16)
	}
}
win.BitArrayOverwriter = BitArrayOverwriter
class BitArrayReader {
	//chaning this requires changing server side
	/**
	 * @param {Uint8Array} array An array of values from 0 to 255
	 */
	constructor(array, allowPassLength) {
		this.data = array // Byte array; values are assumed to be under 256
		this.bit = 0
		this.allowPassLength = allowPassLength
	}
	get canRead(){
		return this.bit < this.data.length*8
	}
	read(bits, negative = false) {
		let openBits = 32 - bits
		let { data, bit } = this
		this.bit += bits // Move pointer
		if (bit > data.length * 8 && !this.allowPassLength) {
			throw new RangeError("Cannot read more bits")
		}

		let unread = 8 - (bit & 7)
		let index = bit >>> 3
		let ret = 0
		while (bits > 0) {
			let n = data[index] & -1 >>> 32 - unread
			ret |= bits >= unread ? n << bits - unread : n >> unread - bits
			bits -= unread
			unread = 8
			index++
		}
		if (negative) {
			// console.log("Negative", ret, ret << openBits >> openBits)
			return ret << openBits >> openBits
		}
		return ret
	}
	readDouble(){
		return IEEEToDouble(this.read(32),this.read(32))
	}
	readBasicString(lenBits = 8){
		let len = this.read(lenBits)
		let str = ""
		for (let i = 0; i < len; i++) str += String.fromCharCode(this.read(8))
		return str
	}
	readString(lenBits = 8){
		let len = this.read(lenBits)
		if(!len) return ""
		let arr = new Uint8Array(len)
		for(let i=0; i<len; i++){
			arr[i] = this.read(8)
		}
		return textDecoder.decode(arr)
	}
	readToNew(bits, allowPassLength){
		let ret = new Uint8Array(ceil(bits/8))
		let idx = 0
		while(bits){
			let next = min(bits,8)
			bits -= next
			ret[idx] = this.read(next) << (8-next)
			idx++
		}
		return new BitArrayReader(ret, allowPassLength)
	}
	readToArrayBits(bits){
		let ret = new Uint8Array(ceil(bits/8))
		let idx = 0
		while(bits){
			let next = min(bits,8)
			bits -= next
			ret[idx] = this.read(next) << (8-next)
			idx++
		}
		return ret
	}
	readToArray(length){
		let ret = new Uint8Array(length)
		for(let i = 0; i < length; i++){
			ret[i] = this.read(8)
		}
		return ret
	}
	readToInt16Array(length){
		let ret = new Uint8Array(length)
		for(let i = 0; i < length; i++){
			ret[i] = this.read(16, true)
		}
		return ret
	}
	skip(bits){
		if (this.bit > this.data.length * 8 && !this.allowPassLength) {
			throw new Error("Cannot read more bits")
		}
		this.bit += bits
	}
}
win.BitArrayReader = BitArrayReader

/*
Each item in packetTypes is an array.
The array starts with the name of the packet,
then contains more arrays with property, type, and other things.
These are the types:
	string, number, bitArray, array, object, boolean,
	replacerNumber, mapObject, json, double, int16Array,
	includeIf, constant, basicString, int, uint, byte,
	sparseArray

For numbers, there are 3 more items that are
the amount of bits needed and how much to
multiply the number by (for precision) and a
boolean that shows if the number can be negative.

For arrays and mapObjects and sparseArrays, there is another item that is the type
of things that it will contain.

For objects, there is another item that contains
arrays, each with a property and a type.

For replacerNumbers, there are two more items
which contains the bits, then an object that
contain things to replace.

For includeIf, there the property name is replaced
with a function that checks returns a boolean.
If the function returns true, the things in the
3rd item are included.
*/
const packetDimension = ['dimension',"replacerNumber",3,["","nether","end"]]
//const packetInv = ["inv","object",[["inv","bitArray"],["survivStr","bitArray"],[o=>o.x!==undefined,"includeIf",[["x","int"],["y","int"],["z","int"]]]]]
const packetGameMode = ['gameMode',"replacerNumber",2,["creative","survival","hardcore","spectator"]]
const packetSlot = [null,"object",[["id","uint"],["amount","byte"],[o=>o.durability!==undefined,"includeIf",["durability","uint"]],[o=>o.customName,"includeIf",["customName","string"]]]]
const packetP = [
	['x',"double"], ['y',"double"], ['z',"double"],packetDimension, ['ry',"double"], ['rx',"double"], ['bodyRot',"double"],
	['sneaking',"boolean"], ['username',"string"], ['harmEffect',"number",6,1],
	[o=>o.crackPos,'includeIf',[['crackPos',"array",[null,"int"]]]], ['crack',"number",5,1,true], ['burning',"boolean"], ['holding',"uint"], ['walking',"boolean"], ['eating',"boolean"], ['sprinting',"boolean"], ['punchEffect',"number",8,8],
	['sleeping',"boolean"], ['sitting',"boolean"], ['swimming',"boolean"], ['usingItem',"boolean"], ['hidden',"boolean"], ['spectating',"basicString"], ['scale',"double"],
	["velx","double"],["vely","double"],["velz","double"], ["die","boolean"], ["riding","basicString"], ["onGround","boolean"], ["flying",'boolean']
]
const packetFace = ["face","replacerNumber",3,[undefined/*for no face*/,"bottom","top","north","south","east","west"]]
let packetTypes = [
	["connect",["id","basicString"]],
	["pos",["data","object",packetP],["afk","boolean"]],
	["mySkin", ["data","string"], ["cape","string"]],
	["settings", ["data","object",worldSettingKeys.map(r => [r,"boolean"])],["time","double"],["weather","replacerNumber",2,["","rain","snow"]]],
	["setBlock", ["data","object",[["x","int"],["y","int"],["z","int"],packetDimension,["block","uint"],["keepTags","boolean"]]]],
	["loadSave", /*["data","bitArray"], ["stringChunks","number",8,1]*/ ["mod","string"],["id","basicString"],["name","string"],["activeResourcePacks","array",[null,"string"]],["x","double"],["y","double"],["z","double"],["version","basicString"],["time","double"],["weather","replacerNumber",2,["","rain","snow"]],packetGameMode,["cheats","boolean"],["hotbarSlot","byte"],["flying",'boolean'],["achievments","array",[null,"uint"]]],
	//["loadSaveChunk", ["data","bitArray"],["idx","number",8,1]],
	["resourcePacks",["activeResourcePacks","array",[null,"string"]]],
	["serverCmds",["data","array",[null,"object",[["type","basicString"],["name","basicString"],["id","uint"],["next","array",[null,"uint"]],["redirect","uint"],["info","string"],["argType","basicString"],["func","boolean"],["noCheats","boolean"]]]]],
	["saveProg",["data","basicString"]],
	["canSendPos"],
	["setTags",["x","int"],["y","int"],["z","int"],packetDimension,["data","json"],["lazy","boolean"]],
	["serverChangeBlock",["x","int"],["y","int"],["z","int"],packetDimension,["place","boolean"],packetFace,["shift","boolean"],["blockMode","uint"],["rotate","uint"],["flip","uint"]],
	["entityPos",["data","bitArray"]],
	["entityDelete",["id","basicString"]],
	["entityPosAll", ["data","array",[null,"bitArray"]]],
	//["entEvent",["id","basicString"],["event","basicString"],["data","json"]],
	["particles",["particleType","basicString"],["x","double"],["y","double"],["z","double"],packetDimension,["amount","byte"],["data","json"]],
	["achievment",["data","uint"]],
	//["hit",["damageType","basicString"],["damage","byte"],["velx","double"],["vely","double"],["velz","double"],["username","string"],["id","basicString"],["message","string"],["x","double"],["y","double"],["z","double"],["holding","json"],["burn","number",8,4],["isEntity","boolean"]],
	["harmEffect",["id","basicString"]],
	["die",["id","basicString"],["message","string"]],
	["message",["username","string"],["data","string"],["fromServer","boolean"]],
	["playSound",["x","double"],["y","double"],["z","double"],["data","string"],["volume","double"],["pitch","double"],["hasPos","boolean"]],
	["title",["data","string"],["sub","string"],["color","string"],["fadeIn","number",32,1],["fadeOut","number",32,1],["stay","number",32,1]],
	["remoteControl",["event","basicString"],["key","basicString"],["x","double"],["y","double"]],
	["eval",["data","string"]], ["safeEval",["data","json"]],
	["error",["data","string"]],
	["joined"],
	//["serverCmd",["data","string"],["args","json"],["id","string"],["scope","json"]],
	["runCmd",["data","string"]],
	["loadChunks",["data","array",[null,"int"]],["loadDistance","number",6,1],packetDimension],
	["chunkData",["x","int"],["z","int"],["data","bitArray"],["tops","int16Array"],["solidTops","int16Array"],["biomes","bitArray"],["caveY","int16Array"],["caveBiomes","bitArray"]],
	["tp",['x',"double"],['y',"double"],['z',"double"],packetDimension],
	//["commandDone",["id","string"],["data","json"],["scope","json"]],
	["clientCmd",["data","basicString"],["args","json"]],
	["dc",["data","basicString"]],
	["fetchUsers"],
	//["entClick",["id","string"],["holding","uint"],["fromItem","json"]],
	["effects",["data","mapObject",[null,"object",[["name","string"],["level","byte"],["time","int"],["showParticles","boolean"]]]]],
	["gameMode",packetGameMode,["spectating","basicString"],["spectateRemoteControl","boolean"]],
	["openContainer",["data","string"],["x","int"],["y","int"],["z","int"],packetDimension,["side","boolean"]],
	//["containerData",["data","sparseArray",packetSlot]],
	["containerChange",["data","sparseArray",packetSlot],["idxs","array",[null,"int"]]],
	["hotbar",["slot","byte"]],
	["entInteract",["data","basicString"],["hit","boolean"],["cooldown","double"]],
	["respawn"],
	["health",["health","double"],["food","double"],["foodSaturation","double"],["oxygen","double"],["burning","boolean"],["freezeEffect","uint"],["XP","double"],["level","uint"],["nextLevel","uint"]],
	["damage",["x","double"],["y","double"],["z","double"],["lastHealth","double"],["velx","double"],["vely","double"],["velz","double"]],
	["jump"], ["sleep"], ["sit",["riding","basicString"]],
	["rot",["rx","double"],["ry","double"],["bodyRot","double"]],
	["closeContainer"],
	["containerChangeFurnace",["burnProgress","double"],["progress","double"]],
	["containerChangeAnvil",["rename","string"],["cost","uint"]],
	["containerChangeCommandBlock",["data","string"]],
	["startBreak",["x","int"],["y","int"],["z","int"]],
	["containerChangeSign",["data","string"],["side","boolean"]],
	["portalOut"], ["doEndPoem"]
	/*["test",
		["a",'string'],['n','number',8,4],
		["data","array",[null,"string"]],
		['n2','number',32,1]
	]*/
]
win.unorderedPackets = new Set(["chunkData"])
let packetNames = []
let packetIds = {}, defaultPacketData = [["FROM","basicString"],["USER","string"],["TO","basicString"]]
for(let i=0; i<packetTypes.length; i++){
	let t = packetTypes[i]
	if(!t) throw new Error("after "+packetNames[i-1])
	packetIds[t[0]] = i
	packetNames[i] = t[0]
	t.shift()
	t.unshift(...defaultPacketData)
}
win.packetTypes = packetTypes
function packetPartToBitArray(i,bab,v){
	switch(i[1]){
		case "number":
			bab.add((v||0)*i[3],i[2])
			break
		case "json":
			v = v ? JSON.stringify(v) : ""
		case "string":
			if(v){
				v = v+""
				bab.addString(v,32)
			}else bab.add(0,32)
			break
		case "bitArray":
			if(v){
				bab.add(v.length,32)
				bab.appendArray(v)
			}else bab.add(0,32)
			break
		case "int16Array":
			if(v){
				bab.add(v.length,32)
				bab.appendInt16Array(v)
			}else bab.add(0,32)
			break
		case "array":
			bab.add(v.length,32)
			for(let j of v){
				packetPartToBitArray(i[2],bab,j)
			}
			break
		case "object":
			bab.add(v?1:0,1)
			if(v) packetToBitArrayLoop(i[2],v,bab)
			break
		case "boolean":
			bab.add(v?1:0,1)
			break
		case "replacerNumber":
			let idx = i[3].indexOf(v)
			if(idx === -1) throw new Error("Unknown replacer number for "+v)
			bab.add(idx,i[2])
			break
		case "mapObject":
			bab.add(Object.keys(v).length,32)
			for(let j in v){
				bab.addString(j,8)
				packetPartToBitArray(i[2],bab,v[j])
			}
			break
		case "constant":
			bab.add(i[2],8)
			break
		case "basicString":
			bab.addBasicString((v||"")+"")
			break
		case "int":
		case "uint":
			bab.add(v||0,32)
			break
		case "byte":
			bab.add(v||0,8)
			break
		case "double":
			bab.addDouble(v||0)
			break
		case "sparseArray":
			bab.add(v.length,32)
			for(let j of v){
				bab.add(j?1:0,1)
				if(j) packetPartToBitArray(i[2],bab,j)
			}
			break
	}
}
function packetToBitArrayLoop(type,obj,bab){
	for(let i of type){
		if(i[1] === "includeIf"){
			if(i[0](obj)){
				bab.add(1,1)
				packetToBitArrayLoop(i[2],obj,bab)
			}else bab.add(0,1)
			continue
		}
		const v = obj[i[0]]
		packetPartToBitArray(i,bab,v)
	}
}
function packetToBitArray(obj, type, returnBAB, bab){
	if(type){
		if(!bab) bab = new BitArrayBuilder()
	}else{
		let id = packetIds[obj.type]
		type = packetTypes[id]
		if(!type) throw new Error("Unknown packet type: "+obj.type)
		if(!bab) bab = new BitArrayBuilder()
		bab.add(id,8)
	}
	packetToBitArrayLoop(type,obj,bab)
	return returnBAB ? bab : bab.array
}
win.packetToBitArray = packetToBitArray
function bitArrayToPacketPart(i,reader){
	switch(i[1]){
		case "number":
			return reader.read(i[2],i[4])/i[3]
		case "string":
			return reader.readString(32)
		case "bitArray":
			let len = reader.read(32)
			return reader.readToArray(len)
		case "array":
			let len2 = reader.read(32), arr = []
			for(let j=0; j<len2; j++){
				arr.push(bitArrayToPacketPart(i[2],reader))
			}
			return arr
		case "object":
			if(reader.read(1)){
				let obj = {}
				bitArrayToPacketLoop(i[2],obj,reader)
				return obj
			}else return
		case "boolean":
			return reader.read(1)
		case "replacerNumber":
			return i[3][reader.read(i[2])]
		case "mapObject":
			let len3 = reader.read(32)
			let obj = {}
			for(let j=0; j<len3; j++){
				obj[reader.readString()] = bitArrayToPacketPart(i[2],reader)
			}
			return obj
		case "json":
			let str2 = reader.readString(32)
			return str2 ? JSON.parse(str2) : undefined
		case "int16Array":
			let len4 = reader.read(32)
			return reader.readToInt16Array(len4)
		case "constant":
			return reader.read(8)
		case "basicString":
			return reader.readBasicString()
		case "int":
			return reader.read(32,true)
		case "uint":
			return reader.read(32)
		case "byte":
			return reader.read(8)
		case "double":
			return reader.readDouble()
		case "sparseArray":
			let len5 = reader.read(32), arr2 = []
			for(let j=0; j<len5; j++){
				arr2.push(reader.read(1) ? bitArrayToPacketPart(i[2],reader) : undefined)
			}
			return arr2
	}
}
function bitArrayToPacketLoop(type,obj,reader){
	for(let i of type){
		if(i[1] === "includeIf"){
			if(reader.read(1)){
				bitArrayToPacketLoop(i[2],obj,reader)
			}
			continue
		}
		obj[i[0]] = bitArrayToPacketPart(i,reader)
	}
}
function bitArrayToPacket(arr,type){
	let reader = arr instanceof BitArrayReader ? arr : new BitArrayReader(arr)
	let obj
	if(type){
		obj = {}
	}else{
		let id = reader.read(8)
		type = packetTypes[id], obj = {type:packetNames[id]}
	}
	bitArrayToPacketLoop(type,obj,reader)
	return obj
}
win.bitArrayToPacket = bitArrayToPacket

function initShapes() {
	function mapCoords(rect, face, texWidth,texHeight) {
		if(rect.custom) return mapCustomCoords(rect, texWidth,texHeight)
		let x = rect.x
		let y = rect.y
		let z = rect.z
		let w = rect.w
		let h = rect.h
		let tx = rect.tx
		let ty = rect.ty
		let tw = rect.tw
		let th = rect.th
		let tex = [tx+tw,ty, tx,ty, tx,ty+th, tx+tw,ty+th]
		if(rect.rt){
			if(rect.rt === -1){
				tex[0] = tx+th
				tex[5] = ty+tw
				tex[6] = tx+th
				tex[7] = ty+tw
				tex.unshift(...tex.splice(tex.length-2,2))
			}else if(rect.rt === 2){
				tex.push(...tex.splice(0,4))
			}else{
				tex[0] = tx+th
				tex[5] = ty+tw
				tex[6] = tx+th
				tex[7] = ty+tw
				tex.push(...tex.splice(0,2))
			}
		}
		if(rect.txf){
			tex[0] = tw-(tex[0]-tx)+tx
			tex[2] = tw-(tex[2]-tx)+tx
			tex[4] = tw-(tex[4]-tx)+tx
			tex[6] = tw-(tex[6]-tx)+tx
		}
		if(rect.tyf){
			tex[1] = th-(tex[1]-ty)+ty
			tex[3] = th-(tex[3]-ty)+ty
			tex[5] = th-(tex[5]-ty)+ty
			tex[7] = th-(tex[7]-ty)+ty
		}
		let pos = null, normal = null
		switch(face) {
			case 0: // Bottom
				pos = [x,y,z, x+w,y,z, x+w,y,z+h, x,y,z+h]
				normal = [0,1,0]
				break
			case 1: // Top
				pos = [x,y,z, x+w,y,z, x+w,y,z-h, x,y,z-h]
				normal = [0,-1,0]
				break
			case 2: // North
				pos = [x,y,z, x-w,y,z, x-w,y-h,z, x,y-h,z]
				normal = [0,0,-1]
				break
			case 3: // South
				pos = [x,y,z, x+w,y,z, x+w,y-h,z, x,y-h,z]
				normal = [0,0,1]
				break
			case 4: // East
				pos = [x,y,z, x,y,z+w, x,y-h,z+w, x,y-h,z]
				normal = [-1,0,0]
				break
			case 5: // West
				pos = [x,y,z, x,y,z-w, x,y-h,z-w, x,y-h,z]
				normal = [1,0,0]
				break
		}
		pos = pos.map(c => c / 16 - 0.5)
		let minmax = compareArr(pos, [])
		pos.max = minmax.splice(3, 3)
		pos.min = minmax
		for(let i=0; i<tex.length; i+=2){
			tex[i] /= texWidth
			tex[i+1] /= texHeight
		}
		
		return {
			pos,
			tex,
			normal
		}
	}
	function mapCustomCoords(coords,texWidth,texHeight){
		let {x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4, tx,ty,tw,th} = coords
		let tex = [tx+tw,ty, tx,ty, tx,ty+th, tx+tw,ty+th]
		let pos = [x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4]
		pos = pos.map(c => c / 16 - 0.5)
		let minmax = compareArr(pos, [])
		pos.max = minmax.splice(3, 3)
		pos.min = minmax
		for(let i=0; i<tex.length; i+=2){
			tex[i] /= texWidth
			tex[i+1] /= texHeight
		}

		vec1.set(x2-x,y2-y,z2-z)
		vec1.crossProduct(x3-x,y3-y,z3-z,vec3)
		vec2.set(x3-x,y3-y,z3-z)
		vec2.crossProduct(x4-x,y4-y,z4-z,vec4)
		vec3.normalize(), vec4.normalize()
		let normal = [-(vec3.x+vec4.x)/2, -(vec3.y+vec4.y)/2, -(vec3.z+vec4.z)/2]

		return {pos,tex,normal}
	}
	
	// 90 degree clockwise rotation; returns a new shape object
	function rotate(shape, bit) {
		let verts = shape.verts
		let texVerts = shape.texVerts
		let cull = shape.cull
		let pos = []
		let normal = []
		let tex = []
		for (let i = 0; i < verts.length; i++) {
			let side = verts[i]
			pos[i] = []
			tex[i] = []
			normal[i] = []
			for (let j = 0; j < side.length; j++) {
				let face = side[j]
				let c = []
				pos[i][j] = c
				for (let k = 0; k < face.length; k += 3) {
					c[k] = face[k + 2]
					c[k + 1] = face[k + 1]
					c[k + 2] = -face[k]
				}
				
				tex[i][j] = texVerts[i][j].slice() // Copy texture verts exactly
				if (i === 0) {
					// Bottom
					c.push(...c.splice(0, 3))
					tex[i][j].push(...tex[i][j].splice(0, 2))
				}
				if (i === 1) {
					// Top
					c.unshift(...c.splice(-3, 3))
					tex[i][j].unshift(...tex[i][j].splice(-2, 2))
				}

				let minmax = compareArr(c, [])
				c.max = minmax.splice(3, 3)
				c.min = minmax

				normal[i][j] = shape.normal[i][j].slice()
				let temp = normal[i][j][0]
				normal[i][j][0] = normal[i][j][2]
				normal[i][j][2] = -temp
			}
		}
		let temp = tex[2] // North
		tex[2] = tex[5] // North = West
		tex[5] = tex[3] // West = South
		tex[3] = tex[4] // South = East
		tex[4] = temp // East = North

		temp = pos[2] // North
		pos[2] = pos[5] // North = West
		pos[5] = pos[3] // West = South
		pos[3] = pos[4] // South = East
		pos[4] = temp // East = North

		temp = normal[2] // North
		normal[2] = normal[5] // North = West
		normal[5] = normal[3] // West = South
		normal[3] = normal[4] // South = East
		normal[4] = temp // East = North

		let cull2 = {
			top: cull.top,
			bottom: cull.bottom,
			north: cull.west,
			west: cull.south,
			south: cull.east,
			east: cull.north
		}

		return {
			verts: pos,
			texVerts: tex,
			normal,
			cull: cull2,
			rotate: true,
			flip: shape.flip,
			size: shape.size,
			varients: shape.varients,
			bit: bit,
			rotated: true,
			rotateTimes: (shape.rotateTimes || 0) + 1,
			originalVerts: shape.originalVerts,
			hitbox: shape.hitbox
		}
	}

	// Reflect over the y plane; returns a new shape object
	function flip(shape, bit) {
		let verts = shape.verts
		let texVerts = shape.texVerts
		let cull = shape.cull
		let pos = []
		let normal = []
		let tex = []
		for (let i = 0; i < verts.length; i++) {
			let side = verts[i]
			pos[i] = []
			tex[i] = []
			normal[i] = []
			for (let j = 0; j < side.length; j++) {
				let face = side[j].slice().reverse()
				let c = []
				pos[i][j] = c
				for (let k = 0; k < face.length; k += 3) {
					c[k] = face[k + 2]
					c[k + 1] = -face[k + 1]
					c[k + 2] = face[k]
				}
				let minmax = compareArr(c, [])
				c.max = minmax.splice(3, 3)
				c.min = minmax

				tex[i][j] = texVerts[i][j].slice() // Copy texture verts exactly

				normal[i][j] = shape.normal[i][j].slice()
				normal[i][j][1] = -normal[i][j][1]
			}
		}
		let temp = pos[0] // Bottom
		pos[0] = pos[1] // Bottom = Top
		pos[1] = temp // Top = Bottom

		temp = tex[0] // Bottom
		tex[0] = tex[1] // Bottom = Top
		tex[1] = temp // Top = Bottom

		temp = normal[0] // Bottom
		normal[0] = normal[1] // Bottom = Top
		normal[1] = temp // Top = Bottom

		let cull2 = {
			top: cull.bottom,
			bottom: cull.top,
			north: (cull.north & 1) << 1 | (cull.north & 2) >> 1,
			west: (cull.west & 1) << 1 | (cull.west & 2) >> 1,
			south: (cull.south & 1) << 1 | (cull.south & 2) >> 1,
			east: (cull.east & 1) << 1 | (cull.east & 2) >> 1
		}

		return {
			verts: pos,
			texVerts: tex,
			normal,
			cull: cull2,
			rotate: shape.rotate,
			flip: shape.flip,
			size: shape.size,
			varients: shape.varients,
			bit: bit,
			originalVerts: shape.originalVerts
		}
	}

	for (let shape in shapes) {
		win.sh = shape
		let obj = shapes[shape]
		let verts = obj.verts
		obj.size = verts[0].length + verts[1].length + verts[2].length + verts[3].length + verts[4].length + verts[5].length
		obj.texVerts = []
		obj.varients = [obj]
		obj.normal = []
		if(typeof obj.hitbox === "string"){
			obj.hitbox = shapes[obj.hitbox]
		}
		
		obj.originalVerts = []
		for(let i=0; i<verts.length; i++){
			obj.originalVerts[i] = verts[i].slice()
		}
		
		// Populate the vertex coordinates
		let {texWidth = 16, texHeight = 16} = obj
		for (let i = 0; i < verts.length; i++) {
			let side = verts[i]
			let texArr = []
			obj.texVerts.push(texArr)
			let normal = obj.normal[i] = []
			for (let j = 0; j < side.length; j++) {
				let face = side[j]
				let mapped = mapCoords(face, i, texWidth,texHeight)
				side[j] = mapped.pos
				texArr.push(mapped.tex)
				normal[j] = mapped.normal
			}
		}

		if (obj.rotate) {
			let v = obj.varients
			let east = rotate(obj, 4<<10)
			let south = rotate(east, 2<<10)
			let west = rotate(south, 6<<10)
			v[0] = obj
			v[2] = south
			v[4] = east
			v[6] = west
		}
		if (obj.flip) {
			let v = obj.varients
			v[1] = flip(obj,1<<10)
			if (obj.rotate) {
				v[3] = flip(v[2], 3<<10)
				v[5] = flip(v[4], 5<<10)
				v[7] = flip(v[6], 7<<10)
			}
		}
	}
}
function initBlockDataShapes(){
	function makeBlock(tex,shape,Block, base, Name){
		Block.textures = tex
		Block.shape = shape
		Block.shadow = base ? base.shadow : true
		Block.transparent = base ? base.transparent : false
		Block.solid = base ? base.solid : true
		
		if(Name) Block.Name = Name
	}
	
	function rotTex(tex,n){
		tex = tex.slice()
		if(n){
			for(var i=0; i<n; i++){
				let temp = tex[2] // North
				tex[2] = tex[5] // North = West
				tex[5] = tex[3] // West = South
				tex[3] = tex[4] // South = East
				tex[4] = temp // East = North
			}
		}else{
			let temp = tex[2] // North
			tex[2] = tex[5] // North = West
			tex[5] = tex[3] // West = South
			tex[3] = tex[4] // South = East
			tex[4] = temp // East = North
		}
		return tex
	}
	
	var buttonOnclick = function(x,y,z,world){
		var off = this.id | BUTTON
		var on = this.id | SLAB
		var target = null
		switch(world.getBlock(x,y,z)){
			case off | NORTH:
				target = on | NORTH
				break
			case off | SOUTH:
				target = on | SOUTH
				break
			case off | EAST:
				target = on | EAST
				break
			case off | WEST:
				target = on | WEST
		}
		if(target){
			world.setBlock(x,y,z,target)
		}
	}
	var buttonProjectileHit = function(x,y,z,ent){
		let world = ent.world
		this.onclick(x,y,z,world)
	}
	var buttonOnupdate = function(x,y,z,b,world,sx,sy,sz){
		var off = this.id | BUTTON
		var on = this.id | SLAB
		var target = null
		var ax=x,ay=y,az=z, dir
		var block = world.getBlock(x,y,z)
		switch(block){
			case on | NORTH:
			case off | NORTH:
				az++
				dir = "south"
				break
			case on | SOUTH:
			case off | SOUTH:
				az--
				dir = "north"
				break
			case on | EAST:
			case off | EAST:
				ax++
				dir = "east"
				break
			case on | WEST:
			case off | WEST:
				ax--
				dir = "west"
				break
		}
		var hasPower
		switch(block){
			case on | NORTH:
				target = off | NORTH
				hasPower = true
				break
			case on | SOUTH:
				target = off | SOUTH
				hasPower = true
				break
			case on | EAST:
				target = off | EAST
				hasPower = true
				break
			case on | WEST:
				target = off | WEST
				hasPower = true
				break
		}
		if(hasPower && !world.getPower(x,y,z)){
			world.setPower(x,y,z,16,false)
			world.spreadPower(x,y,z,16)
			world.setBlockPower(ax,ay,az,"strong",dir)
			world.playSound(x,y,z, "click",1,0.6)
			
			world.setTimeout(function(){
				world.setBlock(x,y,z,target, false,false,false,false)
				world.setPower(x,y,z,0,false)
				world.unspreadPower(x,y,z,16,false)
				world.setBlockPower(ax,ay,az,null,dir)
				world.playSound(x,y,z, "click",1,0.5)
			},this.stone ? tickTime*20 : tickTime*30, x,y,z)
		}
	}
	
	var pressurePlateActivate = function(x,y,z,block,ent,world){
		if(this.heavyWeighted || this.lightWeighted) return //not going to do those yet
		
		if(world.getBlock(x,y,z) === this.id && pressurePlateHasPressure(x,y,z,world)){
			world.setBlock(x,y,z, this.id | SLAB, false,false,false,false)
		}
	}
	var pressurePlateOnupdate = function(x,y,z,b,world,sx,sy,sz){
		var block = world.getBlock(x,y,z)
		if(block === (this.id | SLAB) && !world.getPower(x,y,z)){
			world.setPower(x,y,z,16,false)
			world.spreadPower(x,y,z,16)
			world.setBlockPower(x,y-1,z,"strong","top")
			world.playSound(x,y,z, "click",1,0.6)
			
			var me = this
			var i = setInterval(function(){
				if(pressurePlateHasPressure(x,y,z,world)) return
				
				clearInterval(i)
				world.setTimeout(function(){
					world.setBlock(x,y,z,me.id, false,false,false,false)
					world.setPower(x,y,z,0,false)
					world.unspreadPower(x,y,z,16,false)
					world.setBlockPower(x,y-1,z,null,"top")
					world.playSound(x,y,z, "click",1,0.5)
				}, tickTime*20, x,y,z)
			}, tickTime*2)
		}
	}
	var logicGateOnupdate = function(x,y,z,b,w,sx,sy,sz){
		this.onpowerupdate(x,y,z,null,null,null,null,w)
	}
	var logicGateOndelete = function(x,y,z,prevTags,prevBlock,world){
		world.unspreadPower(x,y,z,16)
		world.setBlockPower(x,y,z+1,null,"south")
		world.setBlockPower(x,y,z-1,null,"north")
		world.setBlockPower(x+1,y,z,null,"east")
		world.setBlockPower(x-1,y,z,null,"west")
	}
	var logicGateOnpowerupdate = function(x,y,z,sx,sy,sz,blockPowerChanged,world){
		var block = world.getBlock(x,y,z)
		var px = 0, pz = 0
		switch(block){
			case this.id | NORTH:
			case this.id | SLAB | NORTH:
				pz++
				break
			case this.id | SOUTH:
			case this.id | SLAB | SOUTH:
				pz--
				break
			case this.id | EAST:
			case this.id | SLAB | EAST:
				px++
				break
			case this.id | WEST:
			case this.id | SLAB | WEST:
				px--
				break
		}
		var shouldBeOn = this.shouldBeOn(x,y,z,px,pz,world)
		var isOn = false
		var target, tx = x, ty = y, tz = z, side
		switch(block){
			case this.id | NORTH:
				target = this.id | SLAB | NORTH
				tz++
				side = "south"
				break
			case this.id | SOUTH:
				target = this.id | SLAB | SOUTH
				tz--
				side = "north"
				break
			case this.id | EAST:
				target = this.id | SLAB | EAST
				tx++
				side = "east"
				break
			case this.id | WEST:
				target = this.id | SLAB | WEST
				tx--
				side = "west"
				break
			case this.id | SLAB | NORTH:
				isOn = true
				target = this.id | NORTH
				tz++
				side = "south"
				break
			case this.id | SLAB | SOUTH:
				isOn = true
				target = this.id | SOUTH
				tz--
				side = "north"
				break
			case this.id | SLAB | EAST:
				isOn = true
				target = this.id | EAST
				tx++
				side = "east"
				break
			case this.id | SLAB | WEST:
				isOn = true
				target = this.id | WEST
				tx--
				side = "west"
				break
		}
		
		var tblock = world.getBlock(tx,ty,tz)
		if(tblock && blockData[tblock].carryRedstone){
			if(isOn){
				if(world.getPower(tx,ty,tz) !== 15){
					world.setPower(tx,ty,tz,15,false)
					world.spreadPower(tx,ty,tz,15)
				}
			}
		}else if(tblock && !blockData[tblock].transparent){
			if(isOn){
				world.setBlockPower(tx,ty,tz,"strong",side)
			}else{
				world.setBlockPower(tx,ty,tz,null,side)
			}
		}
		if(isOn !== shouldBeOn){
			var t = function(){
				world.setBlock(x,y,z,target,false,false,false,false)
				
				var tblock = world.getBlock(tx,ty,tz)
				if(shouldBeOn){
					if(tblock && blockData[tblock].carryRedstone){
						world.setPower(tx,ty,tz,15,false)
						world.spreadPower(tx,ty,tz,15)
					}else if(tblock && !blockData[tblock].transparent){
						world.setBlockPower(tx,ty,tz,"strong",side)
					}
				}else{
					if(tblock && blockData[tblock].carryRedstone){
						world.unspreadPower(tx,ty,tz,15,true)
					}else if(tblock && !blockData[tblock].transparent){
						world.setBlockPower(tx,ty,tz,null,side)
					}
				}
			}
			world.setTimeout(t,tickTime*2, x,y,z)
		}
	}
	var logicGateGetFacing = function(x,y,z,world){
		var block = world.getBlock(x,y,z)
		switch(block){
			case this.id | NORTH:
			case this.id | SLAB | NORTH:
				return "north"
			case this.id | SOUTH:
			case this.id | SLAB | SOUTH:
				return "south"
			case this.id | EAST:
			case this.id | SLAB | EAST:
				return "east"
			case this.id | WEST:
			case this.id | SLAB | WEST:
				return "west"
		}
	}
	var logicGateCanHavePower = function(rx,ry,rz,x,y,z,world){
		var tx = rx, ty = ry, tz = rz, on
		var block = world.getBlock(rx,ry,rz)
		switch(block){
			case this.id | NORTH | SLAB:
				on = true
			case this.id | NORTH:
				tz++
				break
			case this.id | SOUTH | SLAB:
				on = true
			case this.id | SOUTH:
				tz--
				break
			case this.id | EAST | SLAB:
				on = true
			case this.id | EAST:
				tx++
				break
			case this.id | WEST | SLAB:
				on = true
			case this.id | WEST:
				tx--
				break
		}
		if(on && tx === x && ty === y && tz === z){
			return 15
		}
		return 0
	}
	var signOnplace = function(x,y,z, player,world){
		var block = world.getBlock(x,y,z)
		var tags = {sign:true}
		var rot = round(player.ry*16/Math.PId)
		if((block & STAIR) === STAIR) rot = round(rot/4)*4
		tags.rot = rot
		world.setTags(x,y,z,tags)
	}
	var signOnclick = function(x,y,z,world,p){
		if(p.holding && blockData[p.holding].dye){
			world.setTagByName(x,y,z, "color",colors.dye[blockData[p.holding].dye].slice())
		}else if(p.holding && p.holding === blockIds.glowInkSac){
			let side = getSignSide(world.getTags(x,y,z),p) ? "glow2" : "glow"
			world.setTagByName(x,y,z, side,true)
		}else{
			p.connection.send({type:"openContainer",data:"sign",x,y,z,dimension:world.dimension})
		}
	}
	var itemFrameOnclick = function(x,y,z,world, p){
		var prev = world.getTagByName(x,y,z,"block") || 0
		if(!prev && p.holding) world.setTagByName(x,y,z, "block",p.holding)
		else{
			var rot = world.getTagByName(x,y,z,"rot") || 0
			rot++
			if(rot >= 8) rot = 0
			world.setTagByName(x,y,z, "rot",rot)
		}
	}
	let doorToggle = function(x,y,z,world){
		var b = world.getBlock(x,y,z)
		var o = (b & DOOR) !== DOOR
		var shapeId = o ? (this.id | SLAB) : (this.id | DOOR)
		var setId = o ? (this.id | DOOR) : (this.id | SLAB)
		var set
		if(o){
			if((shapeId | NORTH) === b){
				set = setId | EAST
			}else if((shapeId | EAST) === b){
				set = setId | SOUTH
			}else if((shapeId | SOUTH) === b){
				set = setId | WEST
			}else if((shapeId | WEST) === b){
				set = setId | NORTH
			}
		}else{
			if((shapeId | NORTH) === b){
				set = setId | WEST
			}else if((shapeId | WEST) === b){
				set = setId | SOUTH
			}else if((shapeId | SOUTH) === b){
				set = setId | EAST
			}else if((shapeId | EAST) === b){
				set = setId | NORTH
			}
		}
		world.setBlock(x,y,z,set)
		doorSound(x,y,z,this.name === "ironDoor"?"iron_door":"wooden_door",!o,world)
	}
	let trapdoorToggle = function(x,y,z,world){
		let block = world.getBlock(x,y,z)
		let target
		switch(block){
			case this.id | TRAPDOOR | NORTH:
				target = this.id | TRAPDOOROPEN | NORTH
				break
			case this.id | TRAPDOOR | SOUTH:
				target = this.id | TRAPDOOROPEN | SOUTH
				break
			case this.id | TRAPDOOR | EAST:
				target = this.id | TRAPDOOROPEN | EAST
				break
			case this.id | TRAPDOOR | WEST:
				target = this.id | TRAPDOOROPEN | WEST
				break
		}
		world.setBlock(x,y,z,target)
		doorSound(x,y,z,this.name === "ironTrapdoor"?"iron_trapdoor":"wooden_trapdoor",true,world)
	}
	let trapdoorOpenToggle = function(x,y,z,world){
		let block = world.getBlock(x,y,z)
		let target
		switch(block){
			case this.id | TRAPDOOROPEN | NORTH:
				target = this.id | TRAPDOOR | NORTH
				break
			case this.id | TRAPDOOROPEN | SOUTH:
				target = this.id | TRAPDOOR | SOUTH
				break
			case this.id | TRAPDOOROPEN | EAST:
				target = this.id | TRAPDOOR | EAST
				break
			case this.id | TRAPDOOROPEN | WEST:
				target = this.id | TRAPDOOR | WEST
				break
		}
		world.setBlock(x,y,z,target)
		doorSound(x,y,z,this.name === "ironTrapdoor"?"iron_trapdoor":"wooden_trapdoor",false,world)
	}
	function clickBed(x,y,z,world,p){
    if(p.dimension !== "") return world.explode(x,y,z,5,false)
    p.spawnPoint.x = x
    p.spawnPoint.y = y+1
    p.spawnPoint.z = z
    p.connection.send({type:"message",data:"Respawn point set",fromServer:true})
    if(world.world.skyLight < 0.5){
      let block = world.getBlock(x,y,z)
      y += 0.25
      p.rx = Math.PI2
      switch(block & ROTATION){
        case NORTH:
          z += 0.5
          p.ry = Math.PI
          break
        case SOUTH:
          z -= 0.5
          p.ry = 0
          break
        case EAST:
          x += 0.5
          p.ry = Math.PI2
          break
        case WEST:
          x -= 0.5
          p.ry = -Math.PI2
          break
      }
			p.setRot(p.rx,p.ry,p.ry,true)
			p.tp(x,y,z)
			p.connection.send({type:"sleep"})
    }else p.connection.send({type:"message",data:"Too bright to sleep",fromServer:true})
  }
	function sit(x,y,z,world,p){
		if(x !== undefined){
			p.tp(x,y,z)
			p.riding = null
			const block = world.getBlock(x,y,z)
			switch(block & ROTATION){
				case NORTH:
					p.ry = Math.PI
					break
				case SOUTH:
					p.ry = 0
					break
				case EAST:
					p.ry = Math.PI2
					break
				case WEST:
					p.ry = -Math.PI2
					break
			}
			p.setRot(p.rx,p.ry,p.ry,true)
		}
    p.sitting = true
		p.flying = false
    p.velx = p.vely = p.velz = 0
		p.connection.send({type:"sit",riding:p.riding})
  }

	const liquidData = {
		getLevel:function(block){
			switch(block){
				case this.id | LAYER1:
					return 1
				case this.id | LAYER2:
					return 2
				case this.id | LAYER3:
					return 3
				case this.id | LAYER4:
					return 4
				case this.id | LAYER5:
					return 5
				case this.id | LAYER6:
					return 6
				case this.id | LAYER7:
					return 7
				case this.id | LAYER8:
				case this.id:
					return 8
				default:
					return 0
			}
		},
		getLevelBlock:function(l){
			switch(l){
				case 1:
					return this.id | LAYER1
				case 2:
					return this.id | LAYER2
				case 3:
					return this.id | LAYER3
				case 4:
					return this.id | LAYER4
				case 5:
					return this.id | LAYER5
				case 6:
					return this.id | LAYER6
				case 7:
					return this.id | LAYER7
				case 8:
					return this.id | LAYER8
			}
		},
		getLevelAt:function(x,y,z,world){
			var block = world.getBlock(x,y,z)
			return this.getLevel(block)
		},
		isThisHere:function(x,y,z,world){
			var b = world.getBlock(x,y,z)
			return b && blockData[b].id === this.id
		},
		isThis:function(b){
			return b && blockData[b].id === this.id
		},
		isSourceAt:function(x,y,z,d,world){
			var b = world.getBlock(x,y,z,d)
			return b === this.id
		},
		tryFlowTo:function(x,y,z,level,world,fromSource=false){
			let block = world.getBlock(x,y,z)
			const data = blockData[block]
			if(data.liquid){
				if(this.id === block) return !fromSource//source blocks must spread around other source blocks when above
				else if(this.id === data.id) return true
			}
			if(!block || data.liquidBreakable || data.liquid && this.density > data.density){
				world.setBlock(x,y,z,this.getLevelBlock(level),false,false,false,false)
				if(data.liquidBreakable === "drop"){
					world.addItems(x,y,z,0,0,0,block,true)
					world.blockParticles(block,x,y,z,30, "break")
					world.blockSound(block, "dig", x,y,z)
				}
				return true
			}
		},
		flow:function(x,y,z,world){
			let block = world.getBlock(x,y,z)
			if(!this.isThis(block)) return
			let source = block === this.id
			let level = this.getLevel(block)
			let down = world.getBlock(x,y-1,z)
			if(!source){
				if(this.canDuplicate && (world.getBlock(x,y,z+1) === this.id)+(world.getBlock(x,y,z-1) === this.id)+(world.getBlock(x+1,y,z) === this.id)+(world.getBlock(x-1,y,z) === this.id) >= 2 && (down || down === this.id)){
					return world.setBlock(x,y,z,this.id, false,false,false,false) //if two or more sources surrounding, turn into source
				}
				let levelTarget = level
				if(this.isThisHere(x,y+1,z,world)){
					levelTarget = 8
				}else{
					let around = max(this.getLevelAt(x,y,z+1,world), this.getLevelAt(x,y,z-1,world), this.getLevelAt(x+1,y,z,world), this.getLevelAt(x-1,y,z,world))
					around = this.getLevelDifference(around,world.dimension)
					if(around !== levelTarget) levelTarget = around
					if(levelTarget <= 0) return world.setBlock(x,y,z,0, false,false,false,false)
				}
				if(level !== levelTarget){
					level = levelTarget
					world.setBlock(x,y,z,this.getLevelBlock(level), false,false,false,false)
				}
			}else{
				let above = world.getBlock(x,y+1,z)
				if(blockData[above].liquid && blockData[above].density > this.density){
					world.setBlock(x,y,z,above,false,false,false,false)
					world.setBlock(x,y+1,z,block,false,false,false,false)
					return
				}
			}
			let newLevel = this.getLevelDifference(level,world.dimension)
			if(!this.tryFlowTo(x,y-1,z,8,world,source) && newLevel > 0){
				this.tryFlowTo(x,y,z+1,newLevel,world)
				this.tryFlowTo(x,y,z-1,newLevel,world)
				this.tryFlowTo(x+1,y,z,newLevel,world)
				this.tryFlowTo(x-1,y,z,newLevel,world)
			}
		},
		current:{
			x:0,z:0,
			ang4:Math.sqrt(0.5),
			ang8:Math.sqrt(5)
		},
		getCurrent:function(bx,by,bz,level,noNormalize,world){
			if(level === undefined) level = this.getLevelAt(bx,by,bz,world)
			let x = this.getLevelAt(bx-1,by,bz,world)
			let X = this.getLevelAt(bx+1,by,bz,world)
			let z = this.getLevelAt(bx,by,bz-1,world)
			let Z = this.getLevelAt(bx,by,bz+1,world)
			let current = this.current
			current.x = (X && X < level) + (x > level) - (X > level) - (x && x < level)
			current.z = (Z && Z < level) + (z > level) - (Z > level) - (z && z < level)
			if(noNormalize) return current
			let mag = Math.sqrt(current.x * current.x + current.z * current.z)
			current.x /= mag
			current.z /= mag
			return current
		},
		trySpawnFlow:function(x,y,z,world,level,spread,fromSource=false){
			let block = world.getBlock(x,y,z)
			if(blockData[block].liquid && (block&isCube) === block) return !fromSource //source blocks must spread around other source blocks when above
			let hasSpawnedUnder = this.onspawnflow && this.onspawnflow(x,y,z,world)
			if(!blockData[block].solid && level > this.getLevel(block)){
				world.spawnBlock(x,y,z,this.getLevelBlock(level),true)
				if(!hasSpawnedUnder) spread.push(x,y,z,level)
			}
			return !blockData[block].solid
		},
		spawnFlow:async function(x,y,z,world){
			let spread = [x,y,z,8], count = 0
			while(spread.length){
				let [sx,sy,sz,level] = spread
				let newLevel = this.getLevelDifference(level,world.dimension)
				if(newLevel > 0 && max(abs(sx-x),abs(sz-z)) < 16 && abs(sy-y) < 64){
					const fromSource = sx === x && sy === y && sz === z
					if(!this.trySpawnFlow(sx,sy-1,sz,world,8,spread,fromSource)){
						this.trySpawnFlow(sx+1,sy,sz,world,newLevel,spread)
						this.trySpawnFlow(sx-1,sy,sz,world,newLevel,spread)
						this.trySpawnFlow(sx,sy,sz+1,world,newLevel,spread)
						this.trySpawnFlow(sx,sy,sz-1,world,newLevel,spread)
					}
				}
				spread.splice(0,4)
				if(!((count++)%32)) await yieldThread()
			}
		}
	}

	const railData = {
		lastConnectSides: {},
		isFacing: function(x,y,z,side,setLastConnectSides,world){//are there sides of that rail facing in direction
			let block = world.getBlock(x,y,z)
			if(!blockData[block].rail) return false
			let rot = (block&ROTATION)
			if((block&isState) === CUBE || (block&isState) === SLAB){
				if(side === "north" || side === "south"){
					if(rot === NORTH || rot === SOUTH) return this.lastConnectSides[setLastConnectSides] = true
				}else{
					if(rot === EAST || rot === WEST) return this.lastConnectSides[setLastConnectSides] = true
				}
			}else{//corner rail
				if(rot === NORTH){
					if(side === "south" || side === "west") return this.lastConnectSides[setLastConnectSides] = true
				}else if(rot === SOUTH){
					if(side === "north" || side === "east") return this.lastConnectSides[setLastConnectSides] = true
				}else if(rot === WEST){
					if(side === "south" || side === "east") return this.lastConnectSides[setLastConnectSides] = true
				}else if(rot === EAST){
					if(side === "north" || side === "west") return this.lastConnectSides[setLastConnectSides] = true
				}
			}
			return false
		},
		isConnected: function(x,y,z,world){//returns number of sides connected
			let block = world.getBlock(x,y,z)
			if(!blockData[block].rail) return
			let rot = (block&ROTATION)
			if((block&isState) === CUBE){
				if(rot === NORTH || rot === SOUTH) return this.isFacing(x,y,z+1,"south","north",world) + this.isFacing(x,y,z-1,"north","south",world)
				else return this.isFacing(x+1,y,z,"west","east",world) + this.isFacing(x-1,y,z,"east","west",world)
			}else if((block&isState) === SLAB){
				if(rot === NORTH) return this.isFacing(x,y+1,z+1,"south","northUp",world) + this.isFacing(x,y,z-1,"north","south",world)
				else if(rot === SOUTH) return this.isFacing(x,y+1,z-1,"north","southUp",world) + this.isFacing(x,y,z+1,"south","north",world)
				else if(rot === EAST) return this.isFacing(x+1,y+1,z,"west","eastUp",world) + this.isFacing(x-1,y,z,"east","west",world)
				else if(rot === WEST) return this.isFacing(x-1,y+1,z,"east","westUp",world) + this.isFacing(x+1,y,z,"west","east",world)
			}else{//corner rail
				if(rot === NORTH) return this.isFacing(x,y,z-1,"north","south",world)+this.isFacing(x-1,y,z,"east","west",world)
				else if(rot === SOUTH) return this.isFacing(x,y,z+1,"south","north",world)+this.isFacing(x+1,y,z,"west","east",world)
				else if(rot === WEST) return this.isFacing(x,y,z-1,"north","south",world)+this.isFacing(x+1,y,z,"west","east",world)
				else if(rot === EAST) return this.isFacing(x,y,z+1,"south","north",world)+this.isFacing(x-1,y,z,"east","west",world)
			}
		},
		railonupdate: function(x,y,z,b,world){
			this.lastConnectSides.north = this.lastConnectSides.south = this.lastConnectSides.east = this.lastConnectSides.west = this.lastConnectSides.northUp = this.lastConnectSides.southUp = this.lastConnectSides.eastUp = this.lastConnectSides.westUp = false
			if(this.isConnected(x,y,z,world) === 2) return
			let {north:curConnectNorth, south:curConnectSouth, east:curConnectEast, west:curConnectWest, northUp:curConnectNorthUp, southUp:curConnectSouthUp, eastUp:curConnectEastUp, westUp:curConnectWestUp} = this.lastConnectSides
			//below: is the other rail available for connecting or already connected to this rail
			let north = this.isConnected(x,y,z+1,world) < 2 || curConnectNorth,
				south = this.isConnected(x,y,z-1,world) < 2 || curConnectSouth,
				east = this.isConnected(x+1,y,z,world) < 2 || curConnectEast,
				west = this.isConnected(x-1,y,z,world) < 2 || curConnectWest,
				northUp = this.isConnected(x,y+1,z+1,world) < 2 || curConnectNorthUp,
				southUp = this.isConnected(x,y+1,z-1,world) < 2 || curConnectSouthUp,
				eastUp = this.isConnected(x+1,y+1,z,world) < 2 || curConnectEastUp,
				westUp = this.isConnected(x-1,y+1,z,world) < 2 || curConnectWestUp
			this.lastConnectSides.north = false
			north = north || this.isConnected(x,y-1,z+1,world) < 2 || this.lastConnectSides.north
			this.lastConnectSides.south = false
			south = south || this.isConnected(x,y-1,z-1,world) < 2 || this.lastConnectSides.south
			this.lastConnectSides.east = false
			east = east || this.isConnected(x+1,y-1,z,world) < 2 || this.lastConnectSides.east
			this.lastConnectSides.west = false
			west = west || this.isConnected(x-1,y-1,z,world) < 2 || this.lastConnectSides.west

			let target = this.id
			if(northUp){
				target |= SLAB | NORTH
			}else if(eastUp){
				target |= SLAB | EAST
			}else if(southUp){
				target |= SLAB | SOUTH
			}else if(westUp){
				target |= SLAB | WEST
			}else if(this.name === "rail" && north && east){
				target |= STAIR | SOUTH
			}else if(this.name === "rail" && east && south){
				target |= STAIR | WEST
			}else if(this.name === "rail" && south && west){
				target |= STAIR | NORTH
			}else if(this.name === "rail" && west && north){
				target |= STAIR | EAST
			}else if(north || south){
				target |= NORTH
			}else if(east || west){
				target |= EAST
			}else return
			target |= (b&FLIP)
			if(b !== target){
				world.setBlock(x,y,z,target,false,false,false,true)
			}
		},
		onset: function(x,y,z,world){
			world.updateBlock(x,y+1,z+1,false,false,null,null,null)
			world.updateBlock(x,y+1,z-1,false,false,null,null,null)
			world.updateBlock(x+1,y+1,z,false,false,null,null,null)
			world.updateBlock(x-1,y+1,z,false,false,null,null,null)
			world.updateBlock(x,y-1,z+1,false,false,null,null,null)
			world.updateBlock(x,y-1,z-1,false,false,null,null,null)
			world.updateBlock(x+1,y-1,z,false,false,null,null,null)
			world.updateBlock(x-1,y-1,z,false,false,null,null,null)
			if(this.carryRedstone){
				let power = world.getRedstoneWirePower(x,y,z)
				let strong = world.getSurroundingBlockPower(x,y,z) === "strong"
				if(strong) power = 15
				world.setTagByName(x,y,z,"power",power,false)
				if(power) world.spreadPower(x,y,z,power)
			}
		},
		ondelete:function(x,y,z,prevTags,prev,world){
			world.updateBlock(x,y+1,z+1)
			world.updateBlock(x,y+1,z-1)
			world.updateBlock(x+1,y+1,z)
			world.updateBlock(x-1,y+1,z)
			world.updateBlock(x,y-1,z+1)
			world.updateBlock(x,y-1,z-1)
			world.updateBlock(x+1,y-1,z)
			world.updateBlock(x-1,y-1,z)
			if(this.carryRedstone){
				const power = getTagBits(prevTags,"power",this.id)
				if(power) world.unspreadPower(x,y,z,power)
			}
		}
	}
	
	for (let i = 0; i < BLOCK_COUNT; i++) {
		let baseBlock = blockData[i]
		if(baseBlock.item && baseBlock.name !== "bow"){
			if(baseBlock.spyglass) baseBlock.shape = shapes.spyglass
			else baseBlock.shape = shapes.item
			continue
		}
		
		let drop = baseBlock.drop || i
		let d = baseBlock.drop
		
		let slabBlock = Object.create(baseBlock)
		let stairBlock = Object.create(baseBlock)
		let crossBlock = Object.create(baseBlock)
		let tallcrossBlock = Object.create(baseBlock)
		let doorBlock = Object.create(baseBlock)
		let torchBlock = Object.create(baseBlock)
		let lanternBlock = Object.create(baseBlock)
		let lanternHangBlock = Object.create(baseBlock)
		let beaconBlock = Object.create(baseBlock)
		let cactusBlock = Object.create(baseBlock)
		let paneBlock = Object.create(baseBlock)
		let portalBlock = Object.create(baseBlock)
		let trapdoorBlock = Object.create(baseBlock)
		let openTrapdoor = Object.create(baseBlock)
		let wallFlatBlock = Object.create(baseBlock)
		let fenceBlock = Object.create(baseBlock)
		let wallPostBlock = Object.create(baseBlock)
		let buttonBlock = Object.create(baseBlock)
		let chainBlock = Object.create(baseBlock)
		let potBlock = Object.create(baseBlock)
		let potCrossBlock = Object.create(baseBlock)
		let cornerStairInBlock = Object.create(baseBlock)
		let cornerStairOutBlock = Object.create(baseBlock)
		let verticalSlabBlock = Object.create(baseBlock)
		baseBlock.shape = baseBlock.shapeName ? shapes[baseBlock.shapeName] : shapes.cube
		slabBlock.shape = shapes.slab
		slabBlock.transparent = true
		slabBlock.drop = d || (i | SLAB)
		slabBlock.Name += " Slab"
		stairBlock.shape = shapes.stair
		stairBlock.transparent = true
		stairBlock.drop = d || (i | STAIR)
		stairBlock.Name += " Stair"
		crossBlock.shape = shapes.cross
		crossBlock.drop = drop
		tallcrossBlock.shape = shapes.tallCross
		tallcrossBlock.drop = drop
		doorBlock.shape = shapes.door
		doorBlock.drop = drop
		torchBlock.shape = shapes.torch
		torchBlock.drop = drop
		lanternBlock.shape = shapes.lantern
		lanternHangBlock.shape = shapes.lanternHang
		beaconBlock.shape = shapes.beacon
		beaconBlock.drop = drop
		cactusBlock.shape = shapes.cactus
		cactusBlock.drop = drop
		paneBlock.shape = shapes.pane
		paneBlock.drop = drop
		portalBlock.shape = shapes.portal
		wallFlatBlock.shape = shapes.wallFlat
		wallFlatBlock.drop = drop
		trapdoorBlock.shape = shapes.trapdoor
		trapdoorBlock.drop = drop
		openTrapdoor.shape = shapes.trapdoorOpen
		openTrapdoor.drop = drop
		fenceBlock.shape = shapes.fence
		fenceBlock.transparent = true
		fenceBlock.drop = drop
		wallPostBlock.shape = shapes.wallpost
		wallPostBlock.transparent = true
		wallPostBlock.drop = drop
		buttonBlock.shape = shapes.button
		buttonBlock.drop = drop
		chainBlock.shape = shapes.chain
		chainBlock.drop = drop
		potBlock.shape = shapes.pot
		potBlock.drop = drop
		potCrossBlock.shape = shapes.potCross
		potCrossBlock.drop = drop
		cornerStairInBlock.shape = shapes.stairCornerIn
		cornerStairInBlock.transparent = true
		cornerStairInBlock.drop = d || (i | STAIR)
		cornerStairOutBlock.shape = shapes.stairCornerOut
		cornerStairOutBlock.transparent = true
		cornerStairOutBlock.drop = d || (i | STAIR)
		verticalSlabBlock.shape = shapes.verticalSlab
		verticalSlabBlock.transparent = true
		verticalSlabBlock.drop = d || (i | VERTICALSLAB)
		verticalSlabBlock.Name += " Vertical Slab"
		if(baseBlock.torch || baseBlock.chain){
			slabBlock.drop = i
		}
		if(baseBlock.door){
			var onclick = baseBlock.name === "ironDoor" ? emptyFunc : function(x,y,z,world){
				this.toggle(x,y,z,world)
			}
			var onpowerupdate = function(x,y,z,sx,sy,sz,blockPowerChanged,world){
				var power = world.getRedstonePower(x,y,z) || world.getSurroundingBlockPower(x,y,z) ? true : false
				let block = world.getBlock(x,y,z)
				var open = (block & DOOR) !== DOOR
				if(power !== open) this.toggle(x,y,z,world)
			}
			baseBlock.toggle = doorToggle.bind(baseBlock)
			baseBlock.onclick = onclick.bind(baseBlock)
			baseBlock.onpowerupdate = onpowerupdate.bind(baseBlock)
			slabBlock.shape = shapes.door2
			slabBlock.drop = i
			slabBlock.Name = "Inverted "+baseBlock.name
		}
		if(baseBlock.trapdoor){
			var onclick = baseBlock.name === "ironTrapdoor" ? emptyFunc : function(x,y,z,world){
				this.toggle(x,y,z,world)
			}
			var onpowerupdate = function(x,y,z,sx,sy,sz,blockPowerChanged,world){
				var power = world.getRedstonePower(x,y,z) || world.getSurroundingBlockPower(x,y,z) ? true : false
				let block = world.getBlock(x,y,z)
				var open = (block & TRAPDOOR) !== TRAPDOOR
				if(power !== open) this.toggle(x,y,z,world)
			}
			trapdoorBlock.toggle = trapdoorToggle.bind(baseBlock)
			openTrapdoor.toggle = trapdoorOpenToggle.bind(baseBlock)
			trapdoorBlock.onclick = onclick.bind(trapdoorBlock)
			openTrapdoor.onclick = onclick.bind(openTrapdoor)
			trapdoorBlock.onpowerupdate = onpowerupdate.bind(trapdoorBlock)
			openTrapdoor.onpowerupdate = onpowerupdate.bind(openTrapdoor)
		}
		if(baseBlock.bed){
			baseBlock.shape = shapes.bed
			baseBlock.onclick = clickBed
		}
		if(baseBlock.rotate) baseBlock.shape = shapes.rotate
		if(baseBlock.SW) baseBlock.shape = shapes.SW
		if(baseBlock.cactus) potCrossBlock.shape = shapes.cactusPot
		if(baseBlock.crop) baseBlock.shape = shapes.crop
		if(baseBlock.tallCrop)baseBlock.shape = shapes.tallCrop
		if(baseBlock.anvil) baseBlock.shape = shapes.anvil
		if(baseBlock._1PixLower) baseBlock.shape = shapes._1PixLower, baseBlock.transparent = true
		if(baseBlock.torch) slabBlock.shape = shapes.wallTorch
		if(baseBlock.sporeBlossom) baseBlock.shape = shapes.sporeBlossom
		if(baseBlock.azalea){
			baseBlock.shape = shapes.azalea
			potCrossBlock.shape = shapes.azaleaPot
			var t = baseBlock.potTex
			potCrossBlock.textures = [t[0],t[0],t[1],t[1],t[1],t[1]]
		}
		if(baseBlock.sunflower) baseBlock.shape = shapes.sunflower
		if(baseBlock.sideCross){baseBlock.shape = shapes.sideCross; slabBlock.shape = shapes.bottomCross}
		if(baseBlock.layers){
			torchBlock.shape = shapes.layer1
			torchBlock.solid = true
			torchBlock.shadow = false
			torchBlock.dropAmount = 1
			slabBlock.shape = shapes.layer2
			slabBlock.solid = true
			slabBlock.shadow = false
			slabBlock.dropAmount = 2
			stairBlock.shape = shapes.layer3
			stairBlock.solid = true
			stairBlock.shadow = false
			stairBlock.dropAmount = 3
			crossBlock.shape = shapes.layer4
			crossBlock.solid = true
			crossBlock.shadow = false
			crossBlock.dropAmount = 4
			tallcrossBlock.shape = shapes.layer5
			tallcrossBlock.solid = true
			tallcrossBlock.shadow = false
			tallcrossBlock.dropAmount = 5
			lanternBlock.shape = shapes.layer6
			lanternBlock.solid = true
			lanternBlock.shadow = false
			lanternBlock.dropAmount = 6
			lanternHangBlock.shape = shapes.layer7
			lanternHangBlock.solid = true
			lanternHangBlock.shadow = false
			lanternHangBlock.dropAmount = 7
			doorBlock.shape = shapes.layer8
			doorBlock.solid = true
			doorBlock.shadow = false
			doorBlock.dropAmount = 8
		}
		if(baseBlock.liquid){
			Object.assign(baseBlock,liquidData)
			baseBlock.shape = shapes.liquidLayer8
			torchBlock.shape = shapes.liquidLayer1
			torchBlock.ambientSound = baseBlock.flowSound
			slabBlock.shape = shapes.liquidLayer2
			slabBlock.ambientSound = baseBlock.flowSound
			stairBlock.shape = shapes.liquidLayer3
			stairBlock.ambientSound = baseBlock.flowSound
			crossBlock.shape = shapes.liquidLayer4
			crossBlock.ambientSound = baseBlock.flowSound
			tallcrossBlock.shape = shapes.liquidLayer5
			tallcrossBlock.ambientSound = baseBlock.flowSound
			lanternBlock.shape = shapes.liquidLayer6
			lanternBlock.ambientSound = baseBlock.flowSound
			lanternHangBlock.shape = shapes.liquidLayer7
			lanternHangBlock.ambientSound = baseBlock.flowSound
			doorBlock.shape = shapes.liquidLayer8
			doorBlock.ambientSound = baseBlock.flowSound
		}
		if(baseBlock.name === "grass"){
			crossBlock.shape = shapes.cube
			crossBlock.textures = ["dirt","grassTop","snowGrass","snowGrass","snowGrass","snowGrass"]
			crossBlock.solid = true
			crossBlock.transparent = false
			crossBlock.shadow = true
			crossBlock.biomeTintTop = false
			crossBlock.biomeTintNorth = false
			crossBlock.biomeTintSouth = false
			crossBlock.biomeTintEast = false
			crossBlock.biomeTintWest = false
		}
		if(baseBlock.name === "podzol"){
			crossBlock.shape = shapes.cube
			crossBlock.textures = ["dirt","podzolTop","snowGrass","snowGrass","snowGrass","snowGrass"]
			crossBlock.solid = true
			crossBlock.transparent = false
			crossBlock.shadow = true
		}
		if(baseBlock.name === "farmland"){
			slabBlock.textures = []
			copyArr(baseBlock.textures, slabBlock.textures)
			slabBlock.textures[1] = "farmlandMoist"
			slabBlock.shape = shapes._1PixLower
		}
		if(baseBlock.mushroomBlock){
			var cap = baseBlock.name
			var pore = "mushroomBlockInside"
			makeBlock(new Array(6).fill(pore), shapes.cube, slabBlock)
				slabBlock.drop = i
        makeBlock([pore,cap,pore,pore,pore,pore], shapes.cube, stairBlock)//top only
				stairBlock.drop = i
        makeBlock([pore,pore,cap,cap,cap,cap], shapes.cube, tallcrossBlock)//all sides
				tallcrossBlock.drop = i
        makeBlock([pore,cap,cap,pore,pore,pore], shapes.rotate, doorBlock)//top + 1 side
				doorBlock.drop = i
        makeBlock([pore,cap,cap,pore,cap,pore], shapes.rotate, paneBlock)//top + 2 sides next to each other
				paneBlock.drop = i
        makeBlock([pore,pore,cap,pore,cap,pore], shapes.rotate, portalBlock)//2 side next to each other
				portalBlock.drop = i
        makeBlock([pore,pore,cap,pore,pore,pore], shapes.rotate, wallFlatBlock)//1 side
				wallFlatBlock.drop = i
			//makeBlock([cap,pore,pore,pore,pore,pore], shapes.cube, crossBlock)
			//makeBlock([cap,cap,pore,pore,pore,pore], shapes.cube, tallcrossBlock)
			//makeBlock([cap,pore,cap,pore,pore,pore], shapes.rotate, portalBlock)
			//makeBlock([cap,cap,cap,pore,pore,pore], shapes.rotate, wallFlatBlock)
		}
		if(baseBlock.cake) baseBlock.shape = shapes.cake
		if(baseBlock.stonecutter) baseBlock.shape = shapes.stonecutter
		if(baseBlock.itemFrame){
			baseBlock.shape = shapes.itemFrame
			baseBlock.onclick = itemFrameOnclick
			baseBlock.tagBits = null
		}
		if(baseBlock.name === "redstoneLamp"){
			makeBlock(new Array(6).fill("redstoneLampOn"), shapes.cube, slabBlock)
			slabBlock.lightLevel = 15
		}
		if(baseBlock.name === "endPortalFrame"){
			baseBlock.shape = shapes.endPortalFrame
			makeBlock(baseBlock.textures, shapes.endPortalFrameWithEyeOfEnder, slabBlock)
		}
		if(baseBlock.name === "furnace"){
			var arr = baseBlock.textures.slice()
			arr[3] = "furnaceFrontOn"
			makeBlock(arr, shapes.rotate, slabBlock)
			slabBlock.lightLevel = 13
		}
		if(baseBlock.name === "jungleLeaves"){
			makeBlock(new Array(6).fill("floweringJungleLeaves"), shapes.cube, fenceBlock, null, baseBlock.Name+" with fruit")
			fenceBlock.transparent = true
		}
		if(baseBlock.name === "redBerryLeaves" || baseBlock.name === "blueBerryLeaves"){
			makeBlock(new Array(6).fill(baseBlock.textures[2]+"NoBerries"), shapes.cube, fenceBlock, null, baseBlock.Name+" without berries")
			fenceBlock.transparent = true
		}
		if(baseBlock.fire){
			baseBlock.shape = shapes.fire
			slabBlock.shape = shapes.sideFire
			stairBlock.shape = shapes.bottomFire
		}
		if(baseBlock.name === "endRod"){
			baseBlock.shape = shapes.endRod
			slabBlock.shape = shapes.endRodSW
		}
		if(baseBlock.fenceGate){
			baseBlock.shape = shapes.fenceGate
			baseBlock.transparent = true
			slabBlock.shape = shapes.fenceGateWall
			stairBlock.shape = shapes.fenceGateOpen
			doorBlock.shape = shapes.fenceGateWallOpen
			doorBlock.transparent = true
			baseBlock.onclick = (function(x,y,z,world){
				var b = world.getBlock(x,y,z)
				var set
				var id = this.id
				let o = false
				switch(b){
					case id | CUBE | NORTH:
						set = id | STAIR | NORTH
						o = true
						break
					case id | CUBE | SOUTH:
						set = id | STAIR | SOUTH
						o = true
						break
					case id | CUBE | EAST:
						set = id | STAIR | EAST
						o = true
						break
					case id | CUBE | WEST:
						set = id | STAIR | WEST
						o = true
						break
					case id | SLAB | NORTH:
						set = id | DOOR | NORTH
						o = true
						break
					case id | SLAB | SOUTH:
						set = id | DOOR | SOUTH
						o = true
						break
					case id | SLAB | EAST:
						set = id | DOOR | EAST
						o = true
						break
					case id | SLAB | WEST:
						set = id | DOOR | WEST
						o = true
						break
					case id | STAIR | NORTH:
						set = id | CUBE | NORTH
						break
					case id | STAIR | SOUTH:
						set = id | CUBE | SOUTH
						break
					case id | STAIR | EAST:
						set = id | CUBE | EAST
						break
					case id | STAIR | WEST:
						set = id | CUBE | WEST
						break
					case id | DOOR | NORTH:
						set = id | SLAB | NORTH
						break
					case id | DOOR | SOUTH:
						set = id | SLAB | SOUTH
						break
					case id | DOOR | EAST:
						set = id | SLAB | EAST
						break
					case id | DOOR | WEST:
						set = id | SLAB | WEST
						break
				}
				world.setBlock(x,y,z,set)
				doorSound(x,y,z,"fence_gate",o,world)
			}).bind({id:baseBlock.id})
		}
		if(baseBlock.barrel){
			makeBlock(baseBlock.texturesSW, shapes.SW, slabBlock, null, baseBlock.Name)
			makeBlock(baseBlock.texturesDown, shapes.cube, stairBlock, null, baseBlock.Name)
			makeBlock(baseBlock.texturesOpen, shapes.cube, crossBlock, null, baseBlock.Name)
			makeBlock(baseBlock.texturesSWOpen, shapes.SW, doorBlock, null, baseBlock.Name)
			makeBlock(baseBlock.texturesDownOpen, shapes.cube, tallcrossBlock, null, baseBlock.Name)
		}
		if(baseBlock.chain){
			slabBlock.shape = shapes.chainSW
			slabBlock.textures = slabBlock.textures.slice()
			slabBlock.textures[4] = slabBlock.textures[5] = "chainSW"
		}
		if(baseBlock.name === "beeNest" || baseBlock.name === "beehive"){
			makeBlock(baseBlock.texturesHoney, shapes.rotate, slabBlock)
		}
		if(baseBlock.name === "sponge"){
			makeBlock(baseBlock.wetTexture, shapes.cube, slabBlock)
		}
		if(baseBlock.campfire){
			baseBlock.shape = shapes.campfire
			slabBlock.shape = shapes.campfireUnlit
			slabBlock.transparent = baseBlock.transparent
			slabBlock.shadow = baseBlock.shadow
			slabBlock.lightLevel = 0
			slabBlock.damageUp = 0
		}
		if(baseBlock.bamboo){
			baseBlock.shape = shapes.bamboo
			makeBlock(baseBlock.textures, shapes.bambooSmallLeaf, slabBlock)
			slabBlock.shadow = false
			slabBlock.transparent = true
			makeBlock(baseBlock.textures, shapes.bambooBigLeaf, stairBlock)
			stairBlock.shadow = false
			stairBlock.transparent = true
			makeBlock(baseBlock.textures, shapes.bambooYoung, crossBlock)
			crossBlock.shadow = false
			crossBlock.transparent = true
			makeBlock(baseBlock.textures, shapes.bambooYoungLeaf, tallcrossBlock)
			tallcrossBlock.shadow = false
			tallcrossBlock.transparent = true
			potCrossBlock.shape = shapes.bambooPot
		}
		if(baseBlock.chest) baseBlock.shape = shapes.chest
		if(baseBlock.pressurePlate){
			baseBlock.shape = shapes.pressurePlate
			baseBlock.transparent = true
			baseBlock.shadow = false
			baseBlock.solid = false
			baseBlock.activate = pressurePlateActivate
			baseBlock.onupdate = pressurePlateOnupdate
			makeBlock(baseBlock.textures, shapes.pressurePlateActive, slabBlock, baseBlock)
		}
		if(baseBlock.name === "tomatoPlant"){
			baseBlock.shape = shapes.cross
			makeBlock(baseBlock.textures1, shapes.cross, slabBlock, baseBlock)
			makeBlock(baseBlock.textures2, shapes.cross, stairBlock, baseBlock)
			makeBlock(baseBlock.textures3, shapes.cross, crossBlock, baseBlock)
			makeBlock(baseBlock.textures4, shapes.cross, tallcrossBlock, baseBlock)
			crossBlock.drop = "tomato"
			crossBlock.dropAmount = [4,8]
			tallcrossBlock.drop = "tomato"
			tallcrossBlock.dropAmount = [8,16]
		}
		if(baseBlock.name === "wheat"){
			makeBlock(baseBlock.textures1, shapes.crop, slabBlock, baseBlock)
			makeBlock(baseBlock.textures2, shapes.crop, stairBlock, baseBlock)
			makeBlock(baseBlock.textures3, shapes.crop, crossBlock, baseBlock)
			makeBlock(baseBlock.textures4, shapes.crop, tallcrossBlock, baseBlock)
			makeBlock(baseBlock.textures5, shapes.crop, doorBlock, baseBlock)
			makeBlock(baseBlock.textures6, shapes.crop, torchBlock, baseBlock)
			makeBlock(baseBlock.textures7, shapes.crop, lanternBlock, baseBlock)
			lanternBlock.drop = baseBlock.fullDrop
		}
		if(baseBlock.name === "redstoneDust"){
			baseBlock.shape = shapes.redstoneDust
			makeBlock(new Array(6).fill("redstoneDustLine"), shapes.redstoneDustRotate, slabBlock, baseBlock)
			makeBlock(new Array(6).fill("redstoneDustL"), shapes.redstoneDustRotate, stairBlock, baseBlock)
			makeBlock(new Array(6).fill("redstoneDustT"), shapes.redstoneDustRotate, doorBlock, baseBlock)
			makeBlock(new Array(6).fill("redstoneDust+"), shapes.redstoneDust, paneBlock, baseBlock)

			let flip = Object.create(baseBlock)
			makeBlock(new Array(6).fill("redstoneDustDot"), shapes.redstoneDust, flip, baseBlock)
			flip.tint = flip.blueTint
			blockData[i | FLIP] = flip
			flip = Object.create(baseBlock)
			makeBlock(new Array(6).fill("redstoneDustLine"), shapes.redstoneDustRotate, flip, baseBlock)
			flip.tint = flip.blueTint
			blockData[i | SLAB | FLIP] = flip
			let v = flip.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(flip)
					block.shape = v[j]
					blockData[i | SLAB | FLIP |v[j].bit] = block
				}
			}
			flip = Object.create(baseBlock)
			makeBlock(new Array(6).fill("redstoneDustL"), shapes.redstoneDustRotate, flip, baseBlock)
			flip.tint = flip.blueTint
			blockData[i | STAIR | FLIP] = flip
			v = flip.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(flip)
					block.shape = v[j]
					blockData[i | STAIR | FLIP |v[j].bit] = block
				}
			}
			flip = Object.create(baseBlock)
			makeBlock(new Array(6).fill("redstoneDustT"), shapes.redstoneDustRotate, flip, baseBlock)
			flip.tint = flip.blueTint
			blockData[i | DOOR | FLIP] = flip
			v = flip.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(flip)
					block.shape = v[j]
					blockData[i | DOOR | FLIP |v[j].bit] = block
				}
			}
			flip = Object.create(baseBlock)
			makeBlock(new Array(6).fill("redstoneDust+"), shapes.redstoneDust, flip, baseBlock)
			flip.tint = flip.blueTint
			blockData[i | PANE | FLIP] = flip
		}
		if(baseBlock.redstoneTorch){
			baseBlock.shape = shapes.redstoneTorch
			makeBlock(baseBlock.textures, shapes.redstoneWallTorch, slabBlock, baseBlock)
			makeBlock(baseBlock.textures, shapes.torch, crossBlock, baseBlock)
			crossBlock.lightLevel = 0
			crossBlock.textures = new Array(6).fill("redstoneTorchOff")
			makeBlock(baseBlock.textures, shapes.wallTorch, stairBlock, baseBlock)
			stairBlock.lightLevel = 0
			stairBlock.textures = crossBlock.textures
		}
		if(baseBlock.lever){
			baseBlock.shape = shapes.leverWall
			makeBlock(baseBlock.textures, shapes.leverWallOn, slabBlock, baseBlock)
			makeBlock(baseBlock.textures, shapes.leverFloor, stairBlock, baseBlock)
			makeBlock(baseBlock.textures, shapes.leverFloorOn, crossBlock, baseBlock)
			makeBlock(baseBlock.textures, shapes.leverCeil, tallcrossBlock, baseBlock)
			makeBlock(baseBlock.textures, shapes.leverCeilOn, doorBlock, baseBlock)
		}
		if(baseBlock.button){
			makeBlock(baseBlock.textures, shapes.buttonPushed, slabBlock, baseBlock)
			baseBlock.onclick = buttonOnclick.bind(baseBlock)
			baseBlock.onupdate = buttonOnupdate.bind(baseBlock)
			baseBlock.projectileHit = buttonProjectileHit.bind(baseBlock)
		}
		if(baseBlock.repeater){
			baseBlock.shape = shapes.repeater1
			makeBlock(baseBlock.textures, shapes.repeater2, slabBlock, baseBlock)
			makeBlock(baseBlock.textures, shapes.repeater3, stairBlock, baseBlock)
			makeBlock(baseBlock.textures, shapes.repeater4, doorBlock, baseBlock)
			makeBlock(baseBlock.textures, shapes.repeaterOn1, paneBlock, baseBlock)
			makeBlock(baseBlock.textures, shapes.repeaterOn2, portalBlock, baseBlock)
			makeBlock(baseBlock.textures, shapes.repeaterOn3, wallFlatBlock, baseBlock)
			makeBlock(baseBlock.textures, shapes.repeaterOn4, openTrapdoor, baseBlock)
		}
		if(baseBlock.piston){
			var baseBlockTransparent = Object.create(baseBlock)
			baseBlockTransparent.transparent = true
			
			//not extended
			var textures = baseBlock.textures.slice()
			var t = textures[0]
			textures[0] = textures[1]
			textures[1] = t
			var flipped = Object.create(baseBlock)
			makeBlock(textures, shapes.flipped, flipped, baseBlock)
			blockData[i | FLIP] = flipped
			
			var shape = shapes.SW
			t = baseBlock.textures
			textures = [t[2],t[2],t[0],t[1],t[2],t[2]]
			makeBlock(textures, shape, slabBlock, baseBlock)
			
			//head
			t = baseBlock.textures[1]
			var t2 = baseBlock.headSideTexture
			var t3 = baseBlock.headBackTexture
			makeBlock([t3,t,t2,t2,t2,t2], shapes.pistonHead, stairBlock, baseBlockTransparent)
			flipped = Object.create(baseBlock)
			makeBlock([t,t3,t2,t2,t2,t2], shapes.pistonHeadFlipped, flipped, baseBlockTransparent)
			blockData[i | STAIR | FLIP] = flipped
			
			makeBlock([t2,t2,t3,t,t2,t2], shapes.pistonHeadSW, doorBlock, baseBlockTransparent)
			
			//head cut
			makeBlock(stairBlock.textures, shapes.pistonHeadCut, crossBlock, baseBlock)
			flipped = Object.create(baseBlock)
			makeBlock(blockData[i | STAIR | FLIP].textures, shapes.pistonHeadCutFlipped, flipped, baseBlock)
			blockData[i | CROSS | FLIP] = flipped
			
			makeBlock(doorBlock.textures, shapes.pistonHeadCutSW, paneBlock, baseBlock)
			
			//open
			var textures = baseBlock.textures.slice()
			textures[1] = baseBlock.frontOpenTexture
			makeBlock(textures, shapes.pistonOpen, tallcrossBlock, baseBlockTransparent)
			textures = blockData[i | FLIP].textures.slice()
			textures[0] = baseBlock.frontOpenTexture
			flipped = Object.create(baseBlock)
			makeBlock(textures, shapes.pistonOpenFlipped, flipped, baseBlockTransparent)
			blockData[i | TALLCROSS | FLIP] = flipped
			
			var textures = baseBlock.textures.slice()
			var temp = textures[2] //side with piston head
			textures[2] = textures[0]
			textures[3] = baseBlock.frontOpenTexture
			textures[0] = textures[1] = temp
			makeBlock(textures, shapes.pistonOpenSW, portalBlock, baseBlockTransparent)
		}
		if(baseBlock.name === "tnt"){
			makeBlock(fillTextureArray(baseBlock.superTntTextures), shapes.cube, slabBlock, baseBlock, "Super TNT")
			makeBlock(fillTextureArray(baseBlock.ultraTntTextures), shapes.cube, stairBlock, baseBlock, "Ultra TNT")
			makeBlock(new Array(6).fill("blank"), shapes.cube, crossBlock, baseBlock)
		}
		if(baseBlock.name === "observer"){
			baseBlock.shape = shapes.rotate
			var t = baseBlock.textures
			var textures = [t[3],t[2],t[0],t[1],t[4]+"SW",t[5]+"SW"]
			makeBlock(textures, shapes.cube, slabBlock, baseBlock)
			
			var flipped = Object.create(baseBlock)
			var textures = textures.slice()
			var t = textures[1]
			textures[1] = textures[0]
			textures[0] = t
			makeBlock(textures, shapes.flipped, flipped, baseBlock)
			blockData[i | SLAB | FLIP] = flipped
			
			//on
			textures = baseBlock.textures.slice()
			textures[2] += "On"
			makeBlock(textures, shapes.rotate, stairBlock, baseBlock)
			
			textures = slabBlock.textures.slice()
			textures[1] += "On"
			makeBlock(textures, shapes.cube, crossBlock, baseBlock)
			
			var flipped = Object.create(baseBlock)
			textures = blockData[i | SLAB | FLIP].textures.slice()
			textures[0] += "On"
			makeBlock(textures, shapes.flipped, flipped, baseBlock)
			blockData[i | CROSS | FLIP] = flipped
		}
		if(baseBlock.name === "endPortal"){
			baseBlock.shape = shapes.endPortal
		}
		if(baseBlock.pane){
			var t = baseBlock.textures
			makeBlock([t[2],t[3],t[0],t[1],t[0],t[1]], shapes.horizontalPane, slabBlock, baseBlock)
		}
		if(baseBlock.coloredRedstoneLamp){
			makeBlock(new Array(6).fill(baseBlock.name), shapes.cube, slabBlock)
			slabBlock.lightLevel = 15
		}
		if(baseBlock.name === "sweetBerryBush"){
			baseBlock.shape = shapes.cross
			makeBlock(baseBlock.textures1, shapes.cross, slabBlock, baseBlock)
			slabBlock.spikyBush = true
			makeBlock(baseBlock.textures2, shapes.cross, stairBlock, baseBlock)
			stairBlock.spikyBush = true
			stairBlock.dropAmount = [1,2]
			makeBlock(baseBlock.textures3, shapes.cross, crossBlock, baseBlock)
			crossBlock.spikyBush = true
			crossBlock.dropAmount = [2,3]
		}
		if(baseBlock.logicGate){
			var t = baseBlock.textures.slice()
			t[1] += "On"
			makeBlock(t, baseBlock.shape, slabBlock, baseBlock)
			baseBlock.onupdate = logicGateOnupdate
			baseBlock.onpowerupdate = logicGateOnpowerupdate
			baseBlock.ondelete = logicGateOndelete
			baseBlock.getFacing = logicGateGetFacing
			baseBlock.canHavePower = logicGateCanHavePower
		}
		if(baseBlock.name === "pointedDripstone"){
			makeBlock(new Array(6).fill("pointedDripstoneUpTip"), shapes.cross, baseBlock, baseBlock)
			var flip = Object.create(baseBlock)
			makeBlock(new Array(6).fill("pointedDripstoneDownTip"), shapes.cross, flip, baseBlock)
			blockData[i | FLIP] = flip
			makeBlock(new Array(6).fill("pointedDripstoneUpBase"), shapes.cross, slabBlock, baseBlock)
			var flip = Object.create(baseBlock)
			makeBlock(new Array(6).fill("pointedDripstoneDownBase"), shapes.cross, flip, baseBlock)
			blockData[i | SLAB | FLIP] = flip
			makeBlock(new Array(6).fill("pointedDripstoneUpMiddle"), shapes.cross, stairBlock, baseBlock)
			var flip = Object.create(baseBlock)
			makeBlock(new Array(6).fill("pointedDripstoneDownMiddle"), shapes.cross, flip, baseBlock)
			blockData[i | STAIR | FLIP] = flip
			makeBlock(new Array(6).fill("pointedDripstoneUpFrustum"), shapes.cross, crossBlock, baseBlock)
			var flip = Object.create(baseBlock)
			makeBlock(new Array(6).fill("pointedDripstoneDownFrustum"), shapes.cross, flip, baseBlock)
			blockData[i | CROSS | FLIP] = flip
			makeBlock(new Array(6).fill("pointedDripstoneUpTipMerge"), shapes.cross, tallcrossBlock, baseBlock)
			var flip = Object.create(baseBlock)
			makeBlock(new Array(6).fill("pointedDripstoneDownTipMerge"), shapes.cross, flip, baseBlock)
			blockData[i | TALLCROSS | FLIP] = flip
		}
		if(baseBlock.sign){
			slabBlock.shape = shapes.sign
			slabBlock.textures = baseBlock.textures
			slabBlock.drop = i
			crossBlock.shape = shapes.wallSign
			crossBlock.textures = baseBlock.textures
			crossBlock.drop = i
			baseBlock.shape = shapes.none
			baseBlock.transparent = true
			baseBlock.shadow = false
			baseBlock.solid = false
			baseBlock.onplace = signOnplace
			baseBlock.tagBits = null
			baseBlock.onclick = signOnclick
			stairBlock.shape = shapes.none
		}
		if(baseBlock.name === "composter"){
			baseBlock.shape = shapes.composter
			makeBlock(baseBlock.textures, shapes.composter2, slabBlock, baseBlock)
			makeBlock(baseBlock.textures, shapes.composter3, stairBlock, baseBlock)
			makeBlock(baseBlock.textures, shapes.composter4, crossBlock, baseBlock)
			makeBlock(baseBlock.textures, shapes.composter5, tallcrossBlock, baseBlock)
			makeBlock(baseBlock.textures, shapes.composter6, doorBlock, baseBlock)
			makeBlock(baseBlock.textures, shapes.composter7, torchBlock, baseBlock)
			makeBlock(baseBlock.textures, shapes.composter8, lanternBlock, baseBlock)
		}
		if(baseBlock.name === "cocoa"){
			baseBlock.shape = shapes.cocoaStage0
			baseBlock.textures.fill("cocoaStage0")
			makeBlock(new Array(6).fill("cocoaStage1"), shapes.cocoaStage1, slabBlock, baseBlock)
			makeBlock(new Array(6).fill("cocoaStage2"), shapes.cocoaStage2, stairBlock, baseBlock)
			stairBlock.dropAmount = [2,3]
		}
		if(baseBlock.name === "beetroots"){
			makeBlock(baseBlock.textures1, shapes.crop, slabBlock, baseBlock)
			makeBlock(baseBlock.textures2, shapes.crop, stairBlock, baseBlock)
			makeBlock(baseBlock.textures3, shapes.crop, crossBlock, baseBlock)
			crossBlock.drop = ["beetrootSeeds","beetroot"]
			crossBlock.dropAmount = [1,4]
		}
		if(baseBlock.name === "potatoes"){
			makeBlock(baseBlock.textures1, shapes.crop, slabBlock, baseBlock)
			makeBlock(baseBlock.textures2, shapes.crop, stairBlock, baseBlock)
			makeBlock(baseBlock.textures3, shapes.crop, crossBlock, baseBlock)
			crossBlock.dropAmount = [1,5]
		}
		if(baseBlock.name === "carrots"){
			makeBlock(baseBlock.textures1, shapes.crop, slabBlock, baseBlock)
			makeBlock(baseBlock.textures2, shapes.crop, stairBlock, baseBlock)
			makeBlock(baseBlock.textures3, shapes.crop, crossBlock, baseBlock)
			crossBlock.dropAmount = [2,5]
		}
		if(baseBlock.name === "dropper" || baseBlock.name === "dispenser"){
			baseBlock.shape = shapes.rotate
			makeBlock(baseBlock.upTextures, shapes.cube, slabBlock)
			makeBlock(baseBlock.downTextures, shapes.cube, stairBlock)
		}
		if(baseBlock.name === "hopper"){
			baseBlock.shape = shapes.hopper
			makeBlock(baseBlock.textures, shapes.hopperWall, slabBlock, baseBlock)
		}
		if(baseBlock.name === "comparator"){
			baseBlock.shape = shapes.comparator
			makeBlock(baseBlock.textures, shapes.comparatorOn, slabBlock, baseBlock)
			makeBlock(baseBlock.textures, shapes.comparatorSubtract, stairBlock, baseBlock)
			makeBlock(baseBlock.textures, shapes.comparatorSubtractOn, doorBlock, baseBlock)
		}
		if(baseBlock.name === "daylightDetector"){
			baseBlock.shape = shapes.daylightDetector
			makeBlock(baseBlock.invertedTextures, shapes.daylightDetector, slabBlock, baseBlock)
		}
		if(baseBlock.commandBlock){
			let flip = Object.create(baseBlock)
			makeBlock(baseBlock.errorTextures, shapes.cube, flip, baseBlock)
			blockData[i | FLIP] = flip
			
			makeBlock(baseBlock.sideTextures, shapes.SW, slabBlock, baseBlock)
			flip = Object.create(baseBlock)
			makeBlock(baseBlock.sideErrorTextures, shapes.SW, flip, baseBlock)
			blockData[i | SLAB | FLIP] = flip
			let v = flip.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(flip)
					block.shape = v[j]
					if(v[j].rotated) block.textures = rotTex(flip.textures, v[j].rotateTimes) //rotate textures around
					blockData[i | SLAB | FLIP |v[j].bit] = block
				}
			}

			makeBlock(baseBlock.flipTextures, shapes.flipped, stairBlock, baseBlock)
			flip = Object.create(baseBlock)
			makeBlock(baseBlock.flipErrorTextures, shapes.flipped, flip, baseBlock)
			blockData[i | STAIR | FLIP] = flip
		}
		if(baseBlock.name === "sugarCane"){
			baseBlock.shape = shapes.cross
			makeBlock(baseBlock.textures, shapes.cross, slabBlock, baseBlock)
			slabBlock.tint = baseBlock.purpleTint
		}
		if(baseBlock.name === "bow"){
			baseBlock.shape = shapes.item
			baseBlock.textures = new Array(6).fill(baseBlock.pullTextures[0])
			makeBlock(new Array(6).fill(baseBlock.pullTextures[1]), shapes.item, slabBlock)
			makeBlock(new Array(6).fill(baseBlock.pullTextures[2]), shapes.item, stairBlock)
			makeBlock(new Array(6).fill(baseBlock.pullTextures[3]), shapes.item, crossBlock)
		}
		if(baseBlock.beacon){
			baseBlock.shape = shapes.beacon
		}
		if(baseBlock.name === "pitcherCrop"){
			baseBlock.shape = shapes.pitcherCropStage0
			makeBlock(baseBlock.textures1, shapes.pitcherCropStage1, slabBlock, baseBlock)
			makeBlock(baseBlock.textures2, shapes.pitcherCropStage1, stairBlock, baseBlock)
			makeBlock(baseBlock.textures3, shapes.pitcherCropStage3, crossBlock, baseBlock)
			makeBlock(baseBlock.textures4, shapes.pitcherCropStage3, tallcrossBlock, baseBlock)
		}
		if(baseBlock.name === "torchflower"){
			makeBlock(baseBlock.textures1, shapes.cross, slabBlock, baseBlock)
			makeBlock(baseBlock.textures2, shapes.cross, stairBlock, baseBlock)
			crossBlock.drop = "torchflower"
		}
		if(baseBlock.groundLeaves){
			baseBlock.shape = shapes.flat
			if(baseBlock.thickTexture) makeBlock(new Array(6).fill(baseBlock.thickTexture), shapes.flat, slabBlock, baseBlock, "Thick "+baseBlock.Name)
		}
		if(baseBlock.flowerbed){
			baseBlock.shape = shapes.flowerbed1
			makeBlock(baseBlock.textures, shapes.flowerbed2, slabBlock, baseBlock)
			slabBlock.drop = i
			makeBlock(baseBlock.textures, shapes.flowerbed3, stairBlock, baseBlock)
			stairBlock.drop = i
			makeBlock(baseBlock.textures, shapes.flowerbed4, doorBlock, baseBlock)
			doorBlock.drop = i
		}
		if(baseBlock.name === "fern"){
			baseBlock.shape = shapes.cross
			slabBlock.shape = shapes.fern
			slabBlock.randomRotateOnSpawn = true
		}
		if(baseBlock.carpet){
			baseBlock.shape = shapes.carpet
			baseBlock.shadow = false
			baseBlock.transparent = true
			baseBlock.drop = i
			verticalSlabBlock.shape = shapes.wallCarpet
			verticalSlabBlock.shadow = false
			verticalSlabBlock.transparent = true
			verticalSlabBlock.drop = i
			verticalSlabBlock.Name = "Wall "+baseBlock.Name
		}
		if(baseBlock.coralBlock){
			makeBlock(new Array(6).fill("dead"+baseBlock.name[0].toUpperCase()+baseBlock.name.substring(1)), shapes.cube, slabBlock,baseBlock, "Dead "+baseBlock.Name)
		}
		if(baseBlock.coral){
			baseBlock.shape = shapes.cross
			makeBlock(new Array(6).fill("dead"+baseBlock.name[0].toUpperCase()+baseBlock.name.substring(1)), shapes.cross, slabBlock,baseBlock, "Dead "+baseBlock.Name)
		}
		if(baseBlock.coralFan){
			baseBlock.shape = shapes.coralFan
			makeBlock(new Array(6).fill("dead"+baseBlock.name[0].toUpperCase()+baseBlock.name.substring(1)), shapes.coralFan, slabBlock,baseBlock, "Dead "+baseBlock.Name)
			makeBlock(baseBlock.textures, shapes.coralWallFan, stairBlock,baseBlock)
			makeBlock(new Array(6).fill("dead"+baseBlock.name[0].toUpperCase()+baseBlock.name.substring(1)), shapes.coralWallFan, verticalSlabBlock,baseBlock)
		}
		if(baseBlock.rail){
			baseBlock.shape = shapes.rail
			makeBlock(baseBlock.textures, shapes.railDiagonal, slabBlock,baseBlock)
			if(baseBlock.name === "rail"){
				makeBlock(new Array(6).fill("railCorner"), shapes.rail, stairBlock,baseBlock)
			}
			if(baseBlock.name === "poweredRail"){
				let flip = Object.create(baseBlock)
				makeBlock(new Array(6).fill("poweredRailOn"), shapes.rail, flip,baseBlock)
				blockData[i | FLIP] = flip
				let v = flip.shape.varients
				for (let j = 0; j < v.length; j++) {
					if (v[j]) {
						let block = Object.create(flip)
						block.shape = v[j]
						blockData[i | FLIP | v[j].bit] = block
					}
				}
				flip = Object.create(baseBlock)
				makeBlock(new Array(6).fill("poweredRailOn"), shapes.railDiagonal, flip,baseBlock)
				blockData[i | SLAB | FLIP] = flip
				v = flip.shape.varients
				for (let j = 0; j < v.length; j++) {
					if (v[j]) {
						let block = Object.create(flip)
						block.shape = v[j]
						blockData[i | SLAB | FLIP | v[j].bit] = block
					}
				}
			}
			Object.assign(baseBlock,railData)
		}
		if(baseBlock.name === "cornPlant"){
			baseBlock.shape = shapes.cross
			makeBlock(baseBlock.textures1, shapes.cross, slabBlock, baseBlock)
			makeBlock(baseBlock.textures2, shapes.cross, stairBlock, baseBlock)
			makeBlock(baseBlock.textures3, shapes.tallCross, crossBlock, baseBlock)
			makeBlock(baseBlock.textures4, shapes.tallCross, tallcrossBlock, baseBlock)
			makeBlock(baseBlock.textures5, shapes.tallCross, doorBlock, baseBlock)
			doorBlock.dropAmount = [2,3]
		}
		if(baseBlock.chair){
			baseBlock.shape = shapes.chair
			baseBlock.onclick = sit
		}
		blockData[i | SLAB] = slabBlock
		blockData[i | STAIR] = stairBlock
		blockData[i | CROSS] = crossBlock
		blockData[i | TALLCROSS] = tallcrossBlock
		blockData[i | DOOR] = doorBlock
		blockData[i | TORCH] = torchBlock
		blockData[i | LANTERN] = lanternBlock
		blockData[i | LANTERNHANG] = lanternHangBlock
		if(baseBlock.beacon) blockData[i | BEACON] = beaconBlock
		if(baseBlock.cactus) blockData[i | CACTUS] = cactusBlock
		blockData[i | PANE] = paneBlock
		blockData[i | PORTAL] = portalBlock
		blockData[i | WALLFLAT] = wallFlatBlock
		blockData[i | TRAPDOOR] = trapdoorBlock
		blockData[i | TRAPDOOROPEN] = openTrapdoor
		blockData[i | FENCE] = fenceBlock
		blockData[i | WALLPOST] = wallPostBlock
		if(baseBlock.button) blockData[i | BUTTON] = buttonBlock
		if(baseBlock.chain) blockData[i | CHAIN] = chainBlock
		if(baseBlock.pot) blockData[i | POT] = potBlock
		blockData[i | POTCROSS] = potCrossBlock
		blockData[i | CORNERSTAIRIN] = cornerStairInBlock
		blockData[i | CORNERSTAIROUT] = cornerStairOutBlock
		blockData[i | VERTICALSLAB] = verticalSlabBlock
		let v
		if(baseBlock.shape.rotate || baseBlock.shape.flip){
			let t = baseBlock.textures
			v = baseBlock.shape.varients
			for (let j = 1/*don't overwrite existing one*/; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
					blockData[i | v[j].bit] = block
				}
			}
		}
		v = slabBlock.shape.varients
		for (let j = 0; j < v.length; j++) {
			let t = slabBlock.textures
			if (v[j]) {
				let block = Object.create(slabBlock)
				block.shape = v[j]
				if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
				blockData[i | SLAB | v[j].bit] = block
			}
		}
		v = stairBlock.shape.varients
		for (let j = 0; j < v.length; j++) {
			let t = stairBlock.textures
			if (v[j]) {
				let block = Object.create(stairBlock)
				block.shape = v[j]
				if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
				blockData[i | STAIR | v[j].bit] = block
			}
		}
		v = doorBlock.shape.varients
		for (let j = 0; j < v.length; j++) {
			let t = doorBlock.textures
			if (v[j]) {
				let block = Object.create(doorBlock)
				block.shape = v[j]
				if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
				blockData[i | DOOR | v[j].bit] = block
			}
		}
		v = paneBlock.shape.varients
		for (let j = 0; j < v.length; j++) {
			let t = paneBlock.textures
			if (v[j]) {
				let block = Object.create(paneBlock)
				block.shape = v[j]
				if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
				blockData[i | PANE | v[j].bit] = block
			}
		}
		v = portalBlock.shape.varients
		for (let j = 0; j < v.length; j++) {
			let t = portalBlock.textures
			if (v[j]) {
				let block = Object.create(portalBlock)
				block.shape = v[j]
				if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes)
				blockData[i | PORTAL | v[j].bit] = block
			}
		}
		v = wallFlatBlock.shape.varients
		for (let j = 0; j < v.length; j++) {
			if (v[j]) {
				let block = Object.create(wallFlatBlock)
				block.shape = v[j]
				blockData[i | WALLFLAT | v[j].bit] = block
			}
		}
		v = trapdoorBlock.shape.varients
		for (let j = 0; j < v.length; j++) {
			if (v[j]) {
				let block = Object.create(trapdoorBlock)
				block.shape = v[j]
				blockData[i | TRAPDOOR | v[j].bit] = block
			}
		}
		v = openTrapdoor.shape.varients
		for (let j = 0; j < v.length; j++) {
			if (v[j]) {
				let block = Object.create(openTrapdoor)
				block.shape = v[j]
				blockData[i | TRAPDOOROPEN | v[j].bit] = block
			}
		}
		v = buttonBlock.shape.varients
		for (let j = 0; j < v.length; j++) {
			if (v[j] && blockData[i].button) {
				let block = Object.create(buttonBlock)
				block.shape = v[j]
				blockData[i | BUTTON | v[j].bit] = block
			}
		}
		v = cornerStairInBlock.shape.varients
		for (let j = 0; j < v.length; j++) {
			if (v[j]) {
				let block = Object.create(cornerStairInBlock)
				block.shape = v[j]
				blockData[i | CORNERSTAIRIN | v[j].bit] = block
			}
		}
		v = cornerStairOutBlock.shape.varients
		for (let j = 0; j < v.length; j++) {
			if (v[j]) {
				let block = Object.create(cornerStairOutBlock)
				block.shape = v[j]
				blockData[i | CORNERSTAIROUT | v[j].bit] = block
			}
		}
		v = verticalSlabBlock.shape.varients
		for (let j = 0; j < v.length; j++) {
			if (v[j]) {
				let block = Object.create(verticalSlabBlock)
				block.shape = v[j]
				blockData[i | VERTICALSLAB | v[j].bit] = block
			}
		}
	}
}

let CUBE,SLAB,STAIR,CROSS,TALLCROSS,DOOR,TORCH,LANTERN,LANTERNHANG,BEACON,
		CACTUS,PANE,PORTAL,WALLFLAT,TRAPDOOR,TRAPDOOROPEN,FENCE,WALLPOST,
		BUTTON,CHAIN,POT,POTCROSS,CORNERSTAIRIN,CORNERSTAIROUT,VERTICALSLAB,
		//if you change this, change debugStick and server side
		LAYER1,LAYER2,LAYER3,LAYER4,LAYER5,LAYER6,LAYER7,LAYER8,
		FLIP,NORTH,SOUTH,EAST,WEST,ROTATION// Mask for the direction bits
let isCube, isState
let prevConstVersion = null

function verMoreThan(a,b){
	a = a.split(".").map(r => parseInt(r))
	b = b.split(".").map(r => parseInt(r))
	if(a[0] > b[0]) return true
	if(a[1] > b[1] && a[0] === b[0]) return true
	if(a[2] > b[2] && a[1] === b[1]) return true
}
function bin(n){
	return parseInt(n,2)
}
function constVersion(v){
	if(v === prevConstVersion) return
	prevConstVersion = v
	isCube = 0xff
	//let verNum = v.replace(/(Alpha|Beta) /, '')//.replace(/(?<=\..*)\./g, '') //second regex removes the periods after the first
	//if(verMoreThan(verNum, "1.0.3") || verNum==="1.0.3"){
CUBE = 0
LAYER2=SLAB =          0b10000000000000 // 9th bit
LAYER3=STAIR =        0b100000000000000 // 10th bit
LAYER4=CROSS =        0b110000000000000
LAYER5=TALLCROSS =0b1001110000000000000
LAYER6=LANTERN =    0b10010000000000000
LAYER7=LANTERNHANG=0b100010000000000000
BEACON =           0b100110000000000000
CACTUS =           0b101000000000000000
POT =              0b101010000000000000
POTCROSS =         0b101110000000000000
LAYER1 = TORCH =   0b110000000000000000
CHAIN =            0b110010000000000000
LAYER8 = DOOR =   0b1000010000000000000
PORTAL =          0b1000100000000000000
WALLFLAT =        0b1000110000000000000
PANE =           0b10001000000000000000
TRAPDOOR =        0b1010000000000000000
TRAPDOOROPEN =   0b10000000000000000000
FENCE =          0b11000000000000000000
WALLPOST =       0b11000100000000000000
//WALL = 0x6400<<5
//WALLU = 0x6600<<5 //wall withe exteion under another wall
//FENCQ = 0x4100<<5 //fence (one extension)
BUTTON =         0b10000100000000000000
//CARPET    =      0b10000110000000000000
CORNERSTAIRIN =      0b1000000000000000
CORNERSTAIROUT =     0b1010000000000000
VERTICALSLAB =       0b1100000000000000
FLIP      =               0b10000000000 // 11th bit
NORTH = 0 // 12th and 13th bits for the 4 directions
SOUTH =                  0b100000000000
EAST =                  0b1000000000000
WEST =                  0b1100000000000
ROTATION =              0b1100000000000 // Mask for the direction bits
isCube =                   0b1111111111 // Mask for block id bits
isState =        0b11111110000000000000
	/*}else if(verMoreThan(verNum, "1.0.0") || verNum === "1.0.0"){
CUBE = 0
LAYER2 = SLAB = 0x100 // 9th bit
LAYER3 = STAIR = 0x200 // 10th bit
LAYER4 = CROSS = 0x300
FLIP = 0x400 // 11th bit
LAYER5 = TALLCROSS = 0x700
LAYER6 = LANTERN = 0x900
LAYER7 = LANTERNHANG=0x1100
BEACON = 0x1300
CACTUS = 0x1400
POT = 0x1500
POTCROSS = 0x1700
LAYER1 = TORCH = 0x1800
CHAIN = 0x1900
LAYER8 = DOOR = 0x2100
PORTAL = 0x2200
WALLFLAT = 0x2300
PANE = 0x4400
TRAPDOOR = 0x2800
TRAPDOOROPEN=0x4000
FENCE = 0x6000
WALLPOST = 0x6200
//WALL = 0x6400
//WALLU = 0x6600 //wall withe exteion under another wall
//FENCQ = 0x4100 //fence (one extension)
BUTTON = 0x4200
CARPET    = 0x4300
FLIP      = 0x400 // 11th bit
NORTH = 0 // 12th and 13th bits for the 4 directions
SOUTH = 0x800
EAST = 0x1000
WEST = 0x1800
ROTATION = 0x1800 // Mask for the direction bits
	}else{
		CUBE      = 0
		LAYER2 = SLAB      = 0x100 // 9th bit
		LAYER3 = STAIR     = 0x200 // 10th bit
		LAYER4 = CROSS     = 0x2000
		LAYER5 = TALLCROSS = 0x2200
		LAYER8 = DOOR      = 0x2400
		LAYER1 = TORCH     = 0x2600
		LAYER6 = LANTERN   = 0x2800
		LAYER7 = LANTERNHANG=0x3000
		BEACON    = 0x4200
		CACTUS    = 0x4400
		PANE      = 0x4600
		PORTAL    = 0x5000
		WALLFLAT  = 0x4800
		TRAPDOOR  = 0x5200
		TRAPDOOROPEN=0x5400
		FENCE     = 0x6000
		WALLPOST  = 0x6200
		//WALL      = 0x6400
		//WALLU     = 0x6600 //wall withe exteion under another wall
		//FENCQ     = 0x6800 //fence (one extension)
		BUTTON    = 0x7000
		CHAIN     = 0x7200
		POT       = 0x8000
		POTCROSS  = 0x8200
		CARPET    = 0x8400
		FLIP      = 0x400 // 11th bit
		NORTH     = 0 // 12th and 13th bits for the 4 directions
		SOUTH     = 0x800
		EAST      = 0x1000
		WEST      = 0x1800
		ROTATION  = 0x1800 // Mask for the direction bits
	}*/
}
constVersion(version)

{//Commands
let copiedBlocks
function fillBlocks(x,y,z,x2,y2,z2, blockID,world){
	if(x>x2){var px=x; x=x2; x2=px}
	if(y>y2){var py=y; y=y2; y2=py}
	if(z>z2){var pz=z; z=z2; z2=pz}
	for(var X=x; x2>=X; X++){
		for(var Y=y; y2>=Y; Y++){
			for(var Z=z; z2>=Z; Z++){
				world.setBlock(X,Y,Z,blockID)
			}
		}
	}
}
function copy(x,y,z,x2,y2,z2,world){
	if(x>x2){var px=x; x=x2; x2=px}
	if(y>y2){var py=y; y=y2; y2=py}
	if(z>z2){var pz=z; z=z2; z2=pz}

	copiedBlocks = [];
	for(var X=x; x2>=X; X++){
		var xRow = [];
		for(var Y=y; y2>=Y; Y++){
			var yRow = []
			for(var Z=z; z2>=Z; Z++){
				yRow.push(world.getBlock(X,Y,Z), world.getTags(X,Y,Z));
			}
			xRow.push(yRow);
		}
		copiedBlocks.push(xRow);
	}
}
function paste(x,y,z,world){
	for(var X = 0; X<copiedBlocks.length; X++){
		var xRow = copiedBlocks[X];
		for(var Y=0; Y<xRow.length; Y++){
			var yRow = xRow[Y];
			for(var Z=0; Z<yRow.length/2; Z++){
				var block = yRow[Z*2]
				world.setBlock(X+x,Y+y,Z+z,block)
				var tags = yRow[z*2+1]
				if(tags) world.setTags(X+x,Y+y,Z+z, tags)
			}
		}
	}
}
function replaceBlocks(x,y,z,x2,y2,z2, replace, into,world){
	if(x>x2){var px=x; x=x2; x2=px}
	if(y>y2){var py=y; y=y2; y2=py}
	if(z>z2){var pz=z; z=z2; z2=pz}
	for(var X=x; x2>=X; X++){
		for(var Y=y; y2>=Y; Y++){
			for(var Z=z; z2>=Z; Z++){
				if(world.getBlock(X,Y,Z) === replace){
					world.setBlock(X,Y,Z,into)
				}
			}
		}
	}
}

function fromPlayer(p,world){
	p.prevPosCmd = [round(p.x), ceil(p.y-p.height*0.5), round(p.z)]
	world.world.sendPlayer({type:"clientCmd",data:"fromPlayer",args:{x:p.prevPosCmd[0],y:p.prevPosCmd[1],z:p.prevPosCmd[2]}},p.id)
}
function fillToPlayer(id,p,world){
	if(!p.prevPosCmd) return
	//fills at player feet
	fillBlocks(p.prevPosCmd[0], p.prevPosCmd[1], p.prevPosCmd[2], round(p.x), ceil(p.y-p.height*0.5), round(p.z), id,world)
	world.world.sendPlayer({type:"clientCmd",data:"cancelFrom",args:{}},p.id)
}
function copyToPlayer(p,world){
	if(!p.prevPosCmd) return
	copy(p.prevPosCmd[0], p.prevPosCmd[1], p.prevPosCmd[2], round(p.x), ceil(p.y-p.height*0.5), round(p.z),world);
	p.copiedBlocksCmd = copiedBlocks
	world.world.sendPlayer({type:"clientCmd",data:"copySelect",args:{w:copiedBlocks.length,h:copiedBlocks[0].length,d:copiedBlocks[0][0].length}},p.id)
}
function pasteAtPlayer(p,world){
	if(!p.prevPosCmd) return
	copiedBlocks = p.copiedBlocksCmd
	if(!copiedBlocks) return
	paste(round(p.x), ceil(p.y-p.height*0.5), round(p.z),world)
	world.world.sendPlayer({type:"clientCmd",data:"cancelFrom",args:{}},p.id)
}
function replaceAtPlayer(replace,into,p,world){
	if(!p.prevPosCmd) return
	replaceBlocks(p.prevPosCmd[0], p.prevPosCmd[1], p.prevPosCmd[2], round(p.x), ceil(p.y-p.height*0.5), round(p.z), replace, into, world)
	world.world.sendPlayer({type:"clientCmd",data:"cancelFrom",args:{}},p.id)
}

let cancelShape = 0
async function hcyl(width, height, depth, id, X,Y,Z,world) {
	let cid = cancelShape
	let w2 = width * width
	let d2 = depth * depth
	let w3 = (width - 1.2) * (width - 1.2)
	let d3 = (depth - 1.2) * (depth - 1.2)
	for (let x = floor(-width); x <= ceil(width); x++) {
		for (let y = floor(-height); y <= ceil(height); y++) {
			for (let z = floor(-depth); z <= ceil(depth); z++) {
				let n = x * x / w2 + z * z / d2
				let n2 = x * x / w3 + z * z / d3
				if (n < 1 && n2 >= 1) {
					world.setBlock(round(X + x), round(Y + y), round(Z + z), id)
					await sleep(10)
					if(cancelShape > cid) return
				}
			}
		}
	}
}

async function cyl(width, height, depth, id, X,Y,Z,world) {
	let cid = cancelShape
	let w2 = width * width
	let d2 = depth * depth
	for (let x = floor(-width); x <= ceil(width); x++) {
		for (let y = floor(-height); y <= ceil(height); y++) {
			for (let z = floor(-depth); z <= ceil(depth); z++) {
				let n = x * x / w2 + z * z / d2
				if (n < 1) {
					world.setBlock(round(X + x), round(Y + y), round(Z + z), id)
					await sleep(10)
					if(cancelShape > cid) return
				}
			}
		}
	}
}

async function sphereoid(w, h, d, id, X,Y,Z,world) {
	let cid = cancelShape
	let w2 = w * w
	let h2 = h * h
	let d2 = d * d
	let w3 = (w - 1.5) * (w - 1.5)
	let h3 = (h - 1.5) * (h - 1.5)
	let d3 = (d - 1.5) * (d - 1.5)

	for (let y = floor(-h); y <= ceil(h); y++) {
		for (let x = floor(-w); x <= ceil(w); x++) {
			for (let z = floor(-d); z <= ceil(d); z++) {
				let n = x * x / w2 + y * y / h2 + z * z / d2
				let n2 = x * x / w3 + y * y / h3 + z * z / d3
				if (n < 1 && n2 >= 1) {
					world.setBlock(round(X + x), round(Y + y), round(Z + z), id)
					await sleep(10)
					if(cancelShape > cid) return
				}
			}
		}
	}
}
async function ball(w, h, d, id, X,Y,Z,world) {
	let cid = cancelShape
	let w2 = w * w
	let h2 = h * h
	let d2 = d * d

	for (let y = floor(-h); y <= ceil(h); y++) {
		for (let x = floor(-w); x <= ceil(w); x++) {
			for (let z = floor(-d); z <= ceil(d); z++) {
				let n = x * x / w2 + y * y / h2 + z * z / d2
				if (n < 1) {
					world.setBlock(round(X + x), round(Y + y), round(Z + z), id)
					await sleep(10)
					if(cancelShape > cid) return
				}
			}
		}
	}
}
/*function parsePosition(x,px,int=false){//stuff inside by Trexler
	let ret
	if(x.startsWith('~+')){
		ret = px+parseFloat(x.split("+")[1])
	}else if(x.startsWith('~-')){
		ret = px-parseFloat(x.split("-")[1])
	}else{
		ret = x.startsWith('~')?px:parseFloat(x)
	}
	if(int) ret = round(ret)
	return ret
}*/
function parseTarget(str,pos,world){
	if(str === "@s"){
		return [pos]
	}else if(str === "@a"){
		let a = world.world.players.slice()
		return a
	}else if(str === "@e"){
		return world.world.entities.slice()
	}else if(str === "@p"){
		let closest = Infinity, cp = undefined
		for(let P of world.world.players){
			let d = dist3(pos.x,pos.y,pos.z,P.x,P.y,P.z)
			if(d < closest){
				closest = d
				cp = P
			}
		}
		return [cp]
	}else{
		let p = getPlayerByUsername(str,world)
		return p ? [p] : []
	}
}
/*
types can be: root,literal,argument,redirect
if func exists, the node can be run with it at the end of stack
next is array of node ids
*/
let tempWorldForCommand
class CommandNode{
	constructor(type, name, func, info, argType, redirect, anonymousFunc, noCheats){
		this.type = type
		this.name = name
		this.func = func || undefined
		this.next = []
		this.world = tempWorldForCommand
		this.info = info || undefined
		this.redirect = redirect || undefined
		this.argType = argType || undefined
		this.anonymousFunc = anonymousFunc
		this.id = tempWorldForCommand.commandNodes.length
		this.noCheats = noCheats || false
		tempWorldForCommand.commandNodes.push(this)
	}
	then(){
		for(let n of arguments) this.next.push(n.id)
		return this
	}
	static l(name,func,info,anonymousFunc,noCheats){
		return new this("literal",name,func,info,null,null,anonymousFunc,noCheats)
	}
	static a(name,func,argType,anonymousFunc,noCheats){
		return new this("argument",name,func,null,argType,null,anonymousFunc,noCheats)
	}
	static r(name,redirect){
		return new this("redirect",name,null,null,null,redirect.id)
	}
}
function initDefaultCommands(world){
	tempWorldForCommand = world
	let help, tp, gm, sp
	new CommandNode("root").then(
		help = CommandNode.l("help","client", null,null,true).then(CommandNode.a("help_with_name","client",null,null,true)),
		CommandNode.r("?",help),
		CommandNode.l("echo",null,"Outputs data.").then(CommandNode.a("data", (args,pos,scope) => [args.data+"",""], null,null,true)),
		CommandNode.l("var",null, "Set a variable to a value. Value can be empty.").then(CommandNode.a("name").then(CommandNode.a("value",
		(args,pos,scope) => {
			if(!args.name) return ["Error: name required.","error"]
			scope[args.name] = args.value
		},null,null,true))),
		CommandNode.l("fromPlayer", (args,pos,scope) => fromPlayer(pos,world[pos.dimension]), "Sets starting position to current position", false),
		CommandNode.l("fillToPlayer",null,"Fills from starting position to current position").then(CommandNode.a("block_name",
		(args,pos,scope) => {
			let id = blockIds[args.block_name]
			if(!args.block_name) id = 0
			fillToPlayer(id,pos,world[pos.dimension])
		},"block",false)),
		CommandNode.l("copyToPlayer",(args,pos,scope) => copyToPlayer(pos,world[pos.dimension]),"Copys blocks from starting position to current position",false),
		CommandNode.l("pasteAtPlayer", (args,pos,scope) => pasteAtPlayer(pos,world[pos.dimension]), "Pastes copied blocks at the current position",false),
		CommandNode.l("replaceToPlayer",null,"Replace certain blocks from starting position to current position with a certain block").then(CommandNode.a("replace_what",null,"block").then(CommandNode.a("with_what",
		(args,pos,scope) => {
			let replace = blockIds[args.replace_what]
			if(!args.replace_what) replace = 0
			let into = blockIds[args.with_what]
			if(!args.with_what) into = 0
			replaceAtPlayer(replace,into,pos,world[pos.dimension])
		},"block",false))),
		CommandNode.l("cancelFrom","client","Delete starting position"),
		CommandNode.l("shape",null,"Creates a shape of certain shape.").then(
			CommandNode.l("sphere").then(CommandNode.a("width",null,"number").then(CommandNode.a("height",null,"number").then(CommandNode.a("depth",null,"number").then(CommandNode.a("block_name",
			(args,pos) => {
				let id = blockIds[args.block_name]
				if(!args.block_name) id = 0
				return ball(args.width || 0, args.height || 0, args.depth || 0, id, pos.x,pos.y,pos.z, world[pos.dimension])
			},"block").then(CommandNode.a("x",null,"number").then(CommandNode.a("y",null,"number").then(CommandNode.a("z",
			(args,pos) => {
				let id = blockIds[args.block_name]
				if(!args.block_name) id = 0
				return ball(args.width || 0, args.height || 0, args.depth || 0, id, args.x,args.y,args.z, world[pos.dimension])
			},"number")))))))),
			CommandNode.l("hollowSphere").then(CommandNode.a("width",null,"number").then(CommandNode.a("height",null,"number").then(CommandNode.a("depth",null,"number").then(CommandNode.a("block_name",
			(args,pos) => {
				let id = blockIds[args.block_name]
				if(!args.block_name) id = 0
				return sphereoid(args.width || 0, args.height || 0, args.depth || 0, id, pos.x,pos.y,pos.z, world[pos.dimension])
			},"block").then(CommandNode.a("x",null,"number").then(CommandNode.a("y",null,"number").then(CommandNode.a("z",
			(args,pos) => {
				let id = blockIds[args.block_name]
				if(!args.block_name) id = 0
				return sphereoid(args.width || 0, args.height || 0, args.depth || 0, id, args.x,args.y,args.z, world[pos.dimension])
			},"number")))))))),
			CommandNode.l("cylinder").then(CommandNode.a("width",null,"number").then(CommandNode.a("height",null,"number").then(CommandNode.a("depth",null,"number").then(CommandNode.a("block_name",
			(args,pos) => {
				let id = blockIds[args.block_name]
				if(!args.block_name) id = 0
				return cyl(args.width || 0, args.height || 0, args.depth || 0, id, pos.x,pos.y,pos.z, world[pos.dimension])
			},"block").then(CommandNode.a("x",null,"number").then(CommandNode.a("y",null,"number").then(CommandNode.a("z",
			(args,pos) => {
				let id = blockIds[args.block_name]
				if(!args.block_name) id = 0
				return cyl(args.width || 0, args.height || 0, args.depth || 0, id, args.x,args.y,args.z, world[pos.dimension])
			},"number")))))))),
			CommandNode.l("hollowCylinder").then(CommandNode.a("width",null,"number").then(CommandNode.a("height",null,"number").then(CommandNode.a("depth",null,"number").then(CommandNode.a("block_name",
			(args,pos) => {
				let id = blockIds[args.block_name]
				if(!args.block_name) id = 0
				return hcyl(args.width || 0, args.height || 0, args.depth || 0, id, pos.x,pos.y,pos.z, world[pos.dimension])
			},"block").then(CommandNode.a("x",null,"number").then(CommandNode.a("y",null,"number").then(CommandNode.a("z",
			(args,pos) => {
				let id = blockIds[args.block_name]
				if(!args.block_name) id = 0
				return hcyl(args.width || 0, args.height || 0, args.depth || 0, id, args.x,args.y,args.z, world[pos.dimension])
			},"number"))))))))
		),
		CommandNode.l("cancelShape", () => {cancelShape++}, "Stop generating shapes currently being generated."),
		CommandNode.l("give",null,"Gives the target the the specified amount of specified blocks").then(CommandNode.a("target",null,"target").then(CommandNode.a("block_name",
		(args,pos,scope) => {
			let id = blockIds[args.block_name]
			let arr = parseTarget(args.target,pos,world[pos.dimension])
			if(arr.length){
				for(let i of arr){
					world[i.dimension].addItems(i.x,i.y,i.z,0,0,0,id,false,1)
				}
			}else return ["No such target: "+args.target,"error"]
		},"block").then(CommandNode.a("amount",
		(args,pos,scope) => {
			let id = blockIds[args.block_name]
			let amount = args.amount || 1
			let arr = parseTarget(args.target,pos,world[pos.dimension])
			if(arr.length){
				for(let i of arr){
					world[i.dimension].addItems(i.x,i.y,i.z,0,0,0,id,false,amount)
				}
			}else return ["No such target: "+args.target,"error"]
		},"number")))),
		CommandNode.l("kill").then(CommandNode.a("target",
		(args,pos,scope) => {
			if(world.settings.killCmdOff) return ["Kill command is disabled on this world.","error"]
			args.target = args.target || "@s"
			let arr = parseTarget(args.target,pos,world[pos.dimension])
			if(arr.length){
				for(let i of arr){
					if(i.type === "Player"){
						i.health = 0
						i.damage(1,pos.username+" killed "+(args.target === "@a" ? "everyone" : args.target)+" with the kill command.")
					}else{
						world[i.dimension].deleteEntity(i.id)
					}
				}
			}else return ["No such target: "+args.target,"error"]
		},"target").then(CommandNode.a("message",
		(args,pos,scope) => {
			if(world.settings.killCmdOff) return ["Kill command is disabled on this world.","error"]
			args.target = args.target || "@s"
			let arr = parseTarget(args.target,pos,world[pos.dimension])
			if(arr.length){
				for(let i of arr){
					if(i.type === "Player"){
						i.health = 0
						i.damage(1,args.message)
					}else{
						world[i.dimension].deleteEntity(i.id)
					}
				}
			}else return ["No such target: "+args.target,"error"]
		}))),
		CommandNode.l("time",null,"mode can be: set, add. n is the time to set to. 1000 is a day. n an also be: day, night").then(
			CommandNode.l("set").then(CommandNode.a("time", args => {world.time = args.time === "day" ? 500 : (args.time === "night" ? 0 : parseFloat(args.time))},"number")),
			CommandNode.l("add").then(CommandNode.a("amount", args => {world.time += parseFloat(args.time)},"number"))
		),
		CommandNode.l("weather",null,"Set weather. May take a few moments to start.").then(
			CommandNode.l("clear", () => {world.weather = ""}),
			CommandNode.l("rain", () => {world.weather = "rain"}),
			CommandNode.l("snow", () => {world.weather = "snow"})
		),
		tp = CommandNode.l("teleport",null,"Teleport certain player/self to location/entity/player").then(CommandNode.a("target",null,"target").then(
			CommandNode.a("x",null,"x").then(CommandNode.a("y",null,"y").then(CommandNode.a("z",
			(args,pos) => {
				let arr = parseTarget(args.target,pos,world[pos.dimension])
				for(let e of arr) e.tp(args.x,args.y,args.z)
			}, "z"))),
			CommandNode.a("to_target",
			(args,pos) => {
				let arr = parseTarget(args.target,pos,world[pos.dimension]), to = parseTarget(args.to_target,pos,world[pos.dimension])[0]
				if(!to) return ["No such target: "+args.target,"error"]
				for(let e of arr) e.tp(args.x,args.y,args.z)
			},"target")
		)),
		CommandNode.r("tp",tp),
		CommandNode.l("playSound",null,"Plays a sound. Volume should be a number from 0 to 1.").then(CommandNode.a("sound",
		(args,pos,scope) => {
			world.sendAll({type:"playSound", data:args.sound, volume:1, pitch:1})
		},"sound").then(CommandNode.a("volume",
		(args,pos,scope) => {
			world.sendAll({type:"playSound", data:args.sound, volume:parseFloat(args.volume), pitch:1})
		},"number").then(CommandNode.a("pitch",
		(args,pos,scope) => {
			world.sendAll({type:"playSound", data:args.sound, volume:parseFloat(args.volume), pitch:parseFloat(args.pitch)})
		},"number")))),
		CommandNode.l("title",null,"Shows text on screen. fadeIn and fadeOut and stay are miliseconds.").then(CommandNode.a("text", args => {world.sendAll({type:"title",data:args.text,fadeIn:500,fadeOut:1000,stay:2000})}).then(CommandNode.a("subtext", args => {world.sendAll({type:"title",data:args.text,sub:args.subtext,fadeIn:500,fadeOut:1000,stay:2000})}).then(CommandNode.a("color", args => {world.sendAll({type:"title",data:args.text,sub:args.subtext,color:args.color,fadeIn:500,fadeOut:1000,stay:2000})}).then(
			CommandNode.a("fadeIn",null,"number").then(CommandNode.a("fadeOut",null,"number").then(CommandNode.a("stay",args => {world.sendAll({type:"title",data:args.text,sub:args.subtext,color:args.color,fadeIn:args.fadeIn,fadeOut:args.fadeOut,stay:args.stay})},"number")))
		)))),
		CommandNode.l("setBlock",null,"Set a block at specified position").then(CommandNode.a("x",null,"x").then(CommandNode.a("y",null,"y").then(CommandNode.a("z",null,"number").then(CommandNode.a("block",
		(args,pos,scope) => {
			let block = blockIds[args.block]
			if(block === undefined) block = parseInt(args.block)
			if(!blockData[block]) return ["No such block "+block,"error"]
			world[pos.dimension].setBlock(args.x,args.y,args.z,block)
		},"block"))))),
		CommandNode.l("getBlock",null,"Gets a block at the specified position and sets a variable called block_name.").then(CommandNode.a("x",null,"x").then(CommandNode.a("y",null,"y").then(CommandNode.a("z",
		(args,pos,scope) => {
			scope.block_name = blockData[world[pos.dimension].getBlock(args.x,args.y,args.z,pos.dimension)].name
		},"z")))),
		CommandNode.l("getPos",null,"Gets position of specified target and sets target_x, target_y, target_z, target_dimension, target_name. Target can be @s, @p, or a username.").then(CommandNode.a("target",
		(args,pos,scope) => {
			args.target = args.target || "@s"
			let arr = parseTarget(args.target,pos,world[pos.dimension])
			if(!arr.length) return ["No such target: "+args.target,"error"]
			let t = arr[0]
			scope.target_x = t.x
			scope.target_y = t.y
			scope.target_z = t.z
			scope.target_dimension = t.dimension
			scope.target_name = t.username || t.name
		},"target")),
		CommandNode.l("wait",null,"Wait for certain amount of milliseconds.").then(CommandNode.a("time", args => sleep(args.time),"number",null,true)),
		CommandNode.l("seed", () => [world.worldSeed+"",""], null,null,true),
		CommandNode.l("effect",null,"Start a effect on target. time is in seconds. level should be more than zero.").then(CommandNode.a("target",null,"target").then(CommandNode.a("name").then(CommandNode.a("time",null,"number").then(CommandNode.a("level",
		(args,pos,scope) => {
			let arr = parseTarget(args.target,pos,world[pos.dimension])
			if(!arr.length) return ["No such target: "+args.target,"error"]
			let time = parseFloat(args.time)
			let level = parseFloat(args.level)
			for(let ent of arr){
				if(ent.applyEffect) ent.applyEffect(args.name, level,time,true)
			}
		},"number").then(CommandNode.a("hide_particles",
		(args,pos,scope) => {
			let arr = parseTarget(args.target,pos,world[pos.dimension])
			if(!arr.length) return ["No such target: "+args.target,"error"]
			let time = parseFloat(args.time)
			let level = parseFloat(args.level)
			let showParticles = args.hide_particles
			for(let ent of arr){
				if(ent.applyEffect) ent.applyEffect(args.name, level,time,showParticles)
			}
		},"boolean")))))),
		gm = CommandNode.l("gameMode",null,"Set game mode.",null,true).then(CommandNode.a("mode",
		(args,pos) => {
			let m = args.mode
			if(m === "creative" || m === "c") pos.gameMode = "creative"
			else if(m === "survival" || m === "s") pos.gameMode = "survival"
			else if(m === "spectator" || m === "l") pos.gameMode = "spectator", pos.riding = null
			else return ["Game mode doesn't exsist: "+m,"error"]
			world.sendPlayer({type:"gameMode",gameMode:pos.gameMode},pos.id)
		},"gameMode",false)),
		CommandNode.r("gm",gm),
		CommandNode.l("clear","client","Clear messages",null,true),
		CommandNode.l("clearHistory","client","Clears chat history and input history.",null,true),
		sp = CommandNode.l("spectatePlayer",null,"Spectate a player. If remote_control is set to true and you are the host or certain people, remote control will be enabled.").then(CommandNode.a("username",
		(args,pos) =>{
			let player = getPlayerByUsername(args.username,world[pos.dimension])
			if(player){
				pos.gameMode = "spectator"
				pos.riding = null
				if(args.spectatePlayer_remoteControl === true) p.spectateRemoteControl = true
				world.sendPlayer({type:"gameMode",gameMode:pos.gameMode, spectating:player.id,spectateRemoteControl:false},pos.id)
			}else return ["Player doesn't exist: "+args.username,"error"]
		}).then(CommandNode.a("remoteControl",
		(args,pos) =>{
			let player = getPlayerByUsername(args.username,world[pos.dimension])
			if(player){
				pos.gameMode = "spectator"
				pos.riding = null
				world.sendPlayer({type:"gameMode",gameMode:pos.gameMode, spectating:player.id,spectateRemoteControl:false,spectateRemoteControl:!!args.remoteControl},pos.id)
			}else return ["Player doesn't exist: "+args.username,"error"]
		},"boolean"))),
		CommandNode.r("sp",sp),
		CommandNode.l("reloadChunks","client","Reload chunks. May cause freezing.",null,true),
		CommandNode.l("ban",null,"Bans a player. They cannot rejoin the world. Reason is the reason why you banned them.").then(CommandNode.a("ban_username","client",null,null,true).then(CommandNode.a("ban_reason","client",null,null,true))),
		CommandNode.l("unban").then(CommandNode.a("unban_username","client",null,null,true)),
		CommandNode.l("whitelist",null,"Allow certain people to join. Must be enabled to work.").then(CommandNode.a("whitelist_action","client",null,null,true).then(CommandNode.a("whitelist_username","client",null,null,true))),
		CommandNode.l("online","client","Lists people that are in here.",null,true),
		CommandNode.l("sendEval",null,"Send javascript to players. Can only be used by certain people. Target can be: username, @a, @A. If target isn't specified, it sends it to all players except you. If target is @A, it send to everyone including you.").then(CommandNode.a("target",null,"target").then(CommandNode.a("sendEval_data","client")))
	)
	/*args:["target","name","time","level","hide_particles"],
		argValues:{target:["type:player","@a","@e","@p"], name:["wither","blur"], time:["type:number"], level:"type:number", show_particles:"type:boolean"},
		info:"Start a effect on target. time is in seconds. level should be more than zero.",
		func: (args,pos,scope,world) => {
			let arr = parseTarget(args.target,pos,world)
			if(!arr || !arr[0]) return ["No such target: "+args.target,"error"]
			let time = parseFloat(args.time)
			let level = parseFloat(args.level)
			let showParticles = args.hide_particles !== "true"
			for(let ent of arr){
				if(ent.applyEffect) ent.applyEffect(args.name, level,time,showParticles)
			}
		} */
}
win.initDefaultCommands = initDefaultCommands
}
const {initDefaultCommands} = win

/*function getCmd(name,world){
	for(let i of world.serverCommands){
		if(i.name.toLowerCase() === name.toLowerCase()){
			return i
		}
		if(i.names && i.names.includes(name)){
			return i
		}
	}
}*/
const isString = /\p{L}|\p{N}|\?|_|@|\./u, isSpace = /[^\S\n]/
class CommandReader{
	constructor(str, noRead, tokens = []){
		this.str = str
		this.idx = 0
		this.tokenStart = 0
		this.prevTokenEnd = 0
		this.prevTokenStart = 0
		this.tokens = tokens
		if(!tokens.length){
			let idx = 0
			let tokenStart = 0, tokenEnd = 0
			findingToken:while(idx < str.length){
				tokenStart = idx
				let c = str[idx]
				if(c === "/"  && str[idx+1] === "/") tokens.push("//",null), idx+=2
				else if(c === "/" || c === "$" || c === "\n" || c === "+" || c === "-" || c === "*" || c === "(" || c === ")" || c === "~") tokens.push(c,null), idx++
				else if(c === "&" && str[idx+1] === "&") tokens.push("&&",null), idx+=2
				else if(isSpace.test(c)){
					idx++
					c = str[idx]
					continue findingToken
				}else if(c === "#"){//comment
					while(c !== "\n" && c){
						idx++
						c = str[idx]
					}
					continue findingToken
				}else if(c === '"' || c === "'"){
					const q = c
					let data = ""
					idx++
					c = str[idx]
					while(c !== q && c){
						data += c
						idx++
						c = str[idx]
					}
					tokens.push("string",data)
					idx++
				}else if(isString.test(c)){ //characters like: a b c 1 2 3
					let data = ""
					do{
						data += c
						idx++
						c = str[idx]
					}while(isString.test(c) && c)
					tokens.push("string",data)
				}else throw "§cSyntax error: Unknown character "+c
				tokenEnd = idx
				tokens.push(tokenStart,tokenEnd)
			}
			tokens.push("end",null,idx,str.length)
		}
		if(!noRead) this.read()
	}
	read(){
		if(arguments.length)expectCheck:{
			for(let i of arguments){
				if(this.nextTokenType === i) break expectCheck
			}
			throw "§cSyntax error: Unexpected "+this.nextTokenType+", Expected: "+Array.prototype.join.call(arguments," ")
		}
		let prevToken = this.tokens[this.idx+1]
		this.prevTokenStart = this.tokens[this.idx+2]
		this.prevTokenEnd = this.tokens[this.idx+3]
		if(this.idx === this.tokens.length-1) return prevToken
		this.idx += 4
		this.nextTokenType = this.tokens[this.idx]
		this.nextTokenData = this.tokens[this.idx+1]
		this.tokenStart = this.tokens[this.idx+2]
		return prevToken
	}
	get stackEnd(){
		return this.nextTokenType === "/" || this.nextTokenType === "end"
	}
	get stackEndNoSpace(){
		return (this.nextTokenType === "/" || this.nextTokenType === "end") && this.prevTokenEnd === this.tokenStart
	}
	clone(){
		let other = new this.constructor(this.str,true,this.tokens)
		other.idx = this.idx
		other.nextTokenType = this.nextTokenType
		other.nextTokenData = this.nextTokenData
		other.tokenStart = this.tokenStart
		other.prevTokenEnd = this.prevTokenEnd
		other.prevTokenStart = this.prevTokenStart
		return other
	}
	goTo(other){//expects other.str to equal this.str
		this.idx = other.idx
		this.nextTokenType = other.nextTokenType
		this.nextTokenData = other.nextTokenData
		this.tokenStart = other.tokenStart
		this.prevTokenEnd = other.prevTokenEnd
		this.prevTokenStart = other.prevTokenStart
	}
	nextIs(type,data){
		return this.nextTokenType === type && (!this.nextTokenData || this.nextTokenData === data)
	}
}
win.CommandReader = CommandReader
//use something like this: https://wiki.vg/Command_Data
{
function parseLines(reader){
	let cmds = ["all"]
	while(reader.nextTokenType !== "end"){
		if(reader.nextTokenType === "/") reader.read("/")
		let nodes = ["cmd"]
		while(!reader.stackEnd){
			let n = parseAdd(reader)
			nodes.push(n)
		}
		if(reader.stackEndNoSpace) nodes.stackEndNoSpace = true
		else nodes.nextTokenStart = reader.tokenStart
		cmds.push(nodes)
	}
	return cmds
}
function parseAdd(reader){
	let ret = parseMult(reader)
	while(reader.nextTokenType === "+" || reader.nextTokenType === "-"){
		let type = reader.nextTokenType
		reader.read()
		let start = reader.prevTokenStart, end = reader.prevTokenEnd
		ret = [type, ret, parseMult(reader)]
		ret.start = start, ret.end = end
	}
	return ret
}
function parseMult(reader){
	let ret = parseValue(reader)
	while(reader.nextTokenType === "*" || reader.nextTokenType === "//"){
		let type = reader.nextTokenType
		reader.read()
		let start = reader.prevTokenStart, end = reader.prevTokenEnd
		ret = [type, ret, parseValue(reader)]
		ret.start = start, ret.end = end
	}
	return ret
}
function parseValue(reader){
	let start = reader.tokenStart
	let ret
	if(reader.nextTokenType === "$"){
		reader.read("$")
		ret = ["get",reader.read("string")]
	}else if(reader.nextTokenType === "("){
		reader.read()
		ret = parseAdd(reader)
		reader.read(")")
	}else if(reader.nextTokenType === "~"){
		reader.read()
		ret = ["~"]
	}else{
		let v = reader.read("string")
		if(!isNaN(v)) v = +v
		else if(v === "true") v = true
		else if(v === "false") v = false
		ret = ["string",v]
	}
	ret.start = start, ret.end = reader.prevTokenEnd
	return ret
}
function parseCmd(str,world){
	let reader = new CommandReader(str)
	return parseLines(reader,world)
}
win.parseCmd = parseCmd
}
const {parseCmd} = win
async function runCmd(str, pos, world, anonymous = false, cb = emptyFunc, cheats = true){
	let output = [], newOutputs = []
	let scope = {}
	let cmds
	try{
		cmds = parseCmd(str,world)
		await runParsedCommand(cmds,pos,scope,newOutputs,output,world,anonymous,cb,cheats)
	}catch(e){
		if(typeof e === "string"){
			newOutputs.push(e,"error")
			output.push(...newOutputs)
			return cb(output,newOutputs)
		}else{
			if(e instanceof Error) e.message += "\nrunning command: "+str
			throw e
		}
	}
	output.push(...newOutputs)
	return cb(output,newOutputs)
}
function searchCmdStack(commandNodes,parentNode,stack,stacki,args){
	if(parentNode.type === "redirect"){
		parentNode = commandNodes[parentNode.redirect]
	}
	if(!parentNode.next.length) throw "§cUnknown command: No more nodes after "+parentNode.name
	let error
	for(let n of parentNode.next){//find the best match in the next nodes
		let node = commandNodes[n]
		if(node.type === "literal" || node.type === "redirect"){
			if(stack[stacki][0] !== "string" || (stack[stacki][1]+"").toLowerCase() !== node.name.toLowerCase()) continue
		}else if(node.type === "argument"){
			args[node.name] = stack[stacki]
			if(typeof args[node.name] === "object") args[node.name].argType = node.argType
		}
		let result
		if(stacki === stack.length-1){//last node in stack
			if(node.type === "redirect"){
				result = commandNodes[node.redirect]
			}else result = node
			if(!result.func){
				error = "§cUnknown command: Incomplete command at "+node.name
				continue
			}
		}else{
			try{
				result = searchCmdStack(commandNodes,node,stack,stacki+1,args)
			}catch(e){
				error = e
			}
		}
		if(result !== undefined){
			return result
		}
	}
	throw error || "§cUnknown command: Node does not go after "+parentNode.name
}
win.searchCmdStack = searchCmdStack
async function runParsedCommand(data,pos,scope,newOutputs,output,world,anonymous,cb,cheats, argType=null){//Used if client runs server command
	const action = data[0]
	if(action === "cmd"){
		let actualArgs = {}
		let cmd = searchCmdStack(world.commandNodes,world.commandNodes[0],data,1,actualArgs)
		if(!cheats && !cmd.noCheats){
			throw "§cError: Command requires cheats"
		}
		for(let i in actualArgs){
			actualArgs[i] = await runParsedCommand(actualArgs[i],pos,scope,newOutputs,output,world,anonymous,cb,cheats,actualArgs[i].argType)
		}
		let func = anonymous ? cmd.anonymousFunc !== false && (cmd.anonymousFunc || cmd.func) : cmd.func
		if(cmd.func === "client"){
			if(anonymous) throw "§cCannot run command "+cmd.name
			else world.sendPlayer({type:"clientCmd",data:cmd.name,args:actualArgs},pos.id)
		}else if(func){
			let thisOutput = func(actualArgs,pos,scope)
			if(thisOutput instanceof Promise){//Output previous data because new data won't be instant
				output.push(...newOutputs)
				cb(output,newOutputs)
				newOutputs.length = 0
				thisOutput = await thisOutput
			}
			if(thisOutput && thisOutput[1] === "error"){
				throw thisOutput[0]
			}
			if(thisOutput) newOutputs.push(...thisOutput)
		}else{
			throw "§cError: Incomplete command at "+cmd.name
		}
	}else if(action === "all"){
		for(let i=1; i<data.length; i++) await runParsedCommand(data[i],pos,scope,newOutputs,output,world,anonymous,cb,cheats,argType)
	}else if(action === "get") return scope[data[1]]
	else if(action === "+") return await runParsedCommand(data[1],pos,scope,newOutputs,output,world,anonymous,cb,cheats,argType)+await runParsedCommand(data[2],pos,scope,newOutputs,output,world,anonymous,cb,cheats,argType)
	else if(action === "-") return await runParsedCommand(data[1],pos,scope,newOutputs,output,world,anonymous,cb,cheats,argType)-await runParsedCommand(data[2],pos,scope,newOutputs,output,world,anonymous,cb,cheats,argType)
	else if(action === "*") return await runParsedCommand(data[1],pos,scope,newOutputs,output,world,anonymous,cb,cheats,argType)*await runParsedCommand(data[2],pos,scope,newOutputs,output,world,anonymous,cb,cheats,argType)
	else if(action === "/") return await runParsedCommand(data[1],pos,scope,newOutputs,output,world,anonymous,cb,cheats,argType)/await runParsedCommand(data[2],pos,scope,newOutputs,output,world,anonymous,cb,cheats,argType)
	else if(action === "~") return argType === "x" ? pos.x : argType === "y" ? pos.y : argType === "z" ? pos.z : null
	else if(action === "string") return data[1]
	else throw "Invalid action "+action
}
/*async function runCmdFromClient(name,args,pos,scope,world,id,cheats){
	let cmd = getCmd(name,world)
	let newOutputs = [], output = []
	await runParsedCommand(name,cmd,args,pos,scope,newOutputs,output,world,false,undefined,cheats)
	output.push(...newOutputs)
	world.sendPlayer({type:"commandDone",data:output,scope,id},pos.id)
}*/

class Contacts {
	constructor() {
		this.array = []
		this.size = 0
	}
	add(x, y, z, block, data) {
		if (this.size === this.array.length) {
			this.array.push([ x, y, z, block, data ])
		} else {
			this.array[this.size][0] = x
			this.array[this.size][1] = y
			this.array[this.size][2] = z
			this.array[this.size][3] = block
			this.array[this.size][4] = data
		}
		this.size++
	}
	clear() {
		this.size = 0
	}
}

let inBox = function(p, x, y, z, w, h, d) {
	let iy = y - h/2 - p.height*0.5
	let ih = h + p.height
	let ix = x - w/2 - p.width*0.5
	let iw = w + p.width
	let iz = z - d/2 - p.depth*0.5
	let id = d + p.depth
	return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y < iy + ih && p.z < iz + id
}
let onBox = function(p, x, y, z, w, h, d) {
	let iy = y - h/2 - p.height*0.5
	let ih = h + p.height
	let ix = x - w/2 - p.width*0.5
	let iw = w + p.width
	let iz = z - d/2 - p.depth*0.5
	let id = d + p.depth
	return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y <= iy + ih && p.z < iz + id
}
let touchingBox = function(p, x, y, z, w, h, d) {
	let iy = y - h/2 - p.height*0.5 - 0.1
	let ih = h + p.height + 0.2
	let ix = x - w/2 - p.width*0.5 - 0.1
	let iw = w + p.width + 0.2
	let iz = z - d/2 - p.depth*0.5 - 0.1
	let id = d + p.depth + 0.2
	return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y < iy + ih && p.z < iz + id
}

let entities = [], entityIds = {}
class Entity {
	constructor(x, y, z, pitch, yaw, velx, vely, velz, width, height, depth, vertices, texture, faces, despawns, vao, dimension) {
		this.x = x
		this.y = y
		this.z = z
		this.previousX = x
		this.previousY = y
		this.previousZ = z
		this.canStepX = true
		this.canStepY = true
		this.pitch = pitch
		this.yaw = yaw
		this.roll = 0
		this.pitch2 = 0
		this.previousPitch = pitch
		this.previousYaw = yaw
		this.previousRoll = 0
		this.previousPitch2 = 0
		this.velx = velx
		this.vely = vely
		this.velz = velz
		this.width = width
		this.height = height
		this.depth = depth
		this.offsetY = 0
		this.prevOffsetY = 0
		this.extraSize = 0
		this.hidden = false
		this.harmEffect = 0
		this.contacts = new Contacts()
		this.lastUpdate = performance.now()
		this.onGround = false
		this.hasCollided = false
		this.gravityStength = -0.091
		this.standingOn = 0
		this.insideBlock = 0
		this.despawns = despawns
		this.spawn = this.lastUpdate
		this.canDespawn = false
		this.dieEffect = 0
		this.dieRotate = 0
		this.burning = false
		this.liquid = false
		this.prevLiquid = false
		this.wet = false
		this.parts = {}
		this.shader = 0
		this.world = null //also set in addEntity
		this.chunkX = x >> 4
		this.chunkZ = z >> 4
		this.chunkDimension = ""
		this.glow = false
		this.dimension = dimension
		this.canRide = false
		//this.hitboxWidth = this.hitboxWidth || max(this.width,this.depth)//unused
		//this.hitboxHeight = this.hitboxHeight || this.height
		this.rideOffsetX = 0
		this.rideOffsetY = this.hitboxHeight/2
		this.rideOffsetZ = 0
		this.portalEffect = 0
		this.portalFadeOutEffect = 0
		this.doingPortal = 0
	}
	tp(x,y,z, dimension = this.dimension){
		this.x = x
		this.y = y
		this.z = z
		this.dimension = dimension
		this.world.sendEntityPos(this)
		this.updateChunk()
	}
	updateVelocity(now) {
		this.standingOn = this.world.getBlock(round(this.x), floor(this.y-this.height/2), round(this.z), this.dimension)
		this.insideBlock = this.world.getBlock(round(this.x),round(this.y),round(this.z), this.dimension)
		if(this.prevLiquid !== this.liquid){
			this.prevLiquid = this.liquid
			if(this.liquid && this.wet){
				let pitch = (1/abs(this.y-this.previousY)*0.05+Math.random()*0.2)/((this.width+this.depth)*0.25/*0.25=average&correct width*/)
				if(isFinite(pitch)) this.world.playSound(this.x,this.y-this.height/2,this.z,"liquid.splash",1,pitch)
				this.world.sendAll({
          type:"particles", particleType:"SplashParticle",
          x:this.x, y:this.y-this.height/2, z:this.z, dimension:this.dimension, amount: 10
        })
			}
		}
		this.vely += this.gravityStength
		let drag = this.liquid && !this.canFloat ? 0.7 : (this.onGround ? 0.8 : 0.9)
		if(blockData[this.standingOn].slide) drag = blockData[this.standingOn].slide
		this.velz += (this.velz * drag - this.velz)
		this.velx += (this.velx * drag - this.velx)
		this.vely += (this.vely * drag - this.vely)
	}
	collided(x, y, z, vx, vy, vz, block) {
		let verts = blockData[block].shape.verts
		let px = this.x - this.width / 2 - x
		let py = this.y - this.height / 2 - y
		let pz = this.z - this.depth / 2 - z
		let pxx = this.x + this.width / 2 - x
		let pyy = this.y + this.height / 2 - y
		let pzz = this.z + this.depth / 2 - z
		let minX, minY, minZ, maxX, maxY, maxZ, min, max
		let stuckInBlock = this.mob && this.insideBlock && blockData[this.insideBlock].solid

		//Top and bottom faces
		let faces = verts[0]
		if (vy <= 0) {
			faces = verts[1]
		}
		if (vx === null && vz === null) {
			let col = false
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minZ = min[2]
				max = face.max
				maxX = max[0]
				maxZ = max[2]
				if (face[1] > py && face[1] < pyy && minX < pxx && maxX > px && minZ < pzz && maxZ > pz) {
					col = true
					if (vy <= 0) {
						this.onGround = true
						if(!stuckInBlock) this.y = face[1] + y + this.height / 2; else this.y = this.previousY
						this.vely = 0
					} else {
						if(!stuckInBlock) this.y = face[1] + y - this.height / 2; else this.y = this.previousY
						this.vely = 0
					}
				}
			}
			return col
		}

		//West and East faces
		if (vx < 0) {
			faces = verts[4]
		} else if (vx > 0) {
			faces = verts[5]
		}
		if (vx !== null) {
			let col = false
			for (let face of faces) {
				min = face.min
				minZ = min[2]
				minY = min[1]
				max = face.max
				maxZ = max[2]
				maxY = max[1]
				if (face[0] > px && face[0] < pxx && minY < pyy && maxY > py && minZ < pzz && maxZ > pz) {
					if (maxY - py > 0.5) {
						this.canStepX = false
						if(!stuckInBlock) this.x = x + face[0] + (vx < 0 ? this.width / 2 : -this.width / 2); else this.y = this.previousX
						this.velx = 0
					}
					col = true
				}
			}
			return col
		}

		//South and North faces
		if (vz < 0) {
			faces = verts[2]
		} else if (vz > 0) {
			faces = verts[3]
		}
		if (vz !== null) {
			let col = false
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minY = min[1]
				max = face.max
				maxX = max[0]
				maxY = max[1]
				if (face[2] > pz && face[2] < pzz && minY < pyy && maxY > py && minX < pxx && maxX > px) {
					if (maxY - py > 0.5) {
						this.canStepZ = false
						if(!stuckInBlock) this.z = z + face[2] + (vz < 0 ? this.depth / 2 : -this.depth / 2); else this.y = this.previousY
						this.velz = 0
					}
					col = true
				}
			}
			return col
		}
	}
	move(now) {
		let steps = Math.ceil(max(abs(this.velx / (this.width/2)), abs(this.vely / (this.height/2)), abs(this.velz / (this.depth/2)), 1))
		const VX = this.velx / steps
		const VY = this.vely / steps
		const VZ = this.velz / steps
		
		let pminX = floor(this.x - this.width / 2)
		let pmaxX = ceil(this.x + this.width / 2)
		let pminY = floor(this.y - this.height / 2)
		let pmaxY = ceil(this.y + this.height / 2)
		let pminZ = floor(this.z - this.depth / 2)
		let pmaxZ = ceil(this.z + this.depth / 2)
		let block = null

		let ontouch, closestTouch = Infinity
		let touchX, touchY, touchZ
		this.liquid = this.wet = false
		for (let x = pminX; x <= pmaxX; x++) {
			for (let y = pminY; y <= pmaxY; y++) {
				for (let z = pminZ; z <= pmaxZ; z++) {
					let block = this.world.getBlock(x, y, z, this.dimension)
					if (block && blockData[block].solid) {
						this.contacts.add(x, y, z, block)
					}
					if(blockData[block].activate){
						blockData[block].activate(x,y,z,block,this,this.world)
					}
					if(!inBox(this,x,y,z,1,1,1)) continue
					if(x === round(this.x) && z === round(this.z) && blockData[block].liquid){
						this.liquid = true
						if(this.canFloat && x === round(this.x) && z === round(this.z) && y === round(this.y)){
							this.vely+=1/4
						}
						if(blockData[block].wet) this.wet = true
					}
					if(blockData[block].getCurrent){
						var me = blockData[block]
						var c = me.getCurrent(x,y,z,undefined,undefined,this.world)
						this.velx += (c.x||0)/64
						this.velz += (c.z||0)/64
						var under = this.world.getBlock(x,y-1,z,this.dimension)
						if(me.isThis(under) && under !== me.id) this.vely -= 1/128
					}
					if(blockData[block].ontouch){
						let dist = max(abs(x-this.x),abs(z-this.z),abs(y-this.y))
						if(dist<closestTouch){
							closestTouch = dist
							ontouch = blockData[block].serverontouch
							touchX = x, touchY = y, touchZ = z
						}
					}
					if(this.ontouch) this.ontouch(x,y,z,block)
				}
			}
		}
		this.world.getEntitiesNear(this.x,this.y,this.z, max(this.width,this.height,this.depth)/2, nearEntityArray)
		for(let e of nearEntityArray) {
			if(e.canStandOn && e.block && e.x > pminX && e.x < pmaxX && e.y > pminY && e.y < pmaxY && e.z > pminZ && e.z < pmaxZ) {
				this.contacts.add(e.x, e.y, e.z, e.block, e)
			}
		}
		if(this.world.weather === "rain" && this.world.weatherAmount > 0.5){
			let top = this.world.getSolidTop(round(this.x),round(this.z))
			if(this.y > top) this.wet = true
		}

		this.previousX = this.x
		this.previousY = this.y
		this.previousZ = this.z
		this.previousPitch = this.pitch
		this.previousYaw = this.yaw
		this.previousRoll = this.roll
		this.previousPitch2 = this.pitch2
		this.prevOffsetY = this.offsetY
		this.hasCollided = false
		for(let part in this.parts){
			this.parts[part].prx = this.parts[part].rx
			this.parts[part].pry = this.parts[part].ry
			this.parts[part].prz = this.parts[part].rz
			this.parts[part].pry2 = this.parts[part].ry2
		}

		let maxpushX = 0, minpushX = 0, maxpushY = 0, minpushY = 0, maxpushZ = 0, minpushZ = 0
		for (let j = 1; j <= steps; j++) {
			let px = this.x, pz = this.z, py = this.y
			
			this.canStepX = false
			this.canStepY = false
			this.onGround = false
			//Check collisions in the Y direction
			this.y += VY
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				let x = block[0], y = block[1], z = block[2], vy = VY, thispush = 0
				if(block[4]){
					x = block[4].previousX
					z = block[4].previousZ
					vy -= (block[4].y-block[4].previousY)/steps
					y = lerp(j/steps,block[4].previousY,y)
					thispush = block[4].vely
				}
				if (this.collided(x, y, z, null, vy, null, block[3])) {
					this.hasCollided = true
					if(blockData[block[3]].bounciness){
						thispush -= (VY*steps-thispush)*blockData[block[3]].bounciness
					}
					maxpushY = max(maxpushY,thispush)
					minpushY = min(minpushY,thispush)
					//break
				}
			}

			if (this.onGround) {
				this.canStepX = true
				this.canStepZ = true
			}

			//Check collisions in the X direction
			this.x += VX
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				let x = block[0], y = block[1], z = block[2], vx = VX, thispush = 0
				if(block[4]){
					z = block[4].previousZ
					vx -= (block[4].x-block[4].previousX)/steps
					x = lerp(j/steps,block[4].previousX,x)
					thispush = block[4].velx
				}
				if (this.collided(x, y, z, vx, null, null, block[3])) {
					if (this.canStepX && !this.world.getBlock(block[0], block[1] + 1, block[2], this.dimension) && !this.world.getBlock(block[0], block[1] + 2, block[2]), this.dimension) {
						continue
					}
					this.hasCollided = true
					if(blockData[block[3]].bounciness){
						thispush -= (VX*steps-thispush)*blockData[block[3]].bounciness
					}
					maxpushX = max(maxpushX,thispush)
					minpushX = min(minpushX,thispush)
					//break
				}
			}

			//Check collisions in the Z direction
			this.z += VZ
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				let x = block[0], y = block[1], z = block[2], vz = VZ, thispush = 0
				if(block[4]){
					vz -= (block[4].z-block[4].previousZ)/steps
					z = lerp(j/steps,block[4].previousZ,z)
					thispush = block[4].velz
				}
				if (this.collided(x, y, z, null, null, vz, block[3])) {
					if (this.canStepZ && !this.world.getBlock(block[0], block[1] + 1, block[2], this.dimension) && !this.world.getBlock(block[0], block[1] + 2, block[2], this.dimension)) {
						continue
					}
					this.hasCollided = true
					if(blockData[block[3]].bounciness){
						thispush -= (VZ*steps-thispush)*blockData[block[3]].bounciness
					}
					maxpushZ = max(maxpushZ,thispush)
					minpushZ = min(minpushZ,thispush)
					//break
				}
			}
		}
		
		this.contacts.clear()
		if(this.onGround){
			this.hasCollided = true
		}
		if(maxpushY || minpushY){
			if("lastY" in this) this.lastY = this.y
			this.vely += maxpushY+minpushY
			this.onGround = false
		}
		if(maxpushX || minpushX){
			this.velx += maxpushX+minpushX
		}
		if(maxpushZ || minpushZ){
			this.velz += maxpushZ+minpushZ
		}
		
		this.updateChunk()
		this.lastUpdate = now
		this.contacts.clear()
		if(ontouch){
      ontouch(touchX, touchY, touchZ, this)
    }
		if(this.portalFadeOutEffect > 0){
			this.portalFadeOutEffect -= 2
			this.portalEffect = this.portalFadeOutEffect
		}else if(this.portalEffect > 0){
			this.portalEffect -= 1.25
		}
		if(this.doingPortal){
			let chunk = this.world.getChunk(this.x,this.z)
			if(chunk && chunk.allGenerated){
				blockData[this.doingPortal].doneLoading(this,this.world)
				this.doingPortal = 0
			}
		}
	}
	updateChunk(){
		let chunkX = this.x >> 4, chunkZ = this.z >> 4
		if(this.chunkX !== chunkX || this.chunkZ !== chunkZ || this.dimension !== this.chunkDimension){
			let oldChunk = this.world.getChunk(this.chunkX<<4,this.chunkZ<<4)
			this.world = this.world.world[this.chunkDimension]
			let chunk = this.world.getOrNewChunk(chunkX<<4,chunkZ<<4)
			this.chunkX = chunkX
			this.chunkZ = chunkZ
			this.chunkDimension = this.dimension
			if(oldChunk && oldChunk.entities.has(this.id)){
				oldChunk.entities.delete(this.id)
				chunk.entities.set(this.id, this)
			}
		}
	}
	moveTowards(x,y,z, rw, rh, rd, slowDown = 1, gravity){
		var dist = dist3(this.x/rw,this.y/rh,this.z/rd,x/rw,y/rh,z/rd)
		if(!dist) return
		var aDist = abs(dist)
		if(aDist > 1) return
		var iDist = 1 - aDist //inverted distance
		var velx = x-this.x
		var vely = y-this.y
		var velz = z-this.z
		var mag = sqrt(velx * velx + vely * vely + velz * velz)
		this.velx += velx*iDist/mag/slowDown
		if(!gravity) this.vely = vely*iDist/mag/slowDown
		else if(this.onGround) this.vely += vely*iDist/mag/slowDown*20
		this.velz += velz*iDist/mag/slowDown
		
		/*var toX = lerp(iDist, this.x, x)
		var toY = lerp(iDist, this.y, y)
		var toZ = lerp(iDist, this.z, z)
		this.velx = (toX - this.x) / slowDown * iDist
		if(this.onGround) this.vely = (toY - this.y) / slowDown * iDist
		this.velz = (toZ - this.z) / slowDown * iDist*/

		/*var xd = this.x - p.x, zd = this.z - p.z;
		var x = xd; this.velx = (x-(Math.sign(x)*7.25)) / 150
		if(this.onGround) {var y = this.y - (p.y-p.bottomH); this.vely = (y-(Math.sign(y)*7.25)) / 40}
		var z = zd; this.velz = (z-(Math.sign(z)*7.25)) / 150*/
	}
	setPos(x,y,z,vx,vy,vz){
		this.velx = vx
		this.vely = vy
		this.velz = vz
		this.x = x
		this.y = y
		this.z = z
	}
	update() {
		this.updateVelocity(now)
		this.move(now)
		if (now - this.spawn > this.despawns) {
			this.canDespawn = true
		}
	}
	addPart(name,size,vao,x,y,z,w,h,d,rx,ry,rz = 0,attached = null,glow = false){
		let part =  this.parts[name] = {
			name,
			size,vao,
			x,y,z,w,h,d,rx,ry,rz,ry2:0, //x,y,z,rx,ry are relative to entity position
			px:x,py:y,pz:z,prx:rx,pry:ry,prz:rz,
			originalX:x, originalY:y, originalZ:z,
			attached, glow
		}
		if(vao && vao.tHeVerticesBuffer){
			part.verticesBuffer = vao.tHeVerticesBuffer
			part.textureBuffer = vao.tHeTextureBuffer
			part.normalBuffer = vao.tHeNormalBuffer
		}
		let attachChain = []
		let part2 = part
		while(part2.attached){
			part2 = this.parts[part2.attached]
			if(!part2) break
			attachChain.push(part2.name)
		}
		attachChain.reverse()
		part.attachChain = attachChain
		return part
	}
	facePlayer(){
		this.yaw = Math.PId - (atan2(p.z+p.offsetZ - this.z, p.x+p.offsetX - this.x) + Math.PI2 + Math.PI)
		var adjacent = dist2(this.x,this.z,p.x+p.offsetX,p.z+p.offsetZ)
		this.pitch = Math.PId - atan2(p.y+p.offsetY - this.y, adjacent)
	}
	pointAt(x,y,z){
		this.yaw = Math.PId - (atan2(z - this.z, x - this.x) + Math.PI2 + Math.PI)
		var adjacent = dist2(this.x,this.z,x,z)
		this.pitch = Math.PId - atan2(y - this.y, adjacent)
	}
	/*pushByPlayer(ent){
		let w = this.width/2, d = this.depth/2, h = this.height/2
		let w2 = ent.w, d2 = ent.w
		let w3 = (w+w2)**2, d3 = (d+d2)**2
		if(this.x-w<ent.x+w2 && this.x+w>ent.x-w2 && this.z-d<ent.z+d2 && this.z+d>ent.z-d2 && this.y-h<ent.y+ent.topH && this.y+h>ent.y-ent.bottomH){
			let velx = this.x-ent.x
      let velz = this.z-ent.z
      if(velx === 0 && velz === 0) return
			let mag = sqrt(velx*velx+velz*velz)
			let push = 1-sqrt(velx*velx/w3+velz*velz/d3)
      velx = velx/mag*push*(w+w2)/2
      velz = velz/mag*push*(d+d2)/2
      this.velx += velx, this.velz += velz
		}
	}*/
	pushByMob(ent){
		let w = this.width/2, d = this.depth/2, h = this.height/2
		let w2 = ent.width/2, d2 = ent.depth/2, h2 = ent.height/2
		let w3 = (w+w2)**2, d3 = (d+d2)**2
		if(this.x-w<ent.x+w2 && this.x+w>ent.x-w2 && this.z-d<ent.z+d2 && this.z+d>ent.z-d2 && this.y-h<ent.y+h2 && this.y+h>ent.y-h2){
			let velx = this.x-ent.x
      let velz = this.z-ent.z
      if(velx === 0 && velz === 0) return
			let mag = sqrt(velx*velx+velz*velz)
			let push = 1-sqrt(velx*velx/w3+velz*velz/d3)
      velx = velx/mag*push*(w+w2)/2
      velz = velz/mag*push*(d+d2)/2
      this.velx += velx, this.velz += velz
		}
	}
}

const
	pW = 0.3,
	pTopH = 0.18,
	pDefaultBottomH = 1.62,
	pSitBottomH = 0.995,
	pSneakBottomH = 1.32,
	pSwimBottomH = 0.625,
	pGravity = -0.11
//if you add something to above, change player entity too and server side
class Player extends Entity{
	type = "Player"
	constructor(){
		super(0, 0, 0, 0, 0, 0, 0, 0, pW*2, pDefaultBottomH+pTopH, pW*2, null, null, 0, Infinity, "this isn't really a VAO... but it will be overwritten")
		
		let pix = 1/16
		
		this.targetX = 0
		this.targetY = 0
		this.targetZ = 0
		this.rx = 0
		this.ry = 0
		this.dimension = ""
		this.bodyRot = 0
		this.die = false
		this.cheats = false
		this.resendHealth = false
		this.resendEffects = false
		this.spawnPoint = null
		this.didEndPoem = false
		
		this.sneaking = false
		this.walking = false
		this.sprinting = false
		this.eating = false
		this.sleeping = false
		this.sitting = false
		this.swimming = false
		this.usingItem = false
		this.prevEating = false
		this.eatStart = 0
		
		this.addPart("body",null,null,0,0,0,1,1,1,0,0)

		this.addPart("head",null,null,0,pix*6,0,1,1,1,0,0)
		
		this.addPart("leftArm",null,null,pix*4,pix*6,0,1,1,1,0,0)
		this.addPart("rightArm",null,null,pix*-4,pix*6,0,1,1,1,0,0)
		
		this.addPart("leftLeg",null,null,pix*2,pix*-6,0,1,1,1,0,0)
		this.addPart("rightLeg",null,null,pix*-2,pix*-6,0,1,1,1,0,0)
		
		this.addPart("cape",null,null,0,pix*6,pix*-3,1,1,1,0,0)
		
		this.holding = 0 //shown in the hand, it is set to the blockid for the block the player is holding
		this.addPart("holding",null,null,0, 0, 0, 1,1,1, 0, 0)
		
		this.punchEffect = 0
		this.inventory = {
			hotbar:new Array(9).fill(null), main:new Array(27).fill(null),
			crafting2:new Array(4), crafting3:new Array(9),
			craftingResult:null,craftingName:null,holding:null,
			anvilInput:null,anvilMaterial:null,anvilOutput:null, anvilRename:"", anvilCost:0,
			hotbarSlot:0,
			slotIds:{
				hotbar:[],
				main:[],
				crafting3:[],
				crafting2:[],
				craftingResult:null,
				furnaceInput:null,
				furnaceOutput:null,
				furnaceFuel:null,
				chest:[],
				anvilInput:null,
				anvilMaterial:null,
				anvilOutput:null,
				dispenser:[],
				hopper:[]
			},
			containerData:{}
		}
		this.achievments = []

		this.username = null
		this.afk = false

		this.scale = 1
		this.prevScale = null
		this.direction = new PVector()
		this.crackPos = [0,0,0]
		this.breakStart = 0
	}
	get survival(){return this.gameMode==="survival"||this.gameMode==="hardcore"}
	get spectator(){return this.gameMode==="spectator"}
	respawn(){
    let spawn = this.spawnPoint
		if(!spawn){
			spawn = this.spawnPoint = {x:this.world.world.spawnPoint.x,y:this.world.world.spawnPoint.y,z:this.world.world.spawnPoint.z}
		}
		this.tp(spawn.x,spawn.y+0.5+this.height*0.5,spawn.z)
		this.velx = this.vely = this.velz = 0
		this.lastY = this.y
		this.health = 20
		this.oxygen = 20
    this.food = 20
    this.foodSaturation = 5
    this.foodTimer = 0
    this.foodExhaustion = 0
		this.lastXP = 0
		this.XP = 0
		this.level = 0
		this.totalXP = 0
		this.nextLevel = 0
		this.lastXP = 0
		this.setLevel()
		this.effects = {}
		this.freezeEffect = 0
		this.burnTimer = 0
    this.dieMessage = "Invalid death"
    this.dimension = ""
		this.riding = null
    this.hidden = false
    this.die = false
		this.harmEffect = 0
		this.lastDamage = 0
		this.lastHeal = 0
		this.lastBlockHarm = 0
		this.touchingBurnBlock = false
		this.lastLoseOxygen = 0
		this.lastGetOxygen = 0
		this.burnStart = 0
		this.attackedBy = null
		this.attackedById = null
		this.attackedByTime = 0
		this.lastFreezeHealth = 0
		this.flying = false
	}
	tp(x,y,z,dimension=this.dimension){
		this.targetX = this.x = x
		this.targetY = this.y = y
		this.targetZ = this.z = z
		this.dimension = dimension
		this.world = this.world.world[dimension]
		if(this.connection) this.connection.send({type:"tp",x,y,z,dimension})
	}
	addXP(amount){
    this.lastXP = now
    this.XP += amount
    if(this.XP >= this.nextLevel){
      this.level += Math.floor(this.XP / this.nextLevel)
      this.XP = this.XP % this.nextLevel
			this.world.playSound(this.x,this.y,this.z,"random.levelup")
      this.setLevel()
    }else{
      this.world.playSound(this.x,this.y,this.z,"random.orb")
    }
		this.resendHealth = true
  }
	setLevel(){
    if(this.level <= 15){
      this.nextLevel = 2*this.level+7
    }else if(this.level <= 30){
      this.nextLevel = 5*this.level-38
    }else{
      this.nextLevel = 9*this.level-158
    }
  }
  calculateTotalXP(){
    if(this.level <= 16){
      this.totalXP = (this.level * this.level) + 6 * this.level
    }else if(this.level <= 31){
      this.totalXP = 2.5 * (this.level * this.level) - 40.5 * this.level + 360
    }else if(this.level > 31){
      this.totalXP = 4.5 * (this.level * this.level) - 162.5 * this.level + 2220
    }else this.totalXP = -1 //it didn't match any (that's probably impossible)
    if(this.totalXP !== -1){
      this.totalXP += this.XP
    }
  }
	sendHealth(){
		if(this.connection) this.connection.send({type:"health",health:this.health,food:this.food,foodSaturation:this.foodSaturation,oxygen:this.oxygen,burning:this.burning,freezeEffect:this.freezeEffect,XP:this.XP,level:this.level,nextLevel:this.nextLevel})
	}
	sendEffects(){
		if(this.connection) this.connection.send({type:"effects",data:this.effects})
	}
	saveInv(){
		let inv = this.world.world.playersInv[this.host ? ":host" : this.username]
		if(!inv) inv = this.world.world.playersInv[this.host ? ":host" : this.username] = {}
		inv.survivStr = this.world.world.getSurvivStr(this).array
		inv.inv = this.world.world.getInv(this).array
		inv.version = this.world.world.version
	}
	addAchievment(name){
		let id = achievmentIds[name]
    let a = achievementTypes[id]
    if(!a) throw new Error("No such achievment: "+name)
    if(this.achievments.includes(id)) return
    if(this.cheats) return
    this.achievments.push(id)
    //sideMessage("Achievment Made: "+a.name, a.description)
		//showTitle("§bAchievment Made",a.name)
    this.connection.send({type:"achievment",data:id})
		this.world.sendAll({type:"message",fromServer:true,data:this.username+" achieved: "+a.name})
	}
	addDiscovery(block){
		if(this.cheats || blockData[block].tool) return
		let id = (((block & isCube) << 1) | 1) << 8
		if(this.achievments.includes(id)) return
    this.achievments.push(id)
		//let info
		//if(blockInfo[blockInfoIds[id>>9]]) info = blockInfo[blockInfoIds[id>>9]].data
    //sideMessage("Discovery Made: "+blockData[id>>9].Name, info)
		/*if(!titleShowing || title === "§bAchievment Made"){
			discoverTime = 200
			discoverBlock = id>>9
		}*/
    this.connection.send({type:"achievment",data:id})
		this.world.sendAll({type:"message",fromServer:true,data:this.username+" discovered: "+blockData[block].Name})
	}
	move(now){
		let pminX = floor(this.x - this.width / 2)
		let pmaxX = ceil(this.x + this.width / 2)
		let pminY = floor(this.y - this.height / 2)
		let pmaxY = ceil(this.y + this.height / 2)
		let pminZ = floor(this.z - this.depth / 2)
		let pmaxZ = ceil(this.z + this.depth / 2)
		let block = null

		this.liquid = this.wet = false
		let ontouch, closestTouch = Infinity
		let touchX, touchY, touchZ
    let damageX = 0, damageY = 0, damageZ = 0
		let damageBlockAmount = 0
    let damageBlock
   	let takeDamage = 0
    this.powder = false
    this.spikyBush = false
    this.quicksand = false
		this.damageResistance = 0
		for (let x = pminX; x <= pmaxX; x++) {
			for (let y = pminY; y <= pmaxY; y++) {
				for (let z = pminZ; z <= pmaxZ; z++) {
					let block = this.world.getBlock(x, y, z, this.dimension)
					if (block && blockData[block].solid) {
						this.contacts.add(x, y, z, block)
					}
					if(touchingBox(this,x,y,z,1,1,1)){
						let d = blockData[block].damage
						if(typeof d === "function") d = d(x,y,z,this.world)
						if(d && d>takeDamage) {
							takeDamage = d
							damageBlock = blockData[block]
						}
						if(d){
							damageX += x*d
							damageY += y*d
							damageZ += z*d
							damageBlockAmount+=d
						}
					}
					if(onBox(this,x,y,z,1,1,1)){
						let d = blockData[block].damageUp
						if(d && d>takeDamage) {
							takeDamage = d
							damageBlock = blockData[block]
						}
						if(d){
							damageX += x*d
							damageY += y*d
							damageZ += z*d
							damageBlockAmount+=d
						}
						if(blockData[block].damageResistance && blockData[block].damageResistance > this.damageResistance){
							this.damageResistance = blockData[block].damageResistance
						}
					}
					if(blockData[block].activate){
						blockData[block].activate(x,y,z,block,this,this.world)
					}
					if(!inBox(this,x,y,z,1,1,1)) continue
					if(!this.spectator && blockData[block].serverontouch){
						let dist = max(abs(x-this.x),abs(z-this.z),abs(y-this.y))
						if(dist<closestTouch){
							closestTouch = dist
							ontouch = blockData[block].serverontouch
							touchX = x, touchY = y, touchZ = z
						}
					}
					if(blockData[block].liquid) {
						this.liquid = true
					}
					if(blockData[block].wet){
						this.wet = true
					}
					if(blockData[block].getCurrent && !this.spectator){
						var me = blockData[block]
						var c = me.getCurrent(x,y,z,undefined,undefined,this.world)
						this.velx += (c.x||0)/64
						this.velz += (c.z||0)/64
						var under = this.world.getBlock(x,y-1,z,this.dimension)
						if(me.isThis(under) && under !== me.id) this.vely -= 1/128
					}
					if(!blockData[block].solid && blockData[block].powder){
						this.powder = true
					}
					if(blockData[block].spikyBush){
						this.spikyBush = true
					}
					if(blockData[block].quicksand){
						this.quicksand = true
					}
				}
			}
		}
		this.lastUpdate = now
		this.previousX = this.x
		this.previousY = this.y
		this.previousZ = this.z
		this.x = this.targetX
		this.y = this.targetY
		this.z = this.targetZ
		this.previousPitch = this.pitch
		this.previousYaw = this.yaw
		this.yaw = this.bodyRot

		if(takeDamage > 0 && now - this.lastBlockHarm > 500 && this.survival){
			damageX /= damageBlockAmount
			damageY /= damageBlockAmount
			damageZ /= damageBlockAmount
      this.lastBlockHarm = now
      let msg = damageBlock.dieMessage ? damageBlock.dieMessage(this) : damageBlock.burnEnt ? (this.username+" burned up while touching "+damageBlock.Name) : (this.username+" died because of "+damageBlock.name+". You should avoid it next time.")
      let type = damageBlock.burnEnt ? "fire" : ""
      this.damage(takeDamage, msg, false, type, damageX, damageY, damageZ)
    }
    this.touchingBurnBlock = damageBlock && damageBlock.burnEnt && true
		let blockAtFeet = this.world.getBlock(round(this.x), ceil(this.y-this.height*0.5), round(this.z), this.dimension)
		let blockAtTop = this.world.getBlock(round(this.x), floor(this.y+this.height*0.5), round(this.z), this.dimension)
		if(blockAtTop && blockData[blockAtTop].ladder || blockAtFeet && blockData[blockAtFeet].ladder){
			this.lastY = this.y
		}
		if(this.y > this.lastY) this.lastY = this.y
    
    if(ontouch){
      ontouch(touchX, touchY, touchZ, this)
    }
		if(this.portalFadeOutEffect > 0){
			this.portalFadeOutEffect -= 2
			this.portalEffect = this.portalFadeOutEffect
		}else if(this.portalEffect > 0){
			this.portalEffect -= 1.25
		}
		if(this.doingPortal){
			let chunk = this.world.getChunk(this.x,this.z)
			if(chunk && chunk.allGenerated){
				blockData[this.doingPortal].doneLoading(this,this.world)
				this.doingPortal = 0
			}
		}
	}
	update(){
		if(this.harmEffect > 0){
			this.harmEffect -= 3
		}
		if(this.health <= 0 && !this.die){
			this.die = true
			if(this.survival){
				for(let i of this.inventory.hotbar){
					if(i){
						this.world.addItems(this.x,this.y,this.z,0,0,0,i.id,true,i.amount,i.durability,i.customName,this.id)
					}
				}
				for(let i of this.inventory.main){
					if(i){
						this.world.addItems(this.x,this.y,this.z,0,0,0,i.id,true,i.amount,i.durability,i.customName,this.id)
					}
				}
				this.inventory.hotbar.fill(null)
				this.inventory.main.fill(null)
				this.calculateTotalXP()
				if(this.totalXP > 0) this.world.addEntity(new entities[entityIds.ExperienceOrb](this.x,this.y,this.z,this.totalXP),false,this.dimension)
			}
			this.world.sendAll({type:"die",id:this.id,message:this.dieMessage})
			this.world.poof(this.x,this.y,this.z, undefined,this.dimension, this.width,this.height,this.depth,true)
			this.world.sendAll({type:"message",data:"§6"+this.dieMessage,fromServer:true})
		}
		if(this.die){
			this.dieEffect += 0.05
			if(this.dieEffect > 1){
				this.dieEffect = 1
			}
			this.dieRotate = (this.dieEffect**4)*Math.PI2
		}else{
			this.dieEffect = 0
			this.dieRotate = 0
		}
		this.hidden = this.die || this.spectator
		this.move(now)
		if(!this.die && this.survival){
			if(this.y < minHeight){
				if(this.y <= minEntityY){
					this.dieMessage = this.username+" fell out of the world"+(this.attackedBy ? " while being attacked by "+this.attackedBy+"." : ".")
					this.health = -1
					this.resendHealth = true
				}else if(now-this.lastBlockHarm > 500){
					this.lastBlockHarm = now
					this.damage(4, this.username+" fell out of the world"+(this.attackedBy ? " while being attacked by "+this.attackedBy+"." : "."))
				}
			}

			if(this.walking && this.sprinting){
				this.foodExhaustion += 0.016
			}

			if(this.foodSaturation > this.food) this.foodSaturation = this.food
			/*if(p.food > 17 || p.food === 0){
				var timer = now - p.foodTimer
				if(timer >= 4000){
					p.foodTimer = now
					if(p.food === 0){
						p.health --
						harmEffect = 40
						hitSound()
						updateHUD = true
					}else if(p.foodSaturation > 0 && p.health < 20){
						p.health ++
						healEffect = 40
						updateHUD = true
					}
				}*/
				/*if((timer === 500 || timer === 0) && p.food >= 20 && p.health < 20 && p.foodExhaustion > 0){
					var heal = min(p.foodSaturation/6, 1)
					p.health += heal
					if(p.food > 18){
						p.foodExhaustion += heal*6
					}
					healEffect = 40
					updateHUD = true
				}
			}*/
			let healTimer = now-this.lastHeal
			if(this.health < 20){
				let heal
				if(this.foodSaturation > 6 && this.food === 20 && healTimer >= 500){
					heal = min(this.foodSaturation/6,1)
				}else if(this.food >= 18 && healTimer >= 4000){
					heal = 1
				}
				if(heal){
					this.lastHeal = now
					this.health += heal
					this.foodExhaustion += heal
					this.resendHealth = true
				}
				//if(this.food < 18 && this.food > 0) this.lastHeal = now
			}
			if(this.health > 0 && this.food <= 0 && healTimer >= 4000){
				this.lastHeal = now
				this.damage(1, this.username+" starved to death.")
			}
			if(this.foodExhaustion >= 4){
				this.foodExhaustion -= 4
				this.foodSaturation --
				if(this.foodSaturation <= 0){
					this.food --
					this.resendHealth = true
				}
			}

			if(this.effects.wither && this.survival && now-this.lastBlockHarm > 1000){
				this.lastBlockHarm = now
				this.damage(this.effects.wither.level*0.5, this.username+" got withered. Ew.")
			}
			if(this.powder){
				if(this.freezeEffect<140){
					this.freezeEffect ++
					this.resendHealth = true
					if(this.freezeEffect > 140){
						this.freezeEffect = 140
					}
				}
				if(this.freezeEffect === 140){
					if(now - this.lastFreezeHealth > 2000){
						this.lastFreezeHealth = now
						this.damage(1,this.username+" froze to death.", false, "freeze")
					}
				}else{
					this.lastFreezeHealth = now
				}
			}else if(this.freezeEffect > 0){
				this.freezeEffect --
				this.resendHealth = true
			}
			
			if(this.spikyBush && this.walking && now - this.lastBlockHarm > 500){
				this.lastBlockHarm = now
				this.damage(1, this.username+" died because of spikes.", false, "berrybush")
			}

			if(this.touchingBurnBlock){
				this.burnTimer += 0.2
			}
			if(this.burnTimer > 16) this.burnTimer = 16
			let burning = this.burnTimer > 0
			if(this.burning !== burning) this.burning = burning, this.resendHealth = true
			if(this.survival && this.burning){
				if(now - this.burnStart > 1000){
					this.burnStart = now
					this.burnTimer -= 2
					if(this.burnTimer < 0) this.burnTimer = 0
					this.damage(1, this.username+" burned up.", false, "fire")
				}
			}
			if((this.wet || this.freezeEffect > 0) && this.burnTimer > 0) {
				this.burnTimer = 0
				this.world.poof(this.x,this.y-this.height*0.5+0.25,this.z, 8, this.dimension, this.width*0.5*2,0,this.depth*0.5*2, true)
			}

			let blockHere = this.world.getBlock(round(this.x),round(this.y+this.height*0.5),round(this.z))
			let inLiquid
			if(blockHere && blockData[blockHere].inLiquid) inLiquid = blockData[blockHere].inLiquid
			if(inLiquid){
				if(this.oxygen > 0){
					var time = floor(this.oxygen / 2) * 2 === this.oxygen ? 1000 : 125
					if(now - this.lastLoseOxygen > time){
						this.oxygen --
						this.lastLoseOxygen = now
						this.resendHealth = true
					}
				}else{
					if(now-this.lastBlockHarm > 500){
						this.lastBlockHarm = now
						this.damage(1, this.username+" drowned in "+blockData[blockHere].Name+".",false, "drown")
					}
				}
			}/*suffoacting*/else if(blockHere && (blockData[blockHere].solid && !blockData[blockHere].transparent || blockData[blockHere].quicksand)){
				if(this.oxygen > 0){
					var time = floor(this.oxygen / 2) * 2 === this.oxygen ? 250 : 125
					if(now - this.lastLoseOxygen > time){
						this.oxygen --
						this.resendHealth = true
						this.lastLoseOxygen = now
					}
				}else{
					if(now-this.lastBlockHarm > 500){
						this.lastBlockHarm = now
						var msg = this.username+" was suffocated by "
						var name = blockData[blockHere].Name
						if("aeiouAEIOU".includes(name[0])) msg += "an " //check for vowels
						else msg += "a "
						msg += name+"."
						this.damage(1, msg)
					}
				}
			}else if(this.oxygen < 20 && now - this.lastGetOxygen > 300){
				this.lastGetOxygen = now
				this.oxygen = (floor(this.oxygen/2)*2) + 2
				this.resendHealth = true
			}
			if(this.liquid) this.lastY = this.y
		}else{
			this.burnTimer = 0
			if(this.burning){
				this.burning = false
				this.resendHealth = true
			}
			this.oxygen = 20
		}
		if(this.onGround){
			let fall = (this.lastY - this.y) / this.scale
			this.lastY = this.y
			this.standingOn = this.world.getBlock(round(this.x), floor(this.y-this.height/2), round(this.z), this.dimension)
			let block = this.standingOn
			if(fall > 3 && this.survival && !this.liquid) {
				let fallType = fall > 6 ? "bigfall" : "smallfall"
				let d = fall-3
				let reason = this.username+" fell "+Math.round(fall)+" blocks"+(this.attackedBy ? " while being attacked by "+this.attackedBy+"." : ".")
				if(block && blockData[block].name === "pointedDripstone"){
					d = fall*2-2
					reason = this.username+" fell onto a pointed dripstone and got poked to death"+(this.attackedBy ? " while being attacked by "+this.attackedBy+"." : ".")
				}
				this.damage(Math.floor(d*(1-this.damageResistance)), reason, false, fallType)//Math.floor( (p.velocity.y * p.velocity.y * 8));
			}
		}
		if(this.attackedBy && Date.now()-this.attackedTime > 10000) this.attackedBy = null, this.attackedById = null
		this.holding = this.inventory.hotbar[this.inventory.hotbarSlot] ? this.inventory.hotbar[this.inventory.hotbarSlot].id : 0
		let holdBlockData = blockData[this.holding]
		if(this.eating){
			if(!this.prevEating){
				this.prevEating = true
				this.eatStart = now
			}
			let time = now - this.eatStart
			if(time > 1610){
				this.eatStart = now
				this.food += holdBlockData.food
				this.foodSaturation += holdBlockData.saturation
				this.resendHealth = true
				let holdObj = this.inventory.hotbar[this.inventory.hotbarSlot]
				if(this.survival && holdObj){
					holdObj.amount --
					if(!holdObj.amount) this.inventory.hotbar[this.inventory.hotbarSlot] = null
					if(holdBlockData.eatResult && !newInvItem(this,blockIds[holdBlockData.eatResult])) {
						this.world.addItems(this.x,this.y,this.z,0,0,0,blockIds[holdBlockData.eatResult])
					}
				}
				if(this.food >= 20){
					this.world.playSound(this.x,this.y,this.z,"random.burp")
				}
			}
		}else this.prevEating = false
		if(this.usingItem){
			let holdObj = this.inventory.hotbar[this.inventory.hotbarSlot]
			if(holdBlockData.name === "bow" && hasItem(this,blockIds.arrow)){
        let pull = holdObj.pulling || 0
        let start = holdObj.pullStart || 0
        if(pull < 3 && now - start > 500){
          holdObj.pullStart = now
          pull++
          holdObj.pulling = pull
					let id = holdBlockData.id
          switch(pull){
						case 0:
							holdObj.id = id; break
						case 1:
							holdObj.id = id | SLAB; break
						case 2:
							holdObj.id = id | STAIR; break
						case 3:
							holdObj.id = id | CROSS; break
					}
        }
      }
		}else{
			let holdObj = this.inventory.hotbar[this.inventory.hotbarSlot]
			if(holdBlockData.name === "bow" && holdObj.pulling && hasItem(this,blockIds.arrow)){
				if(!holdObj.pulling) return true
				if(minusOneItem(this,blockIds.arrow)){
					let pd = this.direction
					let i = holdObj.pulling / 3
					this.world.addEntity(new entities[entityIds.Arrow](this.x+pd.x,this.y+pd.y,this.z+pd.z,pd.x*i,pd.y*i,pd.z*i,this.id),false,this.dimension)
				}
				delete holdObj.pulling
				delete holdObj.pullStart
				holdObj.id = holdBlockData.id
			}
		}
		for(let i in this.effects){
			let e = this.effects[i]
			e.time--
			if(e.time <= 0){
				delete this.effects[i]
				this.resendEffects = true
			}
		}
		if(this.food > 20) this.food = 20
		if(this.food < 0) this.food = 0
		if(this.foodSaturation < 0) this.foodSaturation = 0
		if(this.health > 20) this.health = 20
		if(this.oxygen > 20) this.oxygen = 20

		if(this.scale !== this.prevScale){
			this.prevScale = this.scale
			let s = this.scale
			this.width = this.depth = pW*2*s
			this.defaultHeight = this.height = (pDefaultBottomH+pTopH)*s
			this.sitHeight = (pSitBottomH+pTopH)*s
			this.sneakHeight = (pSneakBottomH+pTopH)*s
			this.swimHeight = (pSwimBottomH+pTopH)*s
		}
		if(this.sneaking){
			this.height = this.sneakHeight
		}else if(this.eating || this.usingItem && blockData[this.holding].spyglass){
		}else if(this.sitting){
			this.height = this.sitHeight
		}else if(this.swimming){
			this.height = this.swimHeight
		}else if(!this.sprinting){
			this.height = this.defaultHeight
		}
		
		for(var p in this.parts){
			var part = this.parts[p]
			part.prx = part.rx
			part.pry = part.ry
			part.prz = part.rz
			part.pry2 = part.ry2
			part.lastUpdate = now
		}

		this.direction.x = -sin(this.ry) * cos(this.rx)
		this.direction.y = sin(this.rx)
		this.direction.z = cos(this.ry) * cos(this.rx)
	}
	setPos(x,y,z,vx,vy,vz){
		this.targetX = x
		this.targetY = y
		this.targetZ = z
		this.velx = vx
		this.vely = vy
		this.velz = vz
	}
	setRot(rx,ry, bodyRot, unremote){
		this.rx = rx
		this.ry = ry
		this.bodyRot = (bodyRot || bodyRot === 0) ? bodyRot : ry
		if(unremote) this.connection.send({type:"rot",rx,ry,bodyRot:this.bodyRot})
	}
	applyEffect(name,level,time, showParticles = true){
		time *= 20
		if(this.effects[name]){
			let e = this.effects[name]
			if(level>e.level){
				e.level = level
				e.time = time
				e.showParticles = e.showParticles || showParticles
			}
		}
		this.effects[name] = {level, time, showParticles}
		this.resendEffects = true //this.world.sendPlayer({type:"effect", name,level,time,showParticles},this.id)
	}
	damage(amount, why, nosound,type, x,y,z, attackedBy, velx=0,vely=0,velz=0){
		if(!this.survival) return
		/*let h = inventory.hotbar[inventory.hotbarSlot]
		if(h && h.id && p.usingItem && blockData[h.id].sword){
			amount /= blockData[h.id].durability/30
			h.durability -= amount/5
		}*/

    let prev = amount
    if(this.harmEffect > 0){
      //when your red, you are immune to most damage
      if(amount > this.lastDamage){
        amount -= this.lastDamage
      }else return
    }
		let prevHealth = this.health
    
    this.health -= amount
    this.harmEffect = 30
    this.lastDamage = prev

		if(typeof x === "number" && !velx && !vely && !velz){
			velx = this.x-x, velz = this.z-z
			let mag = sqrt(velx*velx+velz*velz)*4
			velx /= mag, velz /= mag
			vely = 0.5
			if(!velx && !velz) velx = velz = 0//possible NaN
		}
		if(attackedBy){
			this.attackedBy = attackedBy.username || attackedBy.name
			this.attackedById = attackedBy.id
			this.attackedTime = Date.now()
		}
    
    if(!nosound){
      switch(type){
        case "drown":
          drownHurtSound(this)
          break
        case "freeze":
          freezeHurtSound(this)
          break
        case "fire":
          fireHurtSound(this)
          break
        case "berrybush":
          berrybushHurtSound(this)
          break
        case "smallfall":
					this.world.playSound(this.x,this.y,this.z,"damage.smallfall")
          break
        case "bigfall":
					this.world.playSound(this.x,this.y,this.z,"damage.bigfall")
          break
				case "hit":
					oofSound(this) //also does below
        default:
          hitSound(this)
          break
      }
    }
    this.dieMessage = why
    this.world.sendAll({type:"harmEffect",id:this.id})
		this.sendHealth()
		if(this.connection) this.connection.send({type:"damage",x,y,z,lastHealth:prevHealth,velx,vely,velz})
  }
}
entities[entities.length] = class Item extends Entity {
	static name2 = "Item"
	constructor(x, y, z, velx, vely, velz, blockID, autoSetVel, amount, durability = null, name = null, from) {
		super(x, y, z, 0, 0, velx, vely, velz, 0.25, 0.25, 0.25, null, null, 0, 300000/*1500000*/)
		this.block = blockID
		this.from = from || undefined
		this.durability = durability
		this.name = name
		this.amount = amount || 1
		this.gravityStength = -0.07
		this.noHitbox = true
		this.canFloat = true
		this.cullFace = true
		
		if(autoSetVel){
			this.velx = (Math.random()-0.5) * 0.2
			this.vely = Math.random() * 0.2
			this.velz = (Math.random()-0.5) * 0.2
		}
	}
	goCloserToPlayer(e){
		let xDist = this.x - e.x
		let yDist = this.y - (e.y - e.height/2)
		let zDist = this.z - e.z
		var hRange = 1.425
		let comeCloser = xDist > -hRange && xDist < hRange && yDist > -0.75 && yDist < 2.3 && zDist > -hRange && zDist < hRange
		if(comeCloser){
			this.moveTowards(e.x, Math.min(Math.max(this.y, e.y - e.height*0.5),e.y+e.height*0.5), e.z, hRange,2.3,hRange, 3)
		}
		/*if(pickup){
			var dist = dist3(this.x, this.y, this.z, p.x, p.y, p.z)
			var dist2 = dist3(this.x, this.y, this.z, p.x, p.y-1, p.z)
			pickup = ((1 >= dist) && (dist >= -1)) || ((1 >= dist2) && (dist2 >= -1))
		}*/
		let w = e.width*0.5
		return xDist > -w && xDist < w && yDist > 0 && yDist < e.height && zDist > -w && zDist < w
	}
	update() {
		this.updateVelocity(now)
		this.move(now)
		
		if(this.amount <= 0){
			return this.canDespawn = true
		}
		this.yaw += 0.05;
		if(this.yaw > Math.PId){
			this.yaw -= Math.PId
			this.previousYaw -= Math.PId
		}
		
		let pickup
		if(now - this.spawn > 1000){
			for(var P of this.world.world.players){
				if(!P.hidden && !P.die && P.dimension === this.dimension){
					if(this.goCloserToPlayer(P)) pickup = P
				}
			}
		}
		
		let d = 3/4
		var stackSize = blockData[this.block].stackSize
		var c = false
		this.world.getEntitiesNear(this.x,this.y,this.z, 1, nearEntityArray)
		for(var e of nearEntityArray){
			if(e.type === "Item" && e !== this && e.block === this.block && (!e.name && !this.name || e.name === this.name) && e.amount + this.amount <= stackSize){
				var xDist = this.x - e.x
				var yDist = this.y - e.y
				var zDist = this.z - e.z
				let stack = xDist > -d && xDist < d && yDist > -d && yDist < d && zDist > -d && zDist < d
				if(stack){
					this.amount += e.amount
					e.amount = 0
					this.velx = (this.velx+e.velx)/2
					this.vely = (this.vely+e.vely)/2
					this.velz = (this.velz+e.velz)/2
					this.x = (this.x+e.x)/2
					this.y = (this.y+e.y)/2
					this.z = (this.z+e.z)/2
					c = true
				}
			}
		}
		//if(c) this.world.sendAll({type:"entEvent",event:"itemAmount",data:this.amount,id:this.id})
		if(c) this.world.sendEntityPos(this)
		
		if(pickup){
			let pickuped = false
			while(this.amount > 0 && newInvItem(pickup, this.block, this.durability, this.name)){
				this.amount--
				pickuped = true
			}
			if(pickuped){
				if(blockData[this.block].log){
					pickup.addAchievment("Getting Wood")
				}else if(this.block === blockIds.diamond){
					pickup.addAchievment("DIAMONDS!")
				}else if(this.block === blockIds.ancientDebris){
					pickup.addAchievment("Hidden In The Depths")
				}else if(this.block === blockIds.diamond && this.from !== p.id){
					//that achivement
					let from = getPlayerById(this.from)
					if(from) from.addAchievment("Diamonds to you!")
				}else if(this.block === blockIds.tomatoSeeds){
					pickup.addAchievment("Time to plant tomatoes!")
				}
				pickup.addDiscovery(this.block)
				let pitch = rand(0.6, 1.5)
				this.world.playSound(this.x,this.y,this.z,"random.plop",1,pitch)
				this.world.sendEntityPos(this)//send({type:"entEvent",event:"itemAmount",data:this.amount,id:this.id})
			}
		}
		if (now - this.spawn > this.despawns) {
			this.canDespawn = true
		}
		if(!this.amount){
			this.canDespawn = true
		}
		if(this.insideBlock && blockData[this.insideBlock].itemOnTop || this.standingOn && blockData[this.standingOn].itemOnTop){
			var inside = this.insideBlock && blockData[this.insideBlock].itemOnTop
			var block = inside ? this.insideBlock : this.standingOn
			var y = inside ? round(this.y) : ceil(this.y-this.height/2)-1
			var amount = blockData[block].itemOnTop(round(this.x),y,round(this.z),this)
			if(amount){
				this.amount = amount
				this.willUpdateShape = true
				//this.world.sendAll({type:"entEvent",event:"itemAmount",data:this.amount,id:this.id})
				this.world.sendEntityPos(this)
			}else if(amount === 0) this.canDespawn = true
		}
	}
}
let BlockEntity = entities[entities.length] = class BlockEntity extends Entity{
	static name2 = "BlockEntity"
	constructor(blockID, x,y,z, solidOnGround){
		super(x, y, z, 0, 0, 0, 0, 0, 1, 1, 1, null, null, null, 1500000)
		this.block = blockID
		this.solidOnGround = solidOnGround
		this.lastY = y
		this.noHitbox = true
		this.cullFace = true
	}
	changeBlock(blockID){
		if(this.block === blockID) return
		this.block = blockID
	}
	update() {
		this.updateVelocity(now)
		this.move(now)
		if (now - this.spawn > this.despawns) {
			this.canDespawn = true
		}
		
		if(this.onGround && this.solidOnGround){
			var x = round(this.x), y = round(this.y), z = round(this.z)
			var b = this.world.getBlock(x, y, z, this.dimension)
			if(b && !blockData[b].liquid){
				// non cube block breaks falling blocks
				this.world.addItems(x,y,z, 0,0,0, this.block)
			}else{
				this.world.setBlock(x,y,z, this.block,false,false,false,false,this.dimension)
				this.world.blockSound(this.block, "land", x,y,z)
			}
			this.canDespawn = true
		}
		
		if(blockData[this.block].name === "anvil" || blockData[this.block].name === "pointedDripstone"){
			var ent = entCollided(this)
			var d
			if(blockData[this.block].name === "pointedDripstone") d = min(max((this.lastY - this.y - 2) * 2, 0), 40)
			else if(blockData[this.block].name === "anvil") d = min(max((this.lastY - this.y - 1) * 2, 0), 40)
			if(entPlayerCollided){
				var reason
				if(blockData[this.block].name === "pointedDripstone") reason = ent.username+" got poked to death by a falling pointed dripstone"
				else if(blockData[this.block].name === "anvil") reason = ent.username+" got hit by an anvil and stuff"
				ent.damage(d,reason,false,null,this.previousX,this.previousY,this.previousZ)
			}else if(ent && ent.damage){
				ent.damage(d)
			}
			if(blockData[this.block].name === "pointedDripstone" && this.onGround){
				var b = blockIds.pointedDripstone
				this.world.addItems(this.x,this.y,this.z,0,0,0,b,true)
				this.world.blockParticles(b,this.x,this.y,this.z,30, "break")
				this.canDespawn = true
			}
		}
	}
}

let PrimedTNT = entities[entities.length] = class PrimedTNT extends BlockEntity{
	static name2 = "PrimedTNT"
	constructor(x,y,z, timerStart, tntBlockId = blockIds.tnt){
		super(tntBlockId, x,y,z)
		this.velx = (Math.random() * 0.1) - 0.05
		this.vely = Math.random() * 0.1
		this.velz = (Math.random() * 0.1) - 0.05
		
		this.timerStart = timerStart || this.spawn
		this.lastCollidedY = this.timerStart
		this.timeLimit = 80
		
		this.tntBlockId = tntBlockId
	}
	explode(){
		var x = round(this.x), y = round(this.y), z = round(this.z)
		this.world.explode(x,y,z,4, this.liquid || !this.world.world.settings.tntExplode, this.dimension)
	}
	update() {
		this.updateVelocity(now)
		this.move(now)
		
		if(this.onGround){
			this.lastCollidedY = this.y
		}
		var h = this.y - this.lastCollidedY
		if(h > 19.75){
			this.lastCollidedY = this.y
			this.timerStart -= 1000
		}
		
		if((now - this.spawn) / tickTime >= this.timeLimit){
			this.canDespawn = true
			this.explode()
		}
	}
}
entities[entities.length] = class PrimedSuperTNT extends PrimedTNT{
	static name2 = "PrimedSuperTNT"
	constructor(x,y,z, timerStart){
		super(x,y,z, timerStart, blockIds.tnt | SLAB)
	}
	explode(){
		var x = round(this.x), y = round(this.y), z = round(this.z)
		this.world.explode(x,y,z,8, blockData[this.world.getBlock(x,y,z)].liquid || !this.world.world.settings.tntExplode, this.dimension)
	}
}
entities[entities.length] = class PrimedUltraTNT extends PrimedTNT{
	static name2 = "PrimedUltraTNT"
	constructor(x,y,z, timerStart){
		super(x,y,z, timerStart, blockIds.tnt | STAIR)
	}
	explode(){
		var x = round(this.x), y = round(this.y), z = round(this.z)
		this.world.explode(x,y,z,24, blockData[this.world.getBlock(x,y,z)].liquid || !this.world.world.settings.tntExplode, this.dimension)
	}
}
entities[entities.length] = class PrimedUnTNT extends PrimedTNT{
	static name2 = "PrimedUnTNT"
	constructor(x,y,z, timerStart){
		super(x,y,z, timerStart, blockIds.untnt)
	}
	explode(){
		var x = round(this.x), y = round(this.y), z = round(this.z)
		this.world.explode(x,y,z,5, blockData[this.world.getBlock(x,y,z)].liquid || !this.world.world.settings.tntExplode || "original", this.dimension)
	}
}
entities[entities.length] = class MovingBlock extends BlockEntity{
	static name2 = "MovingBlock"
	noRemoteDelete = true
	constructor(block,x,y,z,mx,my,mz,despawns, solidWhenDone = false, tags = null){
		super(block, x,y,z)
		this.sx = x //s stands for start
		this.sy = y
		this.sz = z
		this.mx = mx //m stands for end
		this.my = my
		this.mz = mz
		this.despawns = despawns //also tells how much time for it to move
		this.solidWhenDone = solidWhenDone
		this.tags = tags
		this.canStandOn = true
		this.endAs = null
	}
	update() {
		if (this.lastUpdate - this.spawn >= this.despawns) {
			this.canDespawn = true
			if(this.solidWhenDone){
				this.x = this.mx
				this.y = this.my
				this.z = this.mz
				this.world.setBlock(round(this.x),round(this.y),round(this.z),this.endAs || this.block, false,false,false,false, this.dimension)
				if(this.tags) this.world.setTags(round(this.x),round(this.y),round(this.z), this.tags)
			}
		}
		
		this.previousX = this.x
		this.previousY = this.y
		this.previousZ = this.z
		this.lastUpdate = now
		
		var prog = min((now - this.spawn) / this.despawns, 1)
		this.x = lerp(prog, this.sx, this.mx)
		this.y = lerp(prog, this.sy, this.my)
		this.z = lerp(prog, this.sz, this.mz)
		
		this.velx = this.x - this.previousX
		this.vely = this.y - this.previousY
		this.velz = this.z - this.previousZ
	}
}
entities[entities.length] = class BlockDisplay extends BlockEntity{
	static name2 = "BlockDisplay"
	constructor(block,x,y,z,w,h,d){
		super(block, x,y,z, w,h,d)
		this.width = w
		this.height = h
		this.depth = d
	}
	update() {}
}
entities[entities.length] = class EnderPearl extends BlockEntity{
	static name2 = "EnderPearl"
	constructor(x,y,z,velx,vely,velz,from){
		super(blockIds.enderPearl, x,y,z)
		this.velx = velx
		this.vely = vely
		this.velz = velz
		this.from = from
		this.facesPlayer = true
		
		this.gravityStength = -0.04
	}
	update() {
		this.updateVelocity(now)
		this.move(now)
		if (now - this.spawn > this.despawns) {
			this.canDespawn = true
		}
		if(this.hasCollided){
			if(this.from){
				let p = getPlayerById(this.from,this.world)
				if(p){
					p.tp(this.x,this.y+1,this.z,this.dimension)
					this.canDespawn = true
				}
			}else this.canDespawn = true
		}
		
		this.canFacePlayer = true
	}
}

entities[entities.length] = class Snowball extends BlockEntity{
	static name2 = "Snowball"
	constructor(x,y,z,velx,vely,velz,from){
		super(blockIds.snowball, x,y,z)
		this.velx = velx
		this.vely = vely
		this.velz = velz
		this.from = from
		this.facesPlayer = true
		
		this.gravityStength = -0.04
	}
	update() {
		this.updateVelocity(now)
		this.move(now)
		if(now - this.spawn > 250){
			var collided = entCollided(this)
			let from = getEntityOrPlayer(this.from,this.world)
			from = from && (from.username || from.name)
			if(collided && collided !== this){
				if(entPlayerCollided){
					collided.damage(1,from+" killed "+collided.username+" with snowballs.",false,null,this.previousX,this.previousY,this.previousZ)
				}else{
					if(collided.damage) collided.onhit(1,false, 0,0, this.from)
				}
				this.canDespawn = true
			}
		}
		if (now - this.spawn > this.despawns || this.hasCollided) {
			this.canDespawn = true
		}
		if(this.canDespawn) this.world.blockParticles(this.block,this.x,this.y,this.z,30, "break")
		
		this.canFacePlayer = true
	}
}
entities[entities.length] = class SmallFireball extends BlockEntity{
	static name2 = "SmallFireball"
	constructor(x,y,z,velx,vely,velz,from){
		super(blockIds.fireCharge, x,y,z)
		this.width = this.height = this.depth = 0.3125
		this.velx = velx
		this.vely = vely
		this.velz = velz
		this.from = from
		this.facesPlayer = true
		
		this.gravityStength = -0.07
	}
	update() {
		this.updateVelocity(now)
		this.move(now)
		if(now - this.spawn > 250){
			var collided = entCollided(this)
			let from = getEntityOrPlayer(this.from,this.world)
			from = from && (from.username || from.name)
			if(collided && collided !== this){
				if(entPlayerCollided){
					collided.burnTimer += 8
					collided.damage(5,collided.username+" was shot by fireballs from "+from+".",false,null,this.previousX,this.previousY,this.previousZ)
				}else{
					if(collided.damage) collided.onhit(5,false, 0,0, this.from), collided.burnTimer += 8
				}
				this.canDespawn = true
			}
		}
		if (now - this.spawn > this.despawns || this.hasCollided) {
			this.canDespawn = true
			if(this.hasCollided) this.world.setBlock(round(this.x),round(this.y),round(this.z),blockIds.fire,false,false,false,false,this.dimension)
		}
		if(this.canDespawn) this.world.blockParticles(this.block,this.x,this.y,this.z,30, "break")
		
		this.canFacePlayer = true
	}
}

entities[entities.length] = class Egg extends BlockEntity{
	static name2 = "Egg"
	constructor(x,y,z,velx,vely,velz,from){
		super(blockIds.egg, x,y,z)
		this.velx = velx
		this.vely = vely
		this.velz = velz
		this.from = from
		this.facesPlayer = true
		
		this.gravityStength = -0.07
	}
	update() {
		this.updateVelocity(now)
		this.move(now)
		var collided = entCollided(this)
		let from = getEntityOrPlayer(this.from,this.world)
		from = from && (from.username || from.name)
		if(collided && collided !== this){
			if(entPlayerCollided) collided.damage(1,from+" killed "+collided.username+" with eggs.",false,null,this.previousX,this.previousY,this.previousZ)
			else if(collided.damage) collided.onhit(1,false, 0,0, this.from)
			this.canDespawn = true
		}
		if (now - this.spawn > this.despawns || this.hasCollided) {
			this.canDespawn = true
		}
		if(this.canDespawn){
			this.world.blockParticles(this.block,this.x,this.y,this.z,30, "break")
			if(rand() > 0.9) this.world.addEntity(new entities[entityIds.Chicken](this.x,this.y,this.z))
		}
		
		this.canFacePlayer = true
	}
}
entities[entities.length] = class SlingshotShot extends BlockEntity{
	static name2 = "SlingshotShot"
	constructor(x,y,z,velx,vely,velz){
		super(blockIds.ironNugget, x,y,z)
		this.velx = velx
		this.vely = vely
		this.velz = velz
		this.despawns = 10000
		this.facesPlayer = true
		this.gravityStength = -0.02
	}
	update() {
		this.updateVelocity(now)
		this.move(now)
		if (now - this.spawn > this.despawns && this.onGround) {
			this.canDespawn = true
			//world.addEntity(new Item(this.x,this.y,this.z,0,0,0,blockIds.ironNugget))
		}
		
		var collided = entCollided(this)
		if(collided){
			if(entPlayerCollided) collided.damage(5,collided.username+" got killed by a slingshot.",false,null,this.previousX,this.previousY,this.previousZ)
			else if(collided.damage) collided.damage(5)
			this.canDespawn = true
		}
		
		this.canFacePlayer = true
	}
	move(now) {
		let pminX = floor(this.x - this.width / 2)
		let pmaxX = ceil(this.x + this.width / 2)
		let pminY = floor(this.y - this.height / 2)
		let pmaxY = ceil(this.y + this.height / 2)
		let pminZ = floor(this.z - this.depth / 2)
		let pmaxZ = ceil(this.z + this.depth / 2)
		let block = null

		this.liquid = false
		for (let x = pminX; x <= pmaxX; x++) {
			for (let y = pminY; y <= pmaxY; y++) {
				for (let z = pminZ; z <= pmaxZ; z++) {
					let block = this.world.getBlock(x, y, z, this.dimension)
					if (block && blockData[block].solid) {
						this.contacts.add(x, y, z, block)
					}
					if(x === round(this.x) && z === round(this.z) && blockData[block].liquid){
						this.liquid = true
					}
				}
			}
		}

		this.previousX = this.x
		this.previousY = this.y
		this.previousZ = this.z

		var xBounce, yBounce, zBounce, pvelx = this.velx, pvely = this.vely, pvelz = this.velz
		
		this.canStepX = false
		this.canStepY = false
		this.onGround = false
		this.hasCollided = false
		//Check collisions in the Y direction
		this.y += this.vely
		for (let i = 0; i < this.contacts.size; i++) {
			block = this.contacts.array[i]
			if (this.collided(block[0], block[1], block[2], null, this.vely, null, block[3])) {
				this.y = this.previousY
				this.vely = 0
				this.hasCollided = true
				yBounce = true
				break
			}
		}

		if (this.y === this.previousY) {
			this.canStepX = true
			this.canStepZ = true
		}

		//Check collisions in the X direction
		this.x += this.velx
		for (let i = 0; i < this.contacts.size; i++) {
			block = this.contacts.array[i]
			if (this.collided(block[0], block[1], block[2], this.velx, null, null, block[3])) {
				if (this.canStepX && !this.world.getBlock(block[0], block[1] + 1, block[2], this.dimension) && !this.world.getBlock(block[0], block[1] + 2, block[2], this.dimension)) {
					continue
				}
				this.x = this.previousX
				this.velx = 0
				this.hasCollided = true
				xBounce = true
				break
			}
		}

		//Check collisions in the Z direction
		this.z += this.velz
		for (let i = 0; i < this.contacts.size; i++) {
			block = this.contacts.array[i]
			if (this.collided(block[0], block[1], block[2], null, null, this.velz, block[3])) {
				if (this.canStepZ && !this.world.getBlock(block[0], block[1] + 1, block[2], this.dimension) && !this.world.getBlock(block[0], block[1] + 2, block[2]), this.dimension) {
					continue
				}
				this.z = this.previousZ
				this.velz = 0
				this.hasCollided = true
				zBounce = true
				break
			}
		}
		
		if(this.onGround){
			this.hasCollided = true
		}
		
		if(xBounce) this.velx = -pvelx
		if(yBounce) this.vely = -pvely
		if(zBounce) this.velz = -pvelz

		this.updateChunk()

		this.lastUpdate = now
		this.contacts.clear()
	}
}

entities[entities.length] = class Arrow extends Entity{
	static name2 = "Arrow"
	constructor(x,y,z,dx,dy,dz, from){
		super(x, y, z, 0, 0, dx, dy, dz, 0.25, 0.25, 0.25, null, null, null, 60000)
		this.direction = new PVector(dx,dy,dz)
		this.stopStart = this.spawn
		this.hasStopped = false
		this.noHitbox = true
		this.from = from
	}
	updateVelocity(now) {
		this.vely += -0.005
		let drag = this.liquid ? 0.7 : 0.99
		if(blockData[this.standingOn].slide) drag = blockData[this.standingOn].slide
		this.velz += (this.velz * drag - this.velz)
		this.velx += (this.velx * drag - this.velx)
		this.vely += (this.vely * drag - this.vely)
	}
	update(){
		let pvelx = this.velx
		let pvely = this.vely
		let pvelz = this.velz
		this.updateVelocity(now)
		this.move(now)
		if(this.hasCollided){
			this.x = this.previousX
			this.y = this.previousY
			this.z = this.previousZ
			this.velx = pvelx
			this.vely = pvely
			this.velz = pvelz
		}
		if(this.hasCollided && !this.hasStopped){
			this.hasStopped = true
			this.stopStart = now
			this.direction.x = this.velx
			this.direction.y = this.vely
			this.direction.z = this.velz
			this.direction.normalize()
			var x = round(this.x+this.direction.x)
			var y = round(this.y+this.direction.y)
			var z = round(this.z+this.direction.z)
			var block = this.world.getBlock(x,y,z,this.dimension)
			if(block && blockData[block].projectileHit){
				blockData[block].projectileHit(x,y,z,this)
			}
		}
		if (now - this.stopStart > this.despawns) {
			this.canDespawn = true
		}
		if(!this.hasCollided){
			let collided = entCollided(this)
			let from = getEntityOrPlayer(this.from,this.world)
			from = from && (from.username || from.name)
			let d = dist3(this.velx,this.vely,this.velz,0,0,0)*4
			if(collided && collided !== this){
				this.canDespawn = true
				if(entPlayerCollided) collided.damage(d,collided.username+" got killed by an arrow"+(from ? " from "+from+"." : "."),false,null,this.previousX,this.previousY,this.previousZ,null, this.velx/2, undefined,this.velz/2)
				else if(collided.onhit) collided.onhit(d,false, this.velx/2,this.velz/2, this.from)
				else this.canDespawn = false
			}
		}else{
			let collided = entCollided(this)
			if(entPlayerCollided && !collided.spectator && newInvItem(collided,blockIds.arrow)) this.canDespawn = true
		}
		
		this.yaw = Math.PId - (atan2(this.velz, this.velx) + Math.PI2 + Math.PI)
		var adjacent = sqrt(this.velx*this.velx+this.velz*this.velz)
		this.pitch = Math.PId - atan2(this.vely, adjacent)
	}
}
entities[entities.length] = class ExperienceOrb extends Entity{
	static name2 = "ExperienceOrb"
	constructor(x,y,z,value){
		super(x, y, z, 0, 0, 0, 0, 0, 0.5, 0.5, 0.5, null, null, null, 300000)
		this.amount = value
		this.noHitbox = true
		this.facesPlayer = true
	}
	goToPlayer(e){
		var dist = dist3(this.x,this.y,this.z,e.x,e.y-e.height*0.5,e.z)
		if(dist < 7.25){
			////var speed = (7.25 - dist) / 10
			//var aDist = abs(dist)
			//var xd = this.x - p.x, zd = this.z - p.z;
			//var x = xd/*/abs(zd)*/; this.velx = (x-(Math.sign(x)*7.25)) / 150//; this.velx = -this.velx
			//if(this.onGround) {var y = this.y - (p.y-p.bottomH); this.vely = (y-(Math.sign(y)*7.25)) / 40/*; this.vely = -this.vely*/}
			//var z = zd/*/abs(xd)*/; this.velz = (z-(Math.sign(z)*7.25)) / 150//; this.velx = -this.velx
			this.moveTowards(e.x, e.y-e.height*0.5, e.z, 7.25,7.25,7.25, 5, true)
		}
		return dist < 0.5
	}
	update(){
		let pickup
		for(let p of this.world.world.players){
			if(!p.hidden && !p.die && p.dimension === this.dimension){
				if(this.goToPlayer(p)) pickup = p
			}
		}
		
		this.updateVelocity(now)
		this.move(now)
		if(pickup){
			if(now - pickup.lastXP >= 100){
				pickup.addXP(this.amount)
				this.canDespawn = true
			}
		}
		if (now - this.spawn > this.despawns) {
			this.canDespawn = true
		}
	}
}
entities[entities.length] = class Minecart extends Entity{
	static name2 = "Minecart"
	pushes = true
	constructor(x,y,z){
		super(x, y, z, 0, 0, 0, 0, 0, 0.98, 1, 0.98, null, null, 0, Infinity)
		this.heightOnDiagonal = 1-this.width
		this.defaultHeight = this.height
		this.health = 6
		this.prevOnTrack = false
		this.rideOffsetY = -6/16
		this.canRide = true
	}
	onclick(holding,p){
		p.riding = this.id
		p.connection.send({type:"sit",riding:p.riding})
		return true
	}
	updateVelocity(now) {
		this.standingOn = this.world.getBlock(round(this.x), floor(this.y-this.height/2), round(this.z), this.dimension)
		if(this.prevLiquid !== this.liquid){
			this.prevLiquid = this.liquid
			if(this.liquid && this.wet){
				let pitch = (1/abs(this.y-this.previousY)*0.05+Math.random()*0.2)/((this.width+this.depth)*0.25/*0.25=average&correct width*/)
				if(isFinite(pitch)) this.world.playSound(this.x,this.y-this.height/2,this.z,"liquid.splash",1,pitch)
				this.world.sendAll({
          type:"particles", particleType:"SplashParticle",
          x:this.x, y:this.y-this.height/2, z:this.z, dimension:this.dimension, amount: 10
        })
			}
		}
		this.vely += this.gravityStength
		let drag = this.liquid ? 0.7 : 0.95
		let yDrag = this.liquid ? 0.7 : 0.95
		if(blockData[this.standingOn].slide) drag = blockData[this.standingOn].slide
		this.velz += (this.velz * drag - this.velz)
		this.velx += (this.velx * drag - this.velx)
		this.vely += (this.vely * yDrag - this.vely)
	}
	update() {
		let railX = round(this.x), railY = round(this.y), railZ = round(this.z)
		let onBlock = this.world.getBlock(railX,railY,railZ,this.dimension)
		if(!blockData[onBlock].rail){
			let under = this.world.getBlock(railX,railY-1,railZ,this.dimension)//to allow diagonals
			if(blockData[under].rail) onBlock = under, railY--
		}

		this.updateVelocity(now)
		for(let P of this.world.world.players){
			if(!P.hidden && !P.die && P.dimension === this.dimension && P.riding !== this.id) this.pushByMob(P)
		}
		this.world.getEntitiesNear(this.x,this.y,this.z, 16, nearEntityArray)
		for(let ent of nearEntityArray){
			if(ent.pushes && ent !== this && ent.dimension === this.dimension && ent.riding !== this.id) this.pushByMob(ent)
		}
		let {velx, vely, velz} = this
		let speed = sqrt(velx*velx+velz*velz+vely*vely)*2
		if(speed>1){
			this.velx /= speed, this.vely /= speed, this.velz /= speed
		}
		this.move(now)

		this.height = this.defaultHeight
		this.pitch = 0
		this.offsetY = 0
		if(onBlock && blockData[onBlock].rail){
			let rot = onBlock&ROTATION
			let {prevOnTrack} = this
			if((onBlock & isState) === CUBE){
				let velMag = sqrt(velx*velx+velz*velz)
				if(rot === NORTH || rot === SOUTH) this.velz = prevOnTrack ? velMag*Math.sign(velz) : velz, this.velx = 0, this.x = railX, this.yaw = round(this.yaw/Math.PI)*Math.PI
				else if(rot === EAST || rot === WEST) this.velx = prevOnTrack ? velMag*Math.sign(velx) : velx, this.velz = 0, this.z = railZ, this.yaw = round((this.yaw-Math.PI2)/Math.PI)*Math.PI+Math.PI2
				this.vely = 0, this.y = railY
				this.prevOnTrack = true
			}else if((onBlock & isState) === STAIR){//corner rail
				let originX, originZ
				if(rot === NORTH) originX = railX-0.5, originZ = railZ-0.5
				else if(rot === WEST) originX = railX+0.5, originZ = railZ-0.5
				else if(rot === SOUTH) originX = railX+0.5, originZ = railZ+0.5
				else if(rot === EAST) originX = railX-0.5, originZ = railZ+0.5
				let dx = this.x-originX, dz = this.z-originZ
				let mag = sqrt(dx*dx+dz*dz)*2
				dx /= mag, dz /= mag
				this.x = originX+dx
				this.z = originZ+dz
				let targetYaw = atan2(dx,dz)+Math.PI2
				this.yaw = round((this.yaw-targetYaw)/Math.PI)*Math.PI+targetYaw
				//below: calculate new velocity
				let velMag = sqrt(velx*velx+velz*velz)
				let prevDir = velx*dz + velz*-dx//more accurate if use previous dx and dz
				let s = dz*2, c = -dx*2
				if(prevOnTrack){
					prevDir = Math.sign(prevDir)
					this.velx = velMag*s*prevDir
					this.velz = velMag*c*prevDir
				}else{
					this.velx = prevDir*s
					this.velz = prevDir*c
				}
				this.vely = 0, this.y = railY
				//this.world.blockParticles(4,this.x+Math.sign(velMag)*sin(this.yaw),7,this.z+Math.sign(velMag)*cos(this.yaw),1,'','')
				/*//stop velocity in certain direction
				let dot = this.velx*dx + this.velz*dz
				this.velx = this.velx - dx * dot
				this.velz = this.velz - dz * dot*/
				this.prevOnTrack = true
			}else if((onBlock & isState) === SLAB){//raised
				let diagonal = sqrt(0.5)
				let originX = railX, originY = railY, originZ = railZ, dx = 0, dy = diagonal, dz = 0
				if(rot === NORTH) originZ -= 0.5, dz = diagonal, this.yaw = round(this.yaw/Math.PI)*Math.PI
				else if(rot === SOUTH) originZ += 0.5, dz = -diagonal, this.yaw = round(this.yaw/Math.PI)*Math.PI
				else if(rot === EAST) originX -= 0.5, dx = diagonal, this.yaw = round((this.yaw-Math.PI2)/Math.PI)*Math.PI+Math.PI2
				else if(rot === WEST) originX += 0.5, dx = -diagonal, this.yaw = round((this.yaw-Math.PI2)/Math.PI)*Math.PI+Math.PI2
				let dot = (this.x-originX)*dx + (this.z-originZ)*dz + (this.y-originY)*dy
				this.x = originX+dx*dot
				this.y = originY+dy*dot
				this.z = originZ+dz*dot
				let velMag = sqrt(velx*velx+velz*velz+vely*vely)
				let prevDir = velx*dx + velz*dz + vely*dy//more accurate if use previous dx and dz
				if(prevOnTrack){
					prevDir = Math.sign(prevDir)
					this.velx = velMag*dx*prevDir
					this.velz = velMag*dz*prevDir
					this.vely = velMag*dy*prevDir
				}else{
					this.velx = prevDir*dx
					this.velz = prevDir*dz
					this.vely = prevDir*dy
				}
				this.prevOnTrack = true
				this.height = this.heightOnDiagonal//to allow fitting
				this.pitch = -Math.PI4*Math.sign(sin(this.yaw)*dx+cos(this.yaw)*dz)
				this.offsetY = 0.25
			}else this.prevOnTrack = false
			if(this.yaw > Math.PId) this.yaw -= Math.PId, this.previousYaw -= Math.PId
			if(this.yaw < 0) this.yaw += Math.PId, this.previousYaw += Math.PId
			if(blockData[onBlock].name === "poweredRail"){
				let velMag = sqrt(velx*velx+velz*velz+vely*vely)
				if(onBlock&FLIP){
					if(velMag > 0.01 && velMag<8){
						let extraSpeed = (8-velMag)*0.06
						this.velx += this.velx/velMag*extraSpeed
						this.velz += this.velz/velMag*extraSpeed
						this.vely += this.vely/velMag*extraSpeed
						if((onBlock&isState) === CUBE){
							if(rot === NORTH || rot === SOUTH){
								if(blockData[this.world.getBlock(railX,railY,railZ+1)].solid) this.velz = min(this.velz,-0.1)
								else if(blockData[this.world.getBlock(railX,railY,railZ-1)].solid) this.velz = max(this.velz,0.1)
							}else if(rot === EAST || rot === WEST){
								if(blockData[this.world.getBlock(railX+1,railY,railZ)].solid) this.velx = min(this.velx,-0.1)
								else if(blockData[this.world.getBlock(railX-1,railY,railZ)].solid) this.velx = max(this.velx,0.1)
							}
						}
					}
				}else{
					this.velx *= 0.65
					this.velz *= 0.65
					this.vely *= 0.65
				}
			}
		}else this.prevOnTrack = false
		
		if(this.harmEffect > 0){
			this.harmEffect--
		}
		if(this.health <= 0){
			this.canDespawn = true
			this.world.addItems(this.x,this.y,this.z,0,0,0,blockIds.minecart,true,1,null,null,this.id)
		}
	}
	onhit(damage,remote, vx,vz, from){
		this.health -= damage
		if(this.harmEffect>0) this.harmEffect += 7-floor(this.health)
		else this.harmEffect = 7-floor(this.health)
		if(!remote) this.world.sendEntityPos(this)
	}
}
class Mob extends Entity{
	static mob = true
	mob = true
	pushes = true
	constructor(){
		super(...arguments)
		/*this.moveTime = 0
		this.spinTime = 0
		this.spin = 0
		this.dirx = 0
		this.dirz = 0*/
		this.health = 0
		this.lastDamage = 0
		this.lastY = this.y
		this.path = null
		this.walking = false
		this.panick = 0
		this.drop = null
		this.dropAmount = 0
		this.maxDamageBlock = 0 //for blocks with damage
		this.maxBurnBlock = 0
		this.burnTimer = 0
		this.burning = false
		this.lastBlockDamage = 0
		this.oxygen = 20
		this.lastOxygenChange = 0
		this.spinTarget = 0
		this.spinTargetPitch = 0
		this.die = false
		this.lastStepSound = 0
		this.hostile = false
		this.minFollowDist = 0
		this.maxFollowDist = 0
		this.detectionDist = 0
		this.target = null, this.targetEnt = null
		this.attackStrength = 0
		this.attackCooldown = 0, this.maxAttackCooldown = 0
		this.holding = this.prevHolding = 0
		this.canClimb = false
		this.canFly = false
		this.attacks = null
		this.attracts = null
		this.attractEnt = null
		this.attractedBy = null
		this.sitting = false
		this.owner = null
		this.name = null
		this.despawnStart = performance.now()
		this.hasAI = true
		this.effects = {}
		this.lastPathFind = 0
		this.blockAtFeet = 0
	}
	findPath(fx,fy,fz,x,y,z){
		let spreaded = [], spreadAt = [fx,fy,fz,null] //x y z parent
		let spreadAtIndexes = [null]//points at parent node
		let maxDist = 40, dist, dx, dy, dz, dd
		let sx = fx, sy = fy, sz = fz, xDir, yDir, zDir, cy
		let f = this.canFly
		let closestIdx, closestIdxDist = Infinity
		while(spreadAt.length && max(abs(sx-x),abs(sy-y),abs(sz-z)) > 0){
			sx = spreadAt[spreadAt.length-4]
			sy = spreadAt[spreadAt.length-3]
			sz = spreadAt[spreadAt.length-2]
			let closestDist = Infinity
			xDir = yDir = zDir = 0
			if(max(abs(sx-fx),abs(sy-fy),abs(sz-fz)) > maxDist && spreaded.length > 1000) return
			{
				dx = 1, dz = 0
				let ci = this.world.getBlock(sx+dx,sy-1,sz+dz)
				let a = blockData[this.world.getBlock(sx+dx,sy+1,sz+dz)].solid, b = blockData[this.world.getBlock(sx+dx,sy,sz+dz)].solid, c = blockData[ci].solid, d = blockData[this.world.getBlock(sx+dx,sy-2,sz+dz)].solid
				dy = 1, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
				if((b||f) && !a && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
				dy = 0, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
				if((c || blockData[ci].liquid || f) && !(b || blockData[this.world.getBlock(sx+dx,sy,sz+dz)].liquid) && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
				dy = -1, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
				if((d||f) && !c && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
			}
			{
				dx = -1, dz = 0
				let ci = this.world.getBlock(sx+dx,sy-1,sz+dz)
				let a = blockData[this.world.getBlock(sx+dx,sy+1,sz+dz)].solid, b = blockData[this.world.getBlock(sx+dx,sy,sz+dz)].solid, c = blockData[ci].solid, d = blockData[this.world.getBlock(sx+dx,sy-2,sz+dz)].solid
				dy = 1, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
				if((b||f) && !a && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
				dy = 0, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
				if((c || blockData[ci].liquid || f) && !(b || blockData[this.world.getBlock(sx+dx,sy,sz+dz)].liquid) && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
				dy = -1, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
				if((d||f) && !c && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
			}
			{
				dx = 0, dz = 1
				let ci = this.world.getBlock(sx+dx,sy-1,sz+dz)
				let a = blockData[this.world.getBlock(sx+dx,sy+1,sz+dz)].solid, b = blockData[this.world.getBlock(sx+dx,sy,sz+dz)].solid, c = blockData[ci].solid, d = blockData[this.world.getBlock(sx+dx,sy-2,sz+dz)].solid
				dy = 1, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
				if((b||f) && !a && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
				dy = 0, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
				if((c || blockData[ci].liquid || f) && !(b || blockData[this.world.getBlock(sx+dx,sy,sz+dz)].liquid) && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
				dy = -1, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
				if((d||f) && !c && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
			}
			{
				dx = 0, dz = -1
				let ci = this.world.getBlock(sx+dx,sy-1,sz+dz)
				let a = blockData[this.world.getBlock(sx+dx,sy+1,sz+dz)].solid, b = blockData[this.world.getBlock(sx+dx,sy,sz+dz)].solid, c = blockData[ci].solid, d = blockData[this.world.getBlock(sx+dx,sy-2,sz+dz)].solid
				dy = 1, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
				if((b||f) && !a && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
				dy = 0, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
				if((c || blockData[ci].liquid || f) && !(b || blockData[this.world.getBlock(sx+dx,sy,sz+dz)].liquid) && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
				dy = -1, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
				if((d||f) && !c && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
			}
			let above = blockData[this.world.getBlock(sx,sy+1,sz)], below = blockData[this.world.getBlock(sx,sy-1,sz)]
			dist = abs(sx-x)+abs(sz-z)+abs(sy+1-y)
			if(above.ladder && dist < closestDist && !xyArrayHas(spreaded,spreadAt,sx,sy+1,sz)) closestDist = dist, xDir = 0, yDir = 1, zDir = 0
			dist = abs(sx-x)+abs(sz-z)+abs(sy-1-y)
			if(below.ladder && dist < closestDist && !xyArrayHas(spreaded,spreadAt,sx,sy-1,sz)) closestDist = dist, xDir = 0, yDir = -1, zDir = 0
			if(this.canClimb){
				let b = blockData[this.world.getBlock(sx+1,sy,sz)].solid || blockData[this.world.getBlock(sx-1,sy,sz)].solid || blockData[this.world.getBlock(sx,sy,sz+1)].solid || blockData[this.world.getBlock(sx,sy,sz-1)].solid,
				a2 = blockData[this.world.getBlock(sx,sy+1,sz)].solid,
				b2 = blockData[this.world.getBlock(sx,sy,sz)].solid
				dist = abs(sx-x)+abs(sz-z)+abs(sy+1-y)
				if(!a2 && !b2 && b && dist < closestDist && !xyArrayHas(spreaded,spreadAt,sx,sy+1,sz)) closestDist = dist, xDir = 0, yDir = 1, zDir = 0
			}
			if(this.canFly){
				let a2 = blockData[this.world.getBlock(sx,sy+1,sz)].solid,
				b2 = blockData[this.world.getBlock(sx,sy,sz)].solid
				dist = abs(sx-x)+abs(sz-z)+abs(sy+1-y)
				if(!a2 && !b2 && dist < closestDist && !xyArrayHas(spreaded,spreadAt,sx,sy+1,sz)) closestDist = dist, xDir = 0, yDir = 1, zDir = 0
			}

			/*dist = abs(sx+1-x)+abs(sz-z)
			if(dist < closestDist){
				dx = 1, dy = 0, dz = 0, dd = false, cy = Infinity
				let a = blockData[this.world.getBlock(sx+dx,sy+1,sz+dz)].solid, b = blockData[this.world.getBlock(sx+dx,sy,sz+dz)].solid, c = blockData[this.world.getBlock(sx+dx,sy-1,sz+dz)].solid, d = blockData[this.world.getBlock(sx+dx,sy-2,sz+dz)].solid
				if((b||f) && !a && abs(sy+1-fy) < cy) dy = 1, dd = true, cy = abs(sy-1-fy)
				if((c || blockData[this.world.getBlock(sx+dx,sy-1,sz+dz)].liquid || f) && !(b || blockData[this.world.getBlock(sx+dx,sy,sz+dz)].liquid) && abs(sy-fy) < cy) dy = 0, dd = true, cy = abs(sy-1-fy)
				if((d||f) && !c && abs(sy-1-fy) < cy) dy = -1, dd = true, cy = abs(sy-1-fy)
				if(dd && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz, closestY = cy
			}
			dist = abs(sx-1-x)+abs(sz-z)
			if(dist < closestDist){
				dx = -1, dy = 0, dz = 0, dd = false, cy = Infinity
				let a = blockData[this.world.getBlock(sx+dx,sy+1,sz+dz)].solid, b = blockData[this.world.getBlock(sx+dx,sy,sz+dz)].solid, c = blockData[this.world.getBlock(sx+dx,sy-1,sz+dz)].solid, d = blockData[this.world.getBlock(sx+dx,sy-2,sz+dz)].solid
				if((b||f) && !a && abs(sy+1-fy) < cy) dy = 1, dd = true, cy = abs(sy-1-fy)
				if((c || blockData[this.world.getBlock(sx+dx,sy-1,sz+dz)].liquid || f) && !(b || blockData[this.world.getBlock(sx+dx,sy,sz+dz)].liquid) && abs(sy-fy) < cy) dy = 0, dd = true, cy = abs(sy-1-fy)
				if((d||f) && !c && abs(sy-1-fy) < cy) dy = -1, dd = true, cy = abs(sy-1-fy)
				if(dd && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz, closestY = cy
			}
			dist = abs(sx-x)+abs(sz+1-z)
			if(dist < closestDist){
				dx = 0, dy = 0, dz = 1, dd = false, cy = Infinity
				let a = blockData[this.world.getBlock(sx+dx,sy+1,sz+dz)].solid, b = blockData[this.world.getBlock(sx+dx,sy,sz+dz)].solid, c = blockData[this.world.getBlock(sx+dx,sy-1,sz+dz)].solid, d = blockData[this.world.getBlock(sx+dx,sy-2,sz+dz)].solid
				if((b||f) && !a && abs(sy+1-fy) < cy) dy = 1, dd = true, cy = abs(sy-1-fy)
				if((c || blockData[this.world.getBlock(sx+dx,sy-1,sz+dz)].liquid || f) && !(b || blockData[this.world.getBlock(sx+dx,sy,sz+dz)].liquid) && abs(sy-fy) < cy) dy = 0, dd = true, cy = abs(sy-1-fy)
				if((d||f) && !c && abs(sy-1-fy) < cy) dy = -1, dd = true, cy = abs(sy-1-fy)
				if(dd && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz, closestY = cy
			}
			dist = abs(sx-x)+abs(sz-1-z)
			if(dist < closestDist){
				dx = 0, dy = 0, dz = -1, dd = false, cy = Infinity
				let a = blockData[this.world.getBlock(sx+dx,sy+1,sz+dz)].solid, b = blockData[this.world.getBlock(sx+dx,sy,sz+dz)].solid, c = blockData[this.world.getBlock(sx+dx,sy-1,sz+dz)].solid, d = blockData[this.world.getBlock(sx+dx,sy-2,sz+dz)].solid
				if((b||f) && !a && abs(sy+1-fy) < cy) dy = 1, dd = true, cy = abs(sy-1-fy)
				if((c || blockData[this.world.getBlock(sx+dx,sy-1,sz+dz)].liquid || f) && !(b || blockData[this.world.getBlock(sx+dx,sy,sz+dz)].liquid) && abs(sy-fy) < cy) dy = 0, dd = true, cy = abs(sy-1-fy)
				if((d||f) && !c && abs(sy-1-fy) < cy) dy = -1, dd = true, cy = abs(sy-1-fy)
				if(dd && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz, closestY = cy
			}
			if(!isFinite(closestDist) && this.canClimb){
				let b = blockData[this.world.getBlock(sx+1,sy,sz)].solid || blockData[this.world.getBlock(sx-1,sy,sz)].solid || blockData[this.world.getBlock(sx,sy,sz+1)].solid || blockData[this.world.getBlock(sx,sy,sz-1)].solid,
				a2 = blockData[this.world.getBlock(sx,sy+1,sz)].solid,
				b2 = blockData[this.world.getBlock(sx,sy,sz)].solid
				if(!a2 && !b2 && b && abs(sy+1-fy) < closestY && !xyArrayHas(spreaded,spreadAt,sx,sy+1,sz)) yDir = 1, closestY = abs(sy+1-fy), closestDist = abs(sx-x)+abs(sz-z)
			}else if(!isFinite(closestDist) && this.canFly){
				let a2 = blockData[this.world.getBlock(sx,sy+1,sz)].solid,
				b2 = blockData[this.world.getBlock(sx,sy,sz)].solid
				if(!a2 && !b2 && abs(sy+1-fy) < closestY && !xyArrayHas(spreaded,spreadAt,sx,sy+1,sz)) yDir = 1, closestY = abs(sy+1-fy), closestDist = abs(sx-x)+abs(sz-z)
			}else if(!isFinite(closestDist)){
				let above = blockData[this.world.getBlock(sx,sy+1,sz)], below = blockData[this.world.getBlock(sx,sy-1,sz)]
				if(above.ladder && abs(sy+1-fy) < closestY && !xyArrayHas(spreaded,spreadAt,sx,sy+1,sz)) yDir = 1, closestY = abs(sy+1-fy), closestDist = abs(sx-x)+abs(sz-z)
				if(below.ladder && abs(sy-1-fy) < closestY && !xyArrayHas(spreaded,spreadAt,sx,sy-1,sz)) yDir = -1, closestY = abs(sy-1-fy), closestDist = abs(sx-x)+abs(sz-z)
			}*/
			if(spreadAtIndexes[spreadAtIndexes.length-1] === null){//if not already in spreaded
				spreadAtIndexes[spreadAtIndexes.length-1] = spreaded.length
				spreaded.push(sx,sy,sz, spreadAtIndexes.length>1 ? spreadAtIndexes[spreadAtIndexes.length-2] : null)
				let fromDist = max(abs(sx-x),abs(sy-y),abs(sz-z))
				if(fromDist<closestIdxDist){
					closestIdxDist = fromDist
					closestIdx = spreadAtIndexes[spreadAtIndexes.length-1]
				}
			}
			if(isFinite(closestDist)) spreadAt.push(sx+xDir,sy+yDir,sz+zDir, null), spreadAtIndexes.push(null)
			else spreadAt.pop(), spreadAt.pop(), spreadAt.pop(), spreadAt.pop(), spreadAtIndexes.pop()
		}
		if(sx === fx && sy === fy && sz === fz) return null
		let i = closestIdx, path = [sz+zDir,sy+yDir,sx+xDir]//[sz+zDir,sy+yDir,sx+xDir,sz,sy,sx]
		while(path.length < 85){
			i = spreaded[i+3]
			if(i) path.push(spreaded[i+2],spreaded[i+1],spreaded[i])
			else break
		}
		path.reverse()
		return path
	}
	randomPath(){
		let x = round(this.x+rand(-10,10))
		let z = round(this.z+rand(-10,10))
		let y, y2
		for(y = y2 = round(this.y); y<round(this.y)+10; y++, y2--){
			let data = blockData[this.world.getBlock(x,y,z,this.dimension)]
			if(!data.solid && !data.liquid) break
			data = blockData[this.world.getBlock(x,y2,z,this.dimension)]
			if(!data.solid && !data.liquid) break
		}
		this.path = this.findPath(round(this.x),round(this.y-this.height/2),round(this.z),x,y,z) || null
	}
	AI(now){
		if(!this.hasAI) return
		let target = this.target && getEntityOrPlayer(this.target,this.world)
		let follow = target || this.attractEnt
		let d = follow && max(abs(follow.x-this.x),abs(follow.y-this.y),abs(follow.z-this.z))
		if(this.path && !this.path.length) this.path = null
		if(this.path && (!follow || follow === target && d > this.minFollowDist || follow === this.attractEnt && d > 2)){
			//let x,y,z, c = Infinity, i
			/*for(let i2=0; i2<this.path.length; i2+=3){
				let d = max(abs(this.path[i2]-this.x),abs(this.path[i2+1]-this.y),abs(this.path[i2+2]-this.z))
				if(d < c) c = d, x = this.path[i2], y = this.path[i2+1], z = this.path[i2+2], i = i2
			}
			if(i > 0) this.path.splice(0,i) //get rid of the part that it wont go to
			*/
			let [x,y,z] = this.path
			let yaw = angleOf(x,z,this.x,this.z)
			this.spinTarget = yaw
			if(this.yaw - yaw > Math.PI) yaw += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
			if(this.yaw - yaw < -Math.PI) yaw -= Math.PId
			let d = max(min(yaw - this.yaw, 0.3),-0.3)
			this.yaw += d
			let distToPath = max(abs(this.x-x),abs(this.z-z),abs(this.y-this.height/2-y)), goingVertical = x === this.path[3] && z === this.path[5]
			let speed = this.panick > 0 ? 0.08 : (this.target ? 0.03 : 0.02)
			if(!goingVertical || distToPath > 1){//if going up, don't move unless too far
				this.velx += sin(this.yaw) * speed
				this.velz += cos(this.yaw) * speed
			}
			if(y > round(this.y-this.height/2)){
				if(this.canClimb) this.vely = 0.2
				else if(this.canFly) this.vely += 0.2
				else if(this.onGround) this.vely = 0.6
				if(this.blockAtFeet && blockData[this.blockAtFeet].ladder){
					this.vely = 0.2
				}
			}
			if(distToPath < 1){
				this.path.splice(0,3)
			}
			this.walking = true
		}else{
			this.walking = false
			if(this.spinTarget !== this.yaw){
				let yaw = this.spinTarget
				if(this.yaw - yaw > Math.PI) yaw += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
				if(this.yaw - yaw < -Math.PI) yaw -= Math.PId
				let d = max(min(yaw - this.yaw, 0.1),-0.1)
				this.yaw += d
			}
		}
		if(this.liquid) this.vely += 0.3

		if(this.path && this.sitting) this.path = null
		if(this.sitting && this.targetEnt) this.targetEnt = target = null
		if(target){
			let d = max(abs(this.x-target.x),abs(this.y-target.y),abs(this.z-target.z))
			if(d > this.maxFollowDist ||
			this.dimension !== target.dimension || target.hidden || target.die || target.survival !== undefined && !target.survival
			) this.target = target = null
		}
		if(this.hostile && !target && !this.sitting){
			let c = Infinity
			if(!this.attacks || this.attacks.includes("Player")) for(let ent of this.world.world.players){
				if(this.dimension === ent.dimension && !ent.hidden && !ent.die && ent.survival){
					let d = max(abs(this.x-ent.x),abs(this.y-ent.y),abs(this.z-ent.z))
					if(d<this.detectionDist && d<c){
						c = d
						this.target = ent.id, target = ent
					}
				}
			}
			if(this.attacks){
				this.world.getEntitiesNear(this.x,this.y,this.z, this.detectionDist, nearEntityArray)
				for(let ent of nearEntityArray){
					if(this.dimension === ent.dimension && !ent.hidden && !ent.die && this.attacks.includes(ent.type)){
						let d = max(abs(this.x-ent.x),abs(this.y-ent.y),abs(this.z-ent.z))
						if(d<this.detectionDist && d<c){
							c = d
							this.target = ent.id, target = ent
						}
					}
				}
			}
		}
		this.attractEnt = null
		if(!target && this.attracts){
			let cd = Infinity
			for(let p of this.world.world.players){
				let dist = max(abs(this.x-p.x),abs(this.y-p.y),abs(this.z-p.z))
				if(p.dimension === this.dimension && !p.hidden && !p.die && dist < 5 && dist < cd && this.attracts.includes(p.holding)) cd = dist, this.attractEnt = p
			}
		}
		this.attractedBy = this.attractEnt ? (this.attractEnt.id) : null
		if(this.attackCooldown > 0) this.attackCooldown--
		if(follow && !this.sitting){
			let y = round(follow.y)
			if(!this.canFly){
				while(!blockData[this.world.getBlock(round(follow.x),y,round(follow.z),this.dimension)].solid && y>round(this.y)-this.detectionDist) y--
				y++
			}
			if(now-this.lastPathFind>1000){
				this.lastPathFind = now
				let path = this.findPath(round(this.x),round(this.y-this.height/2),round(this.z),round(follow.x),y,round(follow.z))
				if(path){
					path.splice(0,3)
					this.path = path
				}
			}
			if(target && this.attackStrength && this.attackCooldown <= 0 && (d || d === 0) && d <= this.minFollowDist+0.5){
				let velx = sin(this.yaw)/2, velz = cos(this.yaw)/2
				if(target.type === "Player"){
					let msg = this.name ? target.username+"was killed by "+this.name+"." : this.killMessage(target.username)
					target.damage(this.attackStrength,msg,false,null,this.x,this.y,this.z,this)
				}else if(target.onhit) target.onhit(this.attackStrength,false, velx,velz, this.id)
				this.attackCooldown = this.maxAttackCooldown
				//this.world.sendAllInChunk({type:"entEvent",event:"mobAttack",id:this.id},this.chunkX,this.chunkZ,this.chunkDimension)
				this.world.sendEntityPos(this)
			}
		}else{
			if(!this.sitting && rand() > 0.995 && !this.path){
				this.randomPath()
			}else if(rand() > 0.99){
				this.spinTarget = rand(Math.PId)
				this.spinTargetPitch = 0
			}
		}
		
		if(this.saySound && rand() > 0.999){
			let sound = this.saySound
			if(Array.isArray(sound)) sound = sound[Math.floor(Math.random()*sound.length)]
			this.world.playSound(this.x,this.y,this.z, sound)
		}
		this.targetEnt = target
		if(this.additionalAI) this.additionalAI()
		if(this.yaw<0) this.yaw += Math.PId
		if(this.yaw>Math.PId) this.yaw -= Math.PId
		/*let dt = (now - this.lastUpdate) / 33
		dt = dt > 2 ? 2 : dt
		if(this.moveTime > 0){
			this.moveTime --
			this.velx += this.dirx / 100
			this.velz += this.dirz / 100
		}else if(this.spinTime > 0){
			this.spinTime --
			this.yaw += this.spin
			if(this.yaw > Math.PI*2){
				this.yaw -= Math.PI*2
			}
			if(this.yaw < 0){
				this.yaw += Math.PI*2
			}
		}else if(Math.random()>0.8){
			if(Math.random() > 0.5){
				this.spinTime = Math.random()*60
				this.spin = (Math.random()>0.5 ? 0.05 : -0.05)
			}else{
				this.moveTime = Math.random()*60
				this.dirx = Math.cos(this.yaw)
				this.dirz = -Math.sin(this.yaw)
			}
		}
		if(this.moveTime > 0 && Math.random() > 0.5){
			var b = world.getBlock(round(this.x+this.dirx), this.y, round(this.z+this.dirz), this.dimension)
			if(this.onGround && blockData[b].solid && !blockData[b].liquid){
				this.vely = 0.3
			}
			if(blockData[b].liquid){
				this.vely += 0.05
			}
		}*/
	}
	ontouch(x,y,z,block){
		let data = blockData[block]
		if(inBox(this,x,y,z,1,1,1)){
			if(data.damage){
				let d = data.damage
				if(typeof d === "function") d = d(round(this.x),round(this.y),round(this.z),this.world)
				if(d > this.maxDamageBlock) this.maxDamageBlock = d
			}
			if(data.burnEnt) this.maxBurnBlock = 0.2
		}else if(data.damageUp && onBox(this,x,y,z,1,1,1)){
			if(data.damageUp > this.maxDamageBlock) this.maxDamageBlock = data.damageUp
		}
	}
	mobUpdate(now) {
		this.maxBurnBlock = this.maxDamageBlock = 0
		this.updateVelocity(now)
		this.move(now)
		for(let P of this.world.world.players){
			if(!P.hidden && !P.die && P.dimension === this.dimension && P.riding !== this.id) this.pushByMob(P)
		}
		this.world.getEntitiesNear(this.x,this.y,this.z, 16, nearEntityArray)
		for(let ent of nearEntityArray){
			if(ent.pushes && ent !== this && ent.dimension === this.dimension && ent.riding !== this.id) this.pushByMob(ent)
		}
		let blockAtFeet = this.world.getBlock(round(this.x),ceil(this.y-this.height/2),round(this.z), this.dimension)
		this.blockAtFeet = blockAtFeet
		this.AI(now)
		if(blockAtFeet && blockData[blockAtFeet].ladder){
			this.lastY = this.y
			if(this.vely < 0) this.vely *= 0.2
		}
		
		//health and death & stuff
		if(this.y > this.lastY) this.lastY = this.y
		if(this.onGround && !this.canFly){
			let fall = this.lastY - this.y
			this.lastY = this.y
			if(!this.liquid && fall > 3){
				this.damage(fall-3)
			}
		}
		if(this.maxDamageBlock > 0 && now - this.lastBlockDamage > 500){
			this.lastBlockDamage = now
			this.damage(this.maxDamageBlock)
			if(!this.path) this.randomPath()
			this.sitting = false
			//this.world.sendAllInChunk({type:"entEvent",event:"sit",id:this.id, data:this.sitting},this.chunkX,this.chunkZ,this.chunkDimension)
			this.world.sendEntityPos(this)
			this.panick = 20
		}
		this.burnTimer += this.maxBurnBlock
		if(this.burnTimer > 16) this.burnTimer = 16
		this.burning = this.burnTimer > 0
		if(this.burning){
			if(now - this.lastBlockDamage > 1000){
				this.lastBlockDamage = now
				this.burnTimer -= 2
				if(this.burnTimer < 0) this.burnTimer = 0
				this.damage(1)
				if(!this.path) this.randomPath()
				this.sitting = false
				//this.world.sendAllInChunk({type:"entEvent",event:"sit",id:this.id, data:this.sitting},this.chunkX,this.chunkZ,this.chunkDimension)
				this.world.sendEntityPos(this)
				this.panick = 20
			}
		}
		if(this.insideBlock && (blockData[this.insideBlock].solid && !blockData[this.insideBlock].transparent || blockData[this.insideBlock].liquid)){
			if(this.oxygen > 0){
				if(now - this.lastOxygenChange > (blockData[this.insideBlock].liquid ? 1000 : 500)){
					this.lastOxygenChange = now
					this.oxygen-=2
				}
			}else{
				if(now - this.lastOxygenChange > 500){
					this.lastOxygenChange = now
					this.damage(1)
					this.sitting = false
					if(!this.path) this.randomPath()
					this.panick = 20
					//this.world.sendAllInChunk({type:"entEvent",event:"sit",id:this.id, data:this.sitting},this.chunkX,this.chunkZ,this.chunkDimension)
					this.world.sendEntityPos(this)
				}
			}
		}else if(this.oxygen < 20){
			if(now - this.lastOxygenChange > 250){
				this.lastOxygenChange = now
				this.oxygen+=2
			}
		}
		if(this.oxygen < 0) this.oxygen = 0
		if(this.oxygen > 20) this.oxygen = 20
		
		for(let i in this.effects){
			let e = this.effects[i]
			e.time--
			if(e.time <= 0) delete this.effects[i]
		}
		if(this.effects.wither && now-this.lastBlockDamage > 1000){
			this.lastBlockDamage = now
			this.damage(this.effects.wither.level*0.5)
			if(!this.path) this.randomPath()
			this.panick = 20
    }
		if(this.harmEffect > 0){
			this.harmEffect -= 3
		}
		if(this.health <= 0 && !this.die){
			this.die = true
			this.hasAI = false
			if(this.deathSound){
				let sound = this.deathSound
				if(Array.isArray(sound)) sound = sound[Math.floor(Math.random()*sound.length)]
				this.world.playSound(this.x,this.y,this.z, sound)
			}
			if(this.drop){
				for(let i of this.drop){
					let amount = this.dropAmount || 1
					if(Array.isArray(amount)) amount = round(rand(amount[0],amount[1]))
					this.world.addItems(this.x,this.y,this.z,0,0,0,i,true,amount,null,null,this.id)
				}
				if(this.holding) this.world.addItems(this.x,this.y,this.z,0,0,0,this.holding,true,null,null,null,this.id)
				if(this.experience) this.world.addEntity(new entities[entityIds.ExperienceOrb](this.x, this.y, this.z, this.experience),false,this.dimension)
				if(this.ondie) this.ondie()
			}
		}
		if(this.die){
			this.dieEffect += 0.04//0.05 //slower than client side to allow animation
			this.dieRotate = (this.dieEffect**4)*Math.PI2
			if(this.dieEffect > 1){
				this.canDespawn = true
				this.dieEffect = 0
				this.dieRotate = 0
				this.hidden = true
				this.world.poof(this.x,this.y,this.z, undefined,this.dimension, this.width,this.height,this.depth,true)
			}
		}
		if(this.walking && now - this.lastStepSound > (this.panick ? 500 : 1000)){
			this.lastStepSound = now
			if(this.stepSound){
				let sound = this.stepSound
				if(Array.isArray(sound)) sound = sound[Math.floor(Math.random()*sound.length)]
				this.world.playSound(this.x,this.y-this.height/2,this.z, sound)
			}else this.world.blockSound(this.standingOn,"step",this.x,this.y-this.height/2,this.z)
		}
		if(this.panick > 0) this.panick--
	}
	updateAlways(){
		let canDespawn = true
		for(let p of this.world.world.players){
			if(max(abs(this.x-p.x),abs(this.y-p.y),abs(this.z-p.z)) <= 48) canDespawn = false
		}
		if(this.name) canDespawn = false
		if(!canDespawn) this.despawnStart = now
		else if (now - this.despawnStart > this.despawns) {
			this.canDespawn = true
		}
	}
	damage(amount,vx,vy,vz){
		if(vx) this.velx += vx
		if(vy) this.vely += vy
		if(vz) this.velz += vz
		var prev = amount
		if(this.harmEffect > 0){
			if(amount > this.lastDamage){
				amount -= this.lastDamage
			}else return
		}
		
		this.health -= amount
		this.harmEffect = 30
		this.lastDamage = prev
		if(this.hurtSound){
			let sound = this.hurtSound
			if(Array.isArray(sound)) sound = sound[Math.floor(Math.random()*sound.length)]
			this.world.playSound(this.x,this.y,this.z, sound)
		}
	}
	onhit(damage,remote, vx,vz, from){
		this.panick = 60
		if(!this.path) this.randomPath()
		//this.world.sendAllInChunk({type:"entEvent",event:"sit",id:this.id, data:this.sitting},this.chunkX,this.chunkZ,this.chunkDimension)
		this.sitting = false

		this.damage(damage,vx,min(max(0.5-this.vely,0),0.5),vz)
		setTarget:if(this.hostile){
			if(this.owner){
				let owner = getPlayerByUsername(this.owner,this.world)
				if(from === owner.username) break setTarget
			}
			this.target = from || null
		}
		if(!remote) this.world.sendEntityPos(this)
	}
	applyEffect(name,level,time, showParticles = true){
		time *= 20
		if(this.effects[name]){
			let e = this.effects[name]
			if(level>e.level){
				e.level = level
				e.time = time
				e.showParticles = e.showParticles || showParticles
			}
		}
		this.effects[name] = {level, time, showParticles}
	}
}
entities[entities.length] = class Cow extends Mob{
	static name2 = "Cow"
	drop = [blockIds.rawBeef]
	dropAmount = [1,3]
	saySound = ["cow.say1","cow.say2","cow.say3","cow.say4"]
	stepSound = ["cow.step1","cow.step2","cow.step3","cow.step4"]
	hurtSound = ["cow.hurt1","cow.hurt2","cow.hurt3"]
	defaultName = "Cow"
	constructor(x,y,z){
		super(x, y, z, 0, 0, 0, 0, 0, 1, 21/16, 1, null,null, null, 300000)
		var pix = 1/16
		this.offsetY = pix*9.5
		
		this.addPart("frontRightLeg",null,null,pix*-4,pix*-8,pix*7,1,1,1,0,0)
		this.addPart("frontLeftLeg",null,null,pix*4,pix*-8,pix*7,1,1,1,0,0)
		this.addPart("backRightLeg",null,null,pix*-4,pix*-8,pix*-6,1,1,1,0,0)
		this.addPart("backLeftLeg",null,null,pix*4,pix*-8,pix*-6,1,1,1,0,0)
		this.addPart("head",null,null,0,0,pix*9,1,1,1,0,0)
		
		this.health = 10
		this.attracts = [blockIds.wheat]
	}
	update(){
		this.mobUpdate(now)
	}
	onclick(holding){
		if(holding && holding.id === blockIds.bucket) holding.id = blockIds.milkBucket
	}
}
entities[entities.length] = class Pig extends Mob{
	static name2 = "Pig"
	drop = [blockIds.rawPorkchop]
	dropAmount = [1,3]
	saySound = ["pig.say1","pig.say2","pig.say3"]
	stepSound = ["pig.step1","pig.step2","pig.step3","pig.step4","pig.step5"]
	deathSound = "pig.death"
	defaultName = "Pig"
	constructor(x,y,z){
		super(x, y, z, 0, 0, 0, 0, 0, 1, 1, 1, null,null, null, 300000)
		var pix = 1/16
		this.offsetY = pix*6
		this.addPart("frontRightLeg",null,null,pix*-3,pix*-8,pix*5,1,1,1,0,0)
		this.addPart("frontLeftLeg",null,null,pix*3,pix*-8,pix*5,1,1,1,0,0)
		this.addPart("backRightLeg",null,null,pix*-3,pix*-8,pix*-7,1,1,1,0,0)
		this.addPart("backLeftLeg",null,null,pix*3,pix*-8,pix*-7,1,1,1,0,0)
		this.addPart("head",null,null,0,pix*-2,pix*10,1,1,1,0,0)
		
		this.health = 10
		this.attracts = [blockIds.carrot, blockIds.potato]
	}
	update(){
		this.mobUpdate(now)
	}
}
entities[entities.length] = class Creeper extends Mob{
	static name2 = "Creeper"
	drop = [blockIds.gunpowder]
	dropAmount = [0,2]
	experience = 5
	hurtSound = ["creeper.say1","creeper.say2","creeper.say3","creeper.say4"]
	deathSound = "creeper.death"
	defaultName = "Creeper"
	constructor(x,y,z){
		super(x, y, z, 0, 0, 0, 0, 0, 0.5, 26/16, 0.5, null,null, null, 300000)
		var pix = 1/16
		this.offsetY = pix*-1
		this.addPart("frontRightLeg",null,null,pix*-2,pix*-6,pix*4,1,1,1,0,0)
		this.addPart("frontLeftLeg",null,null,pix*2,pix*-6,pix*4,1,1,1,0,0)
		this.addPart("backRightLeg",null,null,pix*-2,pix*-6,pix*-4,1,1,1,0,0)
		this.addPart("backLeftLeg",null,null,pix*2,pix*-6,pix*-4,1,1,1,0,0)
		this.addPart("head",null,null,0,pix*10,0,1,1,1,0,0)
		
		this.health = 10
		this.hostile = true
		this.minFollowDist = 3
		this.maxFollowDist = this.detectionDist = 16
		this.timerStart = 0
		this.explodeAmount = 0
		this.timeLimit = 30
	}
	explode(){
		var x = round(this.x), y = round(this.y), z = round(this.z)
		this.world.explode(x,y,z,3, this.liquid || !this.world.world.settings.tntExplode, this.dimension)
	}
	update(){
		this.mobUpdate(now)

		let d = this.targetEnt && max(abs(this.targetEnt.x-this.x),abs(this.targetEnt.y-this.y),abs(this.targetEnt.z-this.z))
		if(this.targetEnt && d<=this.minFollowDist){
			if(!this.explodeAmount){
				this.timerStart = now
				this.world.playSound(this.x,this.y,this.z, "random.fuse")
			}
			this.explodeAmount++
			if(this.explodeAmount > 20) this.explodeAmount = 20
		}else if(this.explodeAmount) this.explodeAmount--
		this.shader = 0, this.extraSize = 0
		if(this.explodeAmount>0){
			var i = Math.floor((now - this.timerStart) / 125)
			if(!(i%2)){
				this.shader = 1
			}
			if((now - this.timerStart) / tickTime >= this.timeLimit - 10){
				//get bigger
				this.extraSize = min(-((this.timeLimit - 10) - ((now - this.timerStart) / tickTime)) / 40,0.25)
				this.shader = 1
			}
			if((now - this.timerStart) / tickTime >= this.timeLimit){
				this.canDespawn = true
				this.explode()
			}
		}
	}
	onclick(block){
		if(!block || block.id !== blockIds.flintAndSteel) return
		this.explodeAmount = 100
		this.timerStart = now
		this.world.sendEntityPos(this)
		//this.world.sendAllInChunk({type:"entEvent",event:"creeperForceExplode",id:this.id},this.chunkX,this.chunkZ,this.chunkDimension)
	}
}
entities[entities.length] = class Sheep extends Mob{
	static name2 = "Sheep"
	drop = [blockIds.rawMutton]
	dropAmount = [1,2]
	saySound = ["sheep.say1","sheep.say2","sheep.say3"]
	hurtSound = ["sheep.say1","sheep.say2","sheep.say3"]
	stepSound = ["sheep.step1","sheep.step2","sheep.step3","sheep.step4","sheep.step5"]
	defaultName = "Sheep"
	constructor(x,y,z, color, wool){
		super(x, y, z, 0, 0, 0, 0, 0, 1, 1, 1, null,null, 0, 300000, "vao")
		var pix = 1/16
		this.offsetY = pix*7
		this.addPart("frontRightLeg",null,null,pix*-3,pix*-3,pix*5,1,1,1,0,0)
		this.addPart("frontLeftLeg",null,null,pix*3,pix*-3,pix*5,1,1,1,0,0)
		this.addPart("backRightLeg",null,null,pix*-3,pix*-3,pix*-7,1,1,1,0,0)
		this.addPart("backLeftLeg",null,null,pix*3,pix*-3,pix*-7,1,1,1,0,0)
		this.addPart("head",null,null,0,pix*4,pix*10,1,1,1,0,0)
		this.health = 10
		this.fur = true
		this.eating = 0
		this.color = color
		this.wool = wool
		if(!color){
			let r = rand(100), dye
			if(r > 50) dye = "white"
			else if(r > 35) dye = "lightGray"
			else if(r > 20) dye = "gray"
			else if(r > 5) dye = "black"
			else if(r > 1) dye = "brown"
			else dye = "pink"
			this.color = colors.dye[dye].slice()
			this.wool = dye+"Wool"
		}
		this.attracts = [blockIds.wheat]
	}
	ondie(){
		this.world.addItems(this.x,this.y,this.z,0,0,0,blockIds[this.wool],true,round(rand(1,2)))
	}
	onclick(holding){
		let data = blockData[holding ? holding.id : 0]
		if(data.dye){
			this.color = colors.dye[data.dye].slice()
			this.wool = data.dye+"Wool"
			//if(multiplayer) send({type:"entEvent",event:"sheepColor",data:{color:this.color,wool:this.wool},id:this.id})
			this.world.sendEntityPos(this)
		}else if(data.shears){
			if(!this.fur) return
			this.fur = false
			this.world.addItems(this.x,this.y,this.z,0,0,0,blockIds[this.wool],true,round(rand(1,3)))
			//this.world.sendAllInChunk({type:"entEvent",event:"sheepFur",data:false,id:this.id},this.chunkX,this.chunkZ,this.chunkDimension)
			this.world.sendEntityPos(this)
			this.world.playSound(this.x,this.y,this.z, "sheep.shear")
		}
	}
	additionalAI(now){
		if(!this.eating && this.standingOn === blockIds.grass && rand() > 0.999){
			this.eating = 1
			//this.world.sendAllInChunk({type:"entEvent",event:"sheepEat",id:this.id},this.chunkX,this.chunkZ,this.chunkDimension)
			this.world.sendEntityPos(this)
		}
		if(this.eating && this.standingOn !== blockIds.grass) this.eating = 0
		if(this.eating && ++this.eating > 40){
			this.eating = 0
			this.world.setBlock(round(this.x),floor(this.y-this.height/2),round(this.z),blockIds.dirt,false,false,false,false,this.dimension)
			this.fur = true
			//this.world.sendAllInChunk({type:"entEvent",event:"sheepFur",data:true,id:this.id},this.chunkX,this.chunkZ,this.chunkDimension)
			this.world.sendEntityPos(this)
			this.world.blockParticles(this.standingOn,round(this.x),floor(this.y-this.height/2)+0.5,round(this.z),30, "break")
		}
	}
	update(){
		this.mobUpdate(now)
	}
}
entities[entities.length] = class Chicken extends Mob{
	static name2 = "Chicken"
	drop = [blockIds.rawChicken,blockIds.feather]
	saySound = ["chicken.say1","chicken.say2","chicken.say3"]
	stepSound = ["chicken.step1","chicken.step2"]
	hurtSound = ["chicken.hurt1","chicken.hurt2"]
	defaultName = "Chicken"
	constructor(x,y,z){
		var pix = 1/16
		super(x, y, z, 0, 0, 0, 0, 0, 0.5, pix*11, 0.5, null,null, null, 300000)
		this.offsetY = pix*2.5
		this.addPart("leftWing",null,null,pix*3.5,pix*3,0,1,1,1,0,0)
		this.addPart("rightWing",null,null,pix*-3.5,pix*3,0,1,1,1,0,0)
		this.addPart("rightLeg",null,null,pix*-1.5,pix*-3,0,1,1,1,0,0)
		this.addPart("leftLeg",null,null,pix*1.5,pix*-3,0,1,1,1,0,0)
		this.addPart("head",null,null,0,pix*4,pix*4.5,1,1,1,0,0)
		
		this.health = 4
		this.attracts = [blockIds.beetrootSeeds, blockIds.tomatoSeeds, blockIds.pumpkinSeeds, blockIds.melonSeeds, blockIds.wheatSeeds]
	}
	additionalAI(){
		if(rand() > 0.9998){
			this.world.addItems(this.x,this.y,this.z,0,0,0,blockIds.egg,true)
			this.world.playSound(this.x,this.y,this.z, "chicken.plop")
		}
	}
	update(){
		this.mobUpdate(now)

		if(this.vely < 0){
			this.vely *= 0.5
			this.lastY = this.y
		}
	}
}
entities[entities.length] = class Zombie extends Mob{
	static name2 = "Zombie"
	drop = [blockIds.rottenFlesh]
	dropAmount = [0,3]
	experience = 5
	saySound = ["zombie.say1","zombie.say2","zombie.say3"]
	stepSound = ["zombie.step1","zombie.step2","zombie.step3","zombie.step4","zombie.step5"]
	hurtSound = ["zombie.hurt1","zombie.hurt2"]
	deathSound = "zombie.death"
	defaultName = "Zombie"
	constructor(x,y,z){
		super(x, y, z, 0, 0, 0, 0, 0, 1, 2, 1, null,null, null, 300000)
		var pix = 1/16
		this.offsetY = pix*2
		this.addPart("rightLeg",null,null,pix*-2,pix*-6,0,1,1,1,0,0)
		this.addPart("leftLeg",null,null,pix*2,pix*-6,0,1,1,1,0,0)
		this.addPart("rightArm",null,null,pix*-6,pix*6,pix*0,1,1,1,0,0)
		this.addPart("leftArm",null,null,pix*6,pix*6,pix*0,1,1,1,0,0)
		this.addPart("head",null,null,0,pix*10,0,1,1,1,0,0)
		
		this.health = 20
		this.hostile = true
		this.minFollowDist = 1
		this.maxFollowDist = 35
		this.detectionDist = 17.5
		this.attackStrength = 3
		this.maxAttackCooldown = 20
	}
	killMessage(username){return username+" died from some small punches from a Zombie."}
	update(){
		this.mobUpdate(now)
		if(!this.liquid && this.world.getLight(round(this.x), round(this.y), round(this.z), 0)*this.world.world.skyLight > 11){
			this.burnTimer += 0.2
		}
	}
}
entities[entities.length] = class Skeleton extends Mob{
	static name2 = "Skeleton"
	drop = [blockIds.bone,blockIds.arrow]
	dropAmount = [1,2]
	experience = 5
	saySound = ["skeleton.say1","skeleton.say2","skeleton.say3"]
	stepSound = ["skeleton.step1","skeleton.step2","skeleton.step3","skeleton.step4"]
	hurtSound = ["skeleton.hurt1","skeleton.hurt2","skeleton.hurt3","skeleton.hurt4"]
	deathSound = "skeleton.death"
	defaultName = "Skeleton"
	constructor(x,y,z){
		super(x, y, z, 0, 0, 0, 0, 0, 0.75, 2, 0.75, null,null, null, 300000)
		var pix = 1/16
		this.offsetY = pix*2
		this.addPart("rightLeg",null,null,pix*-2,pix*-6,0,1,1,1,0,0)
		this.addPart("leftLeg",null,null,pix*2,pix*-6,0,1,1,1,0,0)
		this.addPart("rightArm",null,null,pix*-5,pix*6,pix*0,1,1,1,0,0)
		this.addPart("leftArm",null,null,pix*5,pix*6,pix*0,1,1,1,0,0)
		this.addPart("head",null,null,0,pix*10,0,1,1,1,0,0)
		this.addPart("holding",null,null,0,0,0,1,1,1,0,0,undefined,"rightArm") //changed later
		
		this.health = 20
		this.hostile = true
		this.minFollowDist = 8
		this.maxFollowDist = this.detectionDist = 16
		this.holding = blockIds.bow, this.maxAttackCooldown = 20
	}
	additionalAI(){
		if(blockData[this.holding].name === "bow" && this.targetEnt && this.attackCooldown <= 0){
			let vx = this.targetEnt.x - this.x, vy = this.targetEnt.y - this.y, vz = this.targetEnt.z - this.z
			let mag = sqrt(vx*vx+vy*vy+vz*vz)
			vx /= mag, vy /= mag, vz /= mag
			this.world.addEntity(new entities[entityIds.Arrow](this.x+vx,this.y+vy,this.z+vz,vx,vy,vz,this.id),false,this.dimension)
			this.attackCooldown = this.maxAttackCooldown
			this.world.sendEntityPos(this)
			//this.world.sendAllInChunk({type:"entEvent",event:"mobAttack",id:this.id},this.chunkX,this.chunkZ,this.chunkDimension)
		}
	}
	update(){
		this.mobUpdate(now)
		if(!this.liquid && this.world.getLight(round(this.x), round(this.y), round(this.z), 0)*this.world.world.skyLight > 11){
			this.burnTimer += 0.2
		}
	}
}
entities[entities.length] = class Spider extends Mob{
	static name2 = "Spider"
	saySound = ["spider.say1","spider.say2","spider.say3","spider.say4"]
	stepSound = ["spider.step1","spider.step2","spider.step3","spider.step4"]
	deathSound = "spider.death"
	drop = [blockIds.string,blockIds.spiderEye]
	dropAmount = [0,2]
	experience = 5
	constructor(x,y,z,cave){
		let s = cave ? 0.7 : 1
		super(x, y, z, 0, 0, 0, 0, 0, s, s, s, null,null, null, 300000)
		var pix = 1/16
		this.offsetY = pix*2
		let legRot = Math.PI/8
		this.addPart("rightLeg0",null,null,pix*-3,0,0,1,1,1,0,0,legRot)
		this.addPart("rightLeg1",null,null,pix*-3,0,0,1,1,1,0,0,legRot)
		this.addPart("rightLeg2",null,null,pix*-3,0,0,1,1,1,0,0,legRot)
		this.addPart("rightLeg3",null,null,pix*-3,0,0,1,1,1,0,0,legRot)
		this.addPart("leftLeg0",null,null,pix*3,0,0,1,1,1,0,0,-legRot)
		this.addPart("leftLeg1",null,null,pix*3,0,0,1,1,1,0,0,-legRot)
		this.addPart("leftLeg2",null,null,pix*3,0,0,1,1,1,0,0,-legRot)
		this.addPart("leftLeg3",null,null,pix*3,0,0,1,1,1,0,0,-legRot)
		this.addPart("head",null,null,0,0,pix*7,1,1,1,0,0)
		
		this.fur = !!cave
		this.defaultName = cave ? "Cave Spider" : "Spider"
		this.health = 16
		this.canClimb = true
		this.hostile = true
		this.minFollowDist = 1.5
		this.maxFollowDist = 16
		this.detectionDist = -1
		this.attackStrength = 2
		this.maxAttackCooldown = 20
	}
	killMessage(username){return username+" died from a tiny little spider."}
	update(){
		this.mobUpdate(now)

		if(this.prevWalking !== this.walking){
			this.prevWalking = this.walking
			this.walkStart = now
		}
	}
}
entities[entities.length] = class Wolf extends Mob{
	static name2 = "Wolf"
	defaultName = "Wolf"
	constructor(x,y,z){
		super(x, y, z, 0, 0, 0, 0, 0, 0.6, 0.8, 0.6, null,null, null, Infinity, "vao")
		var pix = 1/16
		this.addPart("head",null,null,0,0,pix*10,1,1,1,0,0)
		this.addPart("frontRightLeg",null,null,pix*-1.5,pix*-3,pix*5,1,1,1,0,0)
		this.addPart("frontLeftLeg",null,null,pix*1.5,pix*-3,pix*5,1,1,1,0,0)
		this.addPart("backRightLeg",null,null,pix*-1.5,pix*-3,pix*-6,1,1,1,0,0)
		this.addPart("backLeftLeg",null,null,pix*1.5,pix*-3,pix*-6,1,1,1,0,0)
		this.addPart("tail",null,null,0,0,pix*-8,1,1,1,Math.PI2,0)
		this.addPart("collar",null,null,0,0,pix*6.1,1,1,1,0,0)
		
		this.health = 8
		this.hostile = true
		this.minFollowDist = 1.5
		this.maxFollowDist = 16
		this.detectionDist = 16
		this.attackStrength = 4
		this.maxAttackCooldown = 20
		this.attacks = ["Sheep","Rabbit","Fox","Skeleton"]
		this.attracts = [blockIds.bone]
		this.wetStuff = 0
		this.tame = false
		this.color = colors.dye.red.slice()
	}
	feed(id,from){
		if(id === blockIds.bone){
			if(this.tame){
				let prev = this.health
				this.health++
				if(this.health > 20) this.health = 20
				this.world.sendEntityPos(this)
			}else{
				if(rand(3) > 1){
					this.world.sendAllInChunk({
						type:"particles",particleType:"smokeCube",
						x:this.x,y:this.y,z:this.z,dimension:this.dimension,amount:10
					},this.chunkX,this.chunkZ,this.chunkDimension)
				}else{
					this.world.sendAllInChunk({
						type:"particles",particleType:"hearts",
						x:this.x,y:this.y,z:this.z,dimension:this.dimension,amount:10
					},this.chunkX,this.chunkZ,this.chunkDimension)
					this.world.addEntity(new entities[entityIds.ExperienceOrb](this.x,this.y,this.z, rand(1,7)),false,this.dimension)
					this.tame = true
					this.health *= 20/8
					let owner = getPlayerById(from,this.world)
					this.owner = owner.username
					this.world.sendEntityPos(this)
				}
			}
		}
	}
	onclick(holding,p){
		let data = blockData[holding ? holding.id : 0]
		if(data.dye){
			this.color = colors.dye[data.dye].slice()
			//if(multiplayer) send({type:"entEvent",event:"wolfCollarColor",data:this.color,id:this.id})
			//this.updateShape()
			this.world.sendEntityPos(this)
		}else if(holding && holding.id === blockIds.bone){
			holding.amount--
			this.feed(holding.id,p.id)
		}else if(this.tame){
			this.sitting = !this.sitting
			this.world.sendEntityPos(this)
			//if(multiplayer) send({type:"entEvent",event:"sit",id:this.id, data:this.sitting})
		}
	}
	killMessage(username){return username+" got bited by a wolf."}
	additionalAI(){
		let owner = this.owner && getPlayerByUsername(this.owner,this.world)
		if(!owner || owner.die || owner.hidden) return
		let d = max(abs(this.x-owner.x),abs(this.y-owner.y),abs(this.z-owner.z))
		if(d > 16 && !this.sitting){
			this.target = null
			let x = round(this.x), y = round(this.y), z = round(this.z)
			let closest = Infinity, cx, cy, cz
			for(let x2=-5;x2<5;x2++) for(let z2=-5;z2<5;z2++) for(let y2=-5;y2<5;y2++){
				if(!blockData[this.world.getBlock(owner.x+x2,owner.y+y2,owner.z+z2)].solid){
					let dist = max(abs(x2),abs(y2),abs(z2))
					if(dist < closest && blockData[this.world.getBlock(owner.x+x2,owner.y+y2-1,owner.z+z2)].solid) closest = dist, cx = x2, cy = y2, cz = z2
				}
			}
			if(isFinite(closest)){
				this.x = owner.x+cx
				this.y = owner.y+cy
				this.z = owner.z+cz
				this.path = null
				this.lastY = this.y
				//this.world.sendAll({type:"entEvent",event:"tp",id:this.id, data:{x:this.x,y:this.y,z:this.z}})
				this.world.sendEntityPos(this)
			}
		}else if(d > 8 && !this.sitting){
			if(now-this.lastPathFind>1000){
				this.lastPathFind = now
				let path = this.findPath(round(this.x),round(this.y-this.height/2),round(this.z),round(owner.x),round(owner.y),round(owner.z))
				if(path){
					path.splice(0,3)
					this.path = path
				}
			}
		}
		if(owner && !owner.die && !owner.hidden){
			if(owner.attackedById && this.target !== owner.attackedById){
				this.target = owner.attackedById
				this.world.sendEntityPos(this)
				//send({type:"entEvent",event:"wolfTarget",id:this.id, data:this.target})
			}
		}
	}
	update(){
		this.mobUpdate(now)
		let pix = 1 / 16
		if(!this.target && !this.tame){
			this.world.getEntitiesNear(this.x,this.y,this.z, 16, nearEntityArray)
			let cd = Infinity, ctarget
			for(let i of nearEntityArray){
				if(i.dimension === this.dimension && i.type === this.type && i.target){
					let d = max(abs(i.x-this.x),abs(i.y-this.y),abs(i.z-this.z))
					if(d < 16 && d < cd) cd = d, ctarget = i.target
				}
			}
			if(ctarget) this.target = ctarget
		}
	}
}
entities[entities.length] = class Blaze extends Mob{
	static name2 = "Blaze"
	drop = [blockIds.blazeRod]
	dropAmount = [0,1]
	experience = 10
	saySound = ["blaze.breathe1","blaze.breathe2","blaze.breathe3","blaze.breathe4"]
	hurtSound = ["blaze.hit1","blaze.hit2","blaze.hit3","blaze.hit4"]
	deathSound = "blaze.death"
	defaultName = "Blaze"
	constructor(x,y,z){
		var pix = 1/16
		super(x, y, z, 0, 0, 0, 0, 0, 1, pix*22, 1, null,null, null, 300000)
		this.addPart("head",null,null,0,pix*10,0,1,1,1,0,0)
		
		this.health = 20
		this.hostile = true
		this.minFollowDist = 1
		this.maxFollowDist = 48
		this.detectionDist = 48
		this.attackStrength = 6
		this.maxAttackCooldown = 200
		this.canFly = true
	}
	killMessage(username){return username+" got killed by blaze."}
	additionalAI(){
		if(this.targetEnt){
			if(this.attackCooldown <= 0){
				this.attackCooldown = this.maxAttackCooldown
				//this.world.sendAll({type:"entEvent",event:"mobAttack",id:this.id})
				this.world.sendEntityPos(this)
			}
			if(this.attackCooldown === 20 || this.attackCooldown === 11 || this.attackCooldown === 2){
				let vx = this.targetEnt.x - this.x, vy = this.targetEnt.y - this.y, vz = this.targetEnt.z - this.z
				let mag = sqrt(vx*vx+vy*vy+vz*vz)
				vx /= mag, vy /= mag, vz /= mag
				this.world.addEntity(new entities[entityIds.SmallFireball](this.x+vx,this.y+vy,this.z+vz,vx,vy,vz,this.id),false,this.dimension)
			}
		}
	}
	update(){
		this.mobUpdate(now)
		if(this.burnTimer) this.burnTimer = 0

		if(this.targetEnt && this.attackCooldown > 0 && this.attackCooldown < 100) this.burning = true
	}
}
entities[entities.length] = class Enderman extends Mob{
	static name2 = "Enderman"
	defaultName = "Enderman"
	constructor(x,y,z){
		super(x, y, z, 0, 0, 0, 0, 0, 0.75, 3, 0.75, null,null, null, 300000)
		let pix = 1/16
		this.offsetY = pix*13
		this.addPart("rightLeg",null,null,pix*-2,pix*-6,0,1,1,1,0,0)
		this.addPart("leftLeg",null,null,pix*2,pix*-6,0,1,1,1,0,0)
		this.addPart("rightArm",null,null,pix*-4,pix*6,pix*0,1,1,1,0,0)
		this.addPart("leftArm",null,null,pix*4,pix*6,pix*0,1,1,1,0,0)
		this.addPart("head",null,null,0,pix*10,0,1,1,1,0,0)
		
		this.health = 40
		this.hostile = true
		this.minFollowDist = 1
		this.maxFollowDist = 16
		this.detectionDist = 16
		this.attackStrength = 7
		this.maxAttackCooldown = 20
	}
	killMessage(username){return username+" died from Enderman."}
	update(){
		this.mobUpdate(now)
		if(this.wet){
			if(now - this.lastBlockDamage > 1000){
				this.lastBlockDamage = now
				this.damage(1)
			}
		}
	}
}

let entityOrder = ['Item','BlockEntity', 'PrimedTNT', 'PrimedSuperTNT', 'PrimedUltraTNT', 'PrimedUnTNT', 'MovingBlock', 'EnderPearl', 'Snowball', 'Egg', 'SlingshotShot', 'Arrow', 'Sign', 'ItemFrame', 'ExperienceOrb', 'Cow', 'Pig', 'Creeper', 'Sheep', 'Chicken', 'Zombie', 'Skeleton', 'Spider', 'EnderDragon', 'BlockParticle', 'PoofParticle', 'FallingDustParticle', 'RedstoneParticle', 'ShockwaveParticle', 'SmokeParticle', 'NoteParticle', 'GlintParticle', 'FlameParticle', 'LavaParticle', 'DripParticle', 'SplashParticle', 'Spark', 'TextDisplay','Wolf','HeartParticle',"Blaze","SmallFireball","BlockDisplay","BeaconBeam","Enderman","Minecart"]
let unorderedEntities = entities.slice()
for(let i=0; i<entities.length; i++){
	entityIds[entities[i].name2] = i
}
for(let i=0; i<entityOrder.length; i++){
	if(entityIds[entityOrder[i]] === undefined){
		delete entities[i]
		delete entityIds[entityOrder[i]]
		continue
	}
	entities[i] = unorderedEntities[entityIds[entityOrder[i]]]
	entities[i].prototype.entId = i
	entities[i].prototype.type = entities[i].name2
	entityIds[entities[i].name2] = i
}
win.serverEntities = entities, win.serverEntityIds = entityIds
console.log(entities.length,'entities and particles on server side')

//islandgenerator from https://www.khanacademy.org/computer-programming/minekhan-island-world-type/5771215095939072
class IslandGenerator {
	constructor(world) {
		this.world = world
		this.seedSet = false;
		this.seed = 0;
		this.reset()
	}
	reset(){
		this.size = 600;
		this.diagonalNeighbors = true; //true if the corners are also adjacent
		
		this.grid = [];
		this.vertex = [];
		this.river = [];
		this.precip = [];
		this.biome = [];
		this.biomeBlend = [];
		
		this.highestPoint = [0,0];
		
		this.updates = [];
		this.stage = 0;
		this.changes = 0;
		this.rivers = 0;
		this.h = 0;
		this.X = 0;
	}
	GetVertex(x, y) {
			if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 0;}
			return this.vertex[x+y*this.size];
	}
	GetHeight(x, y) {
			x = (x+this.size/2)*0.5; y = (y+this.size/2)*0.5;
			if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 5;}
			return Math.round(
			(this.GetVertex(Math.floor(x), Math.floor(y))+
			this.GetVertex(Math.floor(x+0.5), Math.floor(y))+
			this.GetVertex(Math.floor(x), Math.floor(y+0.5))+
			this.GetVertex(Math.floor(x+0.5), Math.floor(y+0.5)))*0.5+5);
	};
	GetWater(x, y) {
			if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 1;}
			if (this.GetBiome(x,y) === -15099421 || this.GetBiome(x,y) === -16479791) {return 1}
			return Math.sqrt(this.river[x+y*this.size]);
	}
	GetWaterDepth(x, y) {
			x = (x+this.size/2)*0.5; y = (y+this.size/2)*0.5;
			if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 1;}
			var w = 0;
			for (let x2 = 0; x2 < 1; x2+=0.5) {
					for (let y2 = 0; y2 < 1; y2+=0.5) {
							w += this.GetWater(Math.floor(x+x2),Math.floor(y+y2));
					}
			}
			w = w/4.0;
			if (w > 0.25) {
					return 1;
			}   else {
					return 0;
			}
	}
	GetBiome(x, y) {
			if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return -16479791;}
			return this.biome[x+y*this.size];
	}
	GetBiomeType(x, y) {
			x = (x+this.size/2)*0.5; y = (y+this.size/2)*0.5;
			if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 1;}
			return this.GetBiome(Math.floor(x),Math.floor(y));
	}
	GetNeighbors(x, y) {
			var n = [];
			if (x > 0) {
					n.push({x:x-1, y:y});
					if (this.diagonalNeighbors) {
					if (y > 0) {
							n.push({x:x-1, y:y-1});
					}
					if (y < this.size-1) {
							n.push({x:x-1, y:y+1});
					}}
			}
			if (x < this.size-1) {
					n.push({x:x+1, y:y});
					if (this.diagonalNeighbors) {
					if (y > 0) {
							n.push({x:x+1, y:y-1});
					}
					if (y < this.size-1) {
							n.push({x:x+1, y:y+1});
					}
					}
			}
			if (y > 0) {
					n.push({x:x, y:y-1});
			}
			if (y < this.size-1) {
					n.push({x:x, y:y+1});
			}
			return n;
	}
	GetDown(x, y) {
			var n = this.GetNeighbors(x, y);
			var l = this.size;
			var ld = [];
			for (var i in n) {
					if (this.vertex[n[i].x + n[i].y*this.size] <= l) {
							if (this.vertex[n[i].x + n[i].y*this.size] === l) {
									ld.push(n[i]);
							}
							l = this.vertex[n[i].x + n[i].y*this.size];
							ld = [n[i]];
					}
			}
			if (l <= this.vertex[x + y*this.size]) {
					return ld[Math.floor(this.random(ld.length))];
			}
			return undefined;
	}
	SetSeed(seed) {
			if(this.seed !== seed) this.reset()
			this.seed = seed;
			this.seedSet = true;
			this.randomGenerator = new Marsaglia(hash(seed, 2123155232) * 210000000)
			this.random = (max = 1) => this.randomGenerator.nextDouble()*max
	}
	Generate(start) {
		var end = start+16;
		var nS = 0.021;
		function sq(n) {return n*n}
		function color(r, g, b, a) {
				a = (a === undefined ? 255 : a);
				g = (g === undefined ? r : g);
				b = (b === undefined ? g : b);
				if (a > 127) {a = -256+a;}
				return b+g*256+r*65536+a*16777216;
		}
		if (this.stage === 0) { //landmass
				while (this.X < this.size && win.performance.now() < end) {
						var x = this.X;
						for (var y = 0; y < this.size; y++) {
								this.grid[x +y*this.size] = 0;
								this.vertex[x + y*this.size] = -1;
								this.precip[x + y*this.size] = -1;
								this.river[x + y*this.size] = 0;
								var d = this.size/2-Math.sqrt(sq(x-this.size/2)+sq(y-this.size/2));
								var islandMask = Math.sqrt(sq(this.size/2)-sq(d-this.size/2))*2/this.size;
								var v = this.world.noiseProfile.noise(x*nS, y*nS, this.seed);
								if (v*islandMask > 0.3) {
										this.grid[x+y*this.size] = 1;
								}
						}
						this.X++;
				}
				if (this.X === this.size) {
						this.updates.push({type:"ocean", x:0, y:0});
				}
		}   else if (this.stage === 1) {    //Oceans
				while (this.updates.length > 0 && win.performance.now() < end) {
						var u = this.updates.shift();
						if (this.grid[u.x+u.y*this.size] === 0) {
								this.grid[u.x+u.y*this.size] = 2;
								var n = this.GetNeighbors(u.x, u.y);
								for (var i = 0; i < n.length; i++) {
										if (this.grid[n[i].x+n[i].y*this.size] === 0) {
												this.updates.push({type:"ocean",x:n[i].x,y:n[i].y});
										}
								}
						}
				}
				if (this.updates.length === 0) {
						this.X = this.size;
				}
		}   else if (this.stage === 2) {    //altitude
				if (this.h === -1) {this.h = 0;}
				var doingLake = false;
				var I = 0;
				while (win.performance.now() < end && this.updates.length > 0 && I < this.updates.length) {
						if (this.updates[I].type === "lake") {
								var u = this.updates.splice(I, 1)[0];
								if (this.grid[u.x + u.y*this.size] === 0 && this.vertex[u.x+u.y*this.size] === -1) {
										this.vertex[u.x + u.y*this.size] = u.a;
										var n = this.GetNeighbors(u.x, u.y);
										for (var i in n) {
												if (this.grid[n[i].x+n[i].y*this.size] === 0 && this.vertex[n[i].x + n[i].y*this.size] === -1) {
														this.updates.push({type:"lake",x:n[i].x,y:n[i].y,a:u.a});
												}
										}
								}
								I--;
						}
						I++;
				}
				while (this.X < this.size && win.performance.now() < end && !doingLake) {
						var x = this.X;
						for (var y = 0; y < this.size; y++) {
								if (this.vertex[x+y*this.size] === -1) {
										if (this.grid[x+y*this.size] === 2) {
												this.vertex[x+y*this.size] = this.h;
												this.changes++;
										}   else if (this.h > 0) {
												var n = this.GetNeighbors(x, y);
												var l = this.size;
												var ld;
												for (var i in n) {
														var v = this.vertex[n[i].x + n[i].y*this.size];
														if (v < l && v !== -1) {
																l = v;
																ld = n[i];
														}
												}
												if (l !== this.size && l <= this.h) {
														if (this.grid[x+y*this.size] === 0) {
																this.updates.push({type:"river",x:ld.x,y:ld.y});
																this.updates.push({type:"lake",x:x,y:y,a:l});
														}   else {
																this.vertex[x+y*this.size] = l+1+(this.random() > 0.5 ? 1 : 0);
														}
														this.changes++;
												}
										}
								}
						}
						this.X++;
				}
				if (this.X === this.size && this.h < this.size/3) {
						if (this.changes === 0) {
								this.h++;
						}
						this.X = 0;
						this.changes = 0;
				}
		}   else if (this.stage === 3) {    //altitude readjustment
				
				while (this.X < this.size && win.performance.now() < end) {
						var x = this.X;
						for (var y = 0; y < this.size; y++) {
								this.vertex[x+y*this.size] = (Math.pow(20, this.vertex[x+y*this.size]/this.size*3)-1)/(20-1)*this.size/3;
								if (this.vertex[x+y*this.size] > this.vertex[this.highestPoint[0]+this.highestPoint[1]*this.size]) {
										this.highestPoint[0] = x;
										this.highestPoint[1] = y;
								}
						}
						this.X++;
				}
				
		}   else if (this.stage === 4) {    //rivers
				if (this.rivers === 0) {
						var x, y;
						for (var i = 0; i < 200 && this.rivers < 100; i++) {
								x = Math.floor(this.random(this.size));
								y = Math.floor(this.random(this.size));
								if (this.grid[x+y*this.size] === 1) {
										this.updates.push({type:"river",x:x,y:y});
										this.rivers++;
								}
						}
				}   else {
						if (this.updates.length === 0) {
								this.X = this.size;
						}
				}
				while(this.updates.length > 0 && win.performance.now() < end) {
						var u = this.updates[0];
						if (this.grid[u.x+u.y*this.size] === 1) {
								this.river[u.x+u.y*this.size]++;
								var d = this.GetDown(u.x, u.y);
								if (d === undefined) {
										this.updates.shift();
								}   else {
										this.updates[0].x = d.x; this.updates[0].y = d.y;
								}
						}   else {
								this.updates.shift();
						}
				}
		}   else if (this.stage === 5) {    //precipitation
				while (this.X < this.size && win.performance.now() < end) {
						var x = this.X;
						for (var y = 0; y < this.size; y++) {
								if (this.precip[x + y*this.size] === -1) {
										if (this.h === -1) {
												if (this.grid[x + y*this.size] === 2) {
														this.precip[x + y*this.size] = 5;
														this.changes++;
												}
										}   else {
												if (this.h <= 8) {
														if (this.grid[x + y*this.size] === 0 || this.river[x+y*this.size] > 0) {
																this.precip[x + y*this.size] = 8;
																this.changes++;
														}
												}
												var n = this.GetNeighbors(x, y);
												var h = -1;
												for (var i in n) {
														if (this.precip[n[i].x + n[i].y*this.size] > h) {
																h = this.precip[n[i].x + n[i].y*this.size];
														}
												}
												if (h > -1 && h >= this.h) {
														this.precip[x+y*this.size] = Math.max(h - (this.random() < 0.5 ? 0.66 : 0.33), 0);
														this.changes++;
												}
										}
								}
						}
						this.X++;
				}
				if (this.X === this.size) {
						this.X = 0;
						if (this.h === -1) {
								this.h = 10;
						}   else {
								if (this.changes === 0) {
										this.h--;
								}
								this.changes = 0;
								if (this.h < 0) {
										this.X = this.size;
								}
						}
				}
		}   else if (this.stage === 6) {    //readjust precipitation
				while (this.X < this.size && win.performance.now() < end) {
						var x = this.X;
						for (var y = 0; y < this.size; y++) {
								this.precip[x+y*this.size] = Math.floor(this.precip[x+y*this.size]/10*6);
						}
						this.X++;
				}
		}   else if (this.stage === 7) {    //temperature
				while (this.X < this.size && win.performance.now() < end) {
						var x = this.X;
						for (var y = 0; y < this.size; y++) {
						}
						this.X++;
				}
		}   else if (this.stage === 8) {    //biomes
				while (this.X < this.size && win.performance.now() < end) {
						var x = this.X;
						for (var y = 0; y < this.size; y++) {
								var c;
								var h = Math.floor(this.vertex[x+y*this.size]/this.size*6*5);
								switch (this.grid[x+y*this.size]) {
										case 0: if (h > 2) {
														c = color(157, 194, 201);
												}   else {
														c = color(25, 153, 227);
												}   break;
										case 1: if (this.river[x+y*this.size] > 0) {
																if (h > 2) {
																c = color(157, 194, 201);
														}   else {
																c = color(25, 153, 227);
														}
												}   else {
														switch (h) {
																case 0: switch (this.precip[x+y*this.size]) {
																		case 5: case 4: c = color(10, 133, 72); break;
																		case 3: case 2: c = color(10, 133, 23); break;
																		case 1: c = color(179, 232, 35); break;
																		case 0: c = color(209, 166, 58); break;
																} break;
																case 1: switch (this.precip[x+y*this.size]) {
																		case 5: c = color(14, 156, 85); break;
																		case 4: case 3: c = color(72, 133, 10); break;
																		case 2: case 1: c = color(179, 232, 35); break;
																		case 0: c = color(207, 195, 58); break;
																} break;
																case 2: switch (this.precip[x+y*this.size]) {
																		case 5: case 4: c = color(121, 191, 95); break;
																		case 3: case 2: c = color(155, 161, 135); break;
																		case 1: case 0: c = color(207, 195, 58); break;
																} break;
																case 3: case 4: switch (this.precip[x+y*this.size]) {
																		case 5: case 4: case 3: c = color(255); break;
																		case 2: c = color(149, 189, 94); break;
																		case 1: c = color(180); break;
																		case 0: c = color(128);
																} break;
														}
												}
												break;
										case 2: c = color(4, 137, 209); break;
								}
								this.biome[x+y*this.size] = c;
						}
						this.X++;
				}
		}   else if (this.stage === 9) {    //add lava
				let ph = this.vertex[this.highestPoint[0] + this.highestPoint[1]*this.size]-5;
				while (this.X < this.size && win.performance.now() < end) {
						var x = this.X;
						for (var y = 0; y < this.size; y++) {
								if (this.vertex[x + y*this.size] > ph) {
										this.vertex[x + y*this.size] = ph-2;
										this.biome[x + y*this.size] = -65536;
								}
						}
						this.X++;
				}
		}
		if (this.X === this.size) {
				this.X = 0;
				this.h = -1;
				this.stage++;
				console.log(this.stage)
		}
	}
}

class Section {
	constructor(x, y, z, chunk, blocks = undefined) {
		this.x = x
		this.y = y
		this.z = z
		this.blocks = blocks || new Int32Array(4096)
		this.blockLight = new Uint8Array(4096)
		this.skyLight = new Uint8Array(4096)
		this.tags = new Array(4096)
		this.chunk = chunk
		this.world = chunk && chunk.world
		this.type = chunk && chunk.type
		this.edited = false
		this.caves = this.type !== "" || !this.world.world.caves
	}
	getBlock(x, y, z) {
		return this.blocks[x * 256 + y * 16 + z]
	}
	setBlock(x, y, z, blockId) {
		this.blocks[x * 256 + y * 16 + z] = blockId
	}
	deleteBlock(x, y, z) {
		this.blocks[x * 256 + y * 16 + z] = 0
	}
	setWorldBlock(x,y,z,blockId){
		if(x<0 || x>=16 || y<0 || y>=16 || z<0 || z>=16){
			this.world.setBlock(x+this.x,y+this.y,z+this.z,blockId,true,true)
		}else this.setBlock(x,y,z,blockId)
	}
	updateBlock(x, y, z, world, noOnupdate, sx,sy,sz) {
		let i = x
		let j = y
		let k = z
		x += this.x
		y += this.y
		z += this.z
		let block = this.blocks[i * 256 + j * 16 + k]
		
		if(!noOnupdate) this.world.updateQueue.push(x,y,z,sx,sy,sz)
		/*else if(!noOnupdate){
			if((block & isState) === STAIR || (block & isState) === CORNERSTAIRIN || (block & isState) === CORNERSTAIROUT){
				let front, back //front is lower side
				let rot = block & ROTATION
				switch(rot){
					case NORTH:
						front = this.world.getBlock(x,y,z-1,this.type)
						back = this.world.getBlock(x,y,z+1,this.type)
						break
					case SOUTH:
						front = this.world.getBlock(x,y,z+1,this.type)
						back = this.world.getBlock(x,y,z-1,this.type)
						break
					case EAST:
						front = this.world.getBlock(x-1,y,z,this.type)
						back = this.world.getBlock(x+1,y,z,this.type)
						break
					case WEST:
						front = this.world.getBlock(x+1,y,z,this.type)
						back = this.world.getBlock(x-1,y,z,this.type)
						break
				}
				front = front
				back = back
				let frontType = (front & isState) === STAIR && 1 || (front & isState) === CORNERSTAIRIN && 2 || (front & isState) === CORNERSTAIROUT && 3 || 0
				let backType = (back & isState) === STAIR && 1 || (back & isState) === CORNERSTAIRIN && 2 || (back & isState) === CORNERSTAIROUT && 3 || 0
				let target = blockData[block].id, rotate = 0, type = STAIR
				if(frontType === 1){
					switch(front & ROTATION){
						case NORTH:
							if(rot === EAST) type = CORNERSTAIRIN
							else if(rot === WEST){ rotate = 1; type = CORNERSTAIRIN }
							break
					}
				}
				target |= type
				if(rotate){
					switch(rot){
						case NORTH:
							target |= EAST
							break
						case EAST:
							target |= SOUTH
							break
						case SOUTH:
							target |= WEST
							break
						case WEST:
							target |= NORTH
							break
					}
				}else target |= rot
				if(block !== target) this.world.setBlock(x,y,z,target,false,false,false,false,this.type)
			}
		}*/
	}
	carveCaves() {
		let {world} = this
		let wx = this.x + 16, wz = this.z + 16, wy = this.y + 16
		for (let x = this.x, xx = 0; x < wx; x++, xx++) {
			for (let z = this.z, zz = 0; z < wz; z++, zz++) {
				wy = this.chunk.tops[zz * 16 + xx]
				for (let y = this.y, yy=0; y < wy; y++, yy++) {
					if (isCave(x, y, z, world)) {
						if (y > 3) {
							for (let i = 0; i < sphere.length; i += 3) {
								const block = y+sphere[i + 1]<10 ? blockIds.Lava :  blockIds.air
								this.setWorldBlock(xx + sphere[i], yy + sphere[i + 1], zz + sphere[i + 2], block, true,true)
							}
						}
					}
				}
			}
		}
		this.caves = true
	}
	oldSpawnMobs(){
		let {world} = this
		let fieldMobs = ["Cow","Pig","Sheep","Chicken"]
		let snowMobs = ["Wolf"]
		let hostileMobs = ["Creeper","Zombie","Skeleton","Spider","Enderman"]
		let netherWasteMobs = ["Blaze"]
		let endMobs = ["Enderman"]
		let x = Math.random() * 16 | 0
		let y = Math.random() * 16 | 0
		let z = Math.random() * 16 | 0
		let minChunkX = this.x + x - 32 >> 4
		let maxChunkX = this.x + x + 32 >> 4
		let minChunkZ = this.z + z - 32 >> 4
		let maxChunkZ = this.z + z + 32 >> 4
		let chunks = this.world.chunks
		let block = this.getBlock(x,y,z), light = max(this.getLight(x,y,z,0)*this.world.world.skyLight,this.getLight(x,y,z,1))
		let under = this.chunk.getBlock(x,y+this.y-1,z,0,true)
		if(this.type === "" && !block && light > 10 && under === blockIds.grass){
			for(let x2=minChunkX; x2<=maxChunkX; x2++) for(let z2=minChunkZ; z2<=maxChunkZ; z2++){
				if(chunks[x2] && chunks[x2][z2]) for(let [i,ent] of chunks[x2][z2].entities){
					if(ent.mob && max(abs(this.x+x-ent.x),abs(this.y+y-ent.y),abs(this.z+z-ent.z)) < 32) return
				}
			}
			let amount = rand(1,6)
			let mob = fieldMobs[floor(rand(fieldMobs.length))]
			for(let i=0; i<amount; i++) blockData[blockIds["spawn"+mob]].spawnMob(x+this.x+rand(),y+this.y,z+this.z+rand(),world)
		}else if(this.type === "" && !block && light > 10 && this.world.getBiome(this.x+x,this.y+y,this.z+z) === "snowyPlains" && (under === blockIds.grass || blockData[under].name === "snow")){
			for(let x2=minChunkX; x2<=maxChunkX; x2++) for(let z2=minChunkZ; z2<=maxChunkZ; z2++){
				if(chunks[x2] && chunks[x2][z2]) for(let [i,ent] of chunks[x2][z2].entities){
					if(ent.mob && max(abs(this.x+x-ent.x),abs(this.y+y-ent.y),abs(this.z+z-ent.z)) < 32) return
				}
			}
			let amount = rand(1,6)
			let mob = snowMobs[floor(rand(snowMobs.length))]
			for(let i=0; i<amount; i++) blockData[blockIds["spawn"+mob]].spawnMob(x+this.x+rand(),y+this.y,z+this.z+rand(),world)
		}else if(this.type === "" && !block && light <= 11 && under && 
			!this.getBlock(x,y+1,z) && !this.getBlock(x+1,y,z) && !this.getBlock(x,y,z+1)
			&& !this.getBlock(x+1,y+1,z) && !this.getBlock(x,y+1,z+1)){
			let within = false
			for(let p of this.world.world.players){
				let dist = max(abs(this.x+x-p.x),abs(this.y+y-p.y),abs(this.z+z-p.z))
				if(dist < 16 || p.dimension !== this.type) return
				within = within || dist<32
			}
			if(!within) return
			for(let x2=minChunkX; x2<=maxChunkX; x2++) for(let z2=minChunkZ; z2<=maxChunkZ; z2++){
				if(chunks[x2] && chunks[x2][z2]) for(let [i,ent] of chunks[x2][z2].entities){
					if(ent.mob && ent.hostile && max(abs(this.x+x-ent.x),abs(this.y+y-ent.y),abs(this.z+z-ent.z)) < 32) return
				}
			}
			let mob = hostileMobs[floor(rand(hostileMobs.length))]
			blockData[blockIds["spawn"+mob]].spawnMob(x+this.x+rand(),y+this.y,z+this.z+rand(),world)
		}else if(this.type === "nether" && !block && this.world.getBiome(this.x+x,this.y+y,this.z+z) === "netherWastes" && under === blockIds.netherrack){
			for(let x2=minChunkX; x2<=maxChunkX; x2++) for(let z2=minChunkZ; z2<=maxChunkZ; z2++){
				if(chunks[x2] && chunks[x2][z2]) for(let [i,ent] of chunks[x2][z2].entities){
					if(ent.mob && max(abs(this.x+x-ent.x),abs(this.y+y-ent.y),abs(this.z+z-ent.z)) < 32) return
				}
			}
			let amount = rand(1,6)
			let mob = netherWasteMobs[floor(rand(netherWasteMobs.length))]
			for(let i=0; i<amount; i++) blockData[blockIds["spawn"+mob]].spawnMob(x+this.x+rand(),y+this.y,z+this.z+rand(),world)
		}else if(this.type === "end" && !block && blockData[under].solid){
			for(let x2=minChunkX; x2<=maxChunkX; x2++) for(let z2=minChunkZ; z2<=maxChunkZ; z2++){
				if(chunks[x2] && chunks[x2][z2]) for(let [i,ent] of chunks[x2][z2].entities){
					if(ent.mob && max(abs(this.x+x-ent.x),abs(this.y+y-ent.y),abs(this.z+z-ent.z)) < 32) return
				}
			}
			let amount = rand(1,6)
			let mob = endMobs[floor(rand(endMobs.length))]
			for(let i=0; i<amount; i++) blockData[blockIds["spawn"+mob]].spawnMob(x+this.x+rand(),y+this.y,z+this.z+rand(),world)
		}
	}
	spawnMobs(){
		if(!this.chunk.lit) return
		if(this.world.world.worldType === "alpha") return this.oldSpawnMobs()
		let {world} = this
		let x = Math.random() * 16 | 0
		let y = Math.random() * 16 | 0
		let z = Math.random() * 16 | 0
		let block = this.getBlock(x,y,z)
		if(block ||
			this.getBlock(x,y+1,z) || this.getBlock(x+1,y,z) || this.getBlock(x,y,z+1)
			|| this.getBlock(x+1,y+1,z) || this.getBlock(x,y+1,z+1)) return//no space
		let minChunkX = this.x + x - 32 >> 4
		let maxChunkX = this.x + x + 32 >> 4
		let minChunkZ = this.z + z - 32 >> 4
		let maxChunkZ = this.z + z + 32 >> 4
		let chunks = this.world.chunks
		let light = max(this.getLight(x,y,z,0)*this.world.world.skyLight,this.getLight(x,y,z,1))
		let under = this.chunk.getBlock(x,y+this.y-1,z,0,true)
		let biome = world.getBiome(x+this.x,y+this.y,z+this.z)
		let passiveMobs = biomeData[biome][2]
		let hostileMobs = biomeData[biome][3]
		if(passiveMobs && light > 10 && under){
			for(let x2=minChunkX; x2<=maxChunkX; x2++) for(let z2=minChunkZ; z2<=maxChunkZ; z2++){
				if(chunks[x2] && chunks[x2][z2]) for(let [i,ent] of chunks[x2][z2].entities){
					if(ent.mob && max(abs(this.x+x-ent.x),abs(this.y+y-ent.y),abs(this.z+z-ent.z)) < 32) return
				}
			}
			let mob = passiveMobs[floor(rand(passiveMobs.length))]
			let amount = rand(mob[1],mob[2])
			if(blockIds["spawn"+mob[0]]){
				for(let i=0; i<amount; i++) blockData[blockIds["spawn"+mob[0]]].spawnMob(x+this.x+rand(),y+this.y,z+this.z+rand(),world)
			}
		}
		if(!light && under){
			let within = false
			for(let p of this.world.world.players){
				let dist = max(abs(this.x+x-p.x),abs(this.y+y-p.y),abs(this.z+z-p.z))
				if(dist < 16 || p.dimension !== this.type) return
				within = within || dist<32
			}
			if(!within) return
			for(let x2=minChunkX; x2<=maxChunkX; x2++) for(let z2=minChunkZ; z2<=maxChunkZ; z2++){
				if(chunks[x2] && chunks[x2][z2]) for(let [i,ent] of chunks[x2][z2].entities){
					if(ent.mob && ent.hostile && max(abs(this.x+x-ent.x),abs(this.y+y-ent.y),abs(this.z+z-ent.z)) < 32) return
				}
			}
			let idx = floor(rand((hostileMobs ? hostileMobs.length : 0)+defaultHostileMobs.length))
			let mob = hostileMobs && idx<hostileMobs.length ? hostileMobs[idx] : defaultHostileMobs[idx-(hostileMobs ? hostileMobs.length : 0)]
			let amount = rand(mob[1],mob[2])
			if(blockIds["spawn"+mob[0]]){
				for(let i=0; i<amount; i++) blockData[blockIds["spawn"+mob[0]]].spawnMob(x+this.x+rand(),y+this.y,z+this.z+rand(),world)
			}
		}
	}
	tick() {
		var world = this.world
		for (let i = 0; i < 40; i++) {
			let rnd = Math.random() * this.blocks.length | 0
			let blockID = this.blocks[rnd], block = blockData[blockID]
			let x = (rnd >> 8) + this.x
			let y = (rnd >> 4 & 15) + this.y
			let z = (rnd & 15) + this.z
			if(i<18){
				if ((blockID & isCube) === blockIds.grass || (blockID & isCube) === blockIds.mycelium) {
					// Spread grass
					if (!blockData[world.getBlock(x, y + 1, z, this.type)].transparent) {
						world.setBlock(x, y, z, blockIds.dirt, false,false,false,false, this.type)
						return
					}

					let rnd2 = Math.random() * 27 | 0
					let x2 = rnd2 % 3 - 1
					rnd2 = (rnd2 - x2 - 1) / 3
					let y2 = rnd2 % 3 - 1
					rnd2 = (rnd2 - y2 - 1) / 3
					z += rnd2 - 1
					x += x2
					y += y2

					let spreadTo = this.world.getBlock(x, y, z, this.type)
					if ((spreadTo & isCube) === blockIds.dirt && this.world.getBlock(x, y + 1, z, this.type) === blockIds.air) {
						this.world.setBlock(x, y, z, (blockID & isCube) | (spreadTo & (~isCube)), false,false,false,false, this.type)
					}
				} else if((blockID & isCube) === blockIds.crimsonNylium || (blockID & isCube) === blockIds.warpedNylium){
					// Spread nylium
					if (!blockData[world.getBlock(x, y + 1, z, this.type)].transparent) {
						world.setBlock(x, y, z, blockIds.netherrack, false,false,false,false, this.type)
						return
					}

					let rnd2 = Math.random() * 27 | 0
					let x2 = rnd2 % 3 - 1
					rnd2 = (rnd2 - x2 - 1) / 3
					let y2 = rnd2 % 3 - 1
					rnd2 = (rnd2 - y2 - 1) / 3
					z += rnd2 - 1
					x += x2
					y += y2

					let spreadTo = this.world.getBlock(x, y, z, this.type)
					if ((spreadTo & isCube) === blockIds.netherrack && this.world.getBlock(x, y + 1, z, this.type) === blockIds.air) {
						this.world.setBlock(x, y, z, (blockID & isCube) | (spreadTo & (~isCube)), false,false,false,false, this.type)
					}
				} else if (block.grow){
					block.grow(x,y,z,this.world)
				}else if(block.name === "vine" || block.name === "weepingVines"){
					if(!this.world.getBlock(x,y-1,z)){
						this.world.setBlock(x,y-1,z,blockID, false,false,false,false)
					}
				}else if(block.name === "twistingVines"){
					let i = (rnd >> 8) + this.x
					let j = (rnd >> 4 & 15) + this.y
					let k = (rnd & 15) + this.z
					if(!this.world.getBlock(x,y+1,z)){
						this.world.setBlock(x,y+1,z,blockID, false,false,false,false)
					}
				}
			}
			if(i<8){
				if(blockID === blockIds.tomatoPlant){
					world.setBlock(x, y, z, blockIds.tomatoPlant|SLAB, false,false,false,false, this.type)
				}else if(blockID === (blockIds.tomatoPlant|SLAB)){
					world.setBlock(x, y, z, blockIds.tomatoPlant|STAIR, false,false,false,false, this.type)
				}else if(blockID === (blockIds.tomatoPlant|STAIR)){
					world.setBlock(x, y, z, blockIds.tomatoPlant|CROSS, false,false,false,false, this.type)
				}else if(blockID === (blockIds.tomatoPlant|CROSS)){
					world.setBlock(x, y, z, blockIds.tomatoPlant|TALLCROSS, false,false,false,false, this.type)
				}/*wheat*/else if(blockID === (blockIds.wheat)){
					world.setBlock(x, y, z, blockIds.wheat|SLAB, false,false,false,false, this.type)
				}else if(blockID === (blockIds.wheat|SLAB)){
					world.setBlock(x, y, z, blockIds.wheat|STAIR, false,false,false,false, this.type)
				}else if(blockID === (blockIds.wheat|STAIR)){
					world.setBlock(x, y, z, blockIds.wheat|CROSS, false,false,false,false, this.type)
				}else if(blockID === (blockIds.wheat|CROSS)){
					world.setBlock(x, y, z, blockIds.wheat|TALLCROSS, false,false,false,false, this.type)
				}else if(blockID === (blockIds.wheat|TALLCROSS)){
					world.setBlock(x, y, z, blockIds.wheat|DOOR, false,false,false,false, this.type)
				}else if(blockID === (blockIds.wheat|DOOR)){
					world.setBlock(x, y, z, blockIds.wheat|TORCH, false,false,false,false, this.type)
				}else if(blockID === (blockIds.wheat|TORCH)){
					world.setBlock(x, y, z, blockIds.wheat|LANTERN, false,false,false,false, this.type)
				}/*cactus fruit*/else if(blockID === (blockIds.newCactusFruit|CROSS)){
					world.setBlock(x, y, z, blockIds.greenCactusFruit|CROSS, false,false,false,false, this.type)
				}else if(blockID === (blockIds.greenCactusFruit|CROSS)){
					world.setBlock(x, y, z, blockIds.redCactusFruit|CROSS, false,false,false,false, this.type)
				}else if(blockID === (blockIds.redCactusFruit|CROSS)){
					world.setBlock(x, y, z, blockIds.purpleCactusFruit|CROSS, false,false,false,false, this.type)
				}/*cactus*/else if(blockID === (blockIds.cactus|CACTUS)){
					var tall = 0
					var maxTall = 3
					for(var t=0; t<maxTall; t++){
						if(world.getBlock(x,y-t,z) === (blockIds.cactus|CACTUS)) tall++
						else break
					}
					if(tall >= maxTall) return
					
					var above = world.getBlock(x,y+1,z)
					if(blockData[above].cactusFruit){
						if(world.getBlock(x,y+2,z)) return //the cactus fruit can't replace blocks
						world.setBlock(x,y+2,z, above, false,false,false,false, this.type) //move the cactus fruit up
					}else if(above) return //there is a block so it can't grow
					world.setBlock(x,y+1,z, blockIds.cactus|CACTUS, false,false,false,false, this.type)
				}else if(blockID === blockIds.sweetBerryBush){
					world.setBlock(x, y, z, blockIds.sweetBerryBush|SLAB, false,false,false,false, this.type)
				}else if(blockID === (blockIds.sweetBerryBush | SLAB)){
					world.setBlock(x, y, z, blockIds.sweetBerryBush|STAIR, false,false,false,false, this.type)
				}else if(blockID === (blockIds.sweetBerryBush | STAIR)){
					world.setBlock(x, y, z, blockIds.sweetBerryBush|CROSS, false,false,false,false, this.type)
				}else if(blockID === (blockIds.cocoa | (blockID & ROTATION))){
					world.setBlock(x, y, z, blockIds.cocoa|SLAB|(blockID&ROTATION), false,false,false,false, this.type)
				}else if(blockID === (blockIds.cocoa | SLAB | (blockID & ROTATION))){
					world.setBlock(x, y, z, blockIds.cocoa|STAIR|(blockID&ROTATION), false,false,false,false, this.type)
				}else if(blockID === blockIds.beetroots){//beetroot
					world.setBlock(x, y, z, (blockIds.beetroots|SLAB), false,false,false,false, this.type)
				}else if(blockID === (blockIds.beetroots | SLAB)){
					world.setBlock(x, y, z, (blockIds.beetroots|STAIR), false,false,false,false, this.type)
				}else if(blockID === (blockIds.beetroots | STAIR)){
					world.setBlock(x, y, z, (blockIds.beetroots|CROSS), false,false,false,false, this.type)
				}else if(blockID === blockIds.potatoes){//potato
					world.setBlock(x, y, z, (blockIds.potatoes|SLAB), false,false,false,false, this.type)
				}else if(blockID === (blockIds.potatoes | SLAB)){
					world.setBlock(x, y, z, (blockIds.potatoes|STAIR), false,false,false,false, this.type)
				}else if(blockID === (blockIds.potatoes | STAIR)){
					world.setBlock(x, y, z, (blockIds.potatoes|CROSS), false,false,false,false, this.type)
				}else if(blockID === blockIds.carrots){//carrot
					world.setBlock(x, y, z, (blockIds.carrots|SLAB), false,false,false,false, this.type)
				}else if(blockID === (blockIds.carrots | SLAB)){
					world.setBlock(x, y, z, (blockIds.carrots|STAIR), false,false,false,false, this.type)
				}else if(blockID === (blockIds.carrots | STAIR)){
					world.setBlock(x, y, z, (blockIds.carrots|CROSS), false,false,false,false, this.type)
				}else if(blockID === (blockIds.bambooStalk | STAIR) || blockID === (blockIds.bambooStalk | SLAB) || blockID === blockIds.bambooStalk || blockID === (blockIds.bambooStalk | CROSS) || blockID === (blockIds.bambooStalk | TALLCROSS)){
					var tall = 0
					var maxTall = 16
					let blocks = []
					for(let t=0; t<maxTall; t++){
						let block = world.getBlock(x,y-t,z)
						if(blockData[block].name === "bambooStalk"){
							tall++
							blocks.push(block)
						}else break
					}
					if(tall >= maxTall) return
					
					var above = world.getBlock(x,y+1,z)
					if(above) return //there is a block so it can't grow
					world.setBlock(x,y+1,z, blockIds.bambooStalk | (tall > 3 ? STAIR : TALLCROSS), false,false,false,false, this.type)
					if(tall > 3){
						for(let t=0; t<tall; t++){
							let block = blocks[t]
							if(t === 0 && block !== (blockIds.bambooStalk | SLAB)) world.setBlock(x,y-t,z,blockIds.bambooStalk | SLAB,false,false,false,false)
							else if(block !== blockIds.bambooStalk) world.setBlock(x,y-t,z,blockIds.bambooStalk,false,false,false,false)
						}
					}else{
						for(let t=0; t<tall; t++){
							let block = blocks[t]
							if(t === 0 && block !== (blockIds.bambooStalk | CROSS)) world.setBlock(x,y-t,z,blockIds.bambooStalk | CROSS,false,false,false,false)
						}
					}
				}else if(blockID === (blockIds.bambooShoot | CROSS)){
					if(world.getBlock(x,y+1,z)) return
					world.setBlock(x, y, z, blockIds.bambooStalk|CROSS, false,false,false,false, this.type)
					world.setBlock(x, y+1, z, blockIds.bambooStalk|TALLCROSS, false,false,false,false, this.type)
				}else if(block.name === "sugarCane"){
					let b = blockID
					var tall = 0
					var maxTall = 3
					for(var t=0; t<maxTall; t++){
						if(world.getBlock(x,y-t,z) === b) tall++
						else break
					}
					if(tall >= maxTall) return
					
					var above = world.getBlock(x,y+1,z)
					if(above) return //there is a block so it can't grow
					world.setBlock(x,y+1,z, b, false,false,false,false, this.type)
				}else if(blockID === blockIds.pitcherCrop){
					world.setBlock(x, y, z, (blockIds.pitcherCrop|SLAB), false,false,false,false, this.type)
				}else if(blockID === (blockIds.pitcherCrop | SLAB)){
					world.setBlock(x, y, z, (blockIds.pitcherCrop|STAIR), false,false,false,false, this.type)
				}else if(blockID === (blockIds.pitcherCrop | STAIR)){
					world.setBlock(x, y, z, (blockIds.pitcherCrop|CROSS), false,false,false,false, this.type)
				}else if(blockID === (blockIds.pitcherCrop | CROSS)){
					world.setBlock(x, y, z, (blockIds.pitcherCrop|TALLCROSS), false,false,false,false, this.type)
				}else if(blockID === (blockIds.torchflower | SLAB)){
					world.setBlock(x, y, z, (blockIds.torchflower|STAIR), false,false,false,false, this.type)
				}else if(blockID === (blockIds.torchflower | STAIR)){
					world.setBlock(x, y, z, (blockIds.torchflower|CROSS), false,false,false,false, this.type)
				}else if(block.name === "pointedDripstone"){
					let renjofdxnjlasfrsjln = world.getBlock(x,y+2,z, this.type), asoieuhisd
					if(blockData[renjofdxnjlasfrsjln].liquid){
						let y2
						for(y2=y-1; y2>y-12; y2--){
							asoieuhisd = world.getBlock(x,y2,z)
							if(blockData[asoieuhisd].name !== "pointedDripstone") break
						}
						if(!blockData[asoieuhisd].solid){
							world.setBlock(x,y2,z,blockIds.pointedDripstone|FLIP,false,false,false,false)
							let y3
							for(y3=y2-1; y3>y2-12; y3--){
								asoieuhisd = world.getBlock(x,y3,z)
								if(blockData[asoieuhisd].solid) break
							}
							if(blockData[asoieuhisd].solid){
								world.setBlock(x,y3+1,z,blockIds.pointedDripstone,false,false,false,false)
							}
						}
					}
				}else if(block.coralBlock || block.coral || block.coralFan){
					let state = blockID&isState
					if(state === CUBE || state === SLAB || state === STAIR || state === VERTICALSLAB){
						let wall = state === STAIR || state === VERTICALSLAB
						let wet = (
							blockData[world.getBlock(x,y+1,z)].wet ||
							blockData[world.getBlock(x,y-1,z)].wet ||
							blockData[world.getBlock(x+1,y,z)].wet ||
							blockData[world.getBlock(x-1,y,z)].wet ||
							blockData[world.getBlock(x,y,z+1)].wet ||
							blockData[world.getBlock(x,y,z-1)].wet
						)
						let newState = wall?(wet?STAIR:VERTICALSLAB):(wet?CUBE:SLAB)
						if(newState !== state){
							world.setBlock(x, y, z, (blockID&(~isState))|newState, false,false,false,false, this.type)
						}
					}
				}else if(blockID === blockIds.cornPlant){
					world.setBlock(x, y, z, (blockIds.cornPlant|SLAB), false,false,false,false, this.type)
				}else if(blockID === (blockIds.cornPlant|SLAB)){
					world.setBlock(x, y, z, (blockIds.cornPlant|STAIR), false,false,false,false, this.type)
				}else if(blockID === (blockIds.cornPlant|STAIR)){
					world.setBlock(x, y, z, (blockIds.cornPlant|CROSS), false,false,false,false, this.type)
				}else if(blockID === (blockIds.cornPlant|CROSS)){
					world.setBlock(x, y, z, (blockIds.cornPlant|TALLCROSS), false,false,false,false, this.type)
				}else if(blockID === (blockIds.cornPlant|TALLCROSS)){
					world.setBlock(x, y, z, (blockIds.cornPlant|DOOR), false,false,false,false, this.type)
				}
			}
			if(i<40){
				if(block.name === "fire" || block.name === "Lava"){
					if(this.world.world.settings.fireSpreads) block.tick(x,y,z,this.world)
				}else if(block.tick){
					block.tick(block,x,y,z,this.world)
				}
				if(block.beacon){
					block.update(x,y,z,this.world)
				}
			}
		}
	}
	/** block: 1:block light, 2:sky light, 3:spread from sky light, 4:spread from block light */
	getLight(x, y, z, block = 0) {
		let i = x * 256 + y * 16 + z
		let arr = (block&1) ? this.blockLight : this.skyLight
		return (arr[i] & 15 << ((block&2)<<1)) >> ((block&2)<<1)
	}
	setLight(x, y, z, level, block = 0) {
		let i = x * 256 + y * 16 + z
		let arr = (block&1) ? this.blockLight : this.skyLight
		arr[i] = level << ((block&2)<<1) | arr[i] & ~(15 << ((block&2)<<1))
	}
	getTags(x, y, z){
		return this.tags[x * 256 + y * 16 + z]
	}
	getTagByName(x, y, z, n){
		var t = this.getTags(x,y,z)
		let tagBits = blockData[this.getBlock(x,y,z)].tagBits
		if(tagBits){
			if(!tagBits[n]) return 0
			return (t >>> tagBits[n][0]) & ((1 << tagBits[n][1])-1)
			//((1 << tagBits[n][1])-1) does this: 2 -> 11,  3 -> 111
		}else return t && t[n]
	}
	setTags(x,y,z, data){
		this.tags[x * 256 + y * 16 + z] = data
	}
	setTagByName(x, y, z, n, data){
		var i = x * 256 + y * 16 + z
		var t = this.tags[i]
		let tagBits = blockData[this.getBlock(x,y,z)].tagBits
		if(!t){
			if(tagBits) t = this.tags[i] = 0
			else t = this.tags[i] = {}
		}
		if(tagBits){
			if(!tagBits[n]) throw new Error("Cannot set "+n+" on binary tags.")
			let countMask = (1 << tagBits[n][1])-1
			if(data > countMask) throw new Error("Tag too large")
			let mask = countMask << tagBits[n][0]
			t = (t & (~mask)) | (data << tagBits[n][0])
			//what this complicated thing does is: set certain bits
			if(t) this.tags[i] = t
			else delete this.tags[i]
		}else t[n] = data
		return t
	}
}
let emptySection = new Section(0, 0, 0)
let fullSection = new Section(0, 0, 0)
fullSection.blocks.fill(blockIds.bedrock)
emptySection.skyLight.fill(255)

function getTagBits(t,n,block){
	let tagBits = blockData[block].tagBits
	return (t >>> tagBits[n][0]) & ((1 << tagBits[n][1])-1)
}
function getTag(t,n,block){
	let tagBits = block.tagBits
	if(tagBits){
		return (t >> tagBits[n][0]) & ((1 << tagBits[n][1])-1)
	}else return t && t[n]
}

class Chunk {
	constructor(x, z, world) {
		this.x = x
		this.z = z
		this.maxY = 0
		this.minY = 255
		this.sections = []
		this.cleanSections = []
		this.tops = new Int16Array(16 * 16) // Store the heighest block at every (x,z) coordinate
		this.ceils = new Uint8Array(16 * 16) //for nether
		this.solidTops = new Int16Array(16 * 16)
		this.biomes = new Uint8Array(16 * 16) // biome id at every (x,z) coordinate
		this.caveY = new Int16Array(16 * 16 * 2) //Bottom and top of the highest cave
		this.caveBiomes = new Uint8Array(16 * 16)
		this.caves = this.type !== "" || !caves
		this.generated = false; // Terrain
		this.generating = false //is it currently generating?
		this.populated = false // Trees and ores
		this.lit = false
		this.lazy = false
		this.edited = false
		this.loaded = false
		this.type = world.dimension
		this.world = world
		this.caves = this.type !== "" || !this.world.world.caves
		this.entities = new Map()
		this.columnHashs = new Uint8Array(16 * 16)//used to detect when column changes
		this.canSendClient = false
		this.allGenerated = false
	}
	getBlock(x, y, z) {
		y -= minHeight
		let s = y >> 4
		return s < this.sections.length && s >= 0 ? this.sections[s].getBlock(x, y & 15, z) : 0
	}
	setBlock(x, y, z, blockID, user) {
		let py = y
		y -= minHeight
		if(y<0) return
		if(this.allGenerated && !user){//used for generating trees after populations
			user = this.world
			this.world.sendAllInChunk({type:"setBlock", data:{x:x+this.x, y:py, z:z+this.z, block:blockID, dimension:this.type}},this.x>>4,this.z>>4)
		}
		if (!this.sections[y >> 4]) {
			do {
				let section = new Section(this.x, this.sections.length * 16 + minHeight, this.z, this)
				if(this.lit) section.skyLight.fill(15)
				this.sections.push(section)
			} while (!this.sections[y >> 4])
		}
		if (user && !this.sections[y >> 4].edited) {
			this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice()
			this.sections[y >> 4].edited = true
			this.edited = true
		}
		this.sections[y >> 4].setBlock(x, y & 15, z, blockID)
		this.updateSolidTop(x,py,z,blockID)
		this.columnHashs[z*16+x]++
	}
	updateSolidTop(x,y,z,blockID){
		if(blockID && (blockData[blockID].solid || blockData[blockID].liquid)){
			this.solidTops[z*16+x] = max(this.solidTops[z*16+x],y)
		}else if(y >= this.solidTops[z*16+x]){
			let top = this.solidTops[z*16+x]
			while(true) {
				let block = this.getBlock(x,top,z)
				if(blockData[block].solid || blockData[block].liquid || top<minHeight) break
				top--
			}
			this.solidTops[z*16+x] = top
		}
	}
	deleteBlock(x, y, z, user) {
		let py = y
		y -= minHeight
		if (!this.sections[y >> 4]) {
			return
		}
		if (user && !this.sections[y >> 4].edited) {
			this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice()
			this.sections[y >> 4].edited = true
			this.edited = true
		}
		this.sections[y >> 4].deleteBlock(x, y & 15, z)
		this.minY = py < this.minY ? py : this.minY
		this.maxY = py > this.maxY ? py : this.maxY
		this.updateSolidTop(x,py,z,0)
		this.columnHashs[z*16+x]++
	}
	getOriginalBlock(x,y,z){
		y -= minHeight
		let s = y >> 4
		if(!this.cleanSections[s]) return 0
		y = y & 15
		let c = this.sections[s]
		return this.cleanSections[s][x * c.size * c.size + y * c.size + z]
	}
	getTags(x, y, z){
		y -= minHeight
		let s = y >> 4
		return s < this.sections.length && s >= 0 ? this.sections[s].getTags(x, y & 15, z) : undefined
	}
	getTagByName(x,y,z,n){
		y -= minHeight
		let s = y >> 4
		return s < this.sections.length && s >= 0 ? this.sections[s].getTagByName(x, y & 15, z,n) : undefined
	}
	setTags(x,y,z,data){
		y -= minHeight
		if (!this.sections[y >> 4]) {
			do {
				let section = new Section(this.x, this.sections.length * 16 + minHeight, this.z, this)
				if(this.lit) section.skyLight.fill(15)
				this.sections.push(section)
			} while (!this.sections[y >> 4])
		}
		this.sections[y>>4].setTags(x, y & 15, z, data)
	}
	setTagByName(x,y,z,n,data){
		y -= minHeight
		let s = y >> 4
		if(s < this.sections.length && s >= 0) return this.sections[s].setTagByName(x, y & 15, z,n,data)
	}
	fillLight() {
		let max = this.sections.length * 16 - 1 + minHeight
		let blockSpread = []

		// Set virtical columns of light to level 15
		for (let x = 0; x < 16; x++) {
			for (let z = 0; z < 16; z++) {
				let light = 15, stop = false
				for (let y = max; y >= minHeight; y--) {
					let data = blockData[this.getBlock(x, y, z)]
					if (data.lightLevel) {
						if (!blockSpread[data.lightLevel]) blockSpread[data.lightLevel] = []
						blockSpread[data.lightLevel].push(x + this.x, y, z + this.z)
						this.setLight(x, y, z, data.lightLevel, 1)
						this.setLight(x, y, z, data.lightLevel, 3)
					}
					if (!stop && !data.transparent) {
						this.tops[z * 16 + x] = y
						light = 0
						stop = true
					} else if (light) {
						if(data.decreaseLight) light = Math.max(light-data.decreaseLight,0)
						this.setLight(x, y, z, light, 2)
						this.setLight(x, y, z, light, 0)
					}
				}
			}
		}

		// Spread the light to places where the virtical columns stopped earlier, plus chunk borders
		let spread = []
		for (let x = 0; x < 16; x++) {
			for (let z = 0; z < 16; z++) {
				for (let y = this.tops[z * 16 + x] + 1; y <= max; y++) {
					let light = this.getLight(x, y+1, z, 0)
					if(!spread[light]) spread[light] = []
					if (this.getLight(x+1,y,z,0) < light) {
						spread[light].push(x + this.x, y, z + this.z)
						continue
					}
					if (this.getLight(x-1,y,z,0) < light) {
						spread[light].push(x + this.x, y, z + this.z)
						continue
					}
					if (this.getLight(x,y,z+1,0) < light) {
						spread[light].push(x + this.x, y, z + this.z)
						continue
					}
					if (this.getLight(x,y,z-z,0) < light) {
						spread[light].push(x + this.x, y, z + this.z)
						continue
					}
					break
				}
			}
		}
		
		/*for(let i=0; i<this.toSpread.length; i+=5){
			let spreadone = this.toSpread[i+4] ? blockSpread : spread
			let level = this.toSpread[i+3]
			if(!spreadone[level]) spreadone[level] = []
			this.trySpread(this.toSpread[i],this.toSpread[i+1],this.toSpread[i+2],level,spreadone[level],this.toSpread[i+4])
		}*/
		for(let i = spread.length - 1; i > 0; i--){
			if(spread[i]) this.spreadLight(spread[i], i - 1)
		}

		for (let i = blockSpread.length - 1; i > 0; i--) {
			let blocks = blockSpread[i]
			if (blocks && blocks.length) {
				this.spreadLight(blocks, i - 1, false, 1)
			}
		}

		this.lit = true
	}
	setLight(x, y, z, level, blockLight) {
		y -= minHeight
		if (!this.sections[y >> 4]) {
			do {
				let section = new Section(this.x, this.sections.length * 16 + minHeight, this.z, this)
				if(this.lit) section.skyLight.fill(15)
				this.sections.push(section)
			} while (!this.sections[y >> 4])
		}
		this.sections[y >> 4].setLight(x, y & 15, z, level, blockLight)
	}
	getLight(x, y, z, blockLight = 0) {
		y -= minHeight
		if (!this.sections[y >> 4]) return !(blockLight&1) * 15
		return this.sections[y >> 4].getLight(x, y & 15, z, blockLight)
	}
	trySpread(x, y, z, level, spread, blockLight, update = false) {
		if(y < minHeight) return
		
		if (this.world.getLight(x, y, z, blockLight) < level) {
			//let chunk = this.world.getChunk(x,z)
			if (blockData[this.world.getBlock(x, y, z)].transparent) {
				this.world.setLight(x, y, z, level, blockLight)
				spread.push(x, y, z)
			}
		}
	}
	spreadLight(blocks, level, update = false, blockLight = 0) {
		let spread = []
		let x = 0, y = 0, z = 0
		for (let i = 0; i < blocks.length; i += 3) {
			x = blocks[i]
			y = blocks[i+1]
			z = blocks[i+2]
			if(y < minHeight) continue
			this.trySpread(x - 1, y, z, level, spread, blockLight, update)
			this.trySpread(x + 1, y, z, level, spread, blockLight, update)
			this.trySpread(x, y - 1, z, level, spread, blockLight, update)
			this.trySpread(x, y + 1, z, level, spread, blockLight, update)
			this.trySpread(x, y, z - 1, level, spread, blockLight, update)
			this.trySpread(x, y, z + 1, level, spread, blockLight, update)
		}
		if (level > 1 && spread.length) {
			this.spreadLight(spread, level - 1, update, blockLight)
		}
	}
	tryUnSpread(x, y, z, level, spread, respread, blockLight) {
		if(y < minHeight) return
		
		let light = this.world.getLight(x, y, z, blockLight)
		let spreadSource = this.world.getLight(x, y, z, blockLight|2, this.type) //won't be 0 if light source here
		let trans = blockData[this.world.getBlock(x, y, z)].transparent
		if (light === level) {
			if (trans) {
				this.world.setLight(x, y, z, spreadSource, blockLight, this.type)
				spread.push(x, y, z)
			}
			if(spreadSource) respread[spreadSource].push(x, y, z)
		} else if (light > level) {
			respread[light].push(x, y, z)
		}
	}
	unSpreadLight(blocks, level, respread, blockLight) {
		let spread = []
		let x = 0, y = 0, z = 0
		for (let i = 0; i < blocks.length; i += 3) {
			x = blocks[i]
			y = blocks[i+1]
			z = blocks[i+2]
			if(y < minHeight) continue
			this.tryUnSpread(x - 1, y, z, level, spread, respread, blockLight)
			this.tryUnSpread(x + 1, y, z, level, spread, respread, blockLight)
			this.tryUnSpread(x, y - 1, z, level, spread, respread, blockLight)
			this.tryUnSpread(x, y + 1, z, level, spread, respread, blockLight)
			this.tryUnSpread(x, y, z - 1, level, spread, respread, blockLight)
			this.tryUnSpread(x, y, z + 1, level, spread, respread, blockLight)
		}
		if (level > 1 && spread.length) {
			this.unSpreadLight(spread, level - 1, respread, blockLight)
		}
	}
	reSpreadLight(respread, blockLight) {
		for (let i = respread.length - 1; i > 1; i--) {
			let blocks = respread[i]
			let level = i - 1
			let spread = respread[level]
			for (let j = 0; j < blocks.length; j += 3) {
				let x = blocks[j]
				let y = blocks[j+1]
				let z = blocks[j+2]
				this.trySpread(x - 1, y, z, level, spread, blockLight)
				this.trySpread(x + 1, y, z, level, spread, blockLight)
				this.trySpread(x, y - 1, z, level, spread, blockLight)
				this.trySpread(x, y + 1, z, level, spread, blockLight)
				this.trySpread(x, y, z - 1, level, spread, blockLight)
				this.trySpread(x, y, z + 1, level, spread, blockLight)
			}
		}
	}
	updateBlock(x, y, z, world, lazy, noOnupdate, sx,sy,sz) {
		y -= minHeight
		if (this.allGenerated) {
			this.lazy = lazy
			if ((this.sections.length > y >> 4) && this.sections[y >> 4]) {
				this.sections[y >> 4].updateBlock(x, y & 15, z, world, noOnupdate, sx,sy,sz)
			}
		}
	}
	carveCaves() {
		if(this.world.world.worldType !== "large"){
			for (let i = (-minHeight)>>4; i < this.sections.length; i++) {
				if (!this.sections[i].caves) {
					this.sections[i].carveCaves()
				}
			}
		}/*else if(false){
			let {blocks,tops,biomes,caveY} = await doWork({caves:true, densities:this.densities, bottoms:this.densityBottoms, tops:this.tops, trueX:this.x,trueZ:this.z,blocks:this.tempSections,biomes:this.biomes,seed:this.world.worldSeed,riverCloseness:this.riverCloseness},[...Object.values(this.densities).map(r=>r.buffer),this.densityBottoms.buffer,...this.tempSections.map(r=>r.buffer),this.tops.buffer,this.riverCloseness.buffer])
			for(let i=0; i<blocks.length; i++){
				this.sections[i] = new Section(this.x, i*16+minHeight, this.z, this, blocks[i])
			}
			this.tops.set(tops)
			this.solidTops.set(tops)
			this.caveY.set(caveY)
			this.caveBiomes = biomes
			delete this.densities
			delete this.densityBottoms
			delete this.tempSections
			delete this.riverCloseness
		}*/
		this.caves = true
	}
	async generate() {
		let x = this.x >> 4
		let z = this.z >> 4
		let trueX = this.x
		let trueZ = this.z

		if (this.generated || this.generating) {
			return false
		}
		this.generating = true
		const {noiseProfile} = this.world.world
		let smoothness = generator.smooth
		let hilliness = generator.height
		let biomeSmooth = generator.biomeSmooth
		//{ for the nether terrain
		const bottom = 0 // Minimum height of the ground
		const hillSize = 0.004 // smaller = bigger; 0.005 to 0.01 seems the be a reasonable range
		//}
		let gen = 0, floatGen = 0
		if(this.world.customChunkGenerate && !this.world.customChunkGenerate(this)){
		}else if(this.world.world.worldType === "alpha" && this.type === ""){
		for (let i = 0; i < 16; i++) {
			for (let k = 0; k < 16; k++) {
				floatGen = noiseProfile.noise((trueX + i) * smoothness, (trueZ + k) * smoothness) * hilliness + generator.extra
				gen = Math.round(floatGen)
				/*if(this.type === "nether" && superflat){
					gen = Math.round(floatGen)
				}*/
				this.tops[k * 16 + i] = gen
				let biome = noiseProfile.noise((trueX + i) * biomeSmooth, (trueZ + k) * biomeSmooth);
				var b = getBiome(biome)
				this.biomes[k * 16 + i] = biomeIds[b]
				if(b === "a_desert"){
					this.tops[k * 16 + i] = gen;

					this.setBlock(i, gen, k, blockIds.sand);
					this.setBlock(i, gen - 1, k, blockIds.sand);
					this.setBlock(i, gen - 2, k, blockIds.sandstone);
					this.setBlock(i, gen - 3, k, blockIds.sandstone);
					if(gen<60) {
						gen = 59;
						this.setBlock(i, gen+1, k, blockIds.Water);
						this.setBlock(i, gen, k, blockIds.Water);
						this.setBlock(i, gen - 1, k, blockIds.Water);
						this.setBlock(i, gen - 2, k, blockIds.gravel);
						this.setBlock(i, gen - 3, k, blockIds.gravel);
					}
					if(gen>120){
							this.setBlock(i, gen, k, blockIds.stone);
					}
					if(gen>140){
							this.setBlock(i, gen, k, blockIds.sand);
					}
				}

				if(b === "a_field" || b === "a_oakForest"){
					this.tops[k * 16 + i] = gen;

					this.setBlock(i, gen, k, blockIds.grass);
					this.setBlock(i, gen - 1, k, blockIds.dirt);
					this.setBlock(i, gen - 2, k, blockIds.dirt);
					this.setBlock(i, gen - 3, k, blockIds.dirt);
					if(gen<60) {
						gen = 59;
						this.setBlock(i, gen+1, k, blockIds.Water);
						this.setBlock(i, gen, k, blockIds.Water);
						this.setBlock(i, gen - 1, k, blockIds.Water);
						this.setBlock(i, gen - 2, k, blockIds.gravel);
						this.setBlock(i, gen - 3, k, blockIds.gravel);
					}
				}
				if(b === "a_snowyField"){
					this.tops[k * 16 + i] = gen;

					if(gen >= 60){
						var h = ceil(((floatGen + 0.5) % 1) * 8)
						switch(h){//really smooth terrain!
							case 1:
								this.setBlock(i, gen + 1, k, blockIds.snow | LAYER1)
								break
							case 2:
								this.setBlock(i, gen + 1, k, blockIds.snow | LAYER2)
								break
							case 3:
								this.setBlock(i, gen + 1, k, blockIds.snow | LAYER3)
								break
							case 4:
								this.setBlock(i, gen + 1, k, blockIds.snow | LAYER4)
								break
							case 5:
								this.setBlock(i, gen + 1, k, blockIds.snow | LAYER5)
								break
							case 6:
								this.setBlock(i, gen + 1, k, blockIds.snow | LAYER6)
								break
							case 7:
								this.setBlock(i, gen + 1, k, blockIds.snow | LAYER7)
								break
							case 8:
								this.setBlock(i, gen + 1, k, blockIds.snowBlock)
								break
						}
						this.setBlock(i, gen, k, blockIds.grass | CROSS);
						this.setBlock(i, gen - 1, k, blockIds.dirt);
						this.setBlock(i, gen - 2, k, blockIds.dirt);
						this.setBlock(i, gen - 3, k, blockIds.dirt);
					}
					if(gen<60) {
						gen = 59;
						this.setBlock(i, gen+1, k, blockIds.ice);
						this.setBlock(i, gen, k, blockIds.ice);
						this.setBlock(i, gen - 1, k, blockIds.Water);
						this.setBlock(i, gen - 2, k, blockIds.gravel);
						this.setBlock(i, gen - 3, k, blockIds.gravel);
					}
				}
				
				if(b === "a_jungle" || b === "a_giantJungle" || b === "a_bambooForest"){
					this.tops[k * 16 + i] = gen;

					if(b === "a_bambooForest") this.setBlock(i, gen, k, blockIds.podzol)
					else this.setBlock(i, gen, k, blockIds.grass)
					this.setBlock(i, gen - 1, k, blockIds.dirt);
					this.setBlock(i, gen - 2, k, blockIds.dirt);
					this.setBlock(i, gen - 3, k, blockIds.dirt);
					
					if(gen<60) {
						this.setBlock(i, 60, k, blockIds.Water);
						for(var y=59; y>=gen; y--){
							this.setBlock(i, y, k, blockIds.Water);
						}
						this.setBlock(i, gen, k, blockIds.gravel);
						this.setBlock(i, gen - 1, k, blockIds.gravel);
					}
				}

				for (let j = 1; j < gen - 3; j++) {
					this.setBlock(i, j, k, blockIds.stone)
				}
				this.setBlock(i, 0, k, blockIds.bedrock)
			}
		}}else if(this.type === "nether"){
			for (let i = 0; i < 16; i++) {
				for (let k = 0; k < 16; k++) {
					let wx = trueX + i, wz = trueZ + k
					let biome = noiseProfile.noise((trueX + i) * biomeSmooth, (trueZ + k) * biomeSmooth)
					let b = getNetherBiome(biome)
					this.biomes[k * 16 + i] = biomeIds[b]
					let block = blockIds.netherrack
					if(b === "warpedForest"){
						block = blockIds.warpedNylium
					}else if(b === "crimsonForest"){
						block = blockIds.crimsonNylium
					}
					//const smo = noise((trueX + i) * biomeSize, (trueZ + k) * biomeSize) * flatness + 40
					const smo = 40
					let top = 0
					let solid = false
					for (let j = 1; j < netherHeight; j++) {
						var noiseRes = noiseProfile.noise((trueX + i)/smo, j/smo, (trueZ + k)/smo) - ((110 + j/4) - bottom) * hillSize
						if(j > netherHeight - 10){
							noiseRes = lerp((j - (netherHeight - 10)) / 10, noiseRes, 0.1)
						}
						if (noiseRes > 0) {
							this.setBlock(i, j, k, blockIds.netherrack)
							if(!solid) this.ceils[k * 16 + i] = j
							if(j > 31) solid = true
						} else if (solid && j > 31) {
							this.setBlock(i, j - 1, k, block)
							/*if (chunk.getBlock(i, j - 2, k)) chunk.setBlock(i, j - 2, k, block)
							if (chunk.getBlock(i, j - 3, k)) chunk.setBlock(i, j - 3, k, block)
							if (chunk.getBlock(i, j - 4, k)) chunk.setBlock(i, j - 4, k, block)*/
							solid = false
							top = j
						} else if(j < 32){
							this.setBlock(i, j, k, blockIds.Lava)
							if(this.getBlock(i, j - 1, k) === block) this.setBlock(i, j-2, k, blockIds.netherrack)
						}
					}

					this.tops[k * 16 + i] = top-1
					this.setBlock(i, 0, k, blockIds.bedrock)
					
					/*block = blockIds.netherrack
					for(let j=1; j<gen; j++){
						chunk.setBlock(i, netherHeight - j, k, block)
					}*/
					this.setBlock(i,netherHeight,k, blockIds.bedrock)
				}
			}
		}else if(this.type === "end"){
			for (let i = 0; i < 16; i++) {
				for (let k = 0; k < 16; k++) {
					let wx = trueX + i, wz = trueZ + k
					this.tops[k * 16 + i] = 0
					for(let j = 0; j<64; j++){
						gen = noiseProfile.noise(wx * 0.01, j*0.01, wz * 0.01) - 0.57
						if(wx > -64 && wx < 64 && wz > -64 && wz < 64){
							//main island
							gen = gen + 0.57 - lerp(max(abs(wx),abs(wz))/64, 0,0.57)
						}else if(wx > -80 && wx < 80 && wz > -80 && wz < 80){
							//blend into void
							gen = gen + 0.57 - lerp(max(abs(wx)-64,abs(wz)-64)/16, 0.57,1)
						}else if(wx > -200 && wx < 200 && wz > -200 && wz < 200){
							//blend void into outer islands
							var dist = 200-64
							gen = lerp(max(abs(wx)-dist,abs(wz)-dist,0)/64, -0.1,gen)
						}
						if(j < 32){
							gen = lerp(j/32,-0.1,gen)
						}
						if(j > 48){
							gen = lerp((j-48)/16, gen,-0.1)
						}
						if(gen > 0){
							this.tops[k * 16 + i] = j
							this.setBlock(i,j,k,blockIds.endStone)
						}
					}
					if(wx < -200 || wx > 200 || wz < -200 || wz > 200){
						this.biomes[k * 16 + i] = biomeIds.endIslands
					}else{
						this.biomes[k * 16 + i] = biomeIds.end
					}
				}
			}
		}else if(this.world.world.worldType === "island"){
			let islandGenerator = this.world.world.islandGenerator
			for (let i = 0; i < 16; i++) {
				for (let k = 0; k < 16; k++) {
					let gen = islandGenerator.GetHeight(x*16+i, z*16+k)
					this.tops[k*16+i] = gen
					if (islandGenerator.GetWaterDepth(x*16+i, z*16+k) > 0) {
						this.setBlock(i, gen, k, blockIds.Water);
						this.setBlock(i, gen - 1, k, blockIds.Water)
						this.setBlock(i, gen - 2, k, blockIds.dirt)
						this.setBlock(i, gen - 3, k, blockIds.dirt)
					}   else {
						let biomeHere = islandGenerator.GetBiomeType(x*16+i, z*16+k);
						if (biomeHere === -3161286) {
							this.setBlock(i, gen, k, blockIds.sand)
							this.setBlock(i, gen - 1, k, blockIds.sand)
							this.setBlock(i, gen - 2, k, blockIds.sand)
							this.setBlock(i, gen - 3, k, blockIds.sand)
							this.biomes[k * 16 + i] = biomeIds.desert
						}   else if (biomeHere === -1) {
							this.setBlock(i, gen, k, blockIds.snowBlock)
							this.setBlock(i, gen - 1, k, blockIds.snowBlock)
							this.setBlock(i, gen - 2, k, blockIds.stone)
							this.setBlock(i, gen - 3, k, blockIds.stone)
							this.biomes[k * 16 + i] = biomeIds.snowyPlains
						}   else if (biomeHere === -4934476 || biomeHere === -8355712 || biomeHere === -6963874) {
							this.setBlock(i, gen, k, blockIds.stone)
							this.setBlock(i, gen - 1, k, blockIds.stone)
							this.setBlock(i, gen - 2, k, blockIds.stone)
							this.setBlock(i, gen - 3, k, blockIds.stone)
							this.biomes[k * 16 + i] = biomeIds.desert
						} else if (biomeHere === -65536) {
							this.setBlock(i, gen, k, blockIds.Lava)
							this.setBlock(i, gen - 1, k, blockIds.stone)
							this.setBlock(i, gen - 2, k, blockIds.stone)
							this.setBlock(i, gen - 3, k, blockIds.stone)
							this.biomes[k * 16 + i] = biomeIds.desert
						} else {
							this.setBlock(i, gen, k, blockIds.grass)
							this.setBlock(i, gen - 1, k, blockIds.dirt)
							this.setBlock(i, gen - 2, k, blockIds.dirt)
							this.setBlock(i, gen - 3, k, blockIds.dirt)
							this.biomes[k * 16 + i] = biomeIds.plains
						}
					}

					for (let j = 1; j < gen - 3; j++) {
						this.setBlock(i, j, k, blockIds.stone)
					}
					this.setBlock(i, 0, k, blockIds.bedrock)
				}
			}
		}else if(this.world.world.worldType === "void"){
			for (let i = 0; i < 16; i++) {
				for (let k = 0; k < 16; k++) {
					this.biomes[k * 16 + i] = biomeIds.void
				}
			}
		}else if(this.world.world.worldType === "superflat"){
			for (let i = 0; i < 16; i++) {
				for (let k = 0; k < 16; k++) {
					this.tops[k * 16 + i] = 4;
					this.biomes[k * 16 + i] = biomeIds.plains
		
					this.setBlock(i, 4, k, blockIds.grass);
					this.setBlock(i, 3, k, blockIds.dirt);
					this.setBlock(i, 2, k, blockIds.dirt);
					this.setBlock(i, 1, k, blockIds.dirt);
					this.setBlock(i, 0, k, blockIds.bedrock);
				}
			}
		}else{
			let r = await doWork({generate:true,trueX,trueZ,seed:this.world.world.worldSeed,fancyRivers:this.world.world.fancyRivers,caves:!this.caves})
			if(!r) return
			let {blocks,tops,biomes,minY,maxY,waterTops,caveBiomes,caveY} = r
			this.tops.set(tops)
			this.solidTops.set(tops)
			this.biomes = biomes
			this.minY = minY
			this.maxY = maxY
			this.waterTops = waterTops
			for(let i=0; i<blocks.length; i++){
				this.sections[i] = new Section(this.x, i*16+minHeight, this.z, this, blocks[i])
			}
			this.caveY.set(caveY)
			this.caveBiomes = caveBiomes
			if(!this.caves) this.caves = true//prevent further carving
		}
		this.generating = false
		this.generated = true
	}
	generateOldBlob(replace, blockID, amount, x,y,z, size = 1){
		// Blob code from https://biome-testing.lukep0wers.repl.co
		// generate blobs (ore blobs, dirt blobs, etc)
		let newX=0, newY=0, newZ=0
		for(let cv = 0; cv < amount; cv++) {
			var block = this.getBlock(x+newX, y+newY, z+newZ)
			var canReplace = false
			if(Array.isArray(replace)){
				for(var id of replace){
					if(block === id){
						canReplace = true
						break
					}
				}
			}else{
				if(block === replace) {
					canReplace = true
				}
			}
			if(canReplace) this.setBlock(x+newX, y+newY, z+newZ,blockID);
			newX = round(random(-size, size));
			newY = round(random(-size, size));
			newZ = round(random(-size, size));
		}
	}
	generateBlob(X,Y,Z,replace,oreSegments,oreWeirdness,oreSize,oreSegmentSize, flat = false){
		oreSize = round(oreSize)
		let {world} = this
		//https://www.khanacademy.org/computer-programming/ore-generator/6387555023765504
		let balls=[],bx=0,by=0,bz=0;
		let dx=random()*2-1,dy=random()*2-1,dz=random()*2-1;
		for(let i=0;i<oreSegments;i++){
			let d=Math.hypot(dx,dy,dz);
			dx /= d;
			dy /= d;
			dz /= d;
			balls.push(bx,by,bz);
			bx += dx*oreWeirdness;
			if(!flat) by += dy*oreWeirdness;
			bz += dz*oreWeirdness;
			if(bx>oreSize){
				bx = -oreSize;
			}
			if(bx<-oreSize){
				bx = oreSize;
			}
			if(by>oreSize){
				by = -oreSize;
			}
			if(by<-oreSize){
				by = oreSize;
			}
			if(bz>oreSize){
				bz = -oreSize;
			}
			if(bz<-oreSize){
				bz = oreSize;
			}
			dx=random()*2-1;
			dy=random()*2-1;
			dz=random()*2-1;
		}
		for(let x=-oreSize;x<oreSize;x++){
			for(let y=-oreSize;y<oreSize;y++){
				for(let z=-oreSize;z<oreSize;z++){
					let block = replace[world.getBlock(X+x,Y+y,Z+z)]
					if(block === undefined) continue
					if(typeof block === "function") block = block(X+x,Y+y,Z+z)
					if(block === undefined) continue
					let d=0;
					for(let i=0; i<balls.length; i+=3){
						d += 1/dist3(balls[i],balls[i+1],balls[i+2],x,y,z);
					}
					if(d>1/oreSegmentSize){
						world.spawnBlock(X+x,Y+y,Z+z,block, true)
					}
				}
			}
		}
	}
	spawnOres(replace,tries,minY,maxY,type, oreSize, oreSegmentSize = oreSize/10, oreWeirdness = 4, oreSegments = 8){
		for(let i=0;i<tries;i++){
			let y
			if(type === "triangle") y = round((random(minY,maxY)+random(minY,maxY))*0.5)
			else y = round(random(minY,maxY))
			let x = round(random(15)), z = round(random(15))
			if(!replace[this.getBlock(x,y,z)] || replace.biomes && !replace.biomes.includes(biomeIds[this.biomes[z*16+x]])) continue
			this.generateBlob(this.x+x,y,this.z+z,replace,oreSegments,oreWeirdness,oreSize,oreSegmentSize)
		}
	}
	allFlowers = [blockIds.lilyOftheValley, blockIds.poppy, blockIds.dandelion, 
								blockIds.blueOrchid, blockIds.pinkTulip, blockIds.orangeTulip, blockIds.redTulip, blockIds.whiteTulip,
								blockIds.azureBluet, blockIds.cornFlower, blockIds.purpleFlower, blockIds.witherRose,
								blockIds.allium, blockIds.oxeyeDaisy,
								blockIds.lilac, blockIds.roseBush, blockIds.peony,
								blockIds.TallGrass, blockIds.DoubleTallGrass]
	trashland = [blockIds.grass,blockIds.blackConcrete,blockIds.blackTerracotta,blockIds.soup3,blockIds.coalBlock,blockIds.ancientDebris,blockIds.obsidian,blockIds.blackstone,blockIds.tuff,blockIds.mud]
	spawnSmallTree(i,ground,k,wx,wz,isBirch,dying,thin){
		let place
		let {type, world} = this
		let top = ground + floor(4.5 + random(2.5))
		let rand = floor(random(4096))
		let tree = isBirch === undefined ? (random() < 0.6 ? blockIds.oakLog : ++top && blockIds.birchLog) : (isBirch ? blockIds.birchLog : blockIds.oakLog)
		let leaf = tree === blockIds.oakLog ? blockIds.oakLeaves : blockIds.birchLeaves
		if(thin) tree |= WALLPOST

		//Center
		for (let j = ground + 1; j <= top; j++) {
			this.setBlock(i, j, k, tree)
			if(dying) worldGenArray.add(wx,j,wz,blockIds.mossCarpet)
		}
		this.setBlock(i, top + 1, k, leaf)
		this.setBlock(i, ground, k, blockIds.dirt)

		//Bottom leaves
		for (let x = -2; x <= 2; x++) {
			for (let z = -2; z <= 2; z++) {
				if (x || z) {
					if ((x * z & 7) === 4) {
						place = rand & 1
						rand >>>= 1
						if (place) {
							world.spawnBlock(wx + x, top - 2, wz + z, leaf)
						}
					} else {
						world.spawnBlock(wx + x, top - 2, wz + z, leaf)
					}
				}
			}
		}

		//2nd layer leaves
		for (let x = -2; x <= 2; x++) {
			for (let z = -2; z <= 2; z++) {
				if (x || z) {
					if ((x * z & 7) === 4) {
						place = rand & 1
						rand >>>= 1
						if (place) {
							world.spawnBlock(wx + x, top - 1, wz + z, leaf)
						}
					} else {
						world.spawnBlock(wx + x, top - 1, wz + z, leaf)
					}
				}
			}
		}

		//3rd layer leaves
		for (let x = -1; x <= 1; x++) {
			for (let z = -1; z <= 1; z++) {
				if (x || z) {
					if (x & z) {
						place = rand & 1
						rand >>>= 1
						if (place) {
							world.spawnBlock(wx + x, top, wz + z, leaf)
						}
					} else {
						world.spawnBlock(wx + x, top, wz + z, leaf)
					}
				}
			}
		}

		//Top leaves
		world.spawnBlock(wx + 1, top + 1, wz, leaf)
		world.spawnBlock(wx, top + 1, wz - 1, leaf)
		world.spawnBlock(wx, top + 1, wz + 1, leaf)
		world.spawnBlock(wx - 1, top + 1, wz, leaf)
	}
	spawnSnowSmallTree(i,ground,k,wx,wz){
		let place
		let {type, world} = this
		let top = ground + floor(4.5 + random(2.5))
		let rand = floor(random(4096))
		let tree = random() < 0.6 ? blockIds.oakLog : ++top && blockIds.birchLog
		let leaf = tree === blockIds.oakLog ? blockIds.oakLeaves : blockIds.birchLeaves
		let snow = blockIds.snow

		//Center
		for (let j = ground + 1; j <= top; j++) {
			this.setBlock(i, j, k, tree)
		}
		this.setBlock(i, top + 1, k, leaf)
		this.setBlock(i, ground, k, blockIds.dirt)
		this.setBlock(i, top + 2, k, snow | LAYER2)
		
		//Top leaves
		world.spawnBlock(wx + 1, top + 1, wz, leaf)
		world.spawnBlock(wx, top + 1, wz - 1, leaf)
		world.spawnBlock(wx, top + 1, wz + 1, leaf)
		world.spawnBlock(wx - 1, top + 1, wz, leaf)
		world.spawnBlock(wx + 1, top + 2, wz, snow | LAYER1)
		world.spawnBlock(wx, top + 2, wz - 1, snow | LAYER1)
		world.spawnBlock(wx, top + 2, wz + 1, snow | LAYER1)
		world.spawnBlock(wx - 1, top + 2, wz, snow | LAYER1)

		//Bottom leaves
		for (let x = -2; x <= 2; x++) {
			for (let z = -2; z <= 2; z++) {
				if (x || z) {
					if ((x * z & 7) === 4) {
						place = rand & 1
						rand >>>= 1
						if (place) {
							world.spawnBlock(wx + x, top - 2, wz + z, leaf)
						}
					} else {
						world.spawnBlock(wx + x, top - 2, wz + z, leaf)
					}
				}
			}
		}
		
		//3rd layer leaves
		for (let x = -1; x <= 1; x++) {
			for (let z = -1; z <= 1; z++) {
				if (x || z) {
					if (x & z) {
						place = rand & 1
						rand >>>= 1
						if (place) {
							world.spawnBlock(wx + x, top, wz + z, leaf)
							if(rand & 2) world.spawnBlock(wx + x, top + 1, wz + z, snow | LAYER2)
							else world.spawnBlock(wx + x, top + 1, wz + z, snow | LAYER1)
						}
					} else {
						world.spawnBlock(wx + x, top, wz + z, leaf)
						world.spawnBlock(wx + x, top + 1, wz + z, snow | LAYER1)
					}
				}
			}
		}

		//2nd layer leaves
		for (let x = -2; x <= 2; x++) {
			for (let z = -2; z <= 2; z++) {
				if (x || z) {
					if ((x * z & 7) === 4) {
						place = rand & 1
						rand >>>= 1
						if (place) {
							world.spawnBlock(wx + x, top - 1, wz + z, leaf)
							if(rand & 2) world.spawnBlock(wx + x, top, wz + z, snow | LAYER2)
							else world.spawnBlock(wx + x, top, wz + z, snow | LAYER1)
						}
					} else {
						world.spawnBlock(wx + x, top - 1, wz + z, leaf)
						world.spawnBlock(wx + x, top, wz + z, snow | LAYER1)
					}
				}
			}
		}
		
		//get rid of snow underneath
		/*for (let x = -1; x <= 1; x++) {
			for (let z = -1; z <= 1; z++) {
				if(x || z){
					var g = world.getTop(wx,wz)
					if(g) world.setBlock(wx+i, g+1, wz+k, 0)
				}
			}
		}*/
		//
	}
	spawnCactus(i,ground,k){
		let rnd = random()
		let top = ground + Math.floor(2.5 + rnd*1.5);
		let rand = Math.floor(random(4096));
		let tree = blockIds.cactus | CACTUS;

		//Center
		for (let j = ground + 1; j <= top; j++) {
			this.setBlock(i, j, k, tree);
		}
		
		//Fruit
		switch(round(rnd*4)){
			case 0:
				this.setBlock(i, top+1, k, blockIds.newCactusFruit|CROSS);
				break
			case 1:
				this.setBlock(i, top+1, k, blockIds.greenCactusFruit|CROSS);
				break
			case 2:
				this.setBlock(i, top+1, k, blockIds.redCactusFruit|CROSS);
				break
		}
	}
	spawnCocoaTree(i,ground,k,wx,wz){
		let place
		let {type, world} = this
		let rand = floor(random(4096))
		let tall = floor(5 + random(5)) //5 to 10
		let top = ground + tall
		let tree = blockIds.jungleLog
		let leaf = blockIds.jungleLeaves
		
		//Center
		for (let j = ground + 1; j <= top; j++) {
			this.setBlock(i, j, k, tree)
			worldGenArray.add(wx,j,wz,blockIds.vine)
			worldGenArray.add(wx,j,wz,blockIds.cocoa)
		}
		this.setBlock(i, top + 1, k, leaf)
		this.setBlock(i, ground, k, blockIds.dirt)
		
		//Bottom leaves
		for (let x = -2; x <= 2; x++) {
			for (let z = -2; z <= 2; z++) {
				if (x || z) {
					if ((x * z & 7) === 4) {
						place = rand & 1
						rand >>>= 1
						if (place) {
							world.spawnBlock(wx + x, top - 2, wz + z, leaf)
							worldGenArray.add(wx+x,top-2,wz+z,blockIds.vine)
						}
					} else {
						world.spawnBlock(wx + x, top - 2, wz + z, leaf)
						worldGenArray.add(wx+x,top-2,wz+z,blockIds.vine)
					}
				}
			}
		}

		//2nd layer leaves
		for (let x = -2; x <= 2; x++) {
			for (let z = -2; z <= 2; z++) {
				if (x || z) {
					if ((x * z & 7) === 4) {
						place = rand & 1
						rand >>>= 1
						if (place) {
							world.spawnBlock(wx + x, top - 1, wz + z, leaf)
							worldGenArray.add(wx+x,top-1,wz+z,blockIds.vine)
						}
					} else {
						world.spawnBlock(wx + x, top - 1, wz + z, leaf)
						worldGenArray.add(wx+x,top-1,wz+z,blockIds.vine)
					}
				}
			}
		}

		//3rd layer leaves
		for (let x = -1; x <= 1; x++) {
			for (let z = -1; z <= 1; z++) {
				if (x || z) {
					if (x & z) {
						place = rand & 1
						rand >>>= 1
						if (place) {
							world.spawnBlock(wx + x, top, wz + z, leaf)
							worldGenArray.add(wx+x,top,wz+z,blockIds.vine)
						}
					} else {
						world.spawnBlock(wx + x, top, wz + z, leaf)
						worldGenArray.add(wx+x,top,wz+z,blockIds.vine)
					}
				}
			}
		}

		//Top leaves
		world.spawnBlock(wx + 1, top + 1, wz, leaf)
		world.spawnBlock(wx, top + 1, wz - 1, leaf)
		world.spawnBlock(wx, top + 1, wz + 1, leaf)
		world.spawnBlock(wx - 1, top + 1, wz, leaf)
		worldGenArray.add(wx+1,top+1,wz,blockIds.vine)
		worldGenArray.add(wx,top+1,wz-1,blockIds.vine)
		worldGenArray.add(wx,top+1,wz+1,blockIds.vine)
		worldGenArray.add(wx-1,top+1,wz,blockIds.vine)
	}
	spawnJungleTree(i,ground,k,wx,wz){
		let {type, world} = this
		let tall = floor(10 + random(20)) //10 to 30
		let top = ground + tall
		let tree = blockIds.jungleLog
		let leaf = blockIds.jungleLeaves
		
		//Center
		for (let j = ground + 1; j < top; j++) {
			this.setBlock(i, j, k, tree)
			world.spawnBlock(wx + 1, j, wz, tree)
			world.spawnBlock(wx, j, wz + 1, tree)
			world.spawnBlock(wx+1, j, wz+1, tree)
		}
		this.setBlock(i, ground, k, blockIds.dirt)
		world.spawnBlock(wx + 1, ground, wz, blockIds.dirt, true)
		world.spawnBlock(wx, ground, wz + 1, blockIds.dirt, true)
		world.spawnBlock(wx+1, ground, wz+1, blockIds.dirt, true)

		//Messy part
		//leaves
		let w2 = 5 * 5
		for(var x2=-5; x2<=5; x2++){
			for(var y=2; y<5; y++){
				for(var z2=-5; z2<=5; z2++){
					let x = x2-0.5, z = z2-0.5
					let n = x * x / w2 + y * y / w2 + z * z / w2
					if (n < 1) {
						world.spawnBlock(wx + x+1, top-4+y, wz + z+1, leaf)
						worldGenArray.add(wx+x+1,top-4+y,wz+z+1,blockIds.vine)
					}
				}
			}
		}

		//the diagonal branches
		w2 = 3 * 3
		for(y=ground+5; y<top; y += Math.floor(random(10))){
			let side = floor(random(4))
			let mx=0,mz=0
			switch(side){
				case 0:
					mx=1
					break
				case 1:
					mx=-1
					break
				case 2:
					mz=1
					break
				case 3:
					mz=-1
					break
			}
			let x = mx === 1?2:mx, z = mz === 1?2:mz
			let rnd = floor(random(4))+2
			//branch
			for(var by=0; by<rnd; by++){
				world.spawnBlock(wx+x, y+by, wz+z, tree)
				worldGenArray.add(wx+x,y+by,wz+z,blockIds.vine)
				x += mx
				z += mz
			}
			x -= mx
			z -= mz
			by -= 1

			//leaves
			for(var lx=-3; lx<3; lx++){
				for(var ly=1; ly<3; ly++){
					for(var lz=-3; lz<3; lz++){
						let n = lx * lx / w2 + ly * ly / w2 + lz * lz / w2
						if (n < 1) {
							world.spawnBlock(wx+x + lx, y+by+ly, wz+z + lz, leaf)
							worldGenArray.add(wx+x+lx,y+by+ly,wz+z+lz,blockIds.vine)
						}
					}
				}
			}
			// m = move; l = leaf
		}
		//vines
		for(var vi=0; vi<10; vi++){
			var vy = random(ground, top)
			var side = floor(random(4))
			var vx = wx, vz = wz
			switch(side){
				case 0:
					vz += 2
					side = SOUTH
					break
				case 1:
					vz -= 1
					side = NORTH
					break
				case 2:
					vx += 2
					side = WEST
					break
				case 3:
					vx -= 1
					side = EAST
					break
			}
			var vh = max(floor(random(ground,vy)), ground)
			for(; vy > vh && !world.getBlock(vx, vy, vz); vy --){
				world.spawnBlock(vx,vy,vz, blockIds.vine | WALLFLAT | side)
			}
		}
	}
	spawnJungleBush(i,k,wx,ground,wz){
		let {type, world} = this
		let place, rand = floor(random(512))//9 bits
		let leaf = blockIds.jungleLeaves
		this.setBlock(i,ground+1,k,blockIds.jungleLog)

		//bottom leaves
		for (let x = -2; x <= 2; x++) {
			for (let z = -2; z <= 2; z++) {
				if (x || z) {
					if ((x * z & 7) === 4) {
						place = rand & 1
						rand >>>= 1
						if (place) {
							world.spawnBlock(wx + x, ground+1, wz + z, leaf)
						}
					} else {
						world.spawnBlock(wx + x, ground+1, wz + z, leaf)
					}
				}
			}
		}
		//2nd layer
		for (let x = -1; x <= 1; x++) {
			for (let z = -1; z <= 1; z++) {
				if (x & z) {
					place = rand & 1
					rand >>>= 1
					if (place) {
						world.spawnBlock(wx + x, ground+2, wz + z, leaf)
					}
				} else {
					world.spawnBlock(wx + x, ground+2, wz + z, leaf)
				}
			}
		}
		if(rand & 1){
			this.setBlock(i,ground+3,k,leaf)
		}
	}
	spawnNetherMushroom(i,ground,k,wx,wz,b){
		let place
		let {type, world} = this
		let tall = round(random(4,12))
		if(floor(random(12)) === 1) tall *= 2
		let leafRadius = round(tall*0.25+1.5)
		let top = ground + tall
		let rand = floor(random(4096))
		let tree
		let leaf
		if(b === "warpedForest"){
			tree = blockIds.warpedStem
			leaf = blockIds.warpedWartBlock
		}else if(b === "crimsonForest"){
			tree = blockIds.crimsonStem
			leaf = blockIds.netherWartBlock
		}
		
		//Center
		for (let j = ground + 1; j <= top; j++) {
			this.setBlock(i, j, k, tree)
		}
		this.setBlock(i, top + 1, k, leaf)
		this.setBlock(i, ground, k, blockIds.netherrack)
		
		let w2 = leafRadius**2, w3 = (leafRadius - 2)**2
		for(let x2=-leafRadius; x2<=leafRadius; x2++){
			for(let z2=-leafRadius; z2<=leafRadius; z2++){
				for(let y2=0; y2<=leafRadius; y2++){
					let n = x2 * x2 / w2 + z2 * z2 / w2 + y2 * y2 / w2
					let n2 = x2 * x2 / w3 + y2 * y2 / w3 + z2 * z2 / w3
					if(n>0.5) n += this.world.world.caveNoise((wx+x2)*1.5, (top+y2)*1.5, (wz+z2)*1.5)*0.5
					if (n < 1 && n2 > 1) {
					let thisy = top-leafRadius+2+y2
						world.spawnBlock(wx+x2, thisy, wz+z2, leaf)
						if(!world.getBlock(wx+x2, thisy-1, wz+z2)){
							let randomValue = hash3(wx+x2, thisy, wz+z2)
							if(randomValue<0.02) world.spawnBlock(wx+x2, thisy, wz+z2, blockIds.shroomlight, true)
							if(y2<2){
								if(randomValue>0.8){
									let h = map(randomValue,0.8,1,1,3)
									for(var y=0; y<h; y++){
										world.spawnBlock(wx + x2, thisy - y - 1, wz + z2, leaf)
									}
								}else if(randomValue>0.7 && b === "crimsonForest"){
									let h = map(randomValue,0.7,0.8,1,5)
									for(var y=0; y<h; y++){
										world.spawnBlock(wx + x2, thisy - y - 1, wz + z2, blockIds.weepingVinesPlant)
									}
									world.spawnBlock(wx + x2, thisy - h - 1, wz + z2, blockIds.weepingVines)
								}
							}
						}
					}
				}
			}
		}
		/*
		//Shroomlight
		for(var l=0; l<3; l++) world.spawnBlock(wx + random(-2, 2), top + random(-1,1), wz + random(-2,2), blockIds.shroomlight)
		
		//Top leaves
		for(var x=-1; x<2; x++){
			for(var z=-1; z<2; z++){
				place = (x&1) && (z&1) ? rand & 1 : true
				rand >>>= 1
				if(place){
					world.spawnBlock(wx + x, top + 1, wz + z, leaf)
				}
			}
		}
		
		//layer 2 leaves
		for(var x=-2; x<3; x++){
			for(var z=-2; z<3; z++){
				place = (x===2 || x===-2) && (z===2 || z==-2) ? rand & 1 : true
				rand >>>= 1
				if(place){
					world.spawnBlock(wx + x, top, wz + z, leaf)
				}
			}
		}
		
		rand = floor(random(4096))
		//layer 1 leaves
		for(var x=-2; x<3; x++){
			for(var z=-2; z<3; z++){
				place = x===2 || x===-2 || z===2 || z==-2 ? !(rand & 1) : false
				rand >>>= 1
				if(place){
					world.spawnBlock(wx + x, top - 1, wz + z, leaf)
				}
			}
		}
		
		rand = floor(random(40964096))
		//drooping leaves
		for(var x=-2; x<3; x++){
			for(var z=-2; z<3; z++){
				place = x===2 || x===-2 || z===2 || z==-2
				rand >>>= 1
				if(place){
					var h = rand & 4 && rand & 8 ? rand & 3 : 0
					if(h){
						world.spawnBlock(wx + x, top - 1, wz + z, leaf) //to make sure removed ones are put back
						for(var y=0; y<h; y++){
							world.spawnBlock(wx + x, top - 2 - y, wz + z, leaf)
						}
					}
				}
			}
		}
		
		if(b === "crimsonForest"){
			rand = floor(random(40964096))
			//vines
			for(var x=-2; x<3; x++){
				for(var z=-2; z<3; z++){
					place = x===2 || x===-2 || z===2 || z==-2
					rand >>>= 1
					if(place){
						var h = (rand & 4 && rand & 8) ? (rand & (tall-2)) - 1 : 0
						if(h){
							world.spawnBlock(wx + x, top - 1, wz + z, leaf) //to make sure removed ones are put back
							for(var y=0; y<h; y++){
								world.spawnBlock(wx + x, top - 2 - y, wz + z, blockIds.weepingVinesPlant)
							}
							world.spawnBlock(wx + x, top - 2 - h, wz + z, blockIds.weepingVines)
						}
					}
				}
			}
		}*/
	}
	spawnBamboo(i,ground,k,wx,wz,old=false){
		let {type, world} = this
		if(random() < 0.2){
			this.setBlock(i, ground+1, k, blockIds.bambooShoot | CROSS)
		}else{
			let h = old ? round(12+random()*6) : round(4+random()*10)
			let top = ground+h
			for(var y=ground+1; y<top+1; y++){
				if(y === top){
					this.setBlock(i,y,k,blockIds.bambooStalk | STAIR)
				}else if(y === top-1){
					this.setBlock(i,y,k,blockIds.bambooStalk | SLAB)
				}else{
					this.setBlock(i,y,k,blockIds.bambooStalk)
				}
			}
			if(old){
				for(let b=0; b<6; b++){
					let where = random()
					let j = where > 0.5 ? round(lerp((where-0.5)*2,top,top+4)) : round(lerp((where*2)**3,top,(top+ground)*0.5))
					let rot = hash3(i,b,k)*Math.PId
					let dx = sin(rot), dz = cos(rot)
					for(let l=0; l<4; l++){
						world.spawnBlock(round(wx+dx*l),round(j+l*-0.5),round(wz+dz*l),blockIds.bambooLeaves)
					}
				}
			}
		}
	}
	/*spawnLavaRiver(wx,ground,wz){//replaced with lava spring
		let {type, world} = this
		let it = 0
		let x=wx, y=ground, z=wz
		let dir=floor(random(0,8))
		for(; it<100; it++){
			let xp,zp
			switch(dir){
				case 0:
					x+=1
					zp=true
					break
				case 1:
					x+=1
					z+=1
					break
				case 2:
					z+=1
					xp=true
					break
				case 3:
					x-=1
					z+=1
					break
				case 4:
					x-=1
					zp=true
					break
				case 5:
					x-=1
					z-=1
					break
				case 6:
					z-=1
					xp=true
					break
				case 7:
					x+=1
					z-=1
					break
			}
			if(random() < 0.08){
				dir += round(random(-1,1))
			}
			let prev = world.getBlock(x,y,z)
			world.spawnBlock(x,y,z,blockIds.Lava,true)
			if(xp){
				world.spawnBlock(x+1,y,z,blockIds.Lava,true)
			}
			if(zp){
				world.spawnBlock(x,y,z+1,blockIds.Lava,true)
			}
			if(!prev && y>1){
				y--
				prev = world.getBlock(x,y,z)
				world.spawnBlock(x,y,z,blockIds.Lava,true)
				while(!prev && y>1){
					y--
					prev = world.getBlock(x,y,z)
					world.spawnBlock(x,y,z,blockIds.Lava,true)
				}
			}
			if(world.getBlock(x,y-1,z) === blockIds.Lava) break
		}
	}*/
	tempTreeBranches = []
	branchRot1 = new Quaternion()
	branchRot2 = new Quaternion()
	branchVec1 = new PVector()
	branchVec2 = new PVector()
	branchVec3 = new PVector()
	spawnTreeWBranch(i,ground,k,wx,wz, log,leaf,trunkLength,lengthMul,bendUp,budSpace,branchAngle,defaultBranchRoll,weightPerBlock,budSpaceAdd,maxDepth,leafSize){
		//example: spawnTreeWBranch(i,ground,k,x,z, blockIds.dirt,blockIds.leaves,10,0.9,0.25,2,Math.PI/4,0,0.05,0.2,3,3)
		let {type, world} = this
		let {branchVec1, branchVec2, branchRot1, branchRot2, branchVec3} = this
		this.setBlock(i, ground, k, blockIds.dirt)
		let branches = this.tempTreeBranches
		branches.length = 0
		branches.push(wx,ground,wz, 0,1,0, trunkLength,0)
		let c,dx,dy,dz, subLength
		for(let i=0; i<branches.length; i+=8){
			let x = branches[i], y = branches[i+1], z = branches[i+2]
			dx = branches[i+3], dy = branches[i+4], dz = branches[i+5]
			let length = branches[i+6]
			let depth = branches[i+7]
			//let rx = branches[i+3], ry = branches[i+4]
			//let ryx = sin(ry), ryz = cos(ry)
			if(!dx && !dz){//use specified orthogonal axis
				branchVec1.set(sin(defaultBranchRoll),0,cos(defaultBranchRoll))
			}else{//find orthogonal axis that faces up
				branchVec1.set(dx,dy,dz)
				branchVec2.set(0,1,0)
				branchVec2.crossProductVector(this.branchVec1)
				branchVec1.set(dx,dy,dz)
				branchVec1.crossProductVector(this.branchVec2)
				branchVec1.normalize()
			}
			branchRot1.fromAxisAngle(branchAngle,branchVec1.x,branchVec1.y,branchVec1.z)
			branchRot2.fromAxisAngle(-branchAngle,branchVec1.x,branchVec1.y,branchVec1.z)
			branchVec1.set(dx,dy,dz)
			branchRot1.rotateVector(branchVec1)
			branchVec2.set(dx,dy,dz)
			branchRot2.rotateVector(branchVec2)
			let b = 0, alt = random()>0.5
			for(let l=0; l<length; l++){
				//c = cos(rx)
				//dx = ryx*c, dy = sin(rx), dz = ryz*c
				subLength = length-(l*l/length)
				world.spawnBlock(round(x),round(y),round(z),log)
				b++
				if(depth<maxDepth && b>budSpace+budSpaceAdd*subLength){
					b -= budSpace
					alt = !alt
					if(random()>0.2){
						branchVec3.set(alt ? branchVec1 : branchVec2)
						branchVec3.x += random(-weightPerBlock,weightPerBlock)//add randomness
						branchVec3.y += random(-weightPerBlock,weightPerBlock)
						branchVec3.z += random(-weightPerBlock,weightPerBlock)
						branchVec3.normalize()
						branches.push(x,y,z,branchVec3.x,branchVec3.y,branchVec3.z,subLength*(lengthMul+random(1-lengthMul)*0.8),depth+1)
					}
				}
				x += dx, y += dy, z += dz
				//rx += (Math.PI2-rx)*bendUp//make branch bend up
				dy -= weightPerBlock*subLength
				dx *= (1-bendUp), dz *= (1-bendUp), dy += (1-dy)*bendUp
				let mag = sqrt(dx*dx+dy*dy+dz*dz)
				dx /= mag, dy /= mag, dz /= mag
			}
			let w2 = leafSize*leafSize
			for (let ly = floor(-leafSize); ly < ceil(leafSize); ly++) {
				for (let lx = floor(-leafSize); lx <= ceil(leafSize); lx++) {
					for (let lz = floor(-leafSize); lz <= ceil(leafSize); lz++) {
						let n = lx * lx / w2 + ly * ly / w2 + lz * lz / w2
						if(n > 0.2){
							n += hash3(lx + x, ly + y, lz + z)*0.8
						}
						if (n < 1) {
							world.spawnBlock(lx + x, ly + y, lz + z, leaf)
						}
					}
				}
			}
		}
		branches.length = 0
	}
	spawnBigOak(i,ground,k,wx,wz,dying){
		let {type, world} = this
		this.setBlock(i, ground, k, blockIds.dirt)
		var heightLimit = Math.floor(random(8)+8)
		var trunkHeight
		var leafBottom = 6
		var branchCount
		//var branchSlope = 0.381
		let tree = blockIds.oakLog
		let leaf = blockIds.oakLeaves
		
		let branches = []
		
		trunkHeight = heightLimit
		if(heightLimit > 14) branchCount = 10
		else branchCount = 6
		//let endy = trunkHeight//heightLimit * 0.3
		let maxDist = heightLimit*0.75
		let minDist = heightLimit*0.5
		let tiltRot = random(Math.PId)
		let tilt = random()
		let dirx = sin(tiltRot)*tilt
		let dirz = cos(tiltRot)*tilt
		branches.push([wx+dirx*trunkHeight,ground+trunkHeight,wz+dirz*trunkHeight])
		for(var b=0; b<branchCount; b++){
			let arr = []
			let dist = random(maxDist-minDist)+minDist
			let sy = round(lerp(random()**2,leafBottom,trunkHeight))
			let angle = random(Math.PI*2)
			let angleY = map(sy,leafBottom,trunkHeight,0.4,0.8)*Math.PI2
			let sx = sy*dirx, sz = sy*dirz
			let otherBranchRand = random()
			if(otherBranchRand<0.125 && branches.length>1){//connect to another branch
				let otherBranch = branches[round(random(1,branches.length-1))]
				dist *= 0.25
				let amount = floor(otherBranch.length*otherBranchRand*4/3)*3
				sx = otherBranch[amount]-wx
				sy = otherBranch[amount+1]-ground
				sz = otherBranch[amount+2]-wz
			}
			let side = cos(angleY)
			let ex = wx + sx + dist*0.75*sin(angle)*side
			let ez = wz + sz + dist*0.75*cos(angle)*side
			let ey = sy+dist*sin(angleY)
			line3D(ex,ey+ground,ez,wx+sx,sy+ground,wz+sz,arr)
			branches.push(arr)
		}
		let trunk = []
		line3DConncected(wx+round(dirx*trunkHeight),trunkHeight+ground,wz+round(dirz*trunkHeight),wx,ground,wz,trunk)
		for(var i=0; i<trunk.length; i+=3){
			world.spawnBlock(trunk[i],trunk[i+1],trunk[i+2],tree)
			if(dying) worldGenArray.add(trunk[i],trunk[i+1],trunk[i+2],blockIds.mossCarpet)
		}
		var miny = heightLimit*0.2
		for(var b of branches){
			var x = b[0]
			var y = b[1]
			var z = b[2]
			if(y >= miny+ground){
				for(var bi=0;bi<b.length;bi+=3){
					world.spawnBlock(b[bi],b[bi+1],b[bi+2],tree)
					if(dying) worldGenArray.add(b[bi],b[bi+1],b[bi+2],blockIds.mossCarpet)
				}
			}
		}
		for(var b of branches){
			var l = b.length
			var x = b[l-3]
			var y = b[l-2]
			var z = b[l-1]
			
			let w = 4, h = 3
			let w2 = w*w, h2 = h*h
			for (let ly = -h; ly < h; ly++) {
				for (let lx = -w; lx <= w; lx++) {
					for (let lz = -w; lz <= w; lz++) {
						let n = lx * lx / w2 + ly * ly / h2 + lz * lz / w2
						if(n > 0.2){
							n += this.world.world.caveNoise((lx + x)*3.3, (ly + y)*3.3, (lz + z)*3.3)*0.8
						}
						if (n < 1) {
							world.spawnBlock(lx + x, ly + y, lz + z, leaf)
						}
					}
				}
			}
		}
	}
	spawnFallenTree(i,ground,k,wx,wz,tree,minDist,maxDist,hasVines){//oak: 4-7, birch: 5-15
		let {type, world} = this
		let length = round(random(minDist,maxDist))
		let rnd = floor(random(8))
		let distance = (rnd&1)+2
		let direction = (rnd>>1)&3
		let sw = blockData[tree].swId
		let dx = 0, dz = 0, rot
		switch(direction){
			case 0:
				dx = 1
				rot = EAST
				break
			case 1:
				dz = 1
				rot = NORTH
				break
			case 2:
				dx = -1
				rot = WEST
				break
			case 3:
				dz = -1
				rot = SOUTH
				break
		}
		rnd = floor(random(256))
		this.setBlock(i,ground,k,blockIds.dirt)
		this.setBlock(i,ground+1,k,tree)
		if(hasVines && random()<hasVines){
			worldGenArray.add(wx,ground+1,wz,blockIds.vine)
		}
		ground = world.getTop(wx+distance*dx,wz+distance*dz)
		for(let l=0; l<length; l++){
			let x = wx+(distance+l)*dx, z = wz+(distance+l)*dz
			world.spawnBlock(x,ground+1,z,sw|rot)
			if(rnd&1){
				let mushroom = ((rnd>>1)&1) ? blockIds.redMushroom : blockIds.brownMushroom
				world.spawnBlock(x,ground+2,z,mushroom)
			}
			rnd >>= 2
		}
	}
	spawnSpruce(i,ground,k,wx,wz){
		let {type, world} = this
		let top = ground + floor(random(5,9))
		let tree = blockIds.spruceLog
		let leaf = blockIds.spruceLeaves
		let topOffseted = top+round(random())
		let bigStart = 3 //Which layer do big ones start

		for (let j = ground + 1; j <= top; j++) {
			this.setBlock(i, j, k, tree)
		}
		this.setBlock(i, top + 1, k, leaf)
		this.setBlock(i, ground, k, blockIds.dirt)

		//Top leaves
		world.spawnBlock(wx + 1, topOffseted, wz, leaf)
		world.spawnBlock(wx, topOffseted, wz - 1, leaf)
		world.spawnBlock(wx, topOffseted, wz + 1, leaf)
		world.spawnBlock(wx - 1, topOffseted, wz, leaf)
		
		for(let j=topOffseted-2, l=0; j>ground+1; j--, l++){
			if(l > bigStart && !(l%2)){//big layer
				for (let x = -3; x <= 3; x++) {
					for (let z = -3; z <= 3; z++) {
						if (x || z) {
							if (abs(x) !== 3 || abs(z) !== 3) {
								world.spawnBlock(wx + x, j, wz + z, leaf)
							}
						}
					}
				}
			}else if((l%2) || l>bigStart){//medium big layer
				for (let x = -2; x <= 2; x++) {
					for (let z = -2; z <= 2; z++) {
						if (x || z) {
							if ((x * z & 7) !== 4) {
								world.spawnBlock(wx + x, j, wz + z, leaf)
							}
						}
					}
				}
			}else{//small layer
				world.spawnBlock(wx + 1, j, wz, leaf)
				world.spawnBlock(wx, j, wz - 1, leaf)
				world.spawnBlock(wx, j, wz + 1, leaf)
				world.spawnBlock(wx - 1, j, wz, leaf)
			}
		}
	}
	spawnPine(i,ground,k,wx,wz){
		let {type, world} = this
		let top = ground + floor(random(6,15))
		let tree = blockIds.spruceLog
		let leaf = blockIds.spruceLeaves
		let layers = round(random(2.25,3.75))

		for (let j = ground + 1; j <= top; j++) {
			this.setBlock(i, j, k, tree)
		}
		this.setBlock(i, top + 1, k, leaf)
		this.setBlock(i, ground, k, blockIds.dirt)

		for(let l=0; l<layers; l++){
			if(layers === 3 && l === 1){//medium big layer
				for (let x = -2; x <= 2; x++) {
					for (let z = -2; z <= 2; z++) {
						if (x || z) {
							if ((x * z & 7) !== 4) {
								world.spawnBlock(wx + x, top-l, wz + z, leaf)
							}
						}
					}
				}
			}else{
				world.spawnBlock(wx+1, top - l, wz, leaf)
				world.spawnBlock(wx-1, top - l, wz, leaf)
				world.spawnBlock(wx, top - l, wz+1, leaf)
				world.spawnBlock(wx, top - l, wz-1, leaf)
			}
		}
	}
	spawnBigSpruce(i,ground,k,wx,wz){
		let {type, world} = this
		let top = ground + floor(random(25,35))
		let tree = blockIds.spruceLog
		let leaf = blockIds.spruceLeaves

		this.generateBlob(wx,ground,wz,this.patches.podzol,4,3,6,1.5,true)

		for (let j = ground + 1; j < top; j++) {
			this.setBlock(i, j, k, tree)
			world.spawnBlock(wx + 1, j, wz, tree)
			world.spawnBlock(wx, j, wz + 1, tree)
			world.spawnBlock(wx+1, j, wz+1, tree)
		}
		this.setBlock(i, ground, k, blockIds.dirt)
		world.spawnBlock(wx + 1, ground, wz, blockIds.dirt, true)
		world.spawnBlock(wx, ground, wz + 1, blockIds.dirt, true)
		world.spawnBlock(wx+1, ground, wz+1, blockIds.dirt, true)

		/*//Top leaves
		this.setBlock(i, top, k, leaf)
		world.spawnBlock(wx + 1, top, wz, leaf)
		world.spawnBlock(wx, top, wz + 1, leaf)
		world.spawnBlock(wx+1, top, wz+1, leaf)

		//2nd layer leaves
		world.spawnBlock(wx-1, top-1, wz, leaf)
		world.spawnBlock(wx-1, top-1, wz+1, leaf)
		world.spawnBlock(wx, top-1, wz-1, leaf)
		world.spawnBlock(wx+1, top-1, wz-1, leaf)
		world.spawnBlock(wx+2, top-1, wz, leaf)
		world.spawnBlock(wx+2, top-1, wz+1, leaf)
		world.spawnBlock(wx, top-1, wz+2, leaf)
		world.spawnBlock(wx+1, top-1, wz+2, leaf)*/

		for (let j = top+2, l=0; j > ground+4; j--, l++) {
			let size = round(l/4 + 1)
			let s2 = size * size
			for(let x=-size; x<=size; x++){
				for(let z=-size; z<=size; z++){
					let n = (x+0.5)**2 / s2 + (z+0.5)**2 / s2
					if(j < ground+12){ //Make thinner
						n += (ground+12-j)/12
					}
					/*if(n > 0.2){
						n += this.world.caveNoise((wx+x)*3.3, j*3.3, (wz+z)*3.3)*0.8
					}*/
					let mult = 1/Math.hypot(x,z)*2
					n += this.world.world.caveNoise(wx+x*mult, (j+n)*0.5, wz+z*mult)*0.8
					if (n < 1) {
						world.spawnBlock(wx + x+1, j, wz + z+1, leaf)
					}
				}
			}
		}
	}
	spawnTallSpruce(i,ground,k,wx,wz){
		let {type, world} = this
		let top = ground + floor(random(24,32))
		let bottom = round(lerp(0.8,top,ground))
		let tree = blockIds.spruceLog
		let leaf = blockIds.spruceLeaves

		for (let j = ground + 1; j < top; j++) {
			this.setBlock(i, j, k, tree)
		}
		this.setBlock(i, ground, k, blockIds.dirt)

		for (let j = top+8, l=0; j > bottom; j--, l++) {
			let size = l/4 + 2
			let s2 = size * size
			let noiseAmount = (top+8-j)/(top+8-bottom)
			let noiseAmountHigh = 1-(1-noiseAmount)**4
			//Make thinner
			for(let x=-floor(size); x<=ceil(size); x++){
				for(let z=-floor(size); z<=ceil(size); z++){
					let n = x**2 / s2 + z**2 / s2
					let mult = 1/Math.hypot(x,z)*2
					n += this.world.world.caveNoise(wx+x*mult, (j+n)*0.5, wz+z*mult)*2*noiseAmountHigh
					if(noiseAmount>0.8) n = lerp((noiseAmount-0.8)/0.2, n,1.2)
					if (n < 1) {
						world.spawnBlock(wx + x, j, wz + z, leaf)
					}
				}
			}
		}
	}
	spawnBigPine(i,ground,k,wx,wz){
		let {type, world} = this
		let top = ground + floor(random(15,27))
		let tree = blockIds.spruceLog
		let leaf = blockIds.spruceLeaves
		let bottom = round(lerp(0.65,top,ground))
		//let h = round(random(12,20))//round(random(4,12))

		this.generateBlob(wx,ground,wz,this.patches.podzol,4,3,6,1.5,true)

		for (let j = ground + 1; j < top; j++) {
			this.setBlock(i, j, k, tree)
			world.spawnBlock(wx + 1, j, wz, tree)
			world.spawnBlock(wx, j, wz + 1, tree)
			world.spawnBlock(wx+1, j, wz+1, tree)
		}
		this.setBlock(i, ground, k, blockIds.dirt)
		world.spawnBlock(wx + 1, ground, wz, blockIds.dirt, true)
		world.spawnBlock(wx, ground, wz + 1, blockIds.dirt, true)
		world.spawnBlock(wx+1, ground, wz+1, blockIds.dirt, true)

		/*let w = 8
		let w2 = w**2, h2 = h**2
		for(let x2=-w; x2<w; x2++){
			for(let z2=-w; z2<w; z2++){
				for(let y2=-h; y2<h; y2++){
					let n = x2 * x2 / w2 + z2 * z2 / w2 + y2 * y2 / h2
					if(n > 0.6){
						n += this.world.caveNoise((wx+x2)*2, (top+y2), (wz+z2)*2)*0.4
					}
					if (n < 1) {
						world.spawnBlock(wx+x2, top+y2, wz+z2, leaf)
					}
				}
			}
		}*/
		for (let j = top+2, l=0; j > bottom; j--, l++) {
			let size = l*0.4+1
			let s2 = size * size
			let noiseAmount = (top+2-j)/(top+2-bottom)
			for(let x=-size; x<=size; x++){
				for(let z=-size; z<=size; z++){
					let n = (x+0.5)**2 / s2 + (z+0.5)**2 / s2
					//if(j < (top-h)+4){ //Make thinner
					//	n += ((top-h)+4-j)/4
					//}
					n += this.world.world.caveNoise((wx+x), j, (wz+z))*2.5*noiseAmount
					if(noiseAmount>0.8) n = lerp((noiseAmount-0.8)/0.2, n,1.2)
					if (n < 1) {
						world.spawnBlock(wx + x+1, j, wz + z+1, leaf)
					}
				}
			}
		}
	}
	spawnAcacia(i,ground,k,wx,wz){
		let {type, world} = this
		let top = ground + floor(random(6,8))
		let tree = blockIds.acaciaLog
		let leaf = blockIds.acaciaLeaves
		for (let j = ground + 1; j < top; j++) {
			this.setBlock(i, j, k, tree)
		}
		this.setBlock(i, ground, k, blockIds.dirt)
		let rnd = floor(random(16384))
		let branch1 = rnd&3 //branch length
		let branch2 = (rnd>>2)&3
		let branch1Top = (rnd>>4)&1//vertical part of branch
		let branch2Top = (rnd>>5)&1
		let size1 = 3+((rnd>>6)&1)//radius of leaves
		let size2 = 3+((rnd>>7)&1)
		let dir1 = (rnd>>8)&3//direction of branch
		let dir2 = (rnd>>10)&3
		let offset1 = (rnd>>12)&1//branch go down
		let offset2 = (rnd>>13)&1

		//branch 1
		let dx = 0, dz = 0, y = top-1-offset1, x = wx, z = wz
		switch(dir1){
			case 0: dx = 1; break
			case 1: dz = 1; break
			case 2: dx = -1; break
			case 3: dz = -1; break
		}
		for(let i=0; i<branch1; i++){
			x += dx, z += dz, y++
			world.spawnBlock(x,y,z,tree)
		}
		if(branch1Top){
			y++
			world.spawnBlock(x,y,z,tree)
		}
		let s2 = size1 ** 2
		for(var x2=-size1; x2<size1; x2++){
			for(var y2=size1-2; y2<size1; y2++){
				for(var z2=-size1; z2<size1; z2++){
					let n = x2 * x2 / s2 + y2 * y2 / s2 + z2 * z2 / s2
					if (n < 1) {
						world.spawnBlock(x+x2, y-1+y2, z+z2, leaf)
					}
				}
			}
		}

		if(!branch1 && !branch2 || dir1 === dir2) return
		//branch 2
		dx = 0, dz = 0, y = top-1-offset2, x = wx, z = wz
		switch(dir2){
			case 0: dx = 1; break
			case 1: dz = 1; break
			case 2: dx = -1; break
			case 3: dz = -1; break
		}
		for(let i=0; i<branch2; i++){
			x += dx, z += dz, y++
			world.spawnBlock(x,y,z,tree)
		}
		if(branch2Top){
			y++
			world.spawnBlock(x,y,z,tree)
		}
		s2 = size2 ** 2
		for(var x2=-size2; x2<size2; x2++){
			for(var y2=size2-2; y2<size2; y2++){
				for(var z2=-size2; z2<size2; z2++){
					let n = x2 * x2 / s2 + y2 * y2 / s2 + z2 * z2 / s2
					if (n < 1) {
						world.spawnBlock(x+x2, y-1+y2, z+z2, leaf)
					}
				}
			}
		}
	}
	spawnBigAcacia(i,ground,k,wx,wz){
		let {type, world} = this
		let top = ground + floor(random(14,20))
		let tree = blockIds.acaciaLog
		let leaf = blockIds.acaciaLeaves
		let sw = blockData[tree].swId
		for (let j = ground + 1; j < top; j++) {
			this.setBlock(i, j, k, tree)
		}
		for (let j = top-6; j < top; j++) {//branches
			if(j === top-1 || random()>0.5){
				let dir = floor(random(16))
				let dx = 0, dz = 0, dy = ((dir>>2)+1)/4, y = j, x = wx, z = wz, rot
				switch(dir&3){
					case 0: dx = 1; rot = EAST; break
					case 1: dz = 1; rot = NORTH; break
					case 2: dx = -1; rot = WEST; break
					case 3: dz = -1; rot = SOUTH; break
				}
				let length = (1-dy+0.25)*8
				for(let l=0; l<length; l++){
					x += dx, z += dz, y += dy
					world.spawnBlock(x,round(y),z,sw|rot)
				}
				y = round(y)
				for(var x2=-8; x2<8; x2++){
					for(var y2=6; y2<8; y2++){
						for(var z2=-8; z2<8; z2++){
							let n = x2 * x2 / 64 + y2 * y2 / 64 + z2 * z2 / 64
							if (n < 1) {
								world.spawnBlock(x+x2, y-6+y2, z+z2, leaf)
							}
						}
					}
				}
			}
		}
	}
	spawnDisk(wx,wz, replace, block, underBlock = block, radius){
		let {type, world} = this
		let r2 = radius**2
		let maxY = world.getSolidTop(wx,wz)+10
		for(let x2=-radius; x2<radius; x2++){
			for(let z2=-radius; z2<radius; z2++){
				let n = x2 * x2 / r2 + z2 * z2 / r2
				if (n < 1) {
					let y = world.getSolidTop(wx+x2,wz+z2)
					if(y>maxY) continue
					let blockHere = world.getBlock(wx+x2, y, wz+z2)
					if(!replace.includes(blockHere)) continue
					let under = block !== underBlock && world.getBlock(wx+x2, y+1, wz+z2)
					world.spawnBlock(wx+x2, y, wz+z2, under ? underBlock : block, true)
				}
			}
		}
	}
	spawnRock(X,Y,Z,type){
		const {world} = this
		let oreWeirdness, oreW, oreH
		if(type === "big"){
			oreWeirdness = 0.02, oreW = 16, oreH = 12
		}else if(type === "mossy" || type === "small"){
			oreWeirdness = 0.1, oreW = oreH = 3
		}else if(type === "medium"){
			oreWeirdness = 0.04, oreW = 8, oreH = 4
		}else if(type === "flat"){
			oreWeirdness = 0.01, oreW = 10, oreH = 4
		}
		let block
		for(let x=-oreW;x<oreW;x++){
			for(let z=-oreW;z<oreW;z++){
				const horizontalSubtract = ((x/oreW)**2 + (z/oreW)**2)**2
				for(let y=oreH-1;y>=-oreH;y--){
					if(blockData[world.getBlock(X+x,Y+y,Z+z)].solid) break //Skip to next column
					const n = mapClamped(this.world.world.noiseProfile.noise((X+x)*oreWeirdness*4,(Y+y)*oreWeirdness*1.5,(Z+z)*oreWeirdness*4),0.1,0.7)
					//const n2 = this.world.noiseProfile.noise((Y+y)*oreWeirdness,(Z+z)*oreWeirdness*4,(X+x)*oreWeirdness*4)
					const subtract = ((y+oreH)/oreH/2) + horizontalSubtract//preferMiddle((y+oreH)/oreH/2, 0.1, 0,1)
					if(n>subtract){
						if(type === "mossy"){
							block = blockIds.mossyCobble
						}else if(type === "small"){
							block = blockIds.cobblestone
						}else if(type === "flat"){
							if(!world.getBlock(X+x,Y+y+1,Z+z) && this.world.world.caveNoise((X+x)*0.5,(Y+y)*0.5,(Z+z)*0.5) > 0.65){
								block = blockIds.grass
							}else{
								block = blockIds.limestone
							}
						}else{
							if(!world.getBlock(X+x,Y+y+1,Z+z) && this.world.world.caveNoise((X+x)*0.25,(Y+y)*0.25,(Z+z)*0.25) > 0.6){
								block = blockIds.grass
								if(random()>0.75) world.spawnBlock(X+x,Y+y+1,Z+z, blockIds.TallGrass, this.type, true)
							}else{
								block = blockIds.stone
							}
						}
						world.spawnBlock(X+x,Y+y,Z+z,block, true)
						//const under = world.getBlock(X+x,Y+y-1,Z+z)
						//if(under === blockIds.grass || under === (blockIds.grass|CROSS) || under === blockIds.podzol || under === blockIds.mycelium){
						//	world.spawnBlock(X+x,Y+y-1,Z+z,blockIds.dirt, true)
						//}
						if(y === -oreH){
							let y2 = Y+y-1, under = 0
							if(block === blockIds.grass) block = blockIds.dirt
							while(Y+y-y2<64 && !blockData[under].solid || under === blockIds.dirt || under === blockIds.grass || under === (blockIds.grass|CROSS) || under === blockIds.podzol || under === blockIds.mycelium){
								world.spawnBlock(X+x,y2,Z+z,block, true)
								y2--
								under = world.getBlock(X+x,y2,Z+z)
							}
						}
					}
				}
			}
		}
	}
	generatePatch(X,Y,Z,size,blocks){
		let {world} = this
		for(let x=-size;x<=size;x++){
			for(let y=size;y>=-size;y--){
				for(let z=-size;z<=size;z++){
					let blockHere = blockData[world.getBlock(X+x,Y+y,Z+z)]
					if(hash3(X+x,Y+y,Z+z)*((x/size)**2+(y/size)**2+(z/size)**2) < 0.5 && !blockHere.solid && !blockHere.liquid && blockData[world.getBlock(X+x,Y+y-1,Z+z)].type === "ground"){
						world.spawnBlock(X+x,Y+y,Z+z,blocks[floor(random(blocks.length))],true)
					}
				}
			}
		}
	}
	spawnBigBirch(i,ground,k,wx,wz,tall){
		let {type, world} = this
		let top = ground + (tall ? floor(random(16,20)) : floor(random(6,10)))
		let tree = tall ? blockIds.birchLog : blockIds.birchLog|WALLPOST
		let leaf = blockIds.birchLeaves

		//Center
		for (let j = ground + 1; j <= top; j++) {
			this.setBlock(i, j, k, tree)
		}
		this.setBlock(i, ground, k, blockIds.dirt)

		for(let b=0; b<16; b++){
			let j = round(lerp(random()**3,top+2,(top+ground)*0.5))
			let rot = hash3(i,b,k)*Math.PId
			let dx = sin(rot), dz = cos(rot)
			if(tall) for(let l=0; l<6; l++){
				world.spawnBlock(round(wx+dx*l),round(j+l*-0.5),round(wz+dz*l),leaf)
				world.spawnBlock(round(wx+dx*l+1),round(j+l*-0.5),round(wz+dz*l),leaf)
				world.spawnBlock(round(wx+dx*l-1),round(j+l*-0.5),round(wz+dz*l),leaf)
				world.spawnBlock(round(wx+dx*l),round(j+l*-0.5),round(wz+dz*l+1),leaf)
				world.spawnBlock(round(wx+dx*l),round(j+l*-0.5),round(wz+dz*l-1),leaf)
				world.spawnBlock(round(wx+dx*l),round(j+l*+0.5),round(wz+dz*l),leaf)
				world.spawnBlock(round(wx+dx*l),round(j+l*-1.5),round(wz+dz*l),leaf)
			}else for(let l=0; l<6; l++){
				world.spawnBlock(round(wx+dx*l),round(j+l*-0.5),round(wz+dz*l),leaf)
			}
		}
		/*let leafBottom = round(lerp(0.25,ground,top)), leafTop = top+4
		for(let y=leafBottom; y<leafTop; y++){
			let w = lerp((y-leafBottom)/(leafTop-leafBottom),0,1-(1-(leafTop-y)/(leafTop-leafBottom))**4)*8
			let w2 = w**2
			for(let x2=floor(-w); x2<=ceil(w); x2++){
				for(let z2=floor(-w); z2<=ceil(w); z2++){
					let n = x2 * x2 / w2 + z2 * z2 / w2
					n += this.world.caveNoise((wx+x2)*1.5, y*1.5, (wz+z2)*1.5)
					if (n < 1) {
						world.spawnBlock(wx+x2, y, wz+z2, leaf)
					}
				}
			}
		}*/
		/*let w = 5, h = tall?10:6
		let w2 = w**2, h2 = h**2
		for(let x2=-w; x2<=w; x2++){
			for(let z2=-w; z2<=w; z2++){
				for(let y2=-h; y2<=h; y2++){
					let x = x2, z = z2
					if(y2 < 0){//make thinner
						x *= 1-y2/h
						z *= 1-y2/h
					}
					let n = x * x / w2 + z * z / w2 + y2 * y2 / h2
					n += this.world.caveNoise((wx+x2)*1.5, (top+y2)*1.5, (wz+z2)*1.5)*1.25
					if (n < 1) {
						world.spawnBlock(wx+x2, top+y2, wz+z2, leaf)
					}
				}
			}
		}*/
	}
	spawnShrub(i,ground,k,wx,wz,leafType){
		let {type, world} = this
		let sides = random()>0.5
		let tree, leaf
		let treeType = leafType === "big" ? round(lerp(random()**2,0,2)) : (leafType === "wet" ? 0 : round(random(-1,0)))
		switch(treeType){
			case -1:
				tree = blockIds.acaciaLog, leaf = blockIds.acaciaLeaves
				break
			case 0:
				tree = blockIds.oakLog, leaf = blockIds.oakLeaves
				break
			case 1:
				tree = blockIds.oakLog, leaf = blockIds.redBerryLeaves
				break
			case 2:
				tree = blockIds.oakLog, leaf = blockIds.blueBerryLeaves
				break
		}
		this.setBlock(i,ground+1,k,leaf)
		if(sides){
			this.setBlock(i,ground+2,k,leaf|SLAB)
			world.spawnBlock(wx,ground+1,wz-1,leaf|VERTICALSLAB|NORTH)
			world.spawnBlock(wx,ground+1,wz+1,leaf|VERTICALSLAB|SOUTH)
			world.spawnBlock(wx-1,ground+1,wz,leaf|VERTICALSLAB|EAST)
			world.spawnBlock(wx+1,ground+1,wz,leaf|VERTICALSLAB|WEST)
		}
	}
	spawnBush(i,ground,k,wx,wz,leafType){
		let {type, world} = this
		let rand = floor(random(4096))
		let tree, leaf, leaf2
		let treeType = leafType === "big" ? round(lerp(random()**2,0,2)) : (leafType === "wet" ? 0 : round(random(-1,0)))
		let big = leafType === "big"
		switch(treeType){
			case -1:
				tree = blockIds.acaciaLog, leaf = blockIds.acaciaLeaves
				break
			case 0:
				tree = blockIds.oakLog, leaf = blockIds.oakLeaves
				break
			case 1:
				tree = blockIds.oakLog, leaf = blockIds.redBerryLeaves, leaf2 = leaf|FENCE
				break
			case 2:
				tree = blockIds.oakLog, leaf = blockIds.blueBerryLeaves, leaf2 = leaf|FENCE
				break
		}
		
		let w = big ? random(2,5) : random(2,3), h = big ? w*0.9 : lerp(random()**2,0,4)
		let top = floor(h*0.75)+ground
		for (let j = ground + 1; j <= top; j++) {
			this.setBlock(i, j, k, tree)
		}
		this.setBlock(i, ground, k, blockIds.rootedDirt)

		let w2 = w**2, h2 = h**2
		for(let x2=floor(-w); x2<=ceil(w); x2++){
			for(let z2=floor(-w); z2<=ceil(w); z2++){
				for(let y2=floor(-h); y2<=ceil(h); y2++){
					let x = x2, z = z2
					if(y2 < 0){//make thinner
						x *= 1-y2/h*2
						z *= 1-y2/h*2
					}
					let n = x * x / w2 + z * z / w2 + y2 * y2 / h2
					if(n > 0.6){
						n += this.world.world.caveNoise((wx+x2)*2, (top+y2), (wz+z2)*2)*0.4
					}
					if (n < 1) {
						world.spawnBlock(wx+x2, top+y2, wz+z2, leaf2 && hash3(wx+x2, top+y2, wz+z2) > 0.2 ? leaf2 : leaf)
					}
				}
			}
		}
	}
	spawnDarkOak(i,ground,k,wx,wz){
		let {type, world} = this
		let top = ground+round(random(12,18))
		let tree = blockIds.darkOakLog, leaf = blockIds.darkOakLeaves
		let hasLight = random()>0.85
		let offX, offZ, pOffX, pOffZ
		for (let j = ground + 1; j < top; j++) {
			pOffX = offX, pOffZ = offZ
			offX = round(lerp(Math.min((j-ground-1)*0.25,1),0,world.world.noiseProfile.generator.noise3d(wx,j*0.05,wz))*8)
			offZ = round(lerp(Math.min((j-ground-1)*0.25,1),0,world.world.noiseProfile.generator.noise3d(wx,-j*0.05,wz)*8))
			world.spawnBlock(wx+offX, j, wz+offZ, tree)
			world.spawnBlock(wx + 1+offX, j, wz+offZ, tree)
			world.spawnBlock(wx+offX, j, wz + 1+offZ, tree)
			world.spawnBlock(wx+1+offX, j, wz+1+offZ, tree)
			if(pOffX !== offX || pOffZ !== offZ){
				world.spawnBlock(wx+offX, j-1, wz+offZ, tree)
				world.spawnBlock(wx + 1+offX, j-1, wz+offZ, tree)
				world.spawnBlock(wx+offX, j-1, wz + 1+offZ, tree)
				world.spawnBlock(wx+1+offX, j-1, wz+1+offZ, tree)
			}
		}
		world.spawnBlock(wx, ground, wz, blockIds.dirt, true)
		world.spawnBlock(wx + 1, ground, wz, blockIds.dirt, true)
		world.spawnBlock(wx, ground, wz + 1, blockIds.dirt, true)
		world.spawnBlock(wx+1, ground, wz+1, blockIds.dirt, true)

		let topX = wx+offX, topZ = wz+offZ
		let branch = []
		for(let b=0; b<4; b++){//branches
			let endX = topX+round(random(-6,6))
			let endZ = topZ+round(random(-6,6))
			let startY = round(random(max(ground+5,top-16),top-5))
			let startX = wx+round(world.world.noiseProfile.generator.noise3d(wx,startY*0.05,wz)*8)
			let startZ = wz+round(world.world.noiseProfile.generator.noise3d(wx,-startY*0.05,wz)*8)
			branch.length = 0
			line3D(endX,top,endZ,startX,startY,startZ,branch)
			for(let bi=0; bi<branch.length; bi+=3){
				world.spawnBlock(branch[bi],branch[bi+1],branch[bi+2],tree)
			}
		}

		let w = 10, h = 5
		let w2 = w**2, h2 = h**2
		for(let x2=-w; x2<=w+1; x2++){
			for(let z2=-w; z2<=w+1; z2++){
				for(let y2=-h; y2<=h; y2++){
					let x = x2-0.5, z = z2-0.5
					if(y2 < 0){//make thinner
						x *= 1-y2/h*2
						z *= 1-y2/h*2
					}
					let n = x * x / w2 + z * z / w2 + y2 * y2 / h2
					if(n > 0.6){
						n += this.world.world.caveNoise((topX+x2)*0.4, (top+y2), (topZ+z2)*0.4)*0.4
					}
					if (n < 1) {
						world.spawnBlock(topX+x2, top+y2, topZ+z2, leaf)
						if(n>0.75 && hash3(topX+x2, top+y2, topZ+z2) > 0.75){
							worldGenArray.add(topX+x2, top+y2, topZ+z2,blockIds.vine)
							if(hasLight && !world.getBlock(topX+x2, top+y2-1, topZ+z2) && hash3(topX+x2, top+y2, topZ+z2) > 0.9){
								let length = round(random(5,12))
								for(let l=1; l<length; l++){
									world.spawnBlock(topX+x2, top+y2-l, topZ+z2, hash3(topX+x2, top+y2-l, topZ+z2)>0.75 ? blockIds.caveVinesPlantLit : blockIds.caveVinesPlant)
								}
								world.spawnBlock(topX+x2, top+y2-length, topZ+z2, hash3(topX+x2, top+y2-length, topZ+z2)>0.75 ? blockIds.caveVinesLit : blockIds.caveVines)
							}
						}
					}
				}
			}
		}
	}
	spawnHugeMushroomPiece3x3(x,y,z,dx,dz,rot,nextRot,mushroom){
		let {type, world} = this
		world.spawnBlock(x-dx,y,z-dz,mushroom|PANE|rot)
		world.spawnBlock(x,y,z,mushroom|DOOR|rot)
		world.spawnBlock(x+dx,y,z+dz,mushroom|PANE|nextRot)

		world.spawnBlock(x-dx,y-1,z-dz,mushroom|PORTAL|rot)
		world.spawnBlock(x,y-1,z,mushroom|WALLFLAT|rot)
		world.spawnBlock(x+dx,y-1,z+dz,mushroom|PORTAL|nextRot)
		world.spawnBlock(x-dx,y-2,z-dz,mushroom|PORTAL|rot)
		world.spawnBlock(x,y-2,z,mushroom|WALLFLAT|rot)
		world.spawnBlock(x+dx,y-2,z+dz,mushroom|PORTAL|nextRot)
	}
	spawnHugeMushroom(i,ground,k,wx,wz,isBrown){
		let {type, world} = this
		let height = round(random(5,9))
		if(random()<0.1) height *= 2
		let top = ground+height
		for (let j = ground + 1; j < top; j++) {
			this.setBlock(i, j, k, blockIds.mushroomStem | TALLCROSS)
		}
		this.setBlock(i, ground, k, blockIds.dirt)
		if(isBrown){//Brown mushroom (flat)
			let mushroom = blockIds.brownMushroomBlock
			world.spawnBlock(wx+3,top,wz-2,mushroom|PANE|EAST)
			world.spawnBlock(wx+3,top,wz-1,mushroom|DOOR|EAST)
			world.spawnBlock(wx+3,top,wz,mushroom|DOOR|EAST)
			world.spawnBlock(wx+3,top,wz+1,mushroom|DOOR|EAST)
			world.spawnBlock(wx+3,top,wz+2,mushroom|PANE|NORTH)
			
			world.spawnBlock(wx+2,top,wz+3,mushroom|PANE|NORTH)
			world.spawnBlock(wx+1,top,wz+3,mushroom|DOOR|NORTH)
			world.spawnBlock(wx,top,wz+3,mushroom|DOOR|NORTH)
			world.spawnBlock(wx-1,top,wz+3,mushroom|DOOR|NORTH)
			world.spawnBlock(wx-2,top,wz+3,mushroom|PANE|WEST)

			world.spawnBlock(wx-3,top,wz+2,mushroom|PANE|WEST)
			world.spawnBlock(wx-3,top,wz+1,mushroom|DOOR|WEST)
			world.spawnBlock(wx-3,top,wz,mushroom|DOOR|WEST)
			world.spawnBlock(wx-3,top,wz-1,mushroom|DOOR|WEST)
			world.spawnBlock(wx-3,top,wz-2,mushroom|PANE|SOUTH)

			world.spawnBlock(wx-2,top,wz-3,mushroom|PANE|SOUTH)
			world.spawnBlock(wx-1,top,wz-3,mushroom|DOOR|SOUTH)
			world.spawnBlock(wx,top,wz-3,mushroom|DOOR|SOUTH)
			world.spawnBlock(wx+1,top,wz-3,mushroom|DOOR|SOUTH)
			world.spawnBlock(wx+2,top,wz-3,mushroom|PANE|EAST)
			for(let x=-2; x<=2; x++){
				for(let z=-2; z<=2; z++){
					world.spawnBlock(wx+x,top,wz+z,mushroom|STAIR)
				}
			}
		}else{
			let mushroom = blockIds.redMushroomBlock
			world.spawnBlock(wx,top,wz,mushroom|STAIR)
			world.spawnBlock(wx+1,top,wz,mushroom|DOOR|EAST)
			world.spawnBlock(wx-1,top,wz,mushroom|DOOR|WEST)
			world.spawnBlock(wx,top,wz+1,mushroom|DOOR|NORTH)
			world.spawnBlock(wx,top,wz-1,mushroom|DOOR|SOUTH)
			world.spawnBlock(wx+1,top,wz-1,mushroom|PANE|EAST)
			world.spawnBlock(wx-1,top,wz+1,mushroom|PANE|WEST)
			world.spawnBlock(wx+1,top,wz+1,mushroom|PANE|NORTH)
			world.spawnBlock(wx-1,top,wz-1,mushroom|PANE|SOUTH)
			this.spawnHugeMushroomPiece3x3(wx+2,top-1,wz,0,1,EAST,NORTH,mushroom)
			this.spawnHugeMushroomPiece3x3(wx,top-1,wz+2,-1,0,NORTH,WEST,mushroom)
			this.spawnHugeMushroomPiece3x3(wx-2,top-1,wz,0,-1,WEST,SOUTH,mushroom)
			this.spawnHugeMushroomPiece3x3(wx,top-1,wz-2,1,0,SOUTH,EAST,mushroom)
		}
	}
	spawnCherryTree(i,ground,k,wx,wz){
		let {type, world} = this
		this.setBlock(i, ground, k, blockIds.dirt)
		let branchCount = round(random(1,3))
		let tree = blockIds.cherryLog
		let treeSW = blockIds.cherryLogSW
		let leaf = blockIds.cherryLeaves
		let top = ground+7
		let branches = [wx,top,wz], branch = []
		for(let y=ground; y<top; y++){
			this.setBlock(i,y,k,tree)
		}
		this.setBlock(i,ground,k,blockIds.dirt)
		for(let b=0; b<branchCount; b++){
			let startY = top-round(random(3,4))
			let endY = top-round(random())
			let branchLength = round(random(2,4))
			let dx = 0, dz = 0, rot
			switch(round(random(3))){
				case 0:
					dx = 1, rot = EAST
					break
				case 1:
					dz = 1, rot = NORTH
					break
				case 2:
					dx = -1, rot = WEST
					break
				case 3:
					dz = -1, rot = SOUTH
					break
			}
			branches.push(wx+dx*branchLength,endY,wz+dz*branchLength)
			if(random()>0.5){
				branch.length = 0
				line3DConncected(wx+dx*branchLength,endY,wz+dz*branchLength,wx,startY,wz,branch)
				let swornot = (endY-startY)/branchLength >= 1 ? tree : treeSW|rot
				for(let bi=0; bi<branch.length; bi+=3){
					world.spawnBlock(branch[bi],branch[bi+1],branch[bi+2],swornot)
				}
			}else{
				for(let bi=0; bi<=branchLength; bi++){
					world.spawnBlock(wx+dx*bi,startY,wz+dz*bi,treeSW|rot)
				}
				for(let y=startY; y<endY; y++){
					world.spawnBlock(wx+dx*branchLength,y,wz+dz*branchLength,tree)
				}
			}
		}
		for(let b=0; b<branches.length; b+=3){
			let x = branches[b], y = branches[b+1], z = branches[b+2]
			let w = 5, h = 2.5
			let w2 = w**2, h2 = h**2
			for(let x2=-w; x2<=w; x2++){
				for(let z2=-w; z2<=w; z2++){
					for(let y2=floor(-h); y2<=ceil(h); y2++){
						let n = x2 * x2 / w2 + z2 * z2 / w2 + y2 * y2 / h2
						if(n > 0.5) n += this.world.world.caveNoise((wx+x2)*1.5, (top+y2)*1.5, (wz+z2)*1.5)*0.5
						if (n < 1) {
							world.spawnBlock(x+x2, y+y2, z+z2, leaf)
							if(!world.getBlock(x+x2,y+y2-1,z+z2)){//hanging leaves
								let length = round(lerp(hash3(x+x2,y+y2,z+z2),-1,1.8))
								if(length>0){
									world.spawnBlock(x+x2, y+y2-1, z+z2, leaf)
									if(length>1) world.spawnBlock(x+x2, y+y2-2, z+z2, leaf)
								}
							}
						}
					}
				}
			}
		}
	}
	spawnSwampOak(i,ground,k,wx,wz){
		let place
		let {type, world} = this
		let top = ground + floor(4.5 + random(2.5))
		let rand = floor(random(4096))
		let tree = blockIds.oakLog
		let leaf = blockIds.oakLeaves

		//Center
		for (let j = ground + 1; j <= top; j++) {
			this.setBlock(i, j, k, tree)
		}
		this.setBlock(i, top + 1, k, leaf)
		this.setBlock(i, ground, k, blockIds.dirt)

		//Bottom leaves
		for (let x = -3; x <= 3; x++) {
			for (let z = -3; z <= 3; z++) {
				if (x || z) {
					if (abs(x) === 3 && abs(z) === 3) {
						place = rand & 1
						rand >>>= 1
						if (place) {
							world.spawnBlock(wx + x, top - 2, wz + z, leaf)
							worldGenArray.add(wx + x, top - 2, wz + z, blockIds.vine)
							worldGenArray.add(wx + x, top - 2, wz + z, blockIds.vine)
						}
					} else {
						world.spawnBlock(wx + x, top - 2, wz + z, leaf)
						worldGenArray.add(wx + x, top - 2, wz + z, blockIds.vine)
						worldGenArray.add(wx + x, top - 2, wz + z, blockIds.vine)
					}
				}
			}
		}

		//2nd layer leaves
		for (let x = -3; x <= 3; x++) {
			for (let z = -3; z <= 3; z++) {
				if (x || z) {
					if (abs(x) === 3 && abs(z) === 3) {
						place = rand & 1
						rand >>>= 1
						if (place) {
							world.spawnBlock(wx + x, top - 1, wz + z, leaf)
							worldGenArray.add(wx + x, top - 1, wz + z, blockIds.vine)
							worldGenArray.add(wx + x, top - 1, wz + z, blockIds.vine)
						}
					} else {
						world.spawnBlock(wx + x, top - 1, wz + z, leaf)
						worldGenArray.add(wx + x, top - 1, wz + z, blockIds.vine)
						worldGenArray.add(wx + x, top - 1, wz + z, blockIds.vine)
					}
				}
			}
		}

		//3rd layer leaves
		for (let x = -2; x <= 2; x++) {
			for (let z = -2; z <= 2; z++) {
				if (x || z) {
					if (abs(x) === 2 && abs(z) === 2) {
						place = rand & 1
						rand >>>= 1
						if (place) {
							world.spawnBlock(wx + x, top, wz + z, leaf)
							worldGenArray.add(wx + x, top, wz + z, blockIds.vine)
						}
					} else {
						world.spawnBlock(wx + x, top, wz + z, leaf)
						worldGenArray.add(wx + x, top, wz + z, blockIds.vine)
					}
				}
			}
		}

		//Top leaves
		for (let x = -2; x <= 2; x++) {
			for (let z = -2; z <= 2; z++) {
				if ((x || z) && (abs(x) !== 2 || abs(z) !== 2)) {
					world.spawnBlock(wx + x, top+1, wz + z, leaf)
					worldGenArray.add(wx + x, top+1, wz + z, blockIds.vine)
				}
			}
		}
	}
	spawnIceberg(wx,wz){
		let {type, world} = this
		let topH = random()>0.1 ? round(random(10,42)) : round(random(3,17))
		let bottomH = round(random(3,18))
		let radius = round((topH+bottomH)/8)
		let iceRnd = random()
		let ice = iceRnd>0.99 ? blockIds.blueIce : (iceRnd>0.9 ? blockIds.packedIce : blockIds.ice)
		let w2 = radius**2
		for(let x2=-radius; x2<=radius; x2++){
			for(let y2=-bottomH; y2<=topH; y2++){
				for(let z2=-radius; z2<=radius; z2++){
					let n = x2 * x2 / w2 + z2 * z2 / w2 + y2 * y2 / (y2>0 ? topH : bottomH)
					if(n > 0.5) n += this.world.world.caveNoise((wx+x2)*1.5, (waterHeight+y2)*1.5, (wz+z2)*1.5)*0.5
					if (n < 1) {
						world.spawnBlock(wx+x2, waterHeight+y2, wz+z2, ice)
					}
				}
			}
		}
	}
	/*spawnAquifer(){ //Unused because it can affect ores and trees differntly each load
		let {type, world} = this
		let ax = 6//floor(random(16))+this.x
		let az = 8//floor(random(16))+this.z
		let ay = 12//floor(random(minHeight,this.tops[az*16+ax]))
		if(world.getBlock(ax,ay,az,type)) return
		let aquiferSpreadAt = [ax,ay,az,0], aquiferSpreaded = 0
		let maxHeight = ay //Will get lower if the aquifer overflows so that it doesn't overflow
		let maxDist = 16**2
		let barrierDist = 15**2
		let dist
		while(aquiferSpreadAt.length){
			let [x,y,z] = aquiferSpreadAt.splice(0,4)
			if(y > maxHeight) continue //Prevent doing extra unneeded stuff
			dist = (ax-x)**2 + (ay-y)**2 + (az-z)**2
			if(dist > maxDist){
				maxHeight = min(maxHeight, world.getTop(x,z)) //Prevent overflow if outside cave
			}else{
				if(!world.getBlock(x+1,y,z) && !xyArrayHas(aquiferSpreadAt,bigArray,x+1,y,z,undefined,aquiferSpreaded)) aquiferSpreadAt.push(x+1,y,z,0)
				if(!world.getBlock(x-1,y,z) && !xyArrayHas(aquiferSpreadAt,bigArray,x-1,y,z,undefined,aquiferSpreaded)) aquiferSpreadAt.push(x-1,y,z,0)
				if(!world.getBlock(x,y,z+1) && !xyArrayHas(aquiferSpreadAt,bigArray,x,y,z+1,undefined,aquiferSpreaded)) aquiferSpreadAt.push(x,y,z+1,0)
				if(!world.getBlock(x,y,z-1) && !xyArrayHas(aquiferSpreadAt,bigArray,x,y,z-1,undefined,aquiferSpreaded)) aquiferSpreadAt.push(x,y,z-1,0)
				if(!world.getBlock(x,y-1,z) && !xyArrayHas(aquiferSpreadAt,bigArray,x,y-1,z,undefined,aquiferSpreaded)) aquiferSpreadAt.push(x,y-1,z,0)
			}
			bigArray[aquiferSpreaded++] = x
			bigArray[aquiferSpreaded++] = y
			bigArray[aquiferSpreaded++] = z
			bigArray[aquiferSpreaded++] = dist>barrierDist
		}
		console.log(ax,ay,az,aquiferSpreaded)
		for(let i=0; i<aquiferSpreaded; i+=4){
			if(bigArray[i+1] > maxHeight) continue
			let x = bigArray[i], y = bigArray[i+1], z = bigArray[i+2]
			let barrier = bigArray[i+3]
			world.spawnBlock(x,y,z,barrier?blockIds.stone:blockIds.Water,true)
		}
	}*/
	/*spawnAmethystGeode(X,Y,Z){
		const {world} = this
		let oreSegments = 4, oreWeirdness = 1, oreSize = 9
		//https://www.khanacademy.org/computer-programming/ore-generator/6387555023765504
		let balls=[],bx=0,by=0,bz=0;
		let dx=random()*2-1,dy=1,dz=random()*2-1;
		for(let i=0;i<oreSegments;i++){
			let d=Math.hypot(dx,dy,dz);
			dx /= d;
			dy /= d;
			dz /= d;
			balls.push(bx,by,bz);
			bx += dx*oreWeirdness;
			by += dy*oreWeirdness;
			bz += dz*oreWeirdness;
			if(bx>oreSize){
				bx = -oreSize;
			}
			if(bx<-oreSize){
				bx = oreSize;
			}
			if(by>oreSize){
				by = -oreSize;
			}
			if(by<-oreSize){
				by = oreSize;
			}
			if(bz>oreSize){
				bz = -oreSize;
			}
			if(bz<-oreSize){
				bz = oreSize;
			}
			dx=random()*2-1;
			dy=random()*2-1;
			dz=random()*2-1;
		}
		let buds = []
		for(let x=-oreSize;x<=oreSize;x++){
			for(let y=oreSize;y>=-oreSize;y--){
				for(let z=-oreSize;z<=oreSize;z++){
					let d=0;
					for(let i=0; i<balls.length; i+=3){
						d += 1/dist3(balls[i],balls[i+1],balls[i+2],x,y,z);
					}
					if(d>0.8){
						world.spawnBlock(X+x,Y+y,Z+z,0,true)
					}else if(d>0.7){
						let bud = random()>0.8
						world.spawnBlock(X+x,Y+y,Z+z, bud?blockIds.buddingAmethyst:blockIds.amethystBlock,true)
						if(bud) buds.push(X+x,Y+y,Z+z)
					}else if(d>0.6){
						world.spawnBlock(X+x,Y+y,Z+z,blockIds.calcite,true)
					}else if(d>0.5){
						world.spawnBlock(X+x,Y+y,Z+z,blockIds.smoothBasalt,true)
					}
				}
			}
		}
		for(let i=0; i<buds.length; i+=3){
			let x = buds[i], y = buds[i+1], z = buds[i+2]
			let type = round(random(3))
			let block
			switch(type){
				case 0:
					block = blockIds.amethystCluster
					break
				case 1:
					block = blockIds.smallAmethystBud
					break
				case 2:
					block = blockIds.mediumAmethystBud
					break
				case 3:
					block = blockIds.largeAmethystBud
					break
			}
			world.spawnBlock(x,y+1,z,block|CROSS)
			world.spawnBlock(x,y-1,z,block|SLAB)
			world.spawnBlock(x+1,y,z,block|WEST)
			world.spawnBlock(x-1,y,z,block|EAST)
			world.spawnBlock(x,y,z+1,block|SOUTH)
			world.spawnBlock(x,y,z-1,block|NORTH)
		}
	}*/
	patches = {
		flowers:[blockIds.poppy,blockIds.dandelion],
		forestFlowers:[blockIds.poppy,blockIds.dandelion,blockIds.lilac,blockIds.roseBush,blockIds.peony,blockIds.lilyOftheValley],
		plainsFlowers:[blockIds.poppy,blockIds.poppy,blockIds.azureBluet,blockIds.azureBluet,blockIds.oxeyeDaisy,blockIds.oxeyeDaisy,blockIds.cornFlower,blockIds.cornFlower,blockIds.orangeTulip,blockIds.pinkTulip,blockIds.redTulip,blockIds.whiteTulip],
		flowerForestFlowers:[blockIds.dandelion,blockIds.poppy,blockIds.allium,blockIds.azureBluet,blockIds.orangeTulip,blockIds.pinkTulip,blockIds.redTulip,blockIds.whiteTulip,blockIds.oxeyeDaisy,blockIds.cornFlower,blockIds.lilyOftheValley,blockIds.pinkPetals,blockIds.pinkPetals],
		sunflowerPlainsFlowers:[blockIds.sunflower,blockIds.sunflower,blockIds.sunflower,blockIds.sunflower,blockIds.sunflower,blockIds.sunflower,blockIds.poppy,blockIds.azureBluet,blockIds.oxeyeDaisy,blockIds.cornFlower],
		meadowFlowers:[blockIds.poppy,blockIds.dandelion,blockIds.allium,blockIds.azureBluet,blockIds.cornFlower,blockIds.oxeyeDaisy,blockIds.torchflower],
		pinkPetals:[blockIds.pinkPetals,blockIds.pinkPetals|SLAB,blockIds.pinkPetals|STAIR,blockIds.pinkPetals|DOOR],
		blueOrchids:[blockIds.blueOrchid],

		grass:[blockIds.TallGrass],
		tallGrass:[blockIds.TallGrass,blockIds.DoubleTallGrass],
		fernGrass:[blockIds.fern|SLAB,blockIds.largeFern,blockIds.TallGrass,blockIds.DoubleTallGrass],
		fernBerries:[blockIds.fern|SLAB,blockIds.sweetBerryBush|CROSS,blockIds.largeFern,blockIds.TallGrass,blockIds.TallGrass,blockIds.DoubleTallGrass],
		grassLeaves:[blockIds.driedOakLeaves,blockIds.driedBirchLeaves,blockIds.driedOakLeaves|SLAB,blockIds.TallGrass,blockIds.TallGrass,blockIds.TallGrass,blockIds.TallGrass],
		lushCaves:[blockIds.TallGrass,blockIds.DoubleTallGrass,blockIds.mossCarpet,blockIds.azalea,blockIds.floweringAzalea],
		jungle:[blockIds.TallGrass,blockIds.TallGrass,blockIds.TallGrass,blockIds.TallGrass,blockIds.DoubleTallGrass,blockIds.DoubleTallGrass,blockIds.DoubleTallGrass,blockIds.DoubleTallGrass,blockIds.fern|SLAB,blockIds.fern|SLAB,blockIds.largeFern,blockIds.largeFern,blockIds.mossCarpet,blockIds.azalea,blockIds.floweringAzalea,blockIds.pitcherPlant],
		seagrass:[blockIds.seagrass,blockIds.tallSeagrass],
		grassAndRareTallGrass:[blockIds.TallGrass,blockIds.TallGrass,blockIds.TallGrass,blockIds.DoubleTallGrass],
		mostThickLeaves:[blockIds.driedOakLeaves|SLAB,blockIds.driedOakLeaves,blockIds.driedOakLeaves,blockIds.driedBirchLeaves,blockIds.TallGrass,blockIds.TallGrass,blockIds.driedSpruceLeaves],
		fernGrassSpruceLeaves:[blockIds.driedSpruceLeaves,blockIds.sweetBerryBush|CROSS,blockIds.TallGrass,blockIds.DoubleTallGrass,blockIds.fern|SLAB,blockIds.largeFern],
		mostTallGrass:[blockIds.DoubleTallGrass,blockIds.DoubleTallGrass,blockIds.TallGrass],
		grassLeavesFern:[blockIds.driedBambooLeaves,blockIds.driedBambooLeaves,blockIds.driedBambooLeaves,blockIds.TallGrass,blockIds.fern|SLAB],
		grassLeavesBirch:[blockIds.driedBirchLeaves,blockIds.driedBirchLeaves,blockIds.TallGrass],
		
		dirtOre: {[blockIds.stone]:blockIds.dirt},
		gravelOre: {[blockIds.stone]:blockIds.gravel,[blockIds.deepslate]:blockIds.gravel},
		graniteOre: {[blockIds.stone]:blockIds.granite,[blockIds.deepslate]:blockIds.granite},
		dioriteOre: {[blockIds.stone]:blockIds.diorite,[blockIds.deepslate]:blockIds.diorite},
		andesiteOre: {[blockIds.stone]:blockIds.andesite,[blockIds.deepslate]:blockIds.andesite},
		tuffOre: {[blockIds.stone]:blockIds.tuff,[blockIds.deepslate]:blockIds.tuff},
		coalOre: {[blockIds.stone]:blockIds.coalOre,[blockIds.deepslate]:blockIds.deepslateCoalOre},
		ironOre: {[blockIds.stone]:blockIds.ironOre,[blockIds.deepslate]:blockIds.deepslateIronOre},
		copperOre: {[blockIds.stone]:blockIds.copperOre,[blockIds.deepslate]:blockIds.deepslateCopperOre},
		redstoneOre: {[blockIds.stone]:blockIds.redstoneOre,[blockIds.deepslate]:blockIds.deepslateRedstoneOre},
		lapisOre: {[blockIds.stone]:blockIds.lapisOre,[blockIds.deepslate]:blockIds.deepslateLapisOre},
		goldOre: {[blockIds.stone]:blockIds.goldOre,[blockIds.deepslate]:blockIds.deepslateGoldOre},
		diamondOre: {[blockIds.stone]:blockIds.diamondOre,[blockIds.deepslate]:blockIds.deepslateDiamondOre},
		emeraldOre: {biomes:["windsweptHills","grove","jaggedPeaks","meadow","frozenPeaks","stonePeaks","windsweptForest","snowySlopes","windsweptGravellyHills","cherryGrove"], [blockIds.stone]:blockIds.emeraldOre,[blockIds.deepslate]:blockIds.deepslateEmeraldOre},
		badlandsGoldOre: {biomes:["badlands,erodedBadlands,woodedBadlands"], [blockIds.stone]:blockIds.goldOre,[blockIds.deepslate]:blockIds.deepslateGoldOre},
		limestoneOre: {[blockIds.stone]:blockIds.limestone,[blockIds.deepslate]:blockIds.limestone},
 		
		//For big spruce & pine
		podzol:{[blockIds.grass]:blockIds.podzol, [blockIds.air]: (x,y,z,dimension) => hash3(x,y,z) > 0.7 || !blockData[this.world.getBlock(x,y-1,z,dimension)].solid || this.world.getBlock(x,y+1,z,dimension) ? undefined : blockIds.driedSpruceLeaves},

		sandDisk:[blockIds.dirt,blockIds.grass,blockIds.coarseDirt,blockIds.rootedDirt],
		clayDisk:[blockIds.dirt],
		dirtDisk:[blockIds.mud,blockIds.clay],
		aboveGroundDisk:[blockIds.grass],

		azaleaLeaves:{0:(x,y,z,dimension) => hash3(x,y,z) > 0.65 ? blockIds.floweringAzaleaLeaves : blockIds.azaleaLeaves},
		mushrooms:[blockIds.redMushroom,blockIds.brownMushroom],
		groundBerries:[blockIds.groundBerries],
		fern:[blockIds.fern|SLAB,blockIds.fern|SLAB,blockIds.fern|SLAB,blockIds.fern|SLAB,blockIds.largeFern]
	}
	async populate() {
		const world = this.world
		const {trees} = world.world
		seedHash(world.worldSeed)
		randomSeed(hash(this.x, this.z) * 210000000)
		const {noiseProfile} = world.world
		let wx = 0, wz = 0, ground = 0
		let trueX = this.x, trueY = this.y, trueZ = this.z
		const type = this.type
		worldGenArray.clear() //generate extras like vines

		if(this.world.customChunkPopulate && !this.world.customChunkPopulate(this)){
		}else if((world.world.worldType === "alpha" || world.world.worldType === "island" || (world.world.worldType === "superflat" && trees)) && type === ""){
			const flowers = this.allFlowers
			const clayReplaceable = [blockIds.dirt, blockIds.stone, blockIds.gravel]
			const dirtReplaceable = [blockIds.stone,blockIds.gravel]
			//let smoothness = generator.smooth, hilliness = generator.height, biomeSmooth = generator.biomeSmooth
			for (let i = 0; i < 16; i++) {
				for (let k = 0; k < 16; k++) {
					wx = this.x + i
					wz = this.z + k

					ground = this.tops[k * 16 + i]
					//biome = superflat ? 0 : noiseProfile.noise((trueX + i) * biomeSmooth, (trueZ + k) * biomeSmooth)
					//var b
					//if(superflat){b = "plains"}else b = getBiome(biome)

					//let nb = getNetherBiome(biome)
					let b = biomes[this.biomes[k * 16 + i]]
					if (trees && random() < 0.01 && type === "" && (b === "a_field" || b === "plains") && this.getBlock(i, ground, k) === blockIds.grass) {
						this.spawnSmallTree(i,ground,k,wx,wz)
					}
					
					if((b === "snowyPlains" || b === "a_snowyField") && trees && random() < 0.01 && type === "" && this.getBlock(i, ground, k)){
						this.spawnSnowSmallTree(i,ground,k,wx,wz)
					}
					
					// Cactus
					if (random() < 0.01 && this.getBlock(i, ground, k) && (b === "a_desert" || b === "desert") && ground > 60 && this.type === "") {
						this.spawnCactus(i,ground,k)
					}
					if (random() < 0.006 && this.getBlock(i, ground, k) && (b === "a_desert" || b === "desert") && ground > 60 && this.type === "") {
						this.setBlock(i,ground+1,k, blockIds.deadBush | CROSS);
					}
					
					// Jungle trees
					if(trees && random() < 0.01 && type === "" && (b === "a_jungle" || b === "a_giantJungle") && this.getBlock(i, ground, k)){
						this.spawnCocoaTree(i,ground,k,wx,wz)
					}
					//Giant jungle trees
					if(trees && random() < 0.01 && type === "" && (b === "a_giantJungle") && this.getBlock(i, ground, k)){
						this.spawnJungleTree(i,ground,k,wx,wz)
					}
					if(trees && random() < 0.015 && type === "" && (b === "a_jungle" || b === "a_giantJungle") && this.getBlock(i, ground, k)){
						let w2 = 3 * 3
						let d2 = 3 * 3
						let h2 = 3 * 3
						for(var x=-3; x<3; x++){
							for(var y=1; y<3; y++){
								for(var z=-3; z<3; z++){
									let n = x * x / w2 + y * y / h2 + z * z / d2
									if (n < 1) {
										world.spawnBlock(wx+x, ground+y, wz+z, blockIds.jungleLeaves)
										worldGenArray.add(wx+x,ground+y,wz+z,blockIds.vine)
									}
								}
							}
						}
						this.setBlock(i, ground+1, k, blockIds.jungleLog)
					}
					
					//flowers and vines
					if (random() < 0.05 && this.getBlock(i, ground, k) === blockIds.grass) {
						var rnd = random()
						var flower
						if(b === "jungle"){
							if(rnd > 0.75){
								flower = blockIds.TallGrass
							}else if(rnd > 0.5){
								flower = blockIds.DoubleTallGrass
							}else if(rnd > 0.25){
								flower = blockIds.fern
							}else{
								flower = blockIds.largeFern
							}
						}else flower = flowers[Math.round(rnd * (flowers.length - 1))]
						world.spawnBlock(wx, ground+1, wz, flower);
					}
					
					//bamboo
					if(random() < 0.2 && this.getBlock(i, ground, k) && b === "a_bambooForest" && ground > 60 && this.type === ""){
						this.spawnBamboo(i,ground,k,wx,wz)
					}
					
					// Blocks of each per chunk in Minecraft
					// Coal: 185.5
					// Iron: 111.5
					// Gold: 10.4
					// Redstone: 29.1
					// Diamond: 3.7
					// Lapis: 4.1
					//there is also copper
					ground -= 4

					if (random() < 3.7 / 256) {
						let y = random() * 16 | 0 + 1
						y = y < ground ? y : ground
						if (this.getBlock(i, y, k)) {
							//this.setBlock(i, y < ground ? y : ground, k, blockIds.diamondOre)
							this.generateOldBlob(blockIds.stone, blockIds.diamondOre, round(random(3, 8)), i,y,k, 10)
						}
					}

					if (random() < 111.5 / 256) {
						let y = random() * 64 | 0 + 1
						y = y < ground ? y : ground
						if (this.getBlock(i, y, k)) {
							//this.setBlock(i, y < ground ? y : ground, k, blockIds.ironOre)
							this.generateOldBlob(blockIds.stone, blockIds.ironOre, round(random(1, 13)), i,y,k, 9)
						}
					}
					
					if (random() < 51 / 256) {
						let y = random() * 64 | 0 + 1
						y = y < ground ? y : ground
						if (this.getBlock(i, y, k)) {
							//this.setBlock(i, y < ground ? y : ground, k, blockIds.copperOre)
							this.generateOldBlob(blockIds.stone, blockIds.copperOre, round(random(1, 16)), i,y,k, 9)
						}
					}

					if (random() < 185.5 / 256) {
						let y = random() * ground | 0 + 1
						y = y < ground ? y : ground
						if (this.getBlock(i, y, k)) {
							//this.setBlock(i, y < ground ? y : ground, k, blockIds.coalOre)
							this.generateOldBlob(blockIds.stone, blockIds.coalOre, round(random(1, 37)), i,y,k, 20)
						}
					}

					if (random() < 10.4 / 256) {
						let y = random() * 32 | 0 + 1
						y = y < ground ? y : ground
						if (this.getBlock(i, y, k)) {
							//this.setBlock(i, y < ground ? y : ground, k, blockIds.goldOre)
							this.generateOldBlob(blockIds.stone, blockIds.goldOre, round(random(1, 13)), i,y,k, 9)
						}
					}

					if (random() < 29.1 / 256) {
						let y = random() * 16 | 0 + 1
						y = y < ground ? y : ground
						if (this.getBlock(i, y, k)) {
							//this.setBlock(i, y < ground ? y : ground, k, blockIds.redstoneOre)
							this.generateOldBlob(blockIds.stone, blockIds.redstoneOre, round(random(1, 10)), i,y,k, 8)
						}
					}

					if (random() < 4.1 / 256) {
						let y = random() * 32 | 0 + 1
						y = y < ground ? y : ground
						if (this.getBlock(i, y, k)) {
							//this.setBlock(i, y < ground ? y : ground, k, blockIds.lapisOre)
							this.generateOldBlob(blockIds.stone, blockIds.lapisOre, round(random(1, 9)), i,y,k, 9)
						}
					}
					
					//clay & dirt
					if (random() < 0.1) {
						let y = random() * ground | 0 + 1
						y = y < ground ? y : ground
						if (this.getBlock(i, y, k)/* && blockData[this.getBlock(i, y+1, k)].name === "Water"*/) {
							this.generateOldBlob(clayReplaceable, blockIds.clay, round(random(20, 40)), i,y,k, 5)
						}
					}
					if (random() < 0.1) {
						let y = random() * ground | 0 + 1
						y = y < ground ? y : ground
						if (this.getBlock(i, y, k)) {
							this.generateOldBlob(dirtReplaceable, blockIds.dirt, round(random(20, 40)), i,y,k, 5)
						}
					}
				}
			}
		}else if(this.type === "nether"){
			for (let i = 0; i < 16; i++) {
				for (let k = 0; k < 16; k++) {
					if (random() < 0.005 && type === "nether" && ground > 79 && (b === "crimsonForest" || b === "warpedForest")){
						this.spawnNetherMushroom(i,ground,k,wx,wz,b)
					}
					var block = this.getBlock(i, ground, k)
					if(random() < 0.05){
						if(block === blockIds.crimsonNylium){
							world.spawnBlock(wx, ground+1, wz, blockIds.crimsonRoots);
						}else if(block === blockIds.warpedNylium){
							world.spawnBlock(wx, ground+1, wz, blockIds.warpedRoots);
						}
					}
					//lava springs
					if(random() < 0.05 && this.getBlock(i,ground,k) && this.type==="nether"){
						let y = round(random(netherHeight))
						if(this.getBlock(i,y,k) && !this.getBlock(i,y-1,k)){
							this.setBlock(this.x+i,y,this.z+k,blockIds.Lava)
							await blockData[blockIds.Lava].spawnFlow(this.x+i,y,this.z+k,world)
						}
					}

					let l
					if(random() < 0.005){
						/*let r = random(12345123451234512345)*3
						let x=wx, y=this.ceils[k * 16 + i], z=wz
						let ri=floor(random(5,15))
						for(l=0; l<ri; l++){
							x += r&1 - 1; r >>>= 1
							y += r&3 - 2; r >>>= 1
							z += r&1 - 1; r >>>= 1
							world.spawnBlock(x,y,z, blockIds.glowstone)
						}*/
						this.generateOldBlob(0, blockIds.glowstone, 20, wx,this.ceils[k * 16 + i],wz, 2)
					}
					
					for(l=0; l<16; l++){
						let x = random(0, 16)
						let y = random(10, 177)
						let z = random(0, 16)
						if(world.getBlock(wx+x,y,wz+z) === blockIds.netherrack && world.getBlock(wx+x,y+1,wz+z) === blockIds.netherrack && world.getBlock(wx+x,y-1,wz+z) === blockIds.netherrack){
							world.setBlock(wx+x,y,wz+z, blockIds.netherQuartzOre)
						}
					}
					
					for(l=0; l<10; l++){
						let x = random(0, 16)
						let y = random(10, 177)
						let z = random(0, 16)
						if(world.getBlock(wx+x,y,wz+z) === blockIds.netherrack && world.getBlock(wx+x,y+1,wz+z) === blockIds.netherrack && world.getBlock(wx+x,y-1,wz+z) === blockIds.netherrack){
							world.setBlock(wx+x,y,wz+z, blockIds.netherGoldOre)
						}
					}
				}
			}
		}else if(this.type === "end"){
			if(!this.x && !this.z){//center
				let top = this.tops[0]
				//pillar
				world.spawnBlock(0,top+1,0,blockIds.bedrock,"end")
				world.spawnBlock(0,top+2,0,blockIds.bedrock,"end")
				world.spawnBlock(0,top+3,0,blockIds.bedrock,"end")
				//torches
				world.spawnBlock(0,top+2,-1,blockIds.torch|SLAB|NORTH,"end")
				world.spawnBlock(0,top+2,1,blockIds.torch|SLAB|SOUTH,"end")
				world.spawnBlock(-1,top+2,0,blockIds.torch|SLAB|EAST,"end")
				world.spawnBlock(1,top+2,0,blockIds.torch|SLAB|WEST,"end")
				//base
				world.spawnBlock(-1,top,-1,blockIds.bedrock,"end")
				world.spawnBlock(-1,top,0,blockIds.bedrock,"end")
				world.spawnBlock(-1,top,1,blockIds.bedrock,"end")
				world.spawnBlock(0,top,-1,blockIds.bedrock,"end")
				world.spawnBlock(0,top,0,blockIds.bedrock,"end")
				world.spawnBlock(0,top,1,blockIds.bedrock,"end")
				world.spawnBlock(1,top,-1,blockIds.bedrock,"end")
				world.spawnBlock(1,top,0,blockIds.bedrock,"end")
				world.spawnBlock(1,top,1,blockIds.bedrock,"end")

				world.spawnBlock(-1,top,-2,blockIds.bedrock,"end")
				world.spawnBlock(0,top,-2,blockIds.bedrock,"end")
				world.spawnBlock(1,top,-2,blockIds.bedrock,"end")
				world.spawnBlock(-1,top,2,blockIds.bedrock,"end")
				world.spawnBlock(0,top,2,blockIds.bedrock,"end")
				world.spawnBlock(1,top,2,blockIds.bedrock,"end")
				world.spawnBlock(2,top,-1,blockIds.bedrock,"end")
				world.spawnBlock(2,top,0,blockIds.bedrock,"end")
				world.spawnBlock(2,top,1,blockIds.bedrock,"end")
				world.spawnBlock(-2,top,-1,blockIds.bedrock,"end")
				world.spawnBlock(-2,top,0,blockIds.bedrock,"end")
				world.spawnBlock(-2,top,1,blockIds.bedrock,"end")
				
				//side
				world.spawnBlock(-1,top+1,-3,blockIds.bedrock,"end")
				world.spawnBlock(0,top+1,-3,blockIds.bedrock,"end")
				world.spawnBlock(1,top+1,-3,blockIds.bedrock,"end")
				world.spawnBlock(-1,top+1,3,blockIds.bedrock,"end")
				world.spawnBlock(0,top+1,3,blockIds.bedrock,"end")
				world.spawnBlock(1,top+1,3,blockIds.bedrock,"end")
				world.spawnBlock(-3,top+1,-1,blockIds.bedrock,"end")
				world.spawnBlock(-3,top+1,0,blockIds.bedrock,"end")
				world.spawnBlock(-3,top+1,1,blockIds.bedrock,"end")
				world.spawnBlock(3,top+1,-1,blockIds.bedrock,"end")
				world.spawnBlock(3,top+1,0,blockIds.bedrock,"end")
				world.spawnBlock(3,top+1,1,blockIds.bedrock,"end")
				//side corners
				world.spawnBlock(-2,top+1,-2,blockIds.bedrock,"end")
				world.spawnBlock(2,top+1,-2,blockIds.bedrock,"end")
				world.spawnBlock(-2,top+1,2,blockIds.bedrock,"end")
				world.spawnBlock(2,top+1,2,blockIds.bedrock,"end")

				world.spawnBlock(0,top+4,0,blockIds.oakSign,"end")
				const text = atob("QmV3YXJlIHRoZQpvbmUgdGhhdApyb2xscy4=")
				world.setTags(0, top+4, 0, {rot:0,text,text2:text}, true,true)
			}
		}else if(world.world.worldType === "large"){
			let topX, topZ, topx, topz, steepX, steepZ
			for (let i = 0; i < 16; i++) {
				wx = this.x + i
				for (let k = 0; k < 16; k++) {
					wz = this.z + k
					ground = this.tops[k * 16 + i]
					let biome = biomes[this.biomes[k * 16 + i]]
					if(biome === "frozenPeaks" || biome === "snowySlopes" || biome === "jaggedPeaks" || biome === "windsweptHills" || biome === "windsweptGravellyHills"){
						topX = world.getTop(wx+1,wz)
						topZ = world.getTop(wx,wz+1)
						topx = world.getTop(wx-1,wz)
						topz = world.getTop(wx,wz-1)
						steepX = (topX-ground)-(topx-ground)
						steepZ = (topZ-ground)-(topz-ground)
						let steepness = sqrt(steepX*steepX+steepZ*steepZ)
						steepX /= steepness, steepZ /= steepness
						if(biome === "frozenPeaks"){
							if(steepness>2){
								if(steepZ < -0.75 || steepZ > 0.75){
									let y = ground-1
									while(this.getBlock(i,y,k) === blockIds.snowBlock){//snow on top of ice
										this.setBlock(i,y,k,blockIds.packedIce)
										y--
									}
								}else if(steepX > 0){
									let y = ground
									while(this.getBlock(i,y,k) === blockIds.snowBlock){
										this.setBlock(i,y,k,blockIds.packedIce)
										y--
									}
								}
							}
						}else if(biome === "snowySlopes" || biome === "jaggedPeaks"){
							if(steepness>4){
								let y = ground
								while(this.getBlock(i,y,k) === blockIds.snowBlock){
									this.setBlock(i,y,k,blockIds.stone)
									y--
								}
							}
						}else if(biome === "windsweptHills"){
							if(steepness>2.5){
								let y = ground
								while(this.getBlock(i,y,k) === blockIds.grass || this.getBlock(i,y,k) === blockIds.dirt){
									this.setBlock(i,y,k,blockIds.stone)
									y--
								}
							}
						}else if(biome === "windsweptGravellyHills"){
							if(steepness>2.5){
								let y = ground
								while(this.getBlock(i,y,k) === blockIds.grass || this.getBlock(i,y,k) === blockIds.dirt){
									this.setBlock(i,y,k,blockIds.gravel)
									y--
								}
							}
						}
					}
					if(biome === "swamp"){
						if(this.getBlock(i,waterHeight,k) === blockIds.grass && noiseProfile.generator.noise2d(wx*0.25,wz*0.25)>0){
							this.setBlock(i,waterHeight,k,blockIds.Water)
						}
					}
					if(biome === "marsh"){
						if(ground === waterHeight) this.setBlock(i,ground,k,blockIds.mud)
						else if(ground === waterHeight+1 && noiseProfile.generator.noise2d(wx*0.25,wz*0.25)>0) this.setBlock(i,ground,k,blockIds.mud)
					}
				}
			}
			if(trees) for (let i = 0; i < 16; i++) {
				let flowerNoiseOffsetX = hash(world.worldSeed,24987398), flowerNoiseOffsetZ = hash(world.worldSeed,91264824)
				wx = this.x + i
				for (let k = 0; k < 16; k++) {
					wz = this.z + k
					ground = this.tops[k * 16 + i]
					let b = biomes[this.biomes[k * 16 + i]]
					let waterTop = this.waterTops[k*16+i]
					let birchAndOak, bigOak, oak, birch, tallBirch, cocoa, bigJungle, spruce, pine, bigSpruce, bigPine, acacia, bigAcacia, bigBirch, tallSpruce, darkOak, cherry, swampOak
					let deadBush, cactus, sugarcane = 0.2, melonPatch, kelp, hugeMushroom, shrubBush, bush, shrubBushType = "big", lilyPad, bamboo, bambooWithLeaves, jungleBush
					let rock = ground > 90 ? 0.15 : 0.05, rockType = ground > 90 ? "flat" : "medium", iceberg
					let grassType, flowerType, flowerDensity = 0.65, flowerNoiseSize = 0.04, grassDensity = 0.4, seagrass, groundBerries, fern //flowerDensity more is less flowers
					let fallenOak, fallenBirch, fallenTallBirch, fallenCocoa, fallenSpruce, fallenTallSpruce
					switch(b){
						case "forest":
							//bush = 2, shrubBushType = "wet", birchAndOak = 10, bigBirch = 0.5, flowerType = this.patches.forestFlowers, grassType = this.patches.grassLeaves, grassDensity = 0.15, groundBerries = 0.25
							birchAndOak = 8, flowerType = this.patches.forestFlowers, grassType = this.patches.grass, grassDensity = 0.15, groundBerries = 0.25
							break
						case "plains":
							oak = 0.1, bigOak = 0.0333333333, rock = 0, flowerType = this.patches.plainsFlowers, grassType = this.patches.tallGrass
							break
						case "flowerForest":
							birchAndOak = 4, flowerDensity = 0.35, flowerType = this.patches.flowerForestFlowers, grassType = this.patches.grass
							break
						case "sunflowerPlains":
							flowerDensity = 0.4, flowerType = this.patches.sunflowerPlainsFlowers, grassType = this.patches.tallGrass
							break
						case "meadow":
							birchAndOak = 0.02, flowerDensity = 0.2, flowerNoiseSize = 0.004, rock = 0, flowerType = this.patches.meadowFlowers, grassType = this.patches.grassAndRareTallGrass, grassDensity = 0.1
							break
						case "birchForest":
							bigBirch = 4, birch = 4, flowerType = this.patches.forestFlowers, grassType = this.patches.grassLeavesBirch, grassDensity = 0.1
							break
						case "oldBirchForest":
							tallBirch = 7, flowerType = this.patches.forestFlowers, grassType = this.patches.grassLeavesBirch, grassDensity = 0.1
							break
						case "sparseJungle":
							bamboo = 0.25, cocoa = 2, bigOak = 0.125, jungleBush = 2, melonPatch = true, grassType = this.patches.tallGrass, grassDensity = 0.1
							worldGenArray.add(wx,ground,wz,blockIds.vine)
							break
						case "jungle":
							bamboo = 0.25, cocoa = 4, bigJungle = 1, bigOak = 1, melonPatch = true, jungleBush = 8, bush = 2, shrubBushType = "wet", grassType = this.patches.jungle, grassDensity = 0.1, fern = 0.5
							worldGenArray.add(wx,ground,wz,blockIds.vine)
							break
						case "bambooJungle":
							bamboo = 180, bigJungle = 1, bigOak = 0.5, melonPatch = true, grassType = this.patches.grass
							worldGenArray.add(wx,ground,wz,blockIds.vine)
							break
						case "desert":
							deadBush = 1, cactus = 1, sugarcane = 0.4, rock = 0
							break
						case "oldSpruceTaiga":
							bigOak = 0.25, oak = 0.125, bush = 1, shrubBushType = "wet", deadBush = 1, tallSpruce = 8, spruce = 1, bigSpruce = 0.25, pine = 0.25, bigPine = 0.125, rock = 1, rockType = "mossy", grassType = this.patches.fernGrassSpruceLeaves, flowerType = this.patches.flowers, groundBerries = 1, fern = 1
							break
						case "oldPineTaiga":
							bigOak = 1, oak = 2, bush = 1, shrubBushType = "wet", deadBush = 1, tallSpruce = 0.5, pine = 1, bigPine = 2, spruce = 0.25, bigSpruce = 0.125, rock = 1, rockType = "mossy", grassType = this.patches.fernGrassSpruceLeaves, flowerType = this.patches.flowers, groundBerries = 0.5, fern = 0.75
							break
						case "grove":
							spruce = 2, pine = 0.666666667, rock = 0
							break
						case "windsweptGravellyHills":
							oak = 0.05, spruce = 0.0333, bigOak = 0.005, flowerDensity = 0.8, rock = 1, rockType = "small", flowerType = this.patches.flowers, grassType = this.patches.grass, grassDensity = 0.6
							break
						case "windsweptForest":
							tallSpruce = 2, oak = 1, spruce = 0.666, bigSpruce = 0.3, bigOak = 0.1, flowerDensity = 0.8, rock = 1, rockType = "small", rock = 0, flowerType = this.patches.flowers, grassType = this.patches.grass, grassDensity = 0.6
							break
						case "windsweptHills":
							rock = 1, rockType = "small", bigOak = 0.1, bigSpruce = 0.1
							break
						case "taiga":
							spruce = 4, pine = 2, bigSpruce = 0.075, bigPine = 0.075, tallSpruce = 0.075, flowerDensity = 0.8, flowerType = this.patches.flowers, grassType = this.patches.fernBerries, grassDensity = 0.4
							break
						case "snowyTaiga":
							spruce = 2, pine = 0.666, bigSpruce = 0.075, bigPine = 0.075, tallSpruce = 2, flowerDensity = 0.8, flowerType = this.patches.flowers, grassType = this.patches.fernGrass, grassDensity = 0.4
							break
						case "snowyPlains":
							spruce = 0.08, flowerType = this.patches.flowers, flowerDensity = 0.8, grassType = this.patches.grass, grassDensity = 0.65
							break
						case "woodedBadlands":
							oak = 4, rock = 0, grassType = this.patches.grass, grassDensity = 0.65, deadBush = 1, cactus = 0.25
							break
						case "badlands":
						case "erodedBadlands":
							deadBush = 1, cactus = 1, rock = 0
							break
						case "savanna":
						case "savannaPlateau":
							acacia = 0.75, bigAcacia = 0.05, oak = 0.1, bush = 0.5, shrubBushType = "dry", grassType = this.patches.tallGrass, flowerType = this.patches.flowers
							break
						case "grassySavanna":
							acacia = 0.1, bigAcacia = 0.01, oak = 0.02, bush = 0.1, shrubBushType = "dry", grassType = this.patches.mostTallGrass, flowerType = this.patches.flowers, grassDensity = 0.1
							break
						case "shrubland":
							rock = 0.1, rockType = "small", shrubBush = 16, shrubBushType = "big", oak = 1, deadBush = 2, grassType = this.patches.tallGrass, grassDensity = 0.2, flowerType = this.patches.flowers
							break
						case "sparseForest":
							bush = 2, shrubBushType = "wet", tallBirch = 0.125, bigOak = 3, tallSpruce = 0.1, flowerType = this.patches.forestFlowers, grassType = this.patches.mostThickLeaves, grassDensity = 0.1
							break
						case "alpineHills":
							spruce = 0.1, tallSpruce = 1, pine = 0.05, grassType = this.patches.tallGrass
							break
						case "darkForest":
							hugeMushroom = 0.5, darkOak = 4, birchAndOak = 1, grassType = this.patches.grass, flowerType = this.patches.forestFlowers
							break
						case "rockyPlains":
							rock = 0.2, rockType = "big", bigOak = 0.04, bigSpruce = 0.04, grassType = this.patches.tallGrass, grassDensity = 0.2
							break
						case "windsweptSavanna":
							acacia = 0.5, grassType = this.patches.grass, flowerType = this.patches.flowers
							break
						case "cherryGrove":
							cherry = 1, flowerType = this.patches.pinkPetals, flowerDensity = 0.3, flowerNoiseSize = 0.1, grassType = this.patches.tallGrass, grassDensity = 0.4
							break
						case "dryShrubland":
							shrubBush = 6, shrubBushType = "dry", deadBush = 1, cactus = 1, rock = 0, sugarcane = 0.4
							break
						case "bambooForest":
							bambooWithLeaves = 80, bush = 1, shrubBushType = "wet", grassType = this.patches.grassLeavesFern, grassDensity = 0, groundBerries = 0.5, fern = 0.1
							break
						case "snowySlopes":
						case "frozenPeaks":
						case "jaggedPeaks":
						case "stonePeaks":
						case "beach":
						case "stonyShore":
						case "snowyBeach":
							rock = 0
							break
						case "frozenOcean":
							iceberg = 0.5
							break
						case "deepFrozenOcean":
							iceberg = 0.25
							break
						case "ocean":
						case "deepOcean":
						case "coldOcean":
						case "deepColdOcean":
							//kelp = 0.5, seagrass = true, grassType = this.patches.seagrass
							break
						case "lukewarmOcean":
						case "deepLukewarmOcean":
							//kelp = 0.3, seagrass = true, grassType = this.patches.seagrass
							break
						case "warmOcean":
							//seagrass = true, grassType = this.patches.seagrass
							//todo: put coral
							break
						case "mushroomFields":
							hugeMushroom = 1, flowerType = this.patches.mushrooms, flowerDensity = 0.5, flowerNoiseSize = 0.1
							break
						case "rockyRiver":
							lilyPad = 0.2, rock = 1, rockType = "big"
							break
						case "swamp":
							swampOak = 4, lilyPad = 12, flowerType = this.patches.blueOrchids, flowerDensity = 0.75, grassType = this.patches.grass, deadBush = 1, hugeMushroom = 0.25
							break
						case "marsh":
							grassType = this.patches.grass
							if(ground>waterHeight+1) bush = 6, shrubBushType = "wet", deadBush = 1, grassDensity = 0.2
							else if(ground>=waterHeight) grassDensity = 0.1
							break
					}

					let under = this.getBlock(i,ground,k), aboveGround = this.getBlock(i,ground+1,k), underWater = blockData[aboveGround].liquid

					useRandom(0)
					if(!underWater){
						if(bamboo && (under === blockIds.grass || under === blockIds.podzol) && random(256) < bamboo){
							this.spawnBamboo(i,ground,k,wx,wz)
						}
						if(birchAndOak && under && random(256) < birchAndOak){
							let rand = random()
							if(rand<0.1) this.spawnBigOak(i,ground,k,wx,wz,random() > 0.9)
							else this.spawnSmallTree(i,ground,k,wx,wz,rand > 0.8, random() > 0.9)
						}
						if(oak && under && random(256) < oak){
							this.spawnSmallTree(i,ground,k,wx,wz, false)
						}
						if(birch && under && random(256) < birch){
							this.spawnSmallTree(i,ground,k,wx,wz,true,false,true)
						}
						if(bigOak && under && random(256) < bigOak){
							this.spawnBigOak(i,ground,k,wx,wz,random() > 0.9)
						}
						if(cocoa && under === blockIds.grass && random(256) < cocoa){
							this.spawnJungleBush(i,k,wx,ground,wz)
						}
						if(jungleBush && under === blockIds.grass && random(256) < jungleBush){
							this.spawnJungleBush(i,k,wx,ground,wz)
						}
						if(bigJungle && under === blockIds.grass && random(256) < bigJungle){
							this.spawnJungleTree(i,ground,k,wx,wz)
						}
						if(deadBush && under && random(256) < deadBush){
							this.setBlock(i,ground+1,k, blockIds.deadBush | CROSS);
						}
						if(cactus && under && random(256) < cactus){
							this.spawnCactus(i,ground,k)
						}
						if(spruce && under && random(256) < spruce){
							this.spawnSpruce(i,ground,k,wx,wz)
						}
						if(pine && under && random(256) < pine){
							this.spawnPine(i,ground,k,wx,wz)
						}
						if(bigSpruce && under && random(256) < bigSpruce){
							this.spawnBigSpruce(i,ground,k,wx,wz)
						}
						if(bigPine && under && random(256) < bigPine){
							this.spawnBigPine(i,ground,k,wx,wz)
						}
						if(acacia && under && random(256) < acacia){
							this.spawnAcacia(i,ground,k,wx,wz)
						}
						if(bigAcacia && under && random(256) < bigAcacia){
							this.spawnBigAcacia(i,ground,k,wx,wz)
						}
						if(bigBirch && under && random(256) < bigBirch){
							this.spawnBigBirch(i,ground,k,wx,wz)
						}
						if(tallBirch && under && random(256) < tallBirch){
							this.spawnBigBirch(i,ground,k,wx,wz,true)
						}
						if(shrubBush && under && random(256) < shrubBush){
							if(random() > 0.5){
								this.spawnBush(i,ground,k,wx,wz,shrubBushType)
							}else{
								this.spawnShrub(i,ground,k,wx,wz,shrubBushType)
							}
						}
						if(bush && under && random(256) < bush){
							this.spawnBush(i,ground,k,wx,wz,shrubBushType)
						}
						if(tallSpruce && under && random(256) < tallSpruce){
							this.spawnTallSpruce(i,ground,k,wx,wz)
						}
						if(darkOak && under && random(256) < darkOak){
							this.spawnDarkOak(i,ground,k,wx,wz)
						}
						if(hugeMushroom && under && random(256) < hugeMushroom){
							this.spawnHugeMushroom(i,ground,k,wx,wz, random()>0.5)
						}
						if(cherry && under && random(256) < cherry){
							this.spawnCherryTree(i,ground,k,wx,wz)
						}
						if(bambooWithLeaves && random(256) < bambooWithLeaves && under){
							this.spawnBamboo(i,ground,k,wx,wz,true)
						}
					}
					if(swampOak && under && random(256) < swampOak){
						if(random() > 0.5) this.spawnSwampOak(i,ground,k,wx,wz)
						else this.spawnBigOak(i,ground,k,wx,wz,true)
					}
					fallenOak = (birchAndOak||oak||0) * 0.05, fallenBirch = (birchAndOak||birch||0) * 0.05, fallenTallBirch = (tallBirch||0) * 0.05
					fallenCocoa = (cocoa||0) * 0.05, fallenSpruce = (spruce||pine||0) * 0.05, fallenTallSpruce = (tallSpruce||0) * 0.05
					if(!underWater){
						if(fallenOak && random(256) < fallenOak){
							this.spawnFallenTree(i,ground,k,wx,wz,blockIds.oakLog,4,7,0.75)
						}
						if(fallenBirch && random(256) < fallenBirch){
							this.spawnFallenTree(i,ground,k,wx,wz,blockIds.birchLog,5,8)
						}
						if(fallenTallBirch && random(256) < fallenTallBirch){
							this.spawnFallenTree(i,ground,k,wx,wz,blockIds.birchLog,5,15)
						}
						if(fallenCocoa && random(256) < fallenCocoa){
							this.spawnFallenTree(i,ground,k,wx,wz,blockIds.jungleLog,4,11,0.75)
						}
						if(fallenSpruce && random(256) < fallenSpruce){
							this.spawnFallenTree(i,ground,k,wx,wz,blockIds.spruceLog,6,10)
						}
						if(fallenTallSpruce && random(256) < fallenTallSpruce){
							this.spawnFallenTree(i,ground,k,wx,wz,blockIds.spruceLog,12,16)
						}
					}
					useRandom(1)
					if(!underWater && ground < 64 && (under === blockIds.grass || under === blockIds.sand) && mapClamped(noiseProfile.noise(wx*0.1,5,wz*0.1),0.3,0.7) < sugarcane){
						if(
							world.getBlock(wx+1,ground,wz) === blockIds.Water ||
							world.getBlock(wx-1,ground,wz) === blockIds.Water ||
							world.getBlock(wx,ground,wz+1) === blockIds.Water ||
							world.getBlock(wx,ground,wz-1) === blockIds.Water
						){
							let block = random() > biomeData[b][1]*0.2+0.9 ? blockIds.sugarCane|SLAB : blockIds.sugarCane|CROSS
							this.setBlock(i,ground+1,k, block)
							this.setBlock(i,ground+2,k, block)
							if(random()>0.5) this.setBlock(i,ground+3,k, block)
						}
					}

					if(b==="trashland"){
						let block=this.trashland[floor(random(this.trashland.length))]
						let h = ceil(mapClamped(noiseProfile.noise(wx*0.2,7,wz*0.2),0.3,0.7)*3)
						if(h===1 && !underWater && random()>0.6)block=blockIds.oil
						for(let l=0;l<h;l++){
							this.setBlock(i,ground+l,k, block)
						}
					}

					if(!underWater && flowerType && blockData[under].type === "ground" && random(mapClamped(noiseProfile.noise(wx*0.1,2,wz*0.1),0.3,0.7)) > flowerDensity){
						let f = flowerType[round(mapClamped(noiseProfile.noise(wx*flowerNoiseSize+flowerNoiseOffsetX,3,wz*flowerNoiseSize+flowerNoiseOffsetZ),0.3,0.7)*(flowerType.length-1))]
						world.spawnBlock(wx, ground+1, wz, f)
					}
					if((!underWater || seagrass) && grassType && blockData[under].type === "ground" && random(mapClamped(noiseProfile.noise(wx*0.1,4,wz*0.1),0.3,0.7)) > grassDensity){
						let f = grassType[floor(random()**3*grassType.length)] //first items are more common than last items
						world.spawnBlock(wx, ground+1, wz, f, seagrass)
					}
					if(!underWater && under === blockIds.grass && mapClamped(noiseProfile.noise(wx*0.1,6,wz*0.1),0.3,0.7) > 0.9){
						if(random() > 0.5){
							world.spawnBlock(wx, ground+1, wz, melonPatch ? blockIds.melon : blockIds.pumpkin)
							if(under === blockIds.grass || under === blockIds.mycelium) this.setBlock(i,ground,k,blockIds.dirt)
						}
					}
					if(!underWater && groundBerries && blockData[under].type === "ground" && random(256) < groundBerries){
						this.generatePatch(wx,ground,wz,4,this.patches.groundBerries)
					}
					if(!underWater && fern && blockData[under].type === "ground" && random(256) < fern){
						this.generatePatch(wx,ground,wz,6,this.patches.fern)
					}
					if(kelp && random(mapClamped(noiseProfile.noise(wx*0.02,8,wz*0.02),0.3,0.7))>kelp){
						let height = min(round(random(16,32)), 63-ground)
						for(let l=0; l<height; l++){
							world.spawnBlock(wx, ground+1+l, wz, l+1 === height ? blockIds.kelp : blockIds.kelpPlant,true)
						}
					}
					if(lilyPad && random(256) < lilyPad && this.getBlock(i,waterHeight,k) === blockIds.Water && !this.getBlock(i,64,k)){
						world.spawnBlock(wx, waterHeight+1, wz, blockIds.lilyPad)
					}
					if(aboveGround === blockIds.Water && random() < (8-Math.max((60-ground)/2/*deeper water has less disks*/,0))/256){
						let disk = waterTop ? round(random(4)) : round(random(-0.6,3)), block, underBlock, replace
						switch(disk){
							case -1: block = blockIds.quicksand; replace = this.patches.aboveGroundDisk; break
							case 0: block = blockIds.sand; replace = this.patches.sandDisk; break
							case 1: block = blockIds.gravel; replace = this.patches.sandDisk; break
							case 2: block = blockIds.clay; replace = this.patches.clayDisk; break
							case 3: block = blockIds.grass; underBlock = blockIds.dirt; replace = this.patches.dirtDisk; break
							case 4: block = blockIds.mud; replace = this.patches.sandDisk; break
						}
						this.spawnDisk(wx,wz, replace, block, underBlock, round(random(3,7)))
					}
					useRandom(4)
					if(rock && random(256) < rock){
						this.spawnRock(wx,ground,wz,rockType)
					}
					if(iceberg && random(256) < iceberg){
						this.spawnIceberg(wx,wz)
					}
					if(waterTop && biomeData[b][1] > 0.5 && random(256)<12){
						let x = wx+round(random())*8-4, z = wz+round(random())*8-4
						this.spawnRock(x,world.getTop(x,z),z,"mossy")
					}
					await yieldThread()
				}
			}
			
			useRandom(1)
			//Place mushrooms
			for (let i = 0; i < 16; i++) {
				let wx = i+this.x
				for (let k = 0; k < 16; k++) {
					let wz = k+this.z
					let b = biomes[this.biomes[k * 16 + i]]
					ground = this.tops[k * 16 + i]
					let mushroomChance = (biomeData[b][1]-0.5)*0.005+0.5
					let top = this.solidTops[k * 16 + i]
					if(top > ground+1 && mushroomChance > 0.5 && random()**2*mushroomChance > 0.5){
						this.generatePatch(wx,ground,wz,2,this.patches.mushrooms)
					}
				}
			}

			useRandom(2)
			if(trees) for (let i = 0; i < 16; i++) {
				let wx = i+this.x
				for (let k = 0; k < 16; k++) {
					let wz = k+this.z
					let b = biomes[this.caveBiomes[k * 16 + i]]
					let caveMin = this.caveY[k*16+i]
					let caveMax = this.caveY[k*16+i+256]
					ground = this.tops[k * 16 + i]
					if(b === "void" || caveMin === caveMax || !this.getBlock(i,caveMin-1,k) || !this.getBlock(i,caveMax+1,k)) continue
					if(b === "dripstoneCaves"){
						if(noiseProfile.noise(wx*0.1,22,wz*0.1) > 0.55 && !blockData[world.getBlock(wx+1,caveMin,wz)].transparent && !blockData[world.getBlock(wx-1,caveMin,wz)].transparent && !blockData[world.getBlock(wx,caveMin,wz+1)].transparent && !blockData[world.getBlock(wx,caveMin,wz-1)].transparent){
							this.setBlock(i,caveMin,k,blockIds.Water)
							continue
						}
						if(noiseProfile.noise(wx*0.04,20,wz*0.04) > 0.4){
							this.setBlock(i,caveMin,k,blockIds.dripstoneBlock)
							this.setBlock(i,caveMax,k,blockIds.dripstoneBlock)
						}
						if(random() > 0.75){
							let h = round(random(8))
							for(let l=1; l<h; l++){
								this.setBlock(i,caveMin+l,k,blockIds.pointedDripstone)
								if(caveMax-l <= caveMin+l) break
								this.setBlock(i,caveMax-l,k,blockIds.pointedDripstone|FLIP)
							}
							for(let l=1; l<h; l++){
								blockData[blockIds.pointedDripstone].spawnUpdate(trueX+i,caveMin+l,trueZ+k,blockIds.pointedDripstone,this.world)
								if(caveMax-l <= caveMin+l) break
								blockData[blockIds.pointedDripstone].spawnUpdate(trueX+i,caveMax-l,trueZ+k,blockIds.pointedDripstone|FLIP,this.world)
							}
						}
					}else if(b === "lushCaves"){
						if(noiseProfile.noise(wx*0.02,21,wz*0.02) > 0.55){
							if(noiseProfile.noise(wx*0.05,23,wz*0.05) > 0.5 && world.getBlock(wx+1,caveMin,wz) && world.getBlock(wx-1,caveMin,wz) && world.getBlock(wx,caveMin,wz+1) && world.getBlock(wx,caveMin,wz-1)){
								this.setBlock(i,caveMin,k, blockIds.Water)
							}else{
								this.setBlock(i,caveMin,k, blockIds.clay)
								if(random() > 0.96){
									let h = round(random(1,4))
									if(h === 1){
										this.setBlock(i,caveMin+1,k, blockIds.smallDripleaf)
									}else{
										for(let l=0; l<h; l++){
											this.setBlock(i,caveMin+1+l,k, l === h-1 ? blockIds.bigDripleaf : (blockIds.bigDripleaf|CROSS))
										}
									}
								}
							}
						}else{
							this.setBlock(i,caveMin,k, blockIds.mossBlock)
							let grassType = this.patches.lushCaves
							if(grassType && random() > 0.5){
								let f = grassType[floor(random()**3*grassType.length)] //first items are more common than last items
								world.spawnBlock(wx, caveMin+1, wz, f)
							}
						}
						this.setBlock(i,caveMax,k, blockIds.mossBlock)
						if(random() > 0.9){
							let h = round(random(1,6))
							for(let l=0; l<h; l++){
								this.setBlock(i, caveMax-1-l, k, (random() > 0.25 ? (l === h-1 ? blockIds.caveVines : blockIds.caveVinesPlant) : (l === h-1 ? blockIds.caveVinesLit : blockIds.caveVinesPlantLit)) | CROSS)
							}
						}else if(random() > 0.98){
							this.setBlock(i,caveMax-1,k, blockIds.sporeBlossom)
						}
					}

					//glow lichen
					let x = wx, z = wz
					let y = round(random(0,caveMax))
					if(!this.getBlock(x,y,z)) continue
					let block = blockIds.glowLichen | WALLFLAT
					switch(floor(random()*4)){
						case 0:
							z++
							block = block | SOUTH
							break
						case 1:
							z--
							block = block | NORTH
							break
						case 2:
							x++
							block = block | WEST
							break
						case 3:
							x--
							block = block | EAST
							break
					}
					if(!world.getBlock(x,y,z)) world.setBlock(x,y,z,block)

					//azalea trees
					if(b === "lushCaves" && random() < 0.001){
						let top = ground + floor(6 + random(2.5))
						for (let j = ground; j <= top; j++) {
							this.setBlock(i, j, k, blockIds.oakLog)
						}
						this.generateBlob(wx,top,wz,this.patches.azaleaLeaves, 8,1,8,0.4)
						for(var l = 0; ground+l > caveMax-3; l--) {
							for(var m = 0; m < 14; m++) {
								let rX = round(random(-2.75, 2.75));
								let rZ = round(random(-2.75, 2.75));
								let here = this.getBlock(i+rX, ground+l, k+rZ)
								if(here !== blockIds.grass && here !== blockIds.air) {
									this.setBlock(i+rX, ground+l, k+rZ, blockIds.rootedDirt);
								} else if(this.getBlock(i+rX, ground+l+1, k+rZ)===blockIds.rootedDirt) {
									this.setBlock(i+rX, ground+l, k+rZ, blockIds.hangingRoots | CROSS);
								}
							}
						}
					}

					await yieldThread()
				}
			}

			useRandom(3)
			this.spawnOres(this.patches.dirtOre,7,0,160,"", 8)
			this.spawnOres(this.patches.gravelOre,14,0,320,"", 8)
			this.spawnOres(this.patches.graniteOre,2,0,128,"", 8)
			this.spawnOres(this.patches.dioriteOre,2,0,128,"", 8)
			this.spawnOres(this.patches.andesiteOre,2,0,128,"", 8)
			this.spawnOres(this.patches.tuffOre,2,-64,0,"", 8)
			await yieldThread()
			this.spawnOres(this.patches.coalOre,20,0,192,"triangle", 4)
			this.spawnOres(this.patches.coalOre,30,136,320,"", 4)
			this.spawnOres(this.patches.ironOre,20,-64,72,"", 3)
			this.spawnOres(this.patches.ironOre,20,-24,56,"triangle", 3)
			this.spawnOres(this.patches.copperOre,20,-16,112,"triangle", 3)
			this.spawnOres(this.patches.redstoneOre,8,-64,15,"", 3)
			await yieldThread()
			this.spawnOres(this.patches.redstoneOre,16,-96,-32,"triangle", 3)
			this.spawnOres(this.patches.lapisOre,4,-32,32,"triangle", 3)
			this.spawnOres(this.patches.lapisOre,8,-64,64,"", 3)
			this.spawnOres(this.patches.goldOre,8,-64,32,"triangle", 3)
			this.spawnOres(this.patches.badlandsGoldOre,50,32,256,"", 3)
			this.spawnOres(this.patches.diamondOre,16,-144,16,"triangle", 2.5)
			await yieldThread()
			this.spawnOres(this.patches.emeraldOre,16,-16,480,"triangle", 4)
			this.spawnOres(this.patches.limestoneOre,1,0,128,"triangle", 6)

			useRandom(5)
			for(let i=0; i<16; i++){//spawn springs
				let x = floor(random(16))
				let z = floor(random(16))
				let y = floor(random(-64,192))
				let wx = x+trueX, wz = z+trueZ
				if(
					(blockData[this.getBlock(x,y,z)].type||"").startsWith("rock") &&
					(
						!world.getBlock(wx+1,y,wz) ||
						!world.getBlock(wx-1,y,wz) ||
						!world.getBlock(wx,y,wz+1) ||
						!world.getBlock(wx,y,wz-1)
					)
				){
					let block = random(-16,y)<0 ? blockIds.Lava : blockIds.Water
					this.setBlock(x,y,z,block)
					await blockData[block].spawnFlow(wx,y,wz,world)
				}
			}
			//place snow
			for (let i = 0; i < 16; i++) {
				wx = trueX+i
				for (let k = 0; k < 16; k++) {
					wz = trueZ+k
					let top = max(this.solidTops[k*16+i],waterHeight)
					let block = this.getBlock(i,top,k)
					if(!blockData[block].slide && getBiomeTemperature(biomes[this.biomes[k*16+i]],top)+(noiseProfile.noise(wx*0.1,wz*0.1)*2-1)*0.02 <= 0.15){
						if(block === blockIds.Water){
							this.setBlock(i,top,k,blockIds.ice)
						}else if(blockData[block].solid && !this.getBlock(i,top+1,k)){
							this.setBlock(i,top+1,k,blockIds.snow|LAYER1)
							if(block === blockIds.grass){
								this.setBlock(i,top,k,blockIds.grass|CROSS)
							}
						}
					}
					top = this.waterTops[k*16+i]
					block = this.getBlock(i,top,k)
					if(top){
						let times = 0
						let minTop = max(min(world.getTop(wx+1,wz),world.getTop(wx-1,wz),world.getTop(wx,wz+1),world.getTop(wx,wz-1)), waterHeight)
						/*while(!blockData[world.getBlock(wx+1,top,wz)].solid+
							!blockData[world.getBlock(wx-1,top,wz)].solid+
							!blockData[world.getBlock(wx,top,wz+1)].solid+
							!blockData[world.getBlock(wx,top,wz-1)].solid
						>2 && times<3){
							this.setBlock(i,top,k,blockIds.air)
							times++
							top--
						}*/
						for(let y=top; y>minTop; y--){
							if(blockData[this.getBlock(i,y,k)].solid) this.setBlock(i,y,k,blockIds.air)
						}
						if(getBiomeTemperature(biomes[this.biomes[k*16+i]],minTop) <= 0.15){
							this.setBlock(i,minTop,k,blockIds.ice)
						}else{
							this.setBlock(i,minTop,k,blockIds.Water)
							await blockData[blockIds.Water].spawnFlow(wx,minTop,wz,world)
						}
					}
				}
			}
			this.waterTops = null
		}
		
		useRandom(1)
		if(worldGenArray.size){
			for(var l=0; l<round(worldGenArray.size*0.75); l++){
				var rnd = (random()*worldGenArray.size)|0
				var block = worldGenArray.array[rnd][3]
				let x = worldGenArray.array[rnd][0], y = worldGenArray.array[rnd][1], z = worldGenArray.array[rnd][2]
				if(block === blockIds.vine){
					block = block | WALLFLAT
					switch(floor(random()*4)){
						case 0:
							z++
							block = block | SOUTH
							break
						case 1:
							z--
							block = block | NORTH
							break
						case 2:
							x++
							block = block | WEST
							break
						case 3:
							x--
							block = block | EAST
							break
					}
					let length = round(random(1,8))
					for(var m=0; m<length; m++){
						if(world.getBlock(x,y-m,z)) break
						world.spawnBlock(x,y-m,z,block)
					}
				}else if(block === blockIds.cocoa){
					switch(floor(random(3))){
						case 1:
							block |= SLAB
							break
						case 2:
							block |= STAIR
							break
					}
					switch(floor(random(4))){
						case 0:
							z++
							block = block | SOUTH
							break
						case 1:
							z--
							block = block | NORTH
							break
						case 2:
							x++
							block = block | WEST
							break
						case 3:
							x--
							block = block | EAST
							break
					}
					world.spawnBlock(x,y,z,block)
				}else if(block === blockIds.mossCarpet){
					block = block | VERTICALSLAB
					switch(floor(random()*4)){
						case 0:
							z++
							block = block | SOUTH
							break
						case 1:
							z--
							block = block | NORTH
							break
						case 2:
							x++
							block = block | WEST
							break
						case 3:
							x--
							block = block | EAST
							break
					}
					world.spawnBlock(x,y,z,block)
				}
			}
		}

		//Structures
		//dont use random after because generateStructureLayout calls randomSeed
		if(this.world.world.structures){
			let genStructs = []
			for(let x = Math.floor((this.x-structureCheckDist)/structureSpacing)*structureSpacing; x <= Math.ceil((this.x+structureCheckDist)/structureSpacing)*structureSpacing; x+=structureSpacing){
				for(let z = Math.floor((this.z-structureCheckDist)/structureSpacing)*structureSpacing; z <= Math.ceil((this.z+structureCheckDist)/structureSpacing)*structureSpacing; z+=structureSpacing){
					let i=0
					for(let s of structures){
						i++
						if(hash3(x,z,i)<s.chance){
							let struct = world.structureData[x+","+z]
							if(!struct) world.structureData[x+","+z] = struct = this.generateStructureLayout(x,z,s)
							genStructs.push(struct)
							break
						}
					}
				}
			}
			for(let s of genStructs){
				for(let j of s){
					let {x,y,z,data:jigsaw} = j
					let {w,h,d,data} = jigsaw
					if(!(
						x < this.x+16 &&
						x+w >= this.x &&
						z < this.z+16 &&
						z+d >= this.z
					)) continue
					if(jigsaw.onGround){
						y = world.getTop(x+jigsaw.centerPos[0],z+jigsaw.centerPos[2])
						if(blockData[world.getBlock(x+jigsaw.centerPos[0],y+1,z+jigsaw.centerPos[2])].liquid) y+=2
						while(blockData[world.getBlock(x+jigsaw.centerPos[0],y,z+jigsaw.centerPos[2])].liquid) y++
						y -= jigsaw.centerPos[1]
					}
					let {rotN, rotS, rotE, rotW} = jigsaw
					for(let i=0;i<data.length;i+=4){
						const bx = data[i]+x
						const bz = data[i+2]+z
						let by = data[i+1] + y
						if(!(
							bx < this.x+16 &&
							bx >= this.x &&
							bz < this.z+16 &&
							bz >= this.z
						)) continue
						if(jigsaw.flatOnGround){
							by = this.tops[(bz-this.z)*16+(bx-this.x)]
							if(blockData[this.getBlock(bx-this.x,by+1,bz-this.z)].liquid) by+=2
							while(blockData[this.getBlock(bx-this.x,by,bz-this.z)].liquid) by++
						}
						let block = data[i+3]
							const prevBlock = this.getBlock(bx-this.x,by,bz-this.z)
						if(typeof block === "function") block = block(rotN,rotE,rotS,rotW,bx,by,bz,prevBlock)
						if(typeof block === "string") block = blockIds[block]
						if(block === undefined) continue
						this.setBlock(bx-this.x,by,bz-this.z,block)
						if(block && blockData[block].solid){
							const under = this.getBlock(bx-this.x,by-1,bz-this.z)
							if(under === blockIds.grass){
								this.setBlock(bx-this.x,by-1,bz-this.z,blockIds.dirt)
							}
						}
					}
				}
			}
		}
		/*if(trees && !world.world.superflat && random() > 0.96){
			let rnd = random(256)
			let x = (rnd >> 4) + this.x
			let z = (rnd & 15) + this.z
			let structure = structureArr[Math.floor(random(structureArr.length))]
			let rot = Math.floor(random(4))
			let {data,w,h,d} = structures[structure].variants[rot]
			let rotS, rotE, rotW
			switch(rot){
				case 0:
					rot = NORTH
					rotE = EAST
					rotS = SOUTH
					rotW = WEST
					break
				case 1:
					rot = EAST
					rotE = NORTH
					rotS = WEST
					rotW = SOUTH
					break
				case 2:
					rot = SOUTH
					rotE = WEST
					rotS = NORTH
					rotW = EAST
					break
				case 3:
					rot = WEST
					rotE = SOUTH
					rotS = EAST
					rotW = NORTH
					break
			}
			let y = structures[structure].getY(x,z,rnd)
			x -= Math.round(w/2)
			y -= Math.round(h/2)
			z -= Math.round(d/2)
			for(let i=0;i<data.length;i+=4){
				let block = data[i+3]
				if(!block) continue
				if(typeof block === "function") block = block(rot,rotE,rotS,rotW)
				if(typeof block === "string") block = blockIds[block]
				world.spawnBlock(x+data[i],y+data[i+1],z+data[i+2],block,type,true)
			}
		}*/

		this.populated = true
	}
	rndStructVariant(structure){
		const rot = Math.floor(random(structure.variants.length))
		let j = structure.variants[rot]
		switch(rot){
			case 0:
					j.rotN = NORTH
					j.rotE = EAST
					j.rotS = SOUTH
					j.rotW = WEST
					break
			case 1:
					j.rotN = EAST
					j.rotE = SOUTH
					j.rotS = WEST
					j.rotW = NORTH
					break
			case 2:
					j.rotN = SOUTH
					j.rotE = WEST
					j.rotS = NORTH
					j.rotW = EAST
					break
			case 3:
					j.rotN = WEST
					j.rotE = NORTH
					j.rotS = EAST
					j.rotW = SOUTH
					break
		}
		return structure.variants[rot]
	}
	generateStructureLayout(x,z,structure){
		randomSeed(hash(x, z) * 210000000)
		let sx = x+Math.floor(random(structureSpacing))//start position
		let sz = z+Math.floor(random(structureSpacing))
		let sy = structure.getY(sx,sz,random())
		let layout = [{
				data: this.rndStructVariant(jigsaws[structure.start[Math.floor(random(structure.start.length))]]),
				x:sx,
				y:sy,
				z:sz
		}]
		if(structure.type === "compound"){
			let adds = layout[0].data.newJigsawTries ? [...layout] : []
			addLoop:for(let i=0; i<structure.maxTries; i++){
				if(!adds.length) break
				let addIdx = Math.floor(
					(//random() > 0.5 ? 
						(1-(1-random())**2)
						//: random()
					)*adds.length)
				let addTo = adds[addIdx]
				if(!addTo.data.newJigsawTries) continue
				tryAddLoop:for(let t=0; t<addTo.data.newJigsawTries; t++){
					let addPos = addTo.data.nextJigsawPos[Math.floor(random(addTo.data.nextJigsawPos.length))]
					let newJigsaw = this.rndStructVariant(jigsaws[addPos[3]])
					let nx = addPos[0]+addTo.x-newJigsaw.centerPos[0]
					let ny = addPos[1]+addTo.y-newJigsaw.centerPos[1]
					let nz = addPos[2]+addTo.z-newJigsaw.centerPos[2]
					if(!(
						nx < sx+structure.maxSize &&
						nx+newJigsaw.w-1 > sx-structure.maxSize &&
						ny < sy+structure.maxSize &&
						ny+newJigsaw.h-1 > sy-structure.maxSize &&
						nz < sz+structure.maxSize &&
						nz+newJigsaw.d-1 > sz-structure.maxSize
					)) continue tryAddLoop
					for(let j of layout){
						if(
							//allow overlap by 1 block on x and z
							nx < j.x+j.data.w-1 &&
							nx+newJigsaw.w-1 > j.x &&
							ny <= j.y+j.data.h-1 &&
							ny+newJigsaw.h-1 >= j.y &&
							nz < j.z+j.data.d-1 &&
							nz+newJigsaw.d-1 > j.z
							/*:
							nx < j.x+j.data.w &&
							nx+newJigsaw.w >= j.x &&
							ny < j.y+j.data.h &&
							ny+newJigsaw.h >= j.y &&
							nz < j.z+j.data.d &&
							nz+newJigsaw.d >= j.z*/
						) continue tryAddLoop //Prevent overlap
					}
					let add = {
						data:newJigsaw,
						x:nx, y:ny, z: nz
					}
					layout.push(add)
					if(newJigsaw.newJigsawTries) adds.push(add)
					if(layout.length >= structure.jigsawCount) break addLoop
				}
			}
		}
		return layout
	}
	tick() {
		const {world} = this
		if (this.edited) {
			for (let i = 0; i < this.sections.length; i++) {
				if (this.sections[i].edited) {
					this.sections[i].tick()
				}
			}
		}
		if(this.allGenerated) for (let [i,entity] of this.entities) {
			entity.update()
			if (entity.canDespawn || (entity.y <= minEntityY)) {
				world.deleteEntity(i)
			}
		}
		if(this.world.weather)weatherStuff:{
			let x = rand(16) | 0, z = rand(16) | 0
			snow:if(this.world.weather === "snow" || this.world.weather === "rain"){
				if(this.world.weather === "rain" && getBiomeTemperature(biomes[this.biomes[z * 16 + x]]) > 0.15) break snow
				if(this.edited && rand(this.world.weatherAmount) > 0.9){
					let y = this.solidTops[z * 16 + x]
					if(y < minHeight || y > weatherHeight) break snow
					let b = this.getBlock(x,y,z), blockMode, set
					let layer = 0
					if((b & LAYER1) === LAYER1) layer = 1
					if((b & LAYER2) === LAYER2) layer = 2
					if((b & LAYER3) === LAYER3) layer = 3
					if((b & LAYER4) === LAYER4) layer = 4
					if((b & LAYER5) === LAYER5) layer = 5
					if((b & LAYER6) === LAYER6) layer = 6
					if((b & LAYER7) === LAYER7) layer = 7
					if((b & LAYER8) === LAYER8) layer = 8
					if(((b & blockIds.snow) === blockIds.snow) && layer > 0 && layer < 8){
						layer ++
						switch(layer){
							case 2:
								blockMode = LAYER2
								break
							case 3:
								blockMode = LAYER3
								break
							case 4:
								blockMode = LAYER4
								break
							case 5:
								blockMode = LAYER5
								break
							case 6:
								blockMode = LAYER6
								break
							case 7:
								blockMode = LAYER7
								break
							case 8:
								blockMode = LAYER8
								break
						}
						set = true
					}else if(!this.getBlock(x,y+1,z)){
						blockMode = LAYER1
						y++
						set = true
					}
					if(set) world.setBlock(x+this.x,y,z+this.z, blockIds.snow | blockMode)
				}
				break weatherStuff
			}
		}
		if(this.world.world.settings.mobSpawning){
			for(let s of this.sections) s.spawnMobs()
		}
	}
	load() {
		if (this.loaded) {
			return
		}
		let chunkX = this.x >> 4
		let chunkZ = this.z >> 4
		let str = `${chunkX},${chunkZ},${this.type}`
		let load = this.world.world.loadFrom[str]
		if (load) {
			let reader = new BitArrayReader(load)
			let paletteLen = reader.read(32)
			let palette = []
			let paletteBits = BitArrayBuilder.bits(paletteLen)
			for (let i = 0; i < paletteLen; i++) palette.push(reader.read(32))
	
			const getIndex = [
				(index, x, y, z) => (y + (index >> 6 & 7))*256 + (x + (index >> 3 & 7))*16 + z + (index >> 0 & 7),
				(index, x, y, z) => (y + (index >> 6 & 7))*256 + (x + (index >> 0 & 7))*16 + z + (index >> 3 & 7),
				(index, x, y, z) => (y + (index >> 3 & 7))*256 + (x + (index >> 6 & 7))*16 + z + (index >> 0 & 7),
				(index, x, y, z) => (y + (index >> 0 & 7))*256 + (x + (index >> 6 & 7))*16 + z + (index >> 3 & 7),
				(index, x, y, z) => (y + (index >> 0 & 7))*256 + (x + (index >> 3 & 7))*16 + z + (index >> 6 & 7),
				(index, x, y, z) => (y + (index >> 3 & 7))*256 + (x + (index >> 0 & 7))*16 + z + (index >> 6 & 7)
			]
	
			let sectionCount = reader.read(32)
			let chunk = {blocks:[],tags:[]}
			for (let i = 0; i < sectionCount; i++) {
				let x = reader.read(1) * 8
				let y = reader.read(8) * 8
				let z = reader.read(1) * 8
				let orientation = reader.read(3)
	
				let runs = reader.read(8)
				let singles = reader.read(9)
				for (let j = 0; j < runs; j++) {
					let index = reader.read(9)
					let types = reader.read(9)
					let lenSize = reader.read(4)
					for (let k = 0; k < types; k++) {
						let chain = reader.read(lenSize) + 1
						let block = reader.read(paletteBits)
						for (let l = 0; l < chain; l++) {
							chunk.blocks[getIndex[orientation](index, x, y, z)] = palette[block]
							index++
						}
					}
				}
				for (let j = 0; j < singles; j++) {
					let index = reader.read(9)
					let block = reader.read(paletteBits)
					chunk.blocks[getIndex[orientation](index, x, y, z)] = palette[block]
				}
				let tagsCount = reader.read(9)
				for(let j=0; j<tagsCount; j++){
					let index = reader.read(9)
					if(reader.read(1)){
						let tags = reader.readString(16)
						try{
							chunk.tags[getIndex[0](index, x, y, z)] = JSON.parse(tags)
						}catch(e){console.log(e)}
					}else{
						chunk.tags[getIndex[0](index, x, y, z)] = reader.read(32)
					}
				}
			}
	
			let entsLen = reader.read(32)
			for(let i=0; i<entsLen; i++){
				let entLen = reader.read(16)
				this.world.world.posEntity(reader.readToNew(entLen, true))
			}
			load = chunk

			for (let j in load.blocks) {
				let block = load.blocks[j], tags = load.tags[j]
				if(!blockData[block]) continue
				const z = j & 15, x = (j >> 4) & 15, y = (j >> 8) + minHeight
				this.setBlock(x,y,z,block,world)
				if(tags) this.setTags(x,y,z,tags)
			}

			delete this.world.world.loadFrom[str]
		}
		this.loaded = true
	}
	async getData(){
/*according to artificial intelligence:
There are several techniques you can use to optimize JavaScript code that compresses data by checking patterns in an array:
1. Use a more efficient pattern matching algorithm: Look for specific patterns in the array data and use more optimized pattern matching algorithms, such as the Knuth-Morris-Pratt (KMP) algorithm or the Boyer-Moore algorithm.
2. Implement memoization: If your compression algorithm involves performing repetitive computations on the same array elements, memoization can help you store the results of these computations and avoid redundant operations.
3. Utilize data structures: Choose appropriate data structures to improve the speed of pattern searching. For example, you can use hash tables or sets to store patterns and quickly check for their existence.
4. Optimize loops and iteration: Make sure your loop code is as efficient as possible by minimizing unnecessary iterations and avoiding excessive function calls or variable lookups within the loop.
5. Parallelize operations: If the pattern matching operations can be executed independently, consider parallelizing the code using technologies like Web Workers or ES2017's async/await, which can help utilize multiple CPU cores efficiently.
6. Leverage built-in JavaScript functions: Use standard JavaScript functions that are specifically designed for performance-critical operations. For example, the `indexOf()` or `includes()` functions can quickly search for patterns in arrays.
7. Avoid unnecessary memory allocations: Minimize additional memory allocations by reusing existing variables or arrays instead of creating new ones.
8. Perform benchmarking and profiling: Measure the performance of your code using browser developer tools and profiling tools to identify bottlenecks and areas for optimization.
Remember to balance optimization with maintainability and readability. Sometimes, heavily optimized code can become hard to understand and debug. Aim for a balance that achieves a good trade-off between performance and code maintainability.
*/
		let ax, ay, az, idx
		let blockSet = new Set()
		let sections = []
		let sectionMap = [], sectionTags = [], sectionTagsLength = []//, sectionSkyLights = [], sectionBlockLights = []
		for (let y = 0; y < this.sections.length; y++) {
			const section = this.sections[y], blocks = section.blocks, tags = section.tags, skyLight = section.skyLight, blockLight = section.blockLight
			for (let i = 0; i < blocks.length; i++) {
				if(blocks[i]){
					blockSet.add(blocks[i])
					ax = (i >> 8)
					ay = (i >> 4 & 15) + section.y - minHeight
					az = (i & 15)
					//let str = `${x>>3},${y>>3},${z>>3}` // 8x8x8 sections
					idx = (ax>>3) | (az>>3)<<1 | (ay>>3)<<2
					if (!sectionMap[idx]) {
						sectionMap[idx] = []
						for (let k = 0; k < 6; k++) sectionMap[idx].push(new Int32Array(512).fill(-1))
						sectionTags[idx] = []
						sectionTagsLength[idx] = 0
						sections.push(idx)
					}

					// 6 copies of the chunk, all oriented in different directions so we can see which one compresses the most
					sectionMap[idx][0][(ay & 7) << 6 | (ax & 7) << 3 | az & 7] = blocks[i]
					sectionMap[idx][1][(ay & 7) << 6 | (az & 7) << 3 | ax & 7] = blocks[i]
					sectionMap[idx][2][(ax & 7) << 6 | (ay & 7) << 3 | az & 7] = blocks[i]
					sectionMap[idx][3][(ax & 7) << 6 | (az & 7) << 3 | ay & 7] = blocks[i]
					sectionMap[idx][4][(az & 7) << 6 | (ax & 7) << 3 | ay & 7] = blocks[i]
					sectionMap[idx][5][(az & 7) << 6 | (ay & 7) << 3 | ax & 7] = blocks[i]
					if(tags[i]){
						sectionTags[idx][(ay & 7) << 6 | (ax & 7) << 3 | az & 7] = typeof tags[i] === "number" ? tags[i] : JSON.stringify(tags[i])
						sectionTagsLength[idx]++
					}
				}
				/*if(skyLight[i]){
					ax = (i >> 8)
					ay = (i >> 4 & 15) + section.y - minHeight
					az = (i & 15)
					idx = (ax>>3) | (az>>3)<<1 | (ay>>3)<<2
					if(!sectionSkyLights[idx]){
						sectionSkyLights[idx] = []
						for (let k = 0; k < 6; k++) sectionSkyLights[idx].push(new Uint8Array(512))
						sections.push(idx)
					}
					sectionSkyLights[idx][0][(ay & 7) << 6 | (ax & 7) << 3 | az & 7] = skyLight[i]
					sectionSkyLights[idx][1][(ay & 7) << 6 | (az & 7) << 3 | ax & 7] = skyLight[i]
					sectionSkyLights[idx][2][(ax & 7) << 6 | (ay & 7) << 3 | az & 7] = skyLight[i]
					sectionSkyLights[idx][3][(ax & 7) << 6 | (az & 7) << 3 | ay & 7] = skyLight[i]
					sectionSkyLights[idx][4][(az & 7) << 6 | (ax & 7) << 3 | ay & 7] = skyLight[i]
					sectionSkyLights[idx][5][(az & 7) << 6 | (ay & 7) << 3 | ax & 7] = skyLight[i]
				}
				if(blockLight[i]){
					ax = (i >> 8)
					ay = (i >> 4 & 15) + section.y - minHeight
					az = (i & 15)
					idx = (ax>>3) | (az>>3)<<1 | (ay>>3)<<2
					if(!sectionBlockLights[idx]){
						sectionBlockLights[idx] = []
						for (let k = 0; k < 6; k++) sectionBlockLights[idx].push(new Uint8Array(512))
						sections.push(idx)
					}
					sectionBlockLights[idx][0][(ay & 7) << 6 | (ax & 7) << 3 | az & 7] = blockLight[i]
					sectionBlockLights[idx][1][(ay & 7) << 6 | (az & 7) << 3 | ax & 7] = blockLight[i]
					sectionBlockLights[idx][2][(ax & 7) << 6 | (ay & 7) << 3 | az & 7] = blockLight[i]
					sectionBlockLights[idx][3][(ax & 7) << 6 | (az & 7) << 3 | ay & 7] = blockLight[i]
					sectionBlockLights[idx][4][(az & 7) << 6 | (ax & 7) << 3 | ay & 7] = blockLight[i]
					sectionBlockLights[idx][5][(az & 7) << 6 | (ay & 7) << 3 | ax & 7] = blockLight[i]
				}*/
			}
			await yieldThread()
		}

		let bab = new BitArrayBuilder()
		let blocks = Array.from(blockSet)
		let palette = {}
		blocks.forEach((block, index) => palette[block] = index)
		let paletteBits = BitArrayBuilder.bits(blocks.length)
		bab.add(blocks.length, 32)
		for (let block of blocks) bab.add(block, 32)

		bab.add(sections.length, 32)
		for (let coords of sections) {
			let sx = coords&1, sz = (coords>>1)&1, sy = coords>>2
			bab.add(sx, 1).add(sy, 8).add(sz, 1)

			// Determine the most compact orientation by checking all 6!
			let bestLength = Infinity, bestRuns, bestSingles, bestDir//, bestSkyLightRuns, bestBlockLightRuns
			for (let i = 0; i < 6; i++) {
				let blocks = sectionMap[coords] && sectionMap[coords][i]
				let thisLength = 0
				let runs = []
				let singles = []
				if(blocks){
					let run = null
					for (let i = 0; i < blocks.length; i++) {
						const block = blocks[i]
						if (block >= 0) {
							if (run) {
								if (block === run[1][run[1].length-1][1]) run[1][run[1].length-1][0]++
								else run[1].push([1, block])
							}else if (i < blocks.length - 2 && blocks[i + 1] >= 0 && blocks[i + 2] >= 0) {
								run = [i, [[1, block]]]
								runs.push(run)
							}else singles.push([i, blocks[i]])
						}
						else run = null
					}
					for (let run of runs) {
						// Determine the number of bits needed to store the lengths of each block type
						let maxBlocks = 0
						for (let block of run[1]) maxBlocks = Math.max(maxBlocks, block[0])
						let lenBits = BitArrayBuilder.bits(maxBlocks)
						thisLength += 9+9+4
						thisLength += run[1].length*(lenBits+paletteBits)
						run[2] = lenBits
					}
					thisLength += singles.length*(9+paletteBits)
				}

				/*let slights = sectionSkyLights[coords] && sectionSkyLights[coords][i], blights = sectionBlockLights[coords] && sectionBlockLights[coords][i]
				let skyLightRuns = [], blockLightRuns = []
				if(slights){
					let run = null, run2 = null
					for (let i = 0; i < slights.length; i++) {
						const level = slights[i]
						if (level > 0) {
							if (run) {
								if (level === run[1][run[1].length-1][1]+(run[1][run[1].length-1][2]*run[1][run[1].length-1][0])) run[1][run[1].length-1][0]++
								else run[1].push([1, level, (slights[i+1]||0)-level])
							}else{
								run = [i, [[1, level, (slights[i+1]||0)-level]]]//The 3rd item is which way the gradient goes
								skyLightRuns.push(run)
							}
						}else run = null
					}
					for (let run of skyLightRuns) {
						let maxBlocks = 0
						for (let block of run[1]) maxBlocks = Math.max(maxBlocks, block[0])
						let lenBits = BitArrayBuilder.bits(maxBlocks)
						thisLength += 9+9+4
						thisLength += run[1].length*(lenBits+8+5)
						run[2] = lenBits
					}
				}
				if(blights){
					let run = null, run2 = null
					for (let i = 0; i < blights.length; i++) {
						const level = blights[i]
						if (level > 0) {
							if (run) {
								if (level === run[1][run[1].length-1][1]+(run[1][run[1].length-1][2]*run[1][run[1].length-1][0])) run[1][run[1].length-1][0]++
								else run[1].push([1, level, (blights[i+1]||0)-level])
							}else{
								run = [i, [[1, level, (blights[i+1]||0)-level]]]//The 3rd item is which way the gradient goes
								blockLightRuns.push(run)
							}
						}else run = null
					}
					for (let run of blockLightRuns) {
						let maxBlocks = 0
						for (let block of run[1]) maxBlocks = Math.max(maxBlocks, block[0])
						let lenBits = BitArrayBuilder.bits(maxBlocks)
						thisLength += 9+9+4
						thisLength += run[1].length*(lenBits+4+9)
						run[2] = lenBits
					}
				}*/

				if (thisLength < bestLength) {
					bestLength = thisLength
					bestRuns = runs
					bestSingles = singles
					bestDir = i
					//bestSkyLightRuns = skyLightRuns
					//bestBlockLightRuns = blockLightRuns
				}
				await yieldThread()
			}
			bab.add(bestDir, 3)
			bab.add(bestRuns.length, 8)
			bab.add(bestSingles.length, 9)
			for (let [start, blocks, lenBits] of bestRuns) {
				bab.add(start, 9).add(blocks.length, 9).add(lenBits, 4)
				for (let [count, block] of blocks) bab.add(count - 1, lenBits).add(palette[block], paletteBits)
			}
			for (let [index, block] of bestSingles) {
				bab.add(index, 9).add(palette[block], paletteBits)
			}
			bab.add(sectionTagsLength[coords] || 0,9)
			if(sectionTagsLength[coords]) for(let i in sectionTags[coords]){
				let tags = sectionTags[coords][i]
				bab.add(i,9)
				if(typeof tags === "number"){
					bab.add(0,1)
					bab.add(tags,32)
				}else{
					bab.add(1,1)
					bab.addString(tags,16)
				}
			}
			/*bab.add(bestSkyLightRuns.length, 9)
			for (let [start, blocks, lenBits] of bestSkyLightRuns) {
				bab.add(start, 9).add(blocks.length, 9).add(lenBits, 4)
				for (let [count, level, gradDir] of blocks) bab.add(count - 1, lenBits).add(level, 8).add(gradDir, 9)
			}
			bab.add(bestBlockLightRuns.length, 9)
			for (let [start, blocks, lenBits] of bestBlockLightRuns) {
				bab.add(start, 9).add(blocks.length, 9).add(lenBits, 4)
				for (let [count, level, gradDir] of blocks) bab.add(count - 1, lenBits).add(level, 4).add(gradDir, 5)
			}*/
			await yieldThread()
		}
		return bab.array
	}
	unload(){
		let chunk = this, bab = new BitArrayBuilder()
		
		let blockSet = new Set()
		let sectionMap = {}, sectionTags = {}, sectionTagsLength = {}
		
		if (chunk.edited) {
			for (let y = 0; y < chunk.sections.length; y++) {
				const section = chunk.sections[y], original = chunk.cleanSections[y], blocks = section.blocks, tags = section.tags
				if(!section.edited) continue
				let changes = false
				for (let i = 0; i < blocks.length; i++) {
					if (blocks[i] !== original[i] || tags[i]) {
						blockSet.add(blocks[i])
						changes = true
						let x = (i >> 8) + section.x
						let y = (i >> 4 & 15) + section.y - minHeight
						let z = (i & 15) + section.z
						let str = `${x>>3},${y>>3},${z>>3}` // 8x8x8 sections
						if (!sectionMap[str]) {
							sectionMap[str] = []
							for (let k = 0; k < 6; k++) sectionMap[str].push(new Int32Array(8*8*8).fill(-1))
							sectionTags[str] = []
							sectionTagsLength[str] = 0
						}

						// 6 copies of the chunk, all oriented in different directions so we can see which one compresses the most
						sectionMap[str][0][(y & 7) << 6 | (x & 7) << 3 | z & 7] = blocks[i]
						sectionMap[str][1][(y & 7) << 6 | (z & 7) << 3 | x & 7] = blocks[i]
						sectionMap[str][2][(x & 7) << 6 | (y & 7) << 3 | z & 7] = blocks[i]
						sectionMap[str][3][(x & 7) << 6 | (z & 7) << 3 | y & 7] = blocks[i]
						sectionMap[str][4][(z & 7) << 6 | (x & 7) << 3 | y & 7] = blocks[i]
						sectionMap[str][5][(z & 7) << 6 | (y & 7) << 3 | x & 7] = blocks[i]
						if(tags[i]){
							sectionTags[str][(y & 7) << 6 | (x & 7) << 3 | z & 7] = typeof tags[i] === "number" ? tags[i] : JSON.stringify(tags[i]).substring(0,65535)
							sectionTagsLength[str]++
						}
					}
				}
				if (!changes) {
					section.edited = false
				}
			}
		}
		
		let sections = Object.entries(sectionMap)
		if(!sections.length && !this.entities.size) return

		let blocks = Array.from(blockSet)
		let palette = {}
		blocks.forEach((block, index) => palette[block] = index)
		let paletteBits = BitArrayBuilder.bits(blocks.length)
		bab.add(blocks.length, 32)
		for (let block of blocks) bab.add(block, 32)

		bab.add(sections.length, 32)
		for (let [coords, section] of sections) {
			let [sx, sy, sz] = coords.split(",")
			sx = +sx, sy = +sy, sz = +sz
			bab.add(sx, 1).add(sy, 8).add(sz, 1)

			// Determine the most compact orientation by checking all 6!
			let bestBAB = null
			for (let i = 0; i < 6; i++) {
				let bab = new BitArrayBuilder()

				let blocks = section[i]
				bab.add(i, 3)

				let run = null
				let runs = []
				let singles = []
				for (let i = 0; i < blocks.length; i++) {
					const block = blocks[i]
					if (block >= 0) {
						if (!run && i < blocks.length - 2 && blocks[i + 1] >= 0 && blocks[i + 2] >= 0) {
							run = [i, []]
							runs.push(run)
						}
						if (run) {
							if (run[1].length && block === run[1][run[1].length-1][1]) run[1][run[1].length-1][0]++
							else run[1].push([1, block])
						}
						else singles.push([i, blocks[i]])
					}
					else run = null
				}

				bab.add(runs.length, 8)
				bab.add(singles.length, 9)
				for (let [start, blocks] of runs) {
					// Determine the number of bits needed to store the lengths of each block type
					let maxBlocks = 0
					for (let block of blocks) maxBlocks = Math.max(maxBlocks, block[0])
					let lenBits = BitArrayBuilder.bits(maxBlocks)

					bab.add(start, 9).add(blocks.length, 9).add(lenBits, 4)
					for (let [count, block] of blocks) bab.add(count - 1, lenBits).add(palette[block], paletteBits)
				}
				for (let [index, block] of singles) {
					bab.add(index, 9).add(palette[block], paletteBits)
				}
				bab.add(sectionTagsLength[coords],9)
				if(sectionTagsLength[coords]) for(let i in sectionTags[coords]){
					let tags = sectionTags[coords][i]
					bab.add(i,9)
					if(typeof tags === "number"){
						bab.add(0,1)
						bab.add(tags,32)
					}else{
						bab.add(1,1)
						bab.addString(tags,16)
					}
				}
				if (!bestBAB || bab.bitLength < bestBAB.bitLength) {
					bestBAB = bab
				}
			}
			bab.append(bestBAB)
		}

		let entities = [...this.entities.values()].filter(r => !r.remote)
		bab.add(entities.length,32)
		let now = performance.now()
		for(let i of entities){
			let pos = this.world.world.getEntPos(i,now)
			bab.add(pos.bitLength,16)
			bab.append(pos)
		}
		
		this.world.world.loadFrom[`${this.x>>4},${this.z>>4},${this.type}`] = bab.array
	}
}

let explodeSounds = ["random.explode1", "random.explode2", "random.explode3", "random.explode4"]
function explodeSound(x,y,z, power = 1, world){
	var sound, soundPower
	//explodeSounds[Math.floor(Math.random()*explodeSounds.length)]
	if(power >= 10) {sound = explodeSounds[0], soundPower = 10}
	else if(power >= 8) {sound = explodeSounds[1], soundPower = 8}
	else if(power >= 4) {sound = explodeSounds[2], soundPower = 4}
	else {sound = explodeSounds[3], soundPower = 1}
	
	var pitch = 1 - ((power - soundPower) / 10)
	if(pitch <= 0) return
	
	world.playSound(x,y,z,sound,1, pitch)
}
let doorSounds = {
	fence_gateOpen:2,
	fence_gateClose:2,
	wooden_doorOpen:4,
	wooden_doorClose:6,
	iron_doorOpen:4,
	iron_doorClose:4,
	wooden_trapdoorOpen:5,
	wooden_trapdoorClose:3,
	iron_trapdoorOpen:4,
	iron_trapdoorClose:4
}
function doorSound(x,y,z,type,open, world){
	let a = doorSounds[type+(open?"Open":"Close")]
	var i = type+"."+(open?"open":"close")+Math.ceil(Math.random()*a)
	world.playSound(x,y,z,i)
}

function fall(x,y,z,b,world, instant, solid = true){
	if(!world.world.settings.blocksFall || world.getBlock(x,y-1,z)) return
	if(instant){
		world.setBlock(x,y,z, 0, false,false,false,false)
		world.addEntity(new entities[entityIds.BlockEntity](b, x,y,z, solid),false)
	}else{
		world.setTimeout(() => {
			if(world.getBlock(x,y-1,z)) return
			
			world.setBlock(x,y,z, 0, false,false,false,false)
			world.addEntity(new entities[entityIds.BlockEntity](b, x,y,z, solid),false)
		}, tickTime, x,y,z)
	}
	return true
}
function needsSupportingBlocks(x,y,z, b,world){ // if block under is gone, dissapear
	if(!world.world.settings.blocksFall) return
	var under = world.getBlock(x,y-1,z)
	if(!under || !blockData[under].solid){
		world.setTimeout(() => {
			var under = world.getBlock(x,y-1,z)
			if(under && blockData[under].solid) return
			world.setBlock(x,y,z, 0,false,false,false,false)
			world.addItems(x,y,z,0,0,0,b&isCube,true)
			world.blockParticles(b,x,y,z,30, "break")
			world.blockSound(b, "dig", x,y,z)
		}, tickTime, x,y,z)
		return true
	}
}
function putItemInContainer(x,y,z,id,durability,customName,lazy,world){
	var tags = world.getTags(x,y,z)
	if(typeof tags === "number") return false
	var block = world.getBlock(x,y,z)
	if(!blockData[block].hasContents || !blockData[block].hasContents(tags)){
		if(blockData[block].setContents) tags = blockData[block].setContents(x,y,z,world)
		else return false
	}
	for(var i=0; i<tags.contents.length; i++){
		if(!tags.contents[i]){
			tags.contents[i] = {id,amount:1,durability,customName}
			if(!lazy) world.setTags(x,y,z,tags)
			return true
		}else if(tags.contents[i].id === id && (!tags.contents[i].customName && !customName || tags.contents[i].customName === customName) && tags.contents[i].amount < blockData[id].stackSize){
			tags.contents[i].amount++
			if(!lazy) world.setTags(x,y,z,tags)
			return true
		}
	}
	return false
}
function getContainerFullness(x,y,z,world){
	var tags = world.getTags(x,y,z)
	var block = world.getBlock(x,y,z)
	if(tags && blockData[block].name === "furnace"){
		return (
			(tags.input && tags.input.id && tags.input.amount / blockData[tags.input.id].stackSize || 0)
		 +(tags.output && tags.output.id && tags.output.amount / blockData[tags.output.id].stackSize || 0)
		 +(tags.fuel && tags.fuel.id && tags.fuel.amount / blockData[tags.fuel.id].stackSize || 0)
		) / 3
	}else if(blockData[block].name === "composter"){
		return blockData[block].getLevel(block) / 16
	}else if(blockData[block].name === "endPortalFrame"){
		return ((block & SLAB) === SLAB) * 1
	}else if(tags && blockData[block].itemFrame){
		return (tags.rot || 0) / 16
	}else if((typeof tags === "object") && tags.contents){
		var f = 0
		for(var i of tags.contents){
			if(i && i.id) f += i.amount / blockData[i.id].stackSize
		}
		f /= tags.contents.length
		return f
	}
}
let nearEntityArray = []
function pressurePlateHasPressure(x,y,z,world){
	world.getEntitiesNear(x,y,z, 2, nearEntityArray)
	for(var ent of nearEntityArray){
		let w2 = ent.width/2, h2 = ent.height/2, d2 = ent.depth/2
		if(x - 0.5 < ent.x + w2 &&
			 x + 0.5 > ent.x - w2 &&
			 y - 0.5 < ent.y + h2 &&
			 y - 0.25 > ent.y - h2 &&
			 z - 0.5 < ent.z + d2 &&
			 z + 0.5 > ent.z - d2) return true
	}
	for(let ent of world.world.players){
		let w2 = ent.width/2, h2 = ent.height/2, d2 = ent.depth/2
		if(x - 0.5 < ent.x + w2 &&
			 x + 0.5 > ent.x - w2 &&
			 y - 0.5 < ent.y + h2 &&
			 y - 0.25 > ent.y - h2 &&
			 z - 0.5 < ent.z + d2 &&
			 z + 0.5 > ent.z - d2) return true
	}
	return false
}
let onBoxEnt = function(x, y, z, w, h, d, ent) {
	let iy = y - h/2 - (ent.height*0.5 || ent.height/2)
	let ih = h + (ent.height || ent.height)
	let ix = x - w/2 - (ent.width*0.5 || ent.width/2)
	let iw = w + (ent.width || ent.width)
	let iz = z - d/2 - (ent.depth*0.5 || ent.width/2)
	let id = d + (ent.depth || ent.width)
	return ent.x > ix && ent.y > iy && ent.z > iz && ent.x < ix + iw && ent.y <= iy + ih && ent.z < iz + id
}

function hitSound(p){
	var i = Math.ceil(Math.random()*3)
	p.world.playSound(p.x,p.y,p.z,"damage.hit"+i)
}
function drownHurtSound(p){
	var i = Math.ceil(Math.random()*4)
	p.world.playSound(p.x,p.y,p.z,"damage.drown"+i)
}
function freezeHurtSound(p){
	var i = Math.ceil(Math.random()*5)
	p.world.playSound(p.x,p.y,p.z,"damage.freeze"+i)
}
function fireHurtSound(p){
	var i = Math.ceil(Math.random()*3)
	p.world.playSound(p.x,p.y,p.z,"damage.fire"+i)
}
function berrybushHurtSound(p){
	var i = Math.ceil(Math.random()*2)
	p.world.playSound(p.x,p.y,p.z,"damage.berrybush"+i)
}
function oofSound(p){
	p.world.playSound(p.x,p.y,p.z,"damage.classic_hurt")
}
function getEntityOrPlayer(id,world){
	for(let p of world.world.players){
		if(p.id === id) return p
	}
	for(let i=0; i<world.world.entities.length; i++){
		if(world.world.entities[i].id === id){
			return world.world.entities[i]
		}
	}
}
function getPlayerByUsername(username2,world){
	for(let p of world.world.players){
		if(p.username === username2) return p
	}
}
function getPlayerById(id,world){
	for(let p of world.world.players){
		if(p.id === id) return p
	}
}

let entPlayerCollided
function entCollided(ent){
	var w2 = ent.width/2, h2 = ent.height/2, d2 = ent.depth/2
	entPlayerCollided = false
	ent.world.getEntitiesNear(ent.x,ent.y,ent.z, 2, nearEntityArray)
	for(var e of nearEntityArray){
		if(e === ent || e.dimension !== ent.dimension) continue
		let ew2 = e.width/2, eh2 = e.height/2, ed2 = e.depth/2
		if(ent.x - w2 < e.x + ew2 &&
		 ent.x + w2 > e.x - ew2 &&
		 ent.y - h2 < e.y + eh2 &&
		 ent.y - h2 > e.y - eh2 &&
		 ent.z - d2 < e.z + ed2 &&
		 ent.z + d2 > e.z - ed2) return e
	}
	for(let e of ent.world.world.players){
		if(e === ent || e.dimension !== ent.dimension || e.hidden || e.die) continue
		let ew2 = e.width/2, eh2 = e.height/2, ed2 = e.depth/2
		if(ent.x - w2 < e.x + ew2 &&
			ent.x + w2 > e.x - ew2 &&
			ent.y - h2 < e.y + eh2 &&
			ent.y - h2 > e.y - eh2 &&
			ent.z - d2 < e.z + ed2 &&
			ent.z + d2 > e.z - ed2){
			entPlayerCollided = true
			return e
		}
	}
}
function getSignSide(tags,p){
	let ry = p.ry*16/Math.PId
	let diff = tags.rot - ry
	if(diff < 0) diff += 16
	if(diff >= 16) diff -= 16
	return diff>4 && diff<12
}

function maxDist(x, z, x2, z2) {
	let ax = abs(x2 - x)
	let az = abs(z2 - z)
	return max(ax, az)
}
let chunkPlayerDistArr = []
let sortChunkPX = 0
let sortChunkPZ = 0
function sortChunks(c1, c2) { //Sort the list of chunks based on distance from the player
	let dx1 = sortChunkPX - c1.x - 8
	let dy1 = sortChunkPZ - c1.z - 8
	let dx2 = sortChunkPX - c2.x - 8
	let dy2 = sortChunkPZ - c2.z - 8
	return dx1 * dx1 + dy1 * dy1 - (dx2 * dx2 + dy2 * dy2)
}
const {
	seedHash,
	hash, hash3
} = (() => {
	// closure around mutable `seed`; updated via calls to `seedHash`

	let seed = Math.random() * 2100000000 | 0;

	const PRIME32_2 = 1883677709;
	const PRIME32_3 = 2034071983;
	const PRIME32_4 = 668265263;
	const PRIME32_5 = 374761393;

	const seedHash = s => {
		seed = s | 0;
	}

	const { imul } = Math;

	const hash = (x, y) => {
		let h32 = 0;

		h32 = seed + PRIME32_5 | 0;
		h32 += 8;

		h32 += imul(x, PRIME32_3);
		h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
		h32 += imul(y, PRIME32_3);
		h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);

		h32 ^= h32 >> 15;
		h32 *= PRIME32_2;
		h32 ^= h32 >> 13;
		h32 *= PRIME32_3;
		h32 ^= h32 >> 16;

		return h32 / 2147483647;
	};
	const hash3 = (x, y, z) => {
		let h32 = 0;

		h32 = seed + PRIME32_5 | 0;
		h32 += 8;

		h32 += imul(x, PRIME32_3);
		h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
		h32 += imul(y, PRIME32_3);
		h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
		h32 += imul(z, PRIME32_3);
		h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);

		h32 ^= h32 >> 15;
		h32 *= PRIME32_2;
		h32 ^= h32 >> 13;
		h32 *= PRIME32_3;
		h32 ^= h32 >> 16;

		return h32 / 2147483647;
	};

	return {
		seedHash,
		hash, hash3
	};
})();

class Marsaglia {
	// from http://www.math.uni-bielefeld.de/~sillke/ALGORITHMS/random/marsaglia-c

	nextInt() {
		const { z, w } = this;

		this.z = 36969 * (z & 65535) + (z >>> 16) & 0xFFFFFFFF;
		this.w = 18000 * (w & 65535) + (w >>> 16) & 0xFFFFFFFF;

		return ((this.z & 0xFFFF) << 16 | this.w & 0xFFFF) & 0xFFFFFFFF;
	}

	nextDouble() {
		const i = this.nextInt() / 4294967296;

		const is_less_than_zero = (i < 0) | 0; // cast to 1 or 0

		return is_less_than_zero + i;
	}

	constructor(i1, i2) { // better param names
		this.z = (i1 | 0) || 362436069;
		this.w = i2 || hash(521288629, this.z) * 2147483647 | 0;
	}
}

// The noise and random functions are copied from the processing.js source code; these others are polyfills made by me to avoid needing to remove all the pjs draw calls

const {
	randomSeed,
	random,
	useRandom
} = (() => {
	// closure around mut `currentRandom`

	let currentRandoms = [], currentRandom, currentRandomId
	let randoms = {}

	const randomSeed = seed => {
		currentRandoms.length = 0
		currentRandoms.push(new Marsaglia(seed))
		for(let i=0; i<5; i++) currentRandoms.push(new Marsaglia(hash(seed,i) * 210000000))
		//Random types: Trees, grass and flowers, cave foliage, ores, rocks
		currentRandom = currentRandoms[0]
	};

	function useRandom(id){
		currentRandomId = id
		currentRandom = currentRandoms[id]
	}

	const random = (min, max) => {
		if (!max) {
			if (min) {
				max = min;
				min = 0;
			} else {
				min = 0;
				max = 1;
			}
		}

		return currentRandom.nextDouble() * (max - min) + min;
	};
	win.serverRandomRandom = () => currentRandom = new Marsaglia(Math.random() * 210000000)
	win.serverRestoreRandom = () => currentRandom = currentRandom[currentRandomId]//prevent random in populate from messing up because it is async

	return {
		randomSeed,
		random,
		useRandom
	};
})()

let savedWorldGenArrayLen
win.serverSaveWorldGen = () => {
	win.serverRandomRandom()
	savedWorldGenArrayLen = worldGenArray.size
}
win.serverRestoreWorldGen = () => {
	win.serverRestoreRandom()
	worldGenArray.size = savedWorldGenArrayLen
}

class PerlinNoise {
	// http://www.noisemachine.com/talk1/17b.html
	// http://mrl.nyu.edu/~perlin/noise/

	static grad3d(i, x, y, z) {
		const h = i & 15; // convert into 12 gradient directions

		const u = h < 8
			? x
			: y;

		const v = h < 4
			? y
			: h === 12 || h === 14
				? x
				: z;

		return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v)
	}

	static grad2d(i, x, y) {
		const v = (i & 1) === 0
			? x
			: y;

		return (i & 2) === 0
			? -v
			: v;
	}

	static grad1d(i, x) {
		return (i & 1) === 0
			? -x
			: x;
	}

	static lerp(t, a, b) {
		return a + t * (b - a);
	}

	// end of statics

	// permutation
	perm = new Uint8Array(0x200);

	// prototype functions:
	noise3d(x, y, z) {
		const { floor } = Math;

		const X = floor(x) & 0xff;
		const Y = floor(y) & 0xff;
		const Z = floor(z) & 0xff;

		x -= floor(x);
		y -= floor(y);
		z -= floor(z);

		const fx = (3 - 2 * x) * x * x;
		const fy = (3 - 2 * y) * y * y;
		const fz = (3 - 2 * z) * z * z;

		const { perm } = this;

		const p0 = perm[X] + Y;
		const p00 = perm[p0] + Z;
		const p01 = perm[p0 + 1] + Z;
		const p1 = perm[X + 1] + Y;
		const p10 = perm[p1] + Z;
		const p11 = perm[p1 + 1] + Z;

		const { lerp, grad3d } = PerlinNoise;

		return lerp(
			fz,
			lerp(
				fy,
				lerp(
					fx,
					grad3d(perm[p00], x, y, z),
					grad3d(perm[p10], x - 1, y, z)
				),
				lerp(
					fx,
					grad3d(perm[p01], x, y - 1, z),
					grad3d(perm[p11],x - 1, y - 1, z)
				)
			),
			lerp(
				fy,
				lerp(
					fx,
					grad3d(perm[p00 + 1], x, y, z - 1),
					grad3d(perm[p10 + 1], x - 1, y, z - 1)
				),
				lerp(
					fx,
					grad3d(perm[p01 + 1], x, y - 1, z - 1),
					grad3d(perm[p11 + 1], x - 1, y - 1, z - 1)
				)
			)
		);
	}

	noise2d(x, y) {
		const { floor } = Math;

		const X = floor(x) & 0xff;
		const Y = floor(y) & 0xff;

		x -= floor(x);
		y -= floor(y);

		const { perm } = this;
		const fx = (3 - 2 * x) * x * x;
		const fy = (3 - 2 * y) * y * y;
		const p0 = perm[X] + Y;
		const p1 = perm[X + 1] + Y;

		const { lerp, grad2d } = PerlinNoise;

		return lerp(
			fy,
			lerp(
				fx,
				grad2d(
					perm[p0],
					x,
					y
				),
				grad2d(
					perm[p1],
					x - 1,
					y
				)
			),
			lerp(
				fx,
				grad2d(
					perm[p0 + 1],
					x,
					y - 1
				),
				grad2d(
					perm[p1 + 1],
					x - 1,
					y - 1
				)
			)
		);
	}

	noise1d(x) {
		const { floor } = Math;

		const X = floor(x) & 0xff;

		x -= floor(x);

		const fx = (3 - 2 * x) * x * x;

		const { lerp, grad1d } = PerlinNoise;

		return lerp(
			fx,
			grad1d(perm[X], x),
			grad1d(perm[X + 1], x - 1)
		);
	}

	constructor(seed) {
		if (seed === undefined) {
			throw new TypeError("A value for `seed` parameter was not provided to `PerlinNoise`");
		}

		const rnd = new Marsaglia(seed);

		// generate permutation
		const { perm } = this;

		// fill 0x0..0x100
		for (let i = 0; i < 0x100; ++i) {
			perm[i] = i;
		}

		for (let i = 0; i < 0x100; ++i) {
			const j = rnd.nextInt() & 0xFF;
			const t = perm[j];
			perm[j] = perm[i];
			perm[i] = t;
		}

		// copy to avoid taking mod in perm[0]
		// copies from first half of array, into the second half
		perm.copyWithin(0x100, 0x0, 0x100);
	}
}
win.PerlinNoise = PerlinNoise
// Copied and modified from https://github.com/blindman67/SimplexNoiseJS
function openSimplexNoise(clientSeed) {
	const SQ4 = 2
	const toNums = function(s) { return s.split(",").map(function(s) { return new Uint8Array(s.split("").map(function(v) { return Number(v) })) }) }
	const decode = function(m, r, s) { return new Int8Array(s.split("").map(function(v) { return parseInt(v, r) + m })) }
	const toNumsB32 = function(s) { return s.split(",").map(function(s) { return parseInt(s, 32) }) }
	const NORM_3D = 1.0 / 206.0
	const SQUISH_3D = 1 / 3
	const STRETCH_3D = -1 / 6
	var base3D = toNums("0000110010101001,2110210120113111,110010101001211021012011")
	const gradients3D = decode(-11, 23, "0ff7mf7fmmfffmfffm07f70f77mm7ff0ff7m0f77m77f0mf7fm7ff0077707770m77f07f70")
	var lookupPairs3D = function() { return new Uint16Array(toNumsB32("0,2,1,1,2,2,5,1,6,0,7,0,10,2,12,2,41,1,45,1,50,5,51,5,g6,0,g7,0,h2,4,h6,4,k5,3,k7,3,l0,5,l1,5,l2,4,l5,3,l6,4,l7,3,l8,d,l9,d,la,c,ld,e,le,c,lf,e,m8,k,ma,i,p9,l,pd,n,q8,k,q9,l,15e,j,15f,m,16a,i,16e,j,19d,n,19f,m,1a8,f,1a9,h,1aa,f,1ad,h,1ae,g,1af,g,1ag,b,1ah,a,1ai,b,1al,a,1am,9,1an,9,1bg,b,1bi,b,1eh,a,1el,a,1fg,8,1fh,8,1qm,9,1qn,9,1ri,7,1rm,7,1ul,6,1un,6,1vg,8,1vh,8,1vi,7,1vl,6,1vm,7,1vn,6")) }
	var p3D = decode(-1, 5, "112011210110211120110121102132212220132122202131222022243214231243124213241324123222113311221213131221123113311112202311112022311112220342223113342223311342223131322023113322023311320223113320223131322203311322203131")
	const setOf = function(count) { var a = [],i = 0; while (i < count) { a.push(i++) } return a }
	const doFor = function(count, cb) { var i = 0; while (i < count && cb(i++) !== true) {} }

	function shuffleSeed(seed,count){
		seed = seed * 1664525 + 1013904223 | 0
		count -= 1
		return count > 0 ? shuffleSeed(seed, count) : seed
	}
	const types = {
		_3D : {
			base : base3D,
			squish : SQUISH_3D,
			dimensions : 3,
			pD : p3D,
			lookup : lookupPairs3D,
		}
	}

	function createContribution(type, baseSet, index) {
		var i = 0
		const multiplier = baseSet[index ++]
		const c = { next : undefined }
		while(i < type.dimensions) {
			const axis = ("xyzw")[i]
			c[axis + "sb"] = baseSet[index + i]
			c["d" + axis] = - baseSet[index + i++] - multiplier * type.squish
		}
		return c
	}

	function createLookupPairs(lookupArray, contributions){
		var i
		const a = lookupArray()
		const res = new Map()
		for (i = 0; i < a.length; i += 2) { res.set(a[i], contributions[a[i + 1]]); }
		return res
	}

	function createContributionArray(type) {
		const conts = []
		const d = type.dimensions
		const baseStep = d * d
		var k, i = 0
		while (i < type.pD.length) {
			const baseSet = type.base[type.pD[i]]
			let previous, current
			k = 0
			do {
				current = createContribution(type, baseSet, k)
				if (!previous) { conts[i / baseStep] = current; }
				else { previous.next = current; }
				previous = current
				k += d + 1
			} while(k < baseSet.length)

			current.next = createContribution(type, type.pD, i + 1)
			if (d >= 3) { current.next.next = createContribution(type, type.pD, i + d + 2) }
			if (d === 4) { current.next.next.next = createContribution(type, type.pD, i + 11) }
			i += baseStep
		}
		const result = [conts, createLookupPairs(type.lookup, conts)]
		type.base = undefined
		type.lookup = undefined
		return result
	}

	let temp = createContributionArray(types._3D)
	const contributions3D = temp[0], lookup3D = temp[1]
	const perm = new Uint8Array(256)
	const perm3D = new Uint8Array(256)
	const source = new Uint8Array(setOf(256))
	var seed = shuffleSeed(clientSeed, 3)
	doFor(256, function(i) {
		i = 255 - i
		seed = shuffleSeed(seed, 1)
		var r = (seed + 31) % (i + 1)
		r += r < 0 ? i + 1 : 0
		perm[i] = source[r]
		perm3D[i] = (perm[i] % 24) * 3
		source[r] = source[i]
	})
	base3D = undefined
	lookupPairs3D = undefined
	p3D = undefined

	return function(x, y, z) {
		const pD = perm3D
		const p = perm
		const g = gradients3D
		const stretchOffset = (x + y + z) * STRETCH_3D
		const xs = x + stretchOffset, ys = y + stretchOffset, zs = z + stretchOffset
		const xsb = floor(xs), ysb = floor(ys), zsb = floor(zs)
		const squishOffset	= (xsb + ysb + zsb) * SQUISH_3D
		const dx0 = x - (xsb + squishOffset), dy0 = y - (ysb + squishOffset), dz0 = z - (zsb + squishOffset)
		const xins = xs - xsb, yins = ys - ysb, zins = zs - zsb
		const inSum = xins + yins + zins
		var c = lookup3D.get(
			(yins - zins + 1) |
			((xins - yins + 1) << 1) |
			((xins - zins + 1) << 2) |
			(inSum << 3) |
			((inSum + zins) << 5) |
			((inSum + yins) << 7) |
			((inSum + xins) << 9)
		)
		var i, value = 0
		while (c !== undefined) {
			const dx = dx0 + c.dx, dy = dy0 + c.dy, dz = dz0 + c.dz
			let attn = 2 - dx * dx - dy * dy - dz * dz
			if (attn > 0) {
				i = pD[(((p[(xsb + c.xsb) & 0xFF] + (ysb + c.ysb)) & 0xFF) + (zsb + c.zsb)) & 0xFF]
				attn *= attn
				value += attn * attn * (g[i++] * dx + g[i++] * dy + g[i] * dz)
			}
			c = c.next
		}
		return value * NORM_3D + 0.5
	}
}
// Save the coords for a small sphere used to carve out caves
let sphere;
{
	let blocks = []
	let radius = 3.5
	let radsq = radius * radius
	for (let i = -radius; i <= radius; i++) {
		for (let j = -radius; j <= radius; j++) {
			for (let k = -radius; k <= radius; k++) {
				if (i*i + j*j + k*k < radsq) {
					blocks.push(i|0, j|0, k|0)
				}
			}
		}
	}
	sphere = new Int8Array(blocks)
}

function isCave(x, y, z, world) {
	// Generate a 3D rigid multifractal noise shell.
	// Then generate another one with different coordinates.
	// Overlay them on top of each other, and the overlapping parts should form a cave-like structure.
	// This is extremely slow, and requires generating 2 noise values for every single block in the world.
	// TODO: replace with a crawler system of some sort, that will never rely on a head position in un-generated chunks.
	let smooth = 0.02
	let caveSize = 0.0055
	return abs(0.5 - world.world.caveNoise(x * smooth, y * smooth, z * smooth)) < caveSize
		&& abs(0.5 - world.world.caveNoise(y * smooth, z * smooth, x * smooth)) < caveSize
}

class PVector {
	constructor(x, y, z) {
		this.x = x
		this.y = y
		this.z = z
	}
	set(x, y, z) {
		if (y === undefined) {
			this.x = x.x
			this.y = x.y
			this.z = x.z
		} else {
			this.x = x
			this.y = y
			this.z = z
		}
	}
	normalize() {
		let mag = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
		this.x /= mag
		this.y /= mag
		this.z /= mag
	}
	add(x,y,z) {
		if (y === undefined) {
			this.x += x.x
			this.y += x.y
			this.z += x.z
		} else {
			this.x += x
			this.y += y
			this.z += z
		}
	}
	mult(m) {
		this.x *= m
		this.y *= m
		this.z *= m
	}
	mag() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
	}
	magSquared() {
		return this.x * this.x + this.y * this.y + this.z * this.z
	}
	crossProduct(x,y,z,vector) {
		vector.x = this.y * z - this.z * y
		vector.y = this.z * x - this.x * z
		vector.z = this.x * y - this.y * x
		return vector
	}
	crossProductVector(vector) {
		this.set(
			this.y * vector.z - this.z * vector.y,
			this.z * vector.x - this.x * vector.z,
			this.x * vector.y - this.y * vector.x
		)
	}
	product(x,y,z,vector) {
		vector.x = this.x * x
		vector.y = this.y * y
		vector.z = this.z * z
		return vector
	}
}
win.PVector = PVector
let vec1 = new PVector(), vec2 = new PVector(), vec3 = new PVector(), vec4 = new PVector()
class Quaternion{
	constructor(x, y, z, w) {
		this.x = x
		this.y = y
		this.z = z
		this.w = w
	}
	set(x, y, z, w) {
		this.x = x
		this.y = y
		this.z = z
		this.w = w
	}
	static fromAxisAngle(angle, dx,dy,dz){
		let s = sin(angle*0.5)
		return new this(dx*s,dy*s,dz*s,cos(angle*0.5))
	}
	fromAxisAngle(angle, dx,dy,dz){
		let s = sin(angle*0.5)
		this.set(dx*s,dy*s,dz*s,cos(angle*0.5))
	}
	mult(other){
		this.set(
			-other.x * this.x - other.y * this.y - other.z * this.z + other.w * this.w,
			other.x * this.w + other.y * this.z - other.z * this.y + other.w * this.x,
			-other.x * this.z + other.y * this.w + other.z * this.x + other.w * this.y,
			other.x * this.y - other.y * this.x + other.z * this.w + other.w * this.z
		)
	}
	rotateVector(v){//from https://gamedev.stackexchange.com/questions/28395/rotating-vector3-by-a-quaternion
		let num12 = this.x + this.x;
    let num2 = this.y + this.y;
    let num = this.z + this.z;
    let num11 = this.w * num12;
    let num10 = this.w * num2;
    let num9 = this.w * num;
    let num8 = this.x * num12;
    let num7 = this.x * num2;
    let num6 = this.x * num;
    let num5 = this.y * num2;
    let num4 = this.y * num;
    let num3 = this.z * num;
    let num15 = ((v.x * ((1 - num5) - num3)) + (v.y * (num7 - num9))) + (v.z * (num6 + num10));
    let num14 = ((v.x * (num7 + num9)) + (v.y * ((1 - num8) - num3))) + (v.z * (num4 - num11));
    let num13 = ((v.x * (num6 - num10)) + (v.y * (num4 + num11))) + (v.z * ((1 - num8) - num5));
    v.x = num15;
    v.y = num14;
    v.z = num13;
	}
}

//piston extend & retract
const pistonPushLimit = 12
function pistonFindStickyBlocksConnectedTo(cx,cy,cz,tx,ty,tz,block,blocks,checkProp,world){
	//c = current position, t = direction
	var spreadAt = [cx,cy,cz,block]
	while(spreadAt.length){
		var sx = spreadAt[0]
		var sy = spreadAt[1]
		var sz = spreadAt[2]
		var block2
		block2 = world.getBlock(sx,sy,sz+1)
		if(block2 && !xyArrayHas(blocks,spreadAt,sx,sy,sz+1)){
			if(!blockData[block2][checkProp]){
				if(!tx && !ty && tz === 1) return false
			}else if(blockData[block2].sticky && block2 !== block && !(!tx && !ty && tz === 1)){
			}else{
				blocks.push(sx,sy,sz+1,block2)
				if(blockData[block2].sticky){
					spreadAt.push(sx,sy,sz+1,block2)
				}else if(!(!tx && !ty && tz === -1)){
					if(pistonFindStack(sx,sy,sz+1,tx,ty,tz,blocks,world) === false) return false
				}
			}
		}
		block2 = world.getBlock(sx,sy,sz-1)
		if(block2 && !xyArrayHas(blocks,spreadAt,sx,sy,sz-1)){
			if(!blockData[block2][checkProp]){
				if(!tx && !ty && tz === -1) return false
			}else if(blockData[block2].sticky && block2 !== block && !(!tx && !ty && tz === -1)){
			}else{
				blocks.push(sx,sy,sz-1,block2)
				if(blockData[block2].sticky){
					spreadAt.push(sx,sy,sz-1,block2)
				}else if(!(!tx && !ty && tz === 1)){
					if(pistonFindStack(sx,sy,sz-1,tx,ty,tz,blocks,world) === false) return false
				}
			}
		}
		block2 = world.getBlock(sx,sy+1,sz)
		if(block2 && !xyArrayHas(blocks,spreadAt,sx,sy+1,sz)){
			if(!blockData[block2][checkProp]){
				if(!tx && ty === 1 && !tz) return false
			}else if(blockData[block2].sticky && block2 !== block && !(!tx && ty === 1 && !tz)){
			}else{
				blocks.push(sx,sy+1,sz,block2)
				if(blockData[block2].sticky){
					spreadAt.push(sx,sy+1,sz,block2)
				}else if(!(!tx && ty === -1 && !tz)){
					if(pistonFindStack(sx,sy+1,sz,tx,ty,tz,blocks,world) === false) return false
				}
			}
		}
		block2 = world.getBlock(sx,sy-1,sz)
		if(block2 && !xyArrayHas(blocks,spreadAt,sx,sy-1,sz)){
			if(!blockData[block2][checkProp]){
				if(!tx && ty === -1 && !tz) return false
			}else if(blockData[block2].sticky && block2 !== block && !(!tx && ty === -1 && !tz)){
			}else{
				blocks.push(sx,sy-1,sz,block2)
				if(blockData[block2].sticky){
					spreadAt.push(sx,sy-1,sz,block2)
				}else if(!(!tx && ty === 1 && !tz)){
					if(pistonFindStack(sx,sy-1,sz,tx,ty,tz,blocks,world) === false) return false
				}
			}
		}
		block2 = world.getBlock(sx+1,sy,sz)
		if(block2 && !xyArrayHas(blocks,spreadAt,sx+1,sy,sz)){
			if(!blockData[block2][checkProp]){
				if(tx === 1 && !ty && !tz) return false
			}else if(blockData[block2].sticky && block2 !== block && !(tx === 1 && !ty && !tz)){
			}else{
				blocks.push(sx+1,sy,sz,block2)
				if(blockData[block2].sticky){
					spreadAt.push(sx+1,sy,sz,block2)
				}else if(!(tx === -1 && !ty && !tz)){
					if(pistonFindStack(sx+1,sy,sz,tx,ty,tz,blocks,world) === false) return false
				}
			}
		}
		block2 = world.getBlock(sx-1,sy,sz)
		if(block2 && !xyArrayHas(blocks,spreadAt,sx-1,sy,sz)){
			if(!blockData[block2][checkProp]){
				if(tx === -1 && !ty && !tz) return false
			}else if(blockData[block2].sticky && block2 !== block && !(tx === -1 && !ty && !tz)){
			}else{
				blocks.push(sx-1,sy,sz,block2)
				if(blockData[block2].sticky){
					spreadAt.push(sx-1,sy,sz,block2)
				}else if(!(tx === 1 && !ty && !tz)){
					if(pistonFindStack(sx-1,sy,sz,tx,ty,tz,blocks,world) === false) return false
				}
			}
		}
		
		spreadAt.splice(0,4)
	}
}
win.pistonFindStickyBlocksConnectedTo = pistonFindStickyBlocksConnectedTo
function pistonFindStack(x,y,z,tx,ty,tz,blocks,world){
	var cx = x, cy = y, cz = z  //current position
	for(var i=0; i<pistonPushLimit+1; i++){
		cx += tx
		cy += ty
		cz += tz
		var block = world.getBlock(cx,cy,cz)
		if(block && !blockData[block].pistonPush) return false
		if(blockData[block].sticky){
			if(pistonFindStickyBlocksConnectedTo(cx,cy,cz,tx,ty,tz,block,blocks,"pistonPush",world) === false) return false
		}
		if(block){if(!xyArrayHas(blocks,null,cx,cy,cz)){blocks.push(cx,cy,cz,block)}}
		else break
	}
}
function getPistonPushedBlocks(x,y,z,tx,ty,tz,world){
	var blocks = [x,y,z,0]
	if(pistonFindStack(x,y,z,tx,ty,tz,blocks,world) === false) return false
	blocks.splice(0,4) //remove the temporary coordinates
	if((blocks.length / 4) > pistonPushLimit) return false
	
	return blocks
}
win.getPistonPushedBlocks = getPistonPushedBlocks
function getPistonPulledBlocks(x,y,z,tx,ty,tz,world){
	var blocks = [x,y,z,0]
	var cx = x+tx, cy = y+ty, cz = z+tz
	cx += tx
	cy += ty
	cz += tz
	var block = world.getBlock(cx,cy,cz)
	if(blockData[block].sticky){
		if(pistonFindStickyBlocksConnectedTo(cx,cy,cz,-tx,-ty,-tz,block,blocks,"pistonPull",world) === false) return false
	}
	if(block && !xyArrayHas(blocks,null,cx,cy,cz) && blockData[block].pistonPull) blocks.push(cx,cy,cz,block)
	
	blocks.splice(0,4)
	if(blocks.length/4 > pistonPushLimit) return false
	return blocks
}
win.getPistonPulledBlocks = getPistonPulledBlocks
let movePositionByFaceArr = []
function movePositionByFace(face,x,y,z){
	switch(face){
		case "top": y++; break
		case "bottom": y--; break
		case "north": z++; break
		case "south": z--; break
		case "east": x++; break
		case "west": x--; break
	}
	movePositionByFaceArr[0] = x
	movePositionByFaceArr[1] = y
	movePositionByFaceArr[2] = z
	return movePositionByFaceArr
}

let colors = {
	rgb:{
		0: [0,0,0],
		1: [0,0,170],
		2: [0,170,0],
		3: [0,170,170],
		4: [170,0,0],
		5: [170,0,170],
		6: [255,170,0],
		7: [170,170,170],
		8: [85,85,85],
		9: [85,85,255],
		a: [85,255,85],
		b: [85,255,255],
		c: [255,85,85],
		d: [255,85,255],
		e: [255,255,85],
		f: [255,255,255],
		g: [221,214,5],//minecoin gold
		h: [227,212,209],//quartz
		i: [206,202,202],
		j: [68,58,59],
		m: [151,22,7],
		n: [180,104,77],
		p: [222,177,45],
		q: [71,160,54],
		s: [44,186,168],
		t: [33,73,123],
		u: [154,92,198]
	},
	css:{},
	dye:{
		red:[176/255, 46/255, 38/255],
		lightGray:[157/255, 157/255, 151/255],
		lightBlue:[58/255, 178/255, 218/255],
		magenta:[199/255, 78/255, 189/255],
		yellow:[254/255, 215/255, 61/255],
		purple:[137/255, 50/255, 184/255],
		orange:[249/255, 128/255, 29/255],
		white:[249/255, 1, 254/255],
		green:[93/255, 124/255, 22/255],
		brown:[131/255, 84/255, 50/255],
		black:[29/255, 29/255, 33/255],
		pink:[243/255, 139/255, 170/255],
		lime:[128/255, 199/255, 31/255],
		gray:[71/255, 79/255, 82/255],
		cyan:[22/255, 156/255, 156/255],
		blue:[60/255, 67/255, 170/255]
	}
}
for(var c in colors.rgb){
	colors.css[c] = "rgb("+colors.rgb[c].join(",")+")"
	colors.rgb[c][0] /= 255
	colors.rgb[c][1] /= 255
	colors.rgb[c][2] /= 255
}
win.colors = colors

let now = 0
function debug(message) {
	let ellapsed = performance.now() - debug.start
	if (ellapsed > 30) {
		console.log(message, ellapsed.toFixed(2), "milliseconds")
	}
}

const worldGenArray = {
	array: [],
	size: 0,
	add: function(x, y, z, block) {
		if (this.size === this.array.length) {
			this.array.push([ x, y, z, block ])
		} else {
			this.array[this.size][0] = x
			this.array[this.size][1] = y
			this.array[this.size][2] = z
			this.array[this.size][3] = block
		}
		this.size++
	},
	clear: function() {
		this.size = 0
	},
	get:function(n){
		if(n < this.size) return this.array[n]
	}
}

class World{ // aka trueWorld
	constructor(options = {}){
		let {
			trees = true, caves = true, fancyRivers = true, worldType = "alpha", structures = true,
			gameMode = "creative", cheats = true,
			settings = defaultWorldSettings,
			customChunkGenerate, customChunkPopulate
		} = options
		this.version = version
		this.generatedChunks = 0
		this.loadFrom = {}
		this[""] = new WorldDimension(this,"")
		this["nether"] = new WorldDimension(this,"nether")
		this["end"] = new WorldDimension(this,"end")
		//this.resourcePacks = []
		this.activeResourcePacks = []
		this.ticking = false
		this.entities = []
		this.players = []
		this.playersInv = {}
		this.trees = trees
		this.caves = caves
		this.fancyRivers = fancyRivers
		this.worldType = worldType
		this.structures = structures
		this.gameMode = gameMode //game mode on join
		this.cheats = cheats //game mode on join
		this.spawnPoint = {
			x:8,z:8,y:70,
			landProg:0
		}//Global Spawn point
		this.loadPromises = [] //Array of promises (load save, find land)
		this.weather = ""
		this.slowWeatherAmount = 0
		this.weatherAmount = 0
		this.nextWeather = rand(0.5,7.5)*1000
		this.time = 375
		this.skyLight = 0
		this.settings = Object.assign({},settings)
		this.loadDistance = 4
		this.loaded = []
		this.loadedNear = []
		this.sortedChunks = []
		this.chunkGenQueue = []
		this.populateQueue = []
		this.generateQueue = []
		this.lightingQueue = []
		this.loadQueue = []
		this.loadedUpdate = true

		this.commandNodes = []
		/*this.commandNodes = defaultServerCommandNodes.map(r => ({...r, func:undefined}))
		this.commandFuncs = Object.fromEntries(defaultServerCommandNodes.map(r => [r.name,r.func]))
		this.commandMap = {}
		for(let i=0; i<this.commandNodes.length; i++){
			let c = this.commandNodes[i]
			if(c.name) this.commandMap[c.id] = c
		}*/
		initDefaultCommands(this)
		this.runCmd = runCmd

		this.worldSeed = 0
		this.islandGenerator = new IslandGenerator(this);
		this.setSeed = (seed, noFindSpawn) => {
			this.worldSeed = seed
			seedHash(seed)
			this.caveNoise = openSimplexNoise(seed)
			this.noiseProfile.noiseSeed(seed)
			this.islandGenerator.SetSeed(seed)
			sendAllWorkers({newSeed:seed})
			if(!noFindSpawn) this.findSpawnPoint()
		}

		this.noiseProfile = {
			generator: undefined,
			octaves: 4,
			fallout: 0.5,
			seed: undefined,
			noiseSeed(seed) {
				this.seed = seed;
				this.generator = new PerlinNoise(this.seed);
			},
			noise(x, y, z) {
				const { generator, octaves, fallout } = this;

				let effect = 1,
					k = 1,
					sum = 0;

				for (let i = 0; i < octaves; ++i) {
					effect *= fallout;

					const k = 1 << i;

					let temp;
					switch (arguments.length) {
						case 1: {
							temp = generator.noise1d(k * x);
							break;
						} case 2: {
							temp = generator.noise2d(k * x, k * y);
							break;
						} case 3: {
							temp = generator.noise3d(k * x, k * y, k * z);
							break;
						}
					}

					sum += effect * (1 + temp) / 2;
				}

				return sum;
			}
		}

		this.pos = setInterval(this.onpos.bind(this), 500)
		this.customChunkGenerate = customChunkGenerate
		this.customChunkPopulate = customChunkPopulate
	}
	findSpawnPoint(){
		if(this.worldType === "large"){
			this.loadPromises.push(
				doWork({findLand:true, seed:this.worldSeed}, progress => {
					this.spawnPoint.landProg = progress
				}).then(land => {
					this.spawnPoint.x = land.x
					this.spawnPoint.y = land.y
					this.spawnPoint.z = land.z
					this.spawnPoint.land = true
				})
			)
		}else{
			this.spawnPoint.y = this.worldType === "superflat" ? 4 : round(this.noiseProfile.noise(this.spawnPoint.x * generator.smooth, this.spawnPoint.z * generator.smooth) * generator.height) + generator.extra
		}
	}
	serverChangeBlock(x,y,z,place,p,face,shift,blockMode,rotate,flip){
		let {dimension} = p
		let holding = p.inventory.hotbar[p.inventory.hotbarSlot] ? p.inventory.hotbar[p.inventory.hotbarSlot].id : 0
		let blockDat = blockData[holding], holdObj = p.inventory.hotbar[p.inventory.hotbarSlot]

		let ox = x, oy = y, oz = z
		let side = false
		if(place){
			switch(face) {
				case "top":
					y += 1
					break
				case "bottom":
					y -= 1
					break
				case "south":
					z -= 1
					side = true
					break
				case "north":
					z += 1
					side = true
					break
				case "west":
					x -= 1
					side = true
					break
				case "east":
					x += 1
					side = true
					break
			}
		}
		let prevBlock = this[dimension].getBlock(x,y,z)
		let prevTags = this[dimension].getTags(x,y,z)
		let dnow = Date.now()
		let breakTime
		if(!place && p.survival){
      breakTime = blockData[prevBlock].hardness*1000
      let harvestTools = blockData[prevBlock].harvestTools
			if(harvestTools === true || harvestTools && harvestTools.includes(holding)){
				breakTime *= 1.5
	      if(holding && blockData[holding].mineSpeed/*(blockData[holding].pickaxe || (blockData[holding].shovel && breakType === "ground") || (blockData[holding].axe && breakType === "wood") || (blockData[holding].hoe && breakType === "plant2"))*/){
	        breakTime /= blockData[holding].mineSpeed
	      }
			}else breakTime *= 5
      if(holding && blockData[holding].shears && blockData[block].shearBreakTime){
        breakTime = blockData[prevBlock].shearBreakTime
      }
      if(p.liquid) breakTime *= 5
			if(!p.onGround) breakTime *= 5
		}
		if(dimension !== p.dimension || breakTime !== undefined && (p.crackPos[0] !== x || p.crackPos[1] !== y || p.crackPos[2] !== z || dnow-p.breakStart<breakTime-250)){
			return p.connection.send({type:"setBlock", data:{x:x, y:y, z:z, block:prevBlock, dimension}})
		}
		if(place){//placed
			let cblock = this[dimension].getBlock(ox,oy,oz)
			if(blockData[cblock].onclick && !shift){
				if(!blockData[cblock].onclick(ox,oy,oz,this[dimension],p,holdObj)){
					if(holdObj && !holdObj.amount) p.inventory.hotbar[p.inventory.hotbarSlot] = null
					return
				}
			}else if(holding && blockData[holding].shovel){
				if(cblock === blockIds.grass || cblock === blockIds.dirt || cblock === blockIds.rootedDirt || cblock === blockIds.mycelium || cblock === blockIds.podzol){
					this[dimension].setBlock(ox,oy,oz,blockIds.dirtPath)
					holdObj.durability --
				}
				if(blockData[cblock].campfire){
					this[dimension].setBlock(ox,oy,oz,blockData[cblock].id | SLAB)
					holdObj.durability --
				}
				return
			}else if(holding && cblock && blockData[holding].axe){
				var name = blockData[cblock].name
				name = name[0].toUpperCase() + name.substring(1)
				name = "stripped"+name
				if(blockIds[name]){
					this[dimension].setBlock(ox,oy,oz,blockIds[name])
					holdObj.durability --
				}
				return
			}else if(holding && cblock && blockData[holding].hoe){
				if((blockData[cblock].name === "grass" || cblock === blockIds.dirt) && !this[dimension].getBlock(ox,oy+1,oz)){
					this[dimension].setBlock(ox,oy,oz,blockIds.farmland)
					holdObj.durability --
				}
				if(cblock === blockIds.rootedDirt){
					this[dimension].setBlock(ox,oy,oz,blockIds.dirt)
					this[dimension].addItems(ox, oy+0.5, oz, 0, 0, 0, blockIds.hangingRoots, true)
					holdObj.durability --
				}
				return
			}else if(holding && cblock && blockData[holding].shears){
				if(cblock === blockIds.pumpkin){
					this[dimension].setBlock(ox,oy,oz,blockIds.carvedPumpkin)
					this[dimension].addItems(ox, oy+0.5, oz, 0, 0, 0, blockIds.pumpkinSeeds, true, 4)
					holdObj.durability --
				}
				return
			}else if(holding && cblock && blockData[holding].name === "eyeOfEnder" && blockData[cblock].name === "endPortalFrame"){
				this[dimension].setBlock(ox,oy,oz,cblock | SLAB)
				blockData[cblock].eyeplace(ox,oy,oz,this[dimension])
				this[dimension].blockSound(holding, "place", ox,oy,oz)
				return
			}
			if(blockDat.serveronuse && (blockDat.useAnywhere || cblock)){
				let cont = blockDat.serveronuse(ox,oy,oz,cblock,this[dimension],face,holdObj,p, blockMode)
				if(holdObj && !holdObj.amount) p.inventory.hotbar[p.inventory.hotbarSlot] = null
				if(!cont) return
			}

			if(holding && blockData[holding].useAs){
	      let useAs = blockData[holding].useAs
	      if(typeof useAs === "function"){
	        useAs = useAs(x,y,z,cblock,face)
	        if(typeof useAs === "string" && blockIds[useAs]){
	          holding = blockIds[useAs]
	        }else holding = useAs
	      }else{
	        holding = blockIds[useAs]
	      }
	    }
			if(!holding || blockData[holding].item) return
			if(!p.cheats) blockMode = 0
			let under = this[dimension].getBlock(x,y-1,z)
      let onPot = !side && blockData[under] && blockData[under].pot
      if(blockData[holding].potCross && onPot){
        blockMode = POTCROSS
      }else if(blockData[holding].crossShape){
        if(onPot && blockIds[blockData[holding].name+"Pot"]){
          block = blockIds[blockData[holding].name+"Pot"]
          blockMode = POTCROSS
        }else{
          blockMode = CROSS
        }
      }
      if(blockData[holding].sideCross){
        if(side){
          blockMode = CUBE
        }else if(face === "bottom"){
          blockMode = SLAB
        }else blockMode = CROSS
      }
      if(blockData[holding].tallcrossShape){
        blockMode = TALLCROSS
      }
      if(blockData[holding].door && blockMode !== SLAB){
        blockMode = DOOR
      }
      if(blockData[holding].torch){
        blockMode = TORCH
        if(side) blockMode = SLAB
      }
      if(blockData[holding].lantern){
        if(this[dimension].getBlock(x,y+1,z)){
          blockMode = LANTERNHANG
        }else{
          blockMode = LANTERN
        }
      }
      if(blockData[holding].beacon){
        blockMode = BEACON
      }
      if(blockData[holding].cactus && blockMode !== POTCROSS){
        blockMode = CACTUS
      }
      if(blockData[holding].pane){
        if(side) blockMode = SLAB
        else blockMode = PANE
      }
      if(blockData[holding].portal){
        blockMode = PORTAL
      }
      if(blockData[holding].wallFlat){
        blockMode = WALLFLAT
      }
      if(blockData[holding].trapdoor){
        if(side){
          blockMode = TRAPDOOROPEN
        }else{
          blockMode = TRAPDOOR
        }
      }
      if(blockData[holding].chain){
        if(side)blockMode = SLAB
        else blockMode = CHAIN
      }
      if(blockData[holding].button){
        blockMode = BUTTON
      }
      if(blockData[holding].pot){
        blockMode = POT
      }
      
      if(blockData[holding].name === "endRod"){
        if(side){
          blockMode = SLAB
        }else{
          blockMode = CUBE
        }
      }
      
      if(blockData[holding].barrel || blockData[holding].commandBlock){
        if(side) blockMode = SLAB
        else if(face === "bottom") blockMode = STAIR
        else blockMode = CUBE
      }
      
      if(blockData[holding].redstoneTorch){
        if(side) blockMode = SLAB
        else blockMode = CUBE
      }
      
      if(blockData[holding].lever){
        if(side) blockMode = CUBE
        else if(face === "top") blockMode = STAIR
        else if(face === "bottom") blockMode = TALLCROSS
      }
      
      if(blockData[holding].piston){
        if(face === "top") blockMode = CUBE
        else if(face === "bottom") blockMode = FLIP
        else if(side) blockMode = SLAB
      }
      
      if(blockData[holding].name === "observer"){
        if(face === "top") blockMode = SLAB | FLIP
        else if(face === "bottom") blockMode = SLAB
        else blockMode = CUBE
      }
      
      if(blockData[holding].name === "pointedDripstone"){
        if(face === "top") blockMode = CUBE
        else blockMode = FLIP
      }
      if(blockData[holding].sign){
        if(side) blockMode = STAIR
        else blockMode = CUBE
      }
      if(blockData[holding].name === "dropper" || blockData[holding].name === "dispenser"){
        if(face === "top") blockMode = SLAB
        else if(face === "bottom") blockMode = STAIR
        else blockMode = CUBE
      }
      if(blockData[holding].name === "hopper"){
        if(side) blockMode = SLAB
        else blockMode = CUBE
      }
			if(blockData[holding].coralFan){
				if(side) blockMode = STAIR
        else blockMode = CUBE
			}
      
      if(side && blockData[holding].swId){
        holding = blockData[holding].swId
      }
      if(blockData[holding].layers){
        let b = this[dimension].getBlock(ox,oy,oz)
        let layer = 0
				let state = b&isState
        if(state === LAYER1) layer = 1
        if(state === LAYER2) layer = 2
        if(state === LAYER3) layer = 3
        if(state === LAYER4) layer = 4
        if(state === LAYER5) layer = 5
        if(state === LAYER6) layer = 6
        if(state === LAYER7) layer = 7
        if(state === LAYER8) layer = 8
        if(((b & isCube) === (holding & isCube)) && layer > 0 && layer < 8){
					//p.connection.send({type:"setBlock", data:{x:x, y:y, z:z, block:this[dimension].getBlock(x,y,z), dimension}})
          x = ox, y = oy, z = oz
          layer ++
          switch(layer){
            case 2:
              blockMode = LAYER2
              break
            case 3:
              blockMode = LAYER3
              break
            case 4:
              blockMode = LAYER4
              break
            case 5:
              blockMode = LAYER5
              break
            case 6:
              blockMode = LAYER6
              break
            case 7:
              blockMode = LAYER7
              break
            case 8:
              blockMode = LAYER8
              break
          }
        }else{
          blockMode = LAYER1
        }
				holding = holding&isCube
      }
			if(!blockData[holding|blockMode]) throw new Error("no block holding: "+holding+"blockMode: "+blockMode)
			let shape = holding && blockData[holding|blockMode].shape
			if (shape && shape.rotate){
				if(rotate === SOUTH) blockMode |= SOUTH
				if(rotate === EAST) blockMode |= EAST
				if(rotate === WEST) blockMode |= WEST
			}
			if (shape && shape.flip){
				if(flip === FLIP) blockMode |= FLIP
			}
			holding |= blockMode
		}
		let dropAmount, drop
		if(p.survival && !place){
			drop = 0
			let block = prevBlock
			let theDrop = blockData[prevBlock].drop
			let amount = blockData[prevBlock].dropAmount
			let canDrop = holding && blockData[prevBlock].harvestTools && (blockData[prevBlock].harvestTools === true || blockData[prevBlock].harvestTools.includes(holding))
			if(!blockData[prevBlock].type) canDrop = true
			if(canDrop){
				if(amount === undefined) amount = 1
				if(amount.length === 2){
					amount = round(rand(amount[0], amount[1]))
				}
				if(holding && blockData[holding].shears && blockData[prevBlock].dropSelfWhenSheared){
					if(blockData[prevBlock].shearDropAmount){
						amount = blockData[prevBlock].shearDropAmount
					}
				}else{
					if(typeof theDrop === "number") block = theDrop
					else if(typeof theDrop === "function"){
						block = blockIds[theDrop()]
					}else if(Array.isArray(theDrop)){
						block = theDrop
					}else if(theDrop) block = blockIds[theDrop]
				}
				if(block){
					drop = block
					dropAmount = amount
				}
			}

			let breakType = blockData[prevBlock].type
			if(holding && blockData[holding].pickaxe) {
				holdObj.durability --
			}
			if(holding && blockData[holding].sword) {
				holdObj.durability -= 2
			}
			if(holding && blockData[holding].shovel) {
				holdObj.durability -= 1
			}
			if(holding && blockData[holding].axe) {
				holdObj.durability -= 1
			}
			if(holding && blockData[holding].hoe && breakType !== "plant2") {
				holdObj.durability -= 1
			}
			p.breakStart = dnow
		}
		let worked = this[dimension].setBlock(x, y, z, place ? holding : 0)
		if(worked === false) return p.connection.send({type:"setBlock", data:{x:x, y:y, z:z, block:prevBlock, dimension}})
		
		if(drop){
			if(Array.isArray(drop)){//drop multiple items
				for(let d of drop){
					if(typeof d === "string") d = blockIds[d]
					this[dimension].addItems(x, y, z, 0, 0, 0, d, true, dropAmount,null,null,p.id)
				}
			}else{
				this[dimension].addItems(x, y, z, 0, 0, 0, drop, true, dropAmount,null,null,p.id)
			}
		}
		if(place){
			if(blockData[holding].onplace) blockData[holding].onplace(x,y,z,p,this[dimension])
			if(p.survival) holdObj.amount--
			if(holdObj && !holdObj.amount) p.inventory.hotbar[p.inventory.hotbarSlot] = null
		}else{
			this[dimension].blockParticles(prevBlock,x,y,z,30, "break")
			if(blockData[prevBlock].onbreak){
				blockData[prevBlock].onbreak(x,y,z, prevBlock, prevTags,this[dimension])
			}
			this[dimension].blockSound(prevBlock, "dig", x, y, z)
			if(p.survival && blockData[prevBlock].experience) this[dimension].addEntity(new entities[entityIds.ExperienceOrb](x, y, z, blockData[prevBlock].experience))
		}
	}
	entInteract(id,hit,cooldown,p){
		let ent = getEntityOrPlayer(id,this[p.dimension])
		if(!ent) return
		let holdObj = p.inventory.hotbar[p.inventory.hotbarSlot]
		let block = blockData[holdObj ? holdObj.id : 0]
		if(hit){
			if(!ent.damage) return
			let atime = (typeof block.attackTime === "number") ? block.attackTime : 5
			let attackDamage = (block && block.attackDamage) || 1
			let damage, critical
			damage = cooldown
			if(p.vely < 0 && !p.onGround && !p.liquid && !p.flying && !p.sprinting && damage > 0.848) critical = true
			damage = max(min(damage, 1), 0.2) * attackDamage
			if(critical) damage *= 1.5
			if(ent.type === "Player"){
				if (this.settings.attack) {
					let msg = (p.username+" killed "+ent.username+(holdObj && blockData[holdObj.id].attackDamage ? " with "+(holdObj.customName || blockData[holdObj.id].Name) : "")+".")
					ent.damage(damage,msg,false,null,p.x,p.y,p.z,p)
					//send({type:"hit", username:p.username, id:p.id, damage:damage, velx:pd.x/2, velz:pd.z/2, holding:inventory.hotbar[inventory.hotbarSlot],x:p.x,y:p.y,z:p.z}, ent.id)
				}
			}else{
				let pd = p.direction
				ent.damage(damage,pd.x/2,0.5,pd.z/2)
			}
			if(block.pickaxe){
				holdObj.durability -= 2
			}
			if(block.sword){
				holdObj.durability --
			}
			if(block.shovel){
				holdObj.durability -= 2
			}
			if(block.axe){
				holdObj.durability -= 2
			}
			p.foodExhaustion += 0.1
		}else{
			if(block.onentityuse){
				if(block.onserverentityuse) block.onserverentityuse(ent,holdObj)
			}
			if(ent.onclick){
				ent.onclick(holdObj,p)
			}
		}
		if(holdObj && !holdObj.amount) p.inventory.hotbar[p.inventory.hotbarSlot] = null
	}

	getEntity(id){
		for(var i=0; i<this.entities.length; i++){
			if(this.entities[i].id === id){
				return i
			}
		}
	}
	static entityPacketType = [
		["version","constant",0],["id","basicString"],["entId","byte"],["x","double"],["y","double"],["z","double"],packetDimension,
		["pitch","double"],["yaw","double"],["velx","double"],["vely","double"],["velz","double"],["spawnRelative","double"],
		[ent=>ent.type==="Item"||ent.type==="ExperienceOrb","includeIf",[["amount","double"]]],
		[ent=>ent.type==="Item"||(ent instanceof BlockEntity),"includeIf",[["block","uint"]]],
		[ent=>ent.type==="Item","includeIf",[["from","basicString"],["durability","int"],["name","string"]]],
		[ent=>ent.type==="BlockEntity","includeIf",[["solidOnGround","boolean"]]],
		[ent=>ent.type==="MovingBlock","includeIf",[["sx","int"],["sy","int"],["sz","int"],["mx","int"],["my","int"],["mz","int"],["despawns","int"],["solidWhenDone","boolean"]]],
		[ent=>ent.type==="TextDisplay","includeIf",[["text","string"],["size","double"],["color","array",[null,"number",8,255]],["background","array",[null,"number",8,255]],["glow","boolean"]]],
		[ent=>ent.mob,"includeIf",[
			["harmEffect","number",6,1],["health","double"],["burning","boolean"],["burnTimer","double"],["oxygen","double"],["spinTarget","double"],
			[ent=>ent.path,"includeIf",[["path","array",[null,"int"]]]],
			[ent=>ent.type==="Sheep"||ent.type==="Spider","includeIf",[["fur","boolean"]]],
			[ent=>ent.type==="Sheep","includeIf",[["wool","basicString"]]],
			[ent=>ent.type==="Sheep"||ent.type==="Wolf","includeIf",[["color","array",[null,"number",8,255]]]],
			["eating","boolean"],["target","basicString"],["tame","boolean"],["sitting","boolean"],["owner","string"],["holding","uint"],["attractedBy","basicString"],
			[ent=>ent.type==="Creeper","includeIf",[["explodeAmount","byte"],["timerStartRelative","double"]]],
			["attackCooldown","byte"],["effects","mapObject",[null,"object",[["level","byte"],["time","int"],["showParticles","boolean"]]]]
		]],
		[ent=>ent.type==="BlockDisplay","includeIf",[["width","double"],["height","double"],["depth","double"]]],
		[ent=>ent.type==="Minecart","includeIf",[["harmEffect","number",6,1],["health","double"]]],
		["doingPortal","uint"]
	]
	getEntPos(ent,now){
		ent.spawnRelative = now-ent.spawn
		if(ent.type === "Creeper") ent.timerStartRelative = now-ent.timerStart
		return packetToBitArray(ent,this.constructor.entityPacketType,true)
		/*let bab = new BitArrayBuilder()
		bab.add(min(ent.id.length,255),8)
		for(let c of ent.id.substring(0,255)) bab.add(c.charCodeAt(0),8)
		bab.add(ent.entId,8)
		bab.add(ent.x*16,24).add(ent.y*16,15).add(ent.z*16,24)
		bab.add(ent.dimension === "nether" ? 1 : (ent.dimension === "end" ? 2 : 0),3)
		bab.add(ent.pitch*100,11)
		bab.add(ent.yaw*100,11)
		bab.add(ent.velx*100,11).add(ent.vely*100,11).add(ent.velz*100,11)
		bab.add(now-ent.spawn,32) //entity should despawn before limit or have no limit
		bab.add((ent.amount||0)*10,20)
		bab.add(ent.block||0,32)
		bab.add(ent.from ? min(ent.from.length,255) : 0,8)
		if(ent.from) for(let c of ent.from.substring(0,255)) bab.add(c.charCodeAt(0),8)
		bab.add(ent.durability||0,16)
		bab.addString(ent.name||"")
		if(ent.type === "BlockEntity"){
			bab.add(ent.solidOnGround||0,1)
		}else if(ent.type === "MovingBlock"){
			bab.add(ent.sx,20).add(ent.sy,20).add(ent.sz,20)
			bab.add(ent.mx,20).add(ent.my,20).add(ent.mz,20)
			bab.add(ent.despawns,32)
			bab.add(ent.solidWhenDone,1)
		}else if(ent.type === "TextDisplay"){
			bab.addString(ent.text)
			bab.add(ent.size*256,8)
			bab.add(ent.color[0]*255,8).add(ent.color[1]*255,8).add(ent.color[2]*255,8)
			bab.add(ent.background[0]*255,8).add(ent.background[1]*255,8).add(ent.background[2]*255,8).add(ent.background[3]*255,8)
			bab.add(ent.glow,1)
		}else if(ent.mob){
			bab.add(ent.harmEffect,6)
			bab.add(round(ent.health),16)
			bab.add(ent.burning,1)
			bab.add(ent.burnTimer*16,8)
			bab.add(ent.oxygen,5)
			bab.add(ent.spinTarget*100,11)
			bab.add(ent.path ? ent.path.length : 0,8)
			if(ent.path && ent.path.length > 255) logError("entity path too long")
			if(ent.path){
				for(let i of ent.path){
					bab.add(i,20)
				}
			}
			bab.add(ent.fur||0,1)
			if(ent.color) bab.add(ent.color[0]*255,8).add(ent.color[1]*255,8).add(ent.color[2]*255,8)
			else bab.add(0,24)
			bab.add(ent.eating||0,6)
			bab.add(ent.target ? min(ent.target.length,255) : 0,8)
			if(ent.target) for(let c of ent.target.substring(0,255)) bab.add(c.charCodeAt(0),8)
			if(ent.type === "Sheep"){
				bab.add(ent.wool ? min(ent.wool.length,255) : 0,8)
				if(ent.wool) for(let c of ent.wool.substring(0,255)) bab.add(c.charCodeAt(0),8)
			}
			bab.add(ent.tame||0,1)
			bab.add(ent.sitting||0,1)
			bab.add(ent.owner ? min(ent.owner.length,255) : 0,8)
			if(ent.owner) for(let c of ent.owner.substring(0,255)) bab.add(c.charCodeAt(0),8)
			bab.add(ent.holding||0, 32)
			bab.add(ent.attractedBy ? min(ent.attractedBy.length,255) : 0,8)
			if(ent.attractedBy) for(let c of ent.attractedBy.substring(0,255)) bab.add(c.charCodeAt(0),8)
			if(ent.type === "Creeper"){
				bab.add(ent.explodeAmount,7)
				bab.add(now-ent.timerStart,32)
			}
			bab.add(ent.attackCooldown, 8)
			let effects = Object.keys(ent.effects)
			bab.add(effects.length,8)
			for(let i of effects){
				bab.addBasicString(i)
				bab.add(ent.effects[i].level,8)
				bab.add(ent.effects[i].time,32)
				bab.add(ent.effects[i].showParticles ? 1 : 0, 1)
			}
		}else if(ent.type === "BlockDisplay"){
			bab.add(ent.width*256,16).add(ent.height*256,16).add(ent.depth*256,16)
		}else if(ent.type === "Minecart"){
			bab.add(ent.harmEffect,6)
			bab.add(round(ent.health),16)
		}
		return bab*/
	}
	posEntity(p, m, preBetaVersion/*preBetaVersion only used in loadsave*/){
		if (typeof p === "string") {
			try {
				p = BitArrayReader(atoarr(p),true)
			}catch(e){
				return
			}
		}else if(!(p instanceof BitArrayReader)) return
		if(p.data[0] !== 0 || preBetaVersion) return this.posEntityOldBab(p, m, preBetaVersion)
		let now = performance.now()
		p = bitArrayToPacket(p,this.constructor.entityPacketType)
		const entType = entityOrder[p.entId]
		let ent = this.entities[this.getEntity(p.id)]
		if(ent){
			if(entType === "TextDisplay" && ent.text !== p.text) ent.setText(p.text)
			if(entType === "Item" && ent.amount !== p.amount) ent.amount = p.amount, ent.willUpdateShape = true
		}else{
			ent = entities[p.entId]
			switch(entType){
				case "Item":
					ent = new ent(p.x, p.y, p.z, p.velx, p.vely, p.velz, p.block, false, p.amount, p.durability||null, null)
					break
				case "BlockEntity":
					ent = new ent(p.block, p.x,p.y,p.z, p.solidOnGround)
					break
				case "PrimedTNT":
				case "PrimedSuperTNT":
				case "PrimedUltraTNT":
				case "PrimedUnTNT":
					ent = new ent(p.x,p.y,p.z)
					break
				case "MovingBlock":
					ent = new ent(p.block, p.sx,p.sy,p.sz,p.mx,p.my,p.mz,p.despawns,p.solidWhenDone)
					break
				case "BlockDisplay":
					ent = new ent(p.block,p.x,p.y,p.z,0,0,0)
					break
				case "EnderPearl":
				case "Snowball":
				case "SmallFireball":
				case "Egg":
				case "SlingshotShot":
				case "Arrow":
					ent = new ent(p.x,p.y,p.z,0,0,0)
					break
				case "ExperienceOrb":
					ent = new ent(p.x,p.y,p.z,p.amount)
					break
				case "Cow":
				case "Pig":
				case "Creeper":
				case "Chicken":
				case "Zombie":
				case "Skeleton":
				case "Wolf":
				case "Blaze":
				case "Enderman":
					ent = new ent(p.x,p.y,p.z)
					break
				case "Sheep":
					ent = new ent(p.x,p.y,p.z, p.color, p.wool)
					break
				case "Spider":
					ent = new ent(p.x,p.y,p.z,p.fur)
					break
				case "EnderDragon":
					ent = new ent(p.x,p.y,p.z)
					break
				case "TextDisplay":
					ent = new ent(p.x,p.y,p.z,p.text,p.size,p.color,p.background,p.glow)
				case "Minecart":
					ent = new ent(p.x,p.y,p.z)
				default:
					break
			}
			if(!ent) return
			ent.id = p.id
			this[p.dimension].addEntity(ent, true)
			ent.previousX = p.x
			ent.previousY = p.y
			ent.previousZ = p.z
		}
		if(!ent) return
		ent.setPos(p.x,p.y,p.z,p.velx,p.vely,p.velz)
		ent.dimension = p.dimension
		if(!ent.facesPlayer){
			ent.yaw = p.yaw
			ent.pitch = p.pitch
		}
		ent.spawn = now - p.spawnRelative
		if("from" in ent) ent.from = p.from
		if(p.name) ent.name = p.name
		ent.doingPortal = p.doingPortal
		if(ent.mob){
			ent.harmEffect = p.harmEffect
			ent.health = p.health
			ent.burning = p.burning
			ent.burnTimer = p.burnTimer
			ent.oxygen = p.oxygen
			ent.spinTarget = p.spinTarget
			if(p.path){
				ent.path = p.path
			}else ent.path = null
			if("fur" in ent) ent.fur = p.fur
			if("color" in ent){
				ent.color = p.color
			}
			if("eating" in ent) ent.eating = p.eating
			ent.target = p.target
			if(entType === "Sheep") ent.wool = p.wool
			if("tame" in ent) ent.tame = p.tame
			if("sitting" in ent) ent.sitting = p.sitting
			if("owner" in ent) ent.owner = p.owner
			ent.holding = p.holding
			ent.attractedBy = p.attractedBy
			if(entType === "Creeper"){
				ent.explodeAmount = p.explodeAmount
				ent.timerStart = now - p.timerStartRelative
			}
			ent.attackCooldown = p.attackCooldown
			ent.effects = p.effects
		}else if(ent.type === "BlockDisplay"){
			ent.width = p.width
			ent.height = p.height
			ent.depth = p.depth
		}else if(ent.type === "Minecart"){
			ent.harmEffect = p.harmEffect
			ent.health = p.health
		}
		ent.updateChunk()
		return ent
	}
	posEntityOldBab(p, m, preBetaVersion){
		let now = performance.now()
		let nameLen = p.read(8)
		let id = ""
		for (let i = 0; i < nameLen; i++) id += String.fromCharCode(p.read(8))
		const type = p.read(8)
		let i = this.getEntity(id)
		let ent
		const entType = entityOrder[type]
		const x = p.read(24,true)/16, y = p.read(preBetaVersion?12:15,true)/16, z = p.read(24,true)/16
		let dimension = p.read(3)
		dimension = dimension === 1 ? "nether" : (dimension === 2 ? "end" : "")
		const pitch = p.read(11,true)/100
		const yaw = p.read(11,true)/100
		const velx = p.read(11,true)/100
		const vely = p.read(11,true)/100
		const velz = p.read(11,true)/100
		const spawn = now - p.read(32,true)
		const amount = preBetaVersion ? p.read(16) : p.read(20)/10
		const block = p.read(32)
		nameLen = p.read(8)
		let from = ""
		for (let i = 0; i < nameLen; i++) from += String.fromCharCode(p.read(8))
		const durability = p.read(16)
		let name = p.readString()
		//below var because it can be accessed outside block scope
		if(entType === "BlockEntity"){
			var solidOnGround = Boolean(p.read(1))
		}else if(entType === "MovingBlock"){
			var sx = p.read(20,true), sy = p.read(20,true), sz = p.read(20,true)
			var mx = p.read(20,true), my = p.read(20,true), mz = p.read(20,true)
			var despawns = p.read(32)
			var solidWhenDone = p.read(1)
		}else if(entType === "TextDisplay"){
			var text = p.readString()
			var size = p.read(8)/256
			var color = [p.read(8)/255,p.read(8)/255,p.read(8)/255]
			var background = [p.read(8)/255,p.read(8)/255,p.read(8)/255,p.read(8)/255]
			var glow = !!p.read(1)
		}else if(entities[type].mob){
			var harmEffect = p.read(6)
			var health = p.read(16)
			var burning = Boolean(p.read(1))
			var burnTimer = p.read(8)/16
			var oxygen = p.read(5)
			var spinTarget = p.read(11)/100
			nameLen = p.read(8)
			if(nameLen){
				var path = []
				for(let i = 0; i < nameLen; i++){
					path.push(p.read(20,true))
				}
			}
			var fur = Boolean(p.read(1))
			var color = [p.read(8)/255,p.read(8)/255,p.read(8)/255]
			var eating = p.read(6)
			nameLen = p.read(8)
			var target = ""
			for (let i = 0; i < nameLen; i++) target += String.fromCharCode(p.read(8))
			if(entType === "Sheep"){
				nameLen = p.read(8)
				var wool = ""
				for (let i = 0; i < nameLen; i++) wool += String.fromCharCode(p.read(8))
			}
			var tame = Boolean(p.read(1))
			var sitting = Boolean(p.read(1))
			nameLen = p.read(8)
			var owner = ""
			for (let i = 0; i < nameLen; i++) owner += String.fromCharCode(p.read(8))
			var holding = p.read(32)
			nameLen = p.read(8)
			var attractedBy = ""
			for (let i = 0; i < nameLen; i++) attractedBy += String.fromCharCode(p.read(8))
			if(entType === "Creeper"){
				var explodeAmount = p.read(7)
				var timerStart = now - p.read(32)
			}
			var attackCooldown = p.read(8)
			let effectsLen = p.read(8)
			var effects = {}
			for(let i=0; i<effectsLen; i++){
				effects[p.readBasicString()] = {level:p.read(8), time:p.read(32), showParticles:p.read(1)}
			}
		}else if(entType === "BlockDisplay"){
			var width = p.read(16)/256, height = p.read(16)/256, depth = p.read(16)/256
		}else if(entType === "Minecart"){
			var harmEffect = p.read(6)
			var health = p.read(16)
		}

		if(i || i===0){
			ent = this.entities[i]
			if(entType === "TextDisplay" && ent.text !== text) ent.setText(text)
			if(entType === "Item" && ent.amount !== amount) ent.amount = amount, ent.willUpdateShape = true
		}else{
			ent = entities[type]
			switch(entType){
				case "Item":
					ent = new ent(x, y, z, velx, vely, velz, block, false, amount, durability||null, null)
					break
				case "BlockEntity":
					ent = new ent(block, x,y,z, solidOnGround)
					break
				case "PrimedTNT":
				case "PrimedSuperTNT":
				case "PrimedUltraTNT":
				case "PrimedUnTNT":
					ent = new ent(x,y,z)
					break
				case "MovingBlock":
					ent = new ent(block, sx,sy,sz,mx,my,mz,despawns,solidWhenDone)
					break
				case "BlockDisplay":
					ent = new ent(block,x,y,z,0,0,0)
					break
				case "EnderPearl":
				case "Snowball":
				case "SmallFireball":
				case "Egg":
				case "SlingshotShot":
				case "Arrow":
					ent = new ent(x,y,z,0,0,0)
					break
				case "ExperienceOrb":
					ent = new ent(x,y,z,amount)
					break
				case "Cow":
				case "Pig":
				case "Creeper":
				case "Chicken":
				case "Zombie":
				case "Skeleton":
				case "Wolf":
				case "Blaze":
				case "Enderman":
					ent = new ent(x,y,z)
					break
				case "Sheep":
					ent = new ent(x,y,z, color, wool)
					break
				case "Spider":
					ent = new ent(x,y,z,fur)
					break
				case "EnderDragon":
					ent = new ent(x,y,z)
					break
				case "TextDisplay":
					ent = new ent(x,y,z,text,size,color,background,glow)
				case "Minecart":
					ent = new ent(x,y,z)
				default:
					break
			}
			if(!ent) return
			ent.id = id
			this[dimension].addEntity(ent, true)
			ent.previousX = parseFloat(p[0])
			ent.previousY = parseFloat(p[1])
			ent.previousZ = parseFloat(p[2])
		}
		if(!ent) return
		ent.setPos(x,y,z,velx,vely,velz)
		ent.dimension = dimension
		if(!ent.facesPlayer){
			ent.yaw = yaw
			ent.pitch = pitch
		}
		ent.spawn = spawn
		if("from" in ent) ent.from = from
		if(name) ent.name = name
		if(ent.mob){
			ent.harmEffect = harmEffect
			ent.health = health
			ent.burning = burning
			ent.burnTimer = burnTimer
			ent.oxygen = oxygen
			ent.spinTarget = spinTarget
			if(path){
				ent.path = path
			}else ent.path = null
			if("fur" in ent) ent.fur = fur
			if("color" in ent){
				ent.color = color
			}
			if("eating" in ent) ent.eating = eating
			ent.target = target
			if(entType === "Sheep") ent.wool = wool
			if("tame" in ent) ent.tame = tame
			if("sitting" in ent) ent.sitting = sitting
			if("owner" in ent) ent.owner = owner
			ent.holding = holding
			ent.attractedBy = attractedBy
			if(entType === "Creeper"){
				ent.explodeAmount = explodeAmount
				ent.timerStart = timerStart
			}
			ent.attackCooldown = attackCooldown
			ent.effects = effects
		}else if(ent.type === "BlockDisplay"){
			ent.width = width
			ent.height = height
			ent.depth = depth
		}else if(ent.type === "Minecart"){
			ent.harmEffect = harmEffect
			ent.health = health
		}
		ent.updateChunk()
		return ent
	}

	loadChunks(){
		this.chunkGenQueue.length = 0
		this.lightingQueue.length = 0
		this.populateQueue.length = 0
		this.generateQueue.length = 0
		this.loadQueue.length = 0
		this.loaded.length = 0
		this.loadedNear.length = 0
		for(let p of this.players){
			let cx = p.x >> 4
			let cz = p.z >> 4
			let loadDistance = min(this.loadDistance,p.loadDistance)
			chunkPlayerDistArr.length = 0
			sortChunkPX = p.x
			sortChunkPZ = p.z
			let minChunkX = cx - loadDistance - 3 //Load extra for generating & populating
			let maxChunkX = cx + loadDistance + 3 //if you change this, change amount in fillReqs
			let minChunkZ = cz - loadDistance - 3
			let maxChunkZ = cz + loadDistance + 3
			for (let x = minChunkX; x <= maxChunkX; x++) {
				for (let z = minChunkZ; z <= maxChunkZ; z++) {
					let chunk = this[p.dimension].getOrNewChunk(x*16,z*16)
					if(maxDist(cx, cz, x, z) <= loadDistance){
						if(!chunk.allGenerated && !this.chunkGenQueue.includes(chunk)) chunkPlayerDistArr.push(chunk)
						if(!this.loadedNear.includes(chunk)){
							this.loadedNear[this.loadedNear.length] = chunk
						}
					}
					if(!this.loaded.includes(chunk)){
						this.loaded[this.loaded.length] = chunk
					}
				}
			}
			this.chunkGenQueue.push(...chunkPlayerDistArr.sort(sortChunks))
		}
	}
	tickUpdates(world,now){
		for(let i = world.timeoutQueue.length-1; i>=0; i--){
			if(now - world.timeoutQueue[i].time >= 0) world.timeoutQueue.splice(i,1)[0].func()
		}
		for(let i=0; i<world.updateQueue.length; i+=6){
			let x = world.updateQueue[i]
			let y = world.updateQueue[i+1]
			let z = world.updateQueue[i+2]
			let sx = world.updateQueue[i+3]
			let sy = world.updateQueue[i+4]
			let sz = world.updateQueue[i+5]
			world.doBlockUpdate(x,y,z,sx,sy,sz)
		}
		world.updateQueue.length = 0
	}
	async tick() {
		let tickStart = performance.now()
		if(this.loadedUpdate){
			this.loadChunks()
			this.loadedUpdate = false
		}
		now = tickStart

		let sleep = 0, sleepTotal = 0
		for(var p of this.players){
			if(p.hidden) continue
			if(p.sleeping) sleep++
			sleepTotal++
		}
		let allSleeping = sleepTotal && sleep === sleepTotal
		
		if(this.settings.dayNightCycle){
			if(allSleeping){
				this.time += 6.25
			}else this.time += 0.125
		}
		if(this.settings.weatherCycle){
			this.nextWeather -= allSleeping ? 6.25 : 0.125
			if(this.nextWeather <= 0) {
				this.nextWeather = 0
				this.weather = this.weather ? "" : "rain"
				this.nextWeather = this.weather ? rand(0.5,1)*1000 : rand(0.5,7.5)*1000
			}
		}
		if(this.weather === "rain" || this.weather === "snow"){
			if(this.slowWeatherAmount >= 0.5){
				this.weatherAmount += 0.02
				if(this.weatherAmount > 1) this.weatherAmount = 1
			}
			this.slowWeatherAmount += 0.01
			if(this.slowWeatherAmount > 1) this.slowWeatherAmount = 1
		}else{
			this.weatherAmount -= 0.02
			if(this.weatherAmount < 0) this.weatherAmount = 0
			this.slowWeatherAmount -= 0.01
			if(this.slowWeatherAmount < 0) this.slowWeatherAmount = 0
		}

		let time = this.time % 1000
		//if you change this, change client
		if(time > 725 && time < 800) this.skyLight = mapFrom(time, 800,725) //get darker
		else if(time > 200 && time < 275) this.skyLight = mapFrom(time, 200,275) //get brighter
		else if(time >= 800 || time <= 200) this.skyLight = 0
		else this.skyLight = 1
		for(let i in this.players){
			this.players[i].update()
			this.players[i].updateLoaded()
		}

		if(this.worldType === "island" && this.islandGenerator.stage < 10){
			if(!this.islandGenerator.promise){
				this.islandGenerator.promise = new Promise(resolve => this.islandGenerator.promiseResolve = resolve)
				this.loadPromises.push(this.islandGenerator.promise)
			}
			this.islandGenerator.Generate(performance.now())
			if(this.islandGenerator.stage >= 10) this.islandGenerator.promiseResolve()
			return
		}

		for (let c of this.loadedNear) {
			c.tick()
		}
		for(let ent of this.entities){
			if(ent.updateAlways) ent.updateAlways()
		}
		
		this.tickUpdates(this[""],tickStart)
		this.tickUpdates(this["nether"],tickStart)
		this.tickUpdates(this["end"],tickStart)

		if(this.ticking) return
		this.ticking = true
		let doneWork = true
		while(doneWork) {
			doneWork = false
			debug.start = performance.now()
			if(this.generateQueue.length){
				for(let i=0; i<this.generateQueue.length; i++){
					let chunk = this.generateQueue[i]
					if(!chunk.generated){
						chunk.generate()
					}else{
						this.generateQueue.splice(i,1)
						i--
					}
				}
				doneWork = true
			}
			if(this.populateQueue.length && !doneWork){
				let chunk = this.populateQueue[this.populateQueue.length - 1]
				if(chunk.populated){
					this.populateQueue.pop()
					if(this.populateQueue.length) doneWork = true
				}else{
					if (!chunk.caves) {
						chunk.carveCaves()
					} else if (!chunk.populated) {
						await chunk.populate()
					}
					doneWork = true
				}
			}

			if (this.loadQueue.length && !doneWork) {
				this.loadQueue.pop().load()
				doneWork = true
			}
			if (this.lightingQueue.length && !doneWork) {
				this.lightingQueue.pop().fillLight()
				doneWork = true
			}

			if (this.chunkGenQueue.length && !doneWork) {
				let chunk = this.chunkGenQueue[0]
				if(this.fillReqs(chunk.x >> 4, chunk.z >> 4, chunk.type)) {
					chunk.allGenerated = true
					this.chunkGenQueue.shift()
					this.generatedChunks++
				}
				doneWork = true
			}
			if (doneWork) await yieldThread()
		}
		this.ticking = false
	}
	fillReqs(x, z, dimension) {
		// Chunks must all be loaded first.
    let done = true
		for (let i = x - 3; i <= x + 3; i++) {//if you change the size, change the adding in loadChunks
			for (let j = z - 3; j <= z + 3; j++) {
				let chunk = this[dimension].getChunk(i*16,j*16)
				if ((!chunk.generated || (!chunk.caves && this.worldType === "large")) && !this.generateQueue.includes(chunk)) {
					this.generateQueue.push(chunk)
					done = false
				}
				if (!chunk.populated && i >= x - 2 && i <= x + 2 && j >= z - 2 && j <= z + 2 && !this.populateQueue.includes(chunk)) {
					this.populateQueue.push(chunk)
					done = false
				}
				if (!chunk.loaded && i >= x - 1 && i <= x + 1 && j >= z - 1 && j <= z + 1 && !this.loadQueue.includes(chunk)) {
					if(this.loadFrom[i+","+j+","+dimension]) this.loadQueue.push(chunk)
					else chunk.loaded = true
					done = false
				}
			}
		}
		let chunk = this[dimension].getChunk(x*16,z*16)
		if(done) chunk.canSendClient = true
		if (!chunk.lit && !this.lightingQueue.includes(chunk)) {
			this.lightingQueue.push(chunk)
			done = false
		}
		return done
	}
	
	getSaveString(){
		let loadFrom = this.loadFrom

		let worldTypeBits1 = this.worldType==="island" ? 2 : (this.worldType === "void" ? 3 : (this.worldType === "superflat" ? 1 : 0))
		let worldTypeBits2 = this.worldType === "large" ? 1 : 0
		let weatherBits = this.weather==="rain" ? 1 : (this.weather === "snow" ? 2 : 0)

		let bab = new BitArrayBuilder()
		bab.addString(this.name)
		bab.add(this.worldSeed, 32)
		bab.add(round(this.time), 32)
		bab.add(weatherBits,2).add(this.nextWeather,17)
		bab.add(worldTypeBits1, 2).add(this.caves, 1).add(this.trees, 1)
		bab.add(version.length, 8)
		for (let c of version) bab.add(c.charCodeAt(0), 8)
		bab.add(worldTypeBits2,1)

		for (let x in this[""].chunks) {
			for (let z in this[""].chunks[x]) {
				this[""].chunks[x][z].unload()
			}
		}
		for (let x in this["nether"].chunks) {
			for (let z in this["nether"].chunks[x]) {
				this["nether"].chunks[x][z].unload()
			}
		}
		for (let x in this["end"].chunks) {
			for (let z in this["end"].chunks[x]) {
				this["end"].chunks[x][z].unload()
			}
		}

		bab.add(Object.keys(loadFrom).length, 32)
		for(let c in loadFrom){
			bab.addBasicString(c)
			bab.add(loadFrom[c].length,32)
			bab.appendArray(loadFrom[c])
		}
		
		bab.add(worldSettingKeys.length,8)
		for(let i of worldSettingKeys){
			bab.add(this.settings[i]?1:0, 1)
		}

		bab.add(this.gameMode === "survival" ? 1 : (this.gameMode==="hardcore"?2:0),2).add(this.cheats?1:0,1)
		bab.add(this.fancyRivers, 1)
		bab.add(this.structures, 1)
		return bab.array
	}
	loadSave(data, onlyMetdata = false) {
		this.structures = this.fancyRivers = false
		
		if (typeof data === "string") {
			if (data.includes("Alpha")) {
				try {
					return this.loadOldSave(data, onlyMetdata)
				}
				catch(e) {
					console.error(e)
					alert("Unable to load save string.")
				}
			}
			try {
				data = atoarr(data)
			}
			catch(e) {
				alert("Malformatted save string. Unable to load")
				throw e
			}
		}

		let reader = new BitArrayReader(data)

		this.name = reader.readString()
		this.setSeed(reader.read(32),true)
		this.time = reader.read(32)

		let weatherBits = reader.read(2)
		this.weather = weatherBits === 1 ? "rain" : (weatherBits === 2 ? "snow" : "")
		this.nextWeather = reader.read(17)

		let worldTypeBits1 = reader.read(2)
		this.caves = reader.read(1)
		this.trees = reader.read(1)
		
		let nameLen = reader.read(8)
		try{
			this.version = ""
			for (let i = 0; i < nameLen; i++) this.version += String.fromCharCode(reader.read(8))
			if(!this.version.includes("Alpha") && !this.version.includes("Beta")) throw ""
		}catch(e){
			console.error(e)
			return this.loadCrossSaveCode(data, onlyMetdata)
		}
		let preBetaVersion = verMoreThan("1.1.0",this.version.replace(/(Alpha|Beta) /, ''))
		let worldTypeBits2 = preBetaVersion ? 0 : (verMoreThan(this.version.replace(/(Alpha|Beta) /, ''),"1.1.1") ? reader.read(1) : (1-reader.read(1)))

		this.worldType = worldTypeBits2 ? "large" : (worldTypeBits1 === 2 ? "island" : (worldTypeBits1 === 3 ? "void" : (worldTypeBits1 ? "superflat" : "alpha")))

		if(onlyMetdata) return

		if(!verMoreThan(this.version.replace(/(Alpha|Beta) /, ''),"1.1.1")){
			this.loadSave_1_1_1(reader,preBetaVersion)
		}else{
			this.loadFrom = {}
			let chunkCount = reader.read(32)
			for(let i=0; i<chunkCount; i++){
				let ckey = reader.readBasicString()
				let datalen = reader.read(32)
				this.loadFrom[ckey] = reader.readToArray(datalen)
			}
		}
		
		let settingsKeys = reader.read(8)
		Object.assign(this.settings,defaultWorldSettings)
		for(let i=0; i<settingsKeys; i++){
			this.settings[worldSettingKeys[i]] = reader.read(1) ? true : false
		}

		if(preBetaVersion){
			let inv = this.playersInv[":host"] = this.playersInv[":host"] || {}
			inv.version = "Alpha 1.0.5"
			let survivLength = reader.read(8)
			if(survivLength){
				inv.survivStr = reader.readToArrayBits(survivLength)
				let asdf = new Player()
				asdf.world = this[""]
				asdf.respawn()
				this.loadSurvivStr(new BitArrayReader(inv.survivStr,true),preBetaVersion,asdf)
				this.cheats = asdf.cheats
				this.gameMode = asdf.survival ? "survival" : "creative"
			}
			let invLength = reader.read(16)
			if(invLength) inv.inv = reader.readToArrayBits(invLength)
		}

		if(!verMoreThan(this.version.replace(/(Alpha|Beta) /, ''),"1.1.1")){
			let entsLen = reader.read(32)
			for(let i=0; i<entsLen; i++){
				let entLen = reader.read(16)
				this.posEntity(reader.readToNew(entLen, true), null, preBetaVersion)
			}
		}
		if(!preBetaVersion){
			let survival = reader.read(2)
			this.gameMode = survival === 1 ? "survival" : (survival === 2 ? "hardcore" : "creative")
			this.cheats = reader.read(1)
			if(reader.canRead) this.fancyRivers = reader.read(1)
			if(reader.canRead) this.structures = reader.read(1)
		}
		this.findSpawnPoint()
	}
	loadSave_1_1_1(reader,preBetaVersion){ //convert to 1.1.2 format
		let paletteLen = reader.read(32)
		let palette = []
		let paletteBits = BitArrayBuilder.bits(paletteLen)
		for (let i = 0; i < paletteLen; i++) palette.push(reader.read(32))

		let sectionCount = reader.read(32)
		let chunks = {}, chunkSectionCount = {}
		for (let i = 0; i < sectionCount; i++) {
			let x = reader.read(16, true) * 8
			let y = reader.read(preBetaVersion?5:8, false) * 8
			let z = reader.read(16, true) * 8
			let dimension = reader.read(3)
			dimension = dimension === 1 ? "nether" : (dimension === 2 ? "end" : "")
			let orientation = reader.read(3)
			if(preBetaVersion) y -= minHeight

			let cx = x >> 4
			let cz = z >> 4

			// Make them into local chunk coords
			x = x !== cx * 16 ? 8 : 0
			z = z !== cz * 16 ? 8 : 0

			let ckey = `${cx},${cz},${dimension}`
			let chunk = chunks[ckey]
			if (!chunk) {
				chunk = new BitArrayBuilder()
				chunks[ckey] = chunk

				chunk.add(paletteLen, 32)
				for (let block of palette) chunk.add(block, 32)
				
				chunkSectionCount[ckey] = {count:0,bit:chunk.bitLength}
				chunk.add(0,32)//replaced later
			}
			chunkSectionCount[ckey].count++
			
			chunk.add(x/8,1)
			chunk.add(y/8,8)
			chunk.add(z/8,1)
			chunk.add(orientation,3)

			let runs = reader.read(8)
			let singles = reader.read(9)
			chunk.add(runs,8)
			chunk.add(singles,9)
			for (let j = 0; j < runs; j++) {
				let index = reader.read(9)
				let types = reader.read(9)
				let lenSize = reader.read(4)
				chunk.add(index,9)
				chunk.add(types,9)
				chunk.add(lenSize,4)
				for (let k = 0; k < types; k++) {
					chunk.add(reader.read(lenSize),lenSize)
					chunk.add(reader.read(paletteBits),paletteBits)
				}
			}
			for (let j = 0; j < singles; j++) {
				chunk.add(reader.read(9),9)
				chunk.add(reader.read(paletteBits),paletteBits)
			}
			let tagsCount = reader.read(9)
			chunk.add(tagsCount,9)
			for(let j=0; j<tagsCount; j++){
				let index = reader.read(9)
				chunk.add(index,9)
				let bit = reader.read(1)
				chunk.add(bit,1)
				if(bit){
					chunk.addString(reader.readString(16),16)
				}else{
					chunk.add(reader.read(32),32)
				}
			}
		}
		for(let i in chunks){
			let bab = chunks[i]
			bab.add(0,32)//entities
			bab.bitLength = chunkSectionCount[i].bit //go back and replace
			bab.add(chunkSectionCount[i].count,32)
			chunks[i] = bab.array
		}
		this.loadFrom = chunks
	}
	getBlockConvert(){
		const oldSLAB     = 0x100 // 9th bit
		const oldSTAIR    = 0x200 // 10th bit
		const oldFLIP     = 0x400 // 11th bit
		const oldSOUTH    = 0x800
		const oldEAST     = 0x1000
		const oldWEST     = 0x1800
		return [
			"air",
			"grass",
			"dirt",
			"stone",
			"bedrock",
			"sand",
			"gravel",
			"leaves",
			"glass",
			"cobblestone",
			"mossyCobble",
			"stoneBricks",
			"mossyStoneBricks",
			"bricks",
			"coalOre",
			"ironOre",
			"goldOre",
			"diamondOre",
			"redstoneOre",
			"lapisOre",
			"emeraldOre",
			"coalBlock",
			"ironBlock",
			"goldBlock",
			"diamondBlock",
			"redstoneBlock",
			"lapisBlock",
			"emeraldBlock",
			"oakPlanks",
			"oakLog",
			"acaciaPlanks",
			"acaciaLog",
			"birchPlanks",
			"birchLog",
			"darkOakPlanks",
			"darkOakLog",
			"junglePlanks",
			"jungleLog",
			"sprucePlanks",
			"spruceLog",
			"whiteWool",
			"orangeWool",
			"magentaWool",
			"lightBlueWool",
			"yellowWool",
			"limeWool",
			"pinkWool",
			"grayWool",
			"lightGrayWool",
			"cyanWool",
			"purpleWool",
			"blueWool",
			"brownWool",
			"greenWool",
			"redWool",
			"blackWool",
			"whiteConcrete",
			"orangeConcrete",
			"magentaConcrete",
			"lightBlueConcrete",
			"yellowConcrete",
			"limeConcrete",
			"pinkConcrete",
			"grayConcrete",
			"lightGrayConcrete",
			"cyanConcrete",
			"purpleConcrete",
			"blueConcrete",
			"brownConcrete",
			"greenConcrete",
			"redConcrete",
			"blackConcrete",
			"bookshelf",
			"netherrack",
			"soulSand",
			"glowstone",
			"netherWartBlock",
			"netherBricks",
			"redNetherBricks",
			"netherQuartzOre",
			"quartzBlock",
			"quartzPillar",
			"chiseledQuartzBlock",
			"chiseledStoneBricks",
			"smoothStone",
			"andesite",
			"polishedAndesite",
			"diorite",
			"polishedDiorite",
			"granite",
			"polishedGranite",
			"light",
			"water",
			"lava",
			"obsidian",
			"cryingObsidian",
			"endStone",
			"endStoneBricks",
			"chiseledNetherBricks",
			"crackedNetherBricks",
			"crackedPolishedBlackstoneBricks",
			"crackedStoneBricks",
			"polishedBlackstoneBricks",
			"prismarineBricks",
			"quartzBricks",
			"oakDoorTop",
			"oakDoorBottom",
			"warpedDoorTop",
			"warpedDoorBottom",
			"ironTrapdoor"
		].reduce((a, v, i) => ({
			...a,
			[i]: blockIds[v],
			[i|oldSLAB]: blockIds[v]|SLAB,
			[i|oldSLAB|oldFLIP]: blockIds[v]|FLIP,
			[i|oldSTAIR]: blockIds[v]|STAIR,
			[i|oldSTAIR|oldSOUTH]: blockIds[v]|STAIR|SOUTH,
			[i|oldSTAIR|oldEAST]: blockIds[v]|STAIR|EAST,
			[i|oldSTAIR|oldWEST]: blockIds[v]|STAIR|WEST,
			[i|oldSTAIR|oldFLIP]: blockIds[v]|STAIR|FLIP,
			[i|oldSTAIR|oldSOUTH|oldFLIP]: blockIds[v]|STAIR|SOUTH|FLIP,
			[i|oldSTAIR|oldEAST|oldFLIP]: blockIds[v]|STAIR|EAST|FLIP,
			[i|oldSTAIR|oldWEST|oldFLIP]: blockIds[v]|STAIR|WEST|FLIP,
		}), {})
	}
	loadCrossSaveCode(data, onlyMetdata){
		const blockConvert = this.getBlockConvert()
		let reader = new BitArrayReader(data)

		let nameLen = reader.read(8)
		this.name = ""
		for (let i = 0; i < nameLen; i++) this.name += String.fromCharCode(reader.read(8))
		this.setSeed(reader.read(32),true)
		this.time = reader.read(32)*0+500

		let inv = this.playersInv[":host"] = {}
		inv.x = reader.read(20, true)
		inv.y = reader.read(8)
		inv.z = reader.read(20, true)
		reader.skip(11)
		reader.skip(11)
		for (let i = 0; i < 9; i++){
			reader.skip(16)
		}
		reader.skip(4)
		reader.skip(1)
		reader.skip(1)

		this.worldType = Boolean(reader.read(1)) ? "superflat" : "alpha"
		this.caves = reader.read(1)
		this.trees = reader.read(1)
		this.version = "Alpha " + [reader.read(8), reader.read(8), reader.read(8)].join(".")

		if(onlyMetdata) return

		let paletteLen = reader.read(16)
		let palette = []
		let paletteBits = BitArrayBuilder.bits(paletteLen)
		for (let i = 0; i < paletteLen; i++) palette.push(reader.read(16))
		for(let i=0; i<palette.length; i++){
			if(blockConvert[palette[i]]) palette[i] = blockConvert[palette[i]]
		}

		const getIndex = [
			(index, x, y, z) => (y + (index >> 6 & 7))*256 + (x + (index >> 3 & 7))*16 + z + (index >> 0 & 7),
			(index, x, y, z) => (y + (index >> 6 & 7))*256 + (x + (index >> 0 & 7))*16 + z + (index >> 3 & 7),
			(index, x, y, z) => (y + (index >> 3 & 7))*256 + (x + (index >> 6 & 7))*16 + z + (index >> 0 & 7),
			(index, x, y, z) => (y + (index >> 0 & 7))*256 + (x + (index >> 6 & 7))*16 + z + (index >> 3 & 7),
			(index, x, y, z) => (y + (index >> 0 & 7))*256 + (x + (index >> 3 & 7))*16 + z + (index >> 6 & 7),
			(index, x, y, z) => (y + (index >> 3 & 7))*256 + (x + (index >> 0 & 7))*16 + z + (index >> 6 & 7)
		]

		let sectionCount = reader.read(32)
		let chunks = {}
		for (let i = 0; i < sectionCount; i++) {
			let x = reader.read(16, true) * 8
			let y = reader.read(5, false) * 8 - minHeight
			let z = reader.read(16, true) * 8
			let orientation = reader.read(3)

			let cx = x >> 4
			let cz = z >> 4

			// Make them into local chunk coords
			x = x !== cx * 16 ? 8 : 0
			z = z !== cz * 16 ? 8 : 0

			let ckey = `${cx},${cz}`
			let chunk = chunks[ckey]
			if (!chunk) {
				chunk = {blocks:[],tags:[]}
				chunks[ckey] = chunk
			}
			let runs = reader.read(8)
			let singles = reader.read(9)
			for (let j = 0; j < runs; j++) {
				let index = reader.read(9)
				let types = reader.read(9)
				let lenSize = reader.read(4)
				for (let k = 0; k < types; k++) {
					let chain = reader.read(lenSize) + 1
					let block = reader.read(paletteBits)
					for (let l = 0; l < chain; l++) {
						chunk.blocks[getIndex[orientation](index, x, y, z)] = palette[block]
						index++
					}
				}
			}
			for (let j = 0; j < singles; j++) {
				let index = reader.read(9)
				let block = reader.read(paletteBits)
				chunk.blocks[getIndex[orientation](index, x, y, z)] = palette[block]
			}
		}

		this.loadFrom = chunks

		this.spawnPoint.y = this.worldType === "superflat" ? 6 : (round(this.noiseProfile.noise(8 * generator.smooth, 8 * generator.smooth) * generator.height) + 2 + generator.extra)
		Object.assign(this.settings, defaultWorldSettings)
	}
	loadOldSave(str, onlyMetdata){
		let data = str.split(";")
		if (!str.includes("Alpha ")) {
			return alert("too old")
		}

		this.name = data.shift()
		let worldData = data.shift().split(",")
		this.setSeed(parseInt(worldData.shift(), 36),true)
		this.time = typeof worldData[0] === "string" ? parseFloat(worldData.shift()) : (worldData.shift(), 375)
		this.weather = worldData.shift() || ""
		this.nextWeather = parseFloat(worldData.shift()) || this.nextWeather

		let inv = this.playersInv[":host"] = {}
		let playerData = data.shift().split(",")
		inv.x = parseInt(playerData[0], 36)
		inv.y = parseInt(playerData[1], 36)
		inv.z = parseInt(playerData[2], 36)
		let options = parseInt(playerData[5], 36)
		let v = data[0].replace("Alpha ","")
		let worldType = options >> 1 & 3
		if(worldType === 0) this.worldType = "alpha"
		if(worldType === 1) this.worldType = "superflat"
		if(worldType === 2) this.worldType = "island"
		if(worldType === 3) this.worldType = "void"
		this.caves = options >> 4 & 1
		this.trees = options >> 5 & 1
		this.gameMode = (options >> 6 & 1) ? "survival" : "creative"
		this.cheats = this.gameMode === "creative"

		let version = data.shift()
		this.version = version

		if(onlyMetdata) return

		// if (version.split(" ")[1].split(".").join("") < 70) {
		// 	alert("This save code is for an older version. 0.7.0 or later is needed")
		// }

		let palletes = data.shift().split("|")
		let pallete = palletes[0].split(",").map(n => parseInt(n, 36)), netherPallete = palletes[1] ? palletes[1].split(",").map(n => parseInt(n, 36)) : "", endPallete = palletes[2] ? palletes[2].split(",").map(n => parseInt(n, 36)) : ""
		let chunks = {}
		if(!verMoreThan(version.replace("Alpha ",""),"0.7.1")){
			const blockConvert = this.getBlockConvert()
			for(let i=0; i<pallete.length; i++){
				if(blockConvert[pallete[i]]){
					pallete[i] = blockConvert[pallete[i]]
				}
			}
		}

		let dimension = ""
		for (let i = 0; data.length; i++) {
			let blocks = data.shift().split(",")
			if(blocks[0].startsWith("|")){
				blocks[0] = blocks[0].substring(1)
				if(dimension === "") dimension = "nether"
				else if(dimension === "nether") dimension = "end"
				else alert("Error: Save string cotains extra dimensions not in this version.")
			}
			if(!blocks[0]) continue //maybe it was only the "|"
			
			let cx = parseInt(blocks.shift(), 36)
			let cy = parseInt(blocks.shift(), 36)
			let cz = parseInt(blocks.shift(), 36)
			let str = `${cx},${cz},${dimension}`
			if (!chunks[str]) chunks[str] = {blocks:[],tags:[]}
			let chunk = chunks[str]

			var currentPallete = dimension === "nether" ? netherPallete : (dimension === "end" ? endPallete : pallete)
			for (let j = 0; j < blocks.length; j++) {
				let block, tags
				if(blocks[j].includes("/")){
					let data = blocks[j].split("/")
					block = parseInt(data[0], 36)
					try{
						tags = parseInt(data[1], 36) || JSON.parse(data[1].replace(/\\x2f/g,"/").replace(/\\x3b/g,";").replace(/\\x2c/g,",").replace(/\\x7c/g,"|"))
					}catch(e){
						console.error(e,data[1])
					}
				}else block = parseInt(blocks[j], 36)
				// Old index was 0xXYZ, new index is 0xYYXZ
				let x = block >> 8 & 15
				let y = block >> 4 & 15
				let z = block & 15
				let index = (cy * 16 + y - minHeight) * 256 + x * 16 + z
				let pid = block >> 12
				chunk.blocks[index] = currentPallete[pid]
				chunk.tags[index] = tags
			}
		}

		for(let i in chunks) chunks[i] = this.loadOldSaveConvert(i,chunks[i])
		this.loadFrom = chunks

		this.spawnPoint.y = this.worldType === "superflat" ? 6 : (round(this.noiseProfile.noise(8 * generator.smooth, 8 * generator.smooth) * generator.height) + 2 + generator.extra)
		Object.assign(this.settings, defaultWorldSettings, {mobSpawning:false})
	}
	loadOldSaveConvert(j,loadFrom){
		let blockSet = new Set()
		let sectionMap = {}, sectionTags = {}, sectionTagsLength = {}
		{
			const section = loadFrom, blocks = section.blocks, tags = section.tags
			let [sx, sz, dimension] = j.split(",")
			sx = +sx, sz = +sz
			for(let i in blocks){
				blockSet.add(blocks[i])
				const z = (i & 15)+sz*16, x = ((i >> 4) & 15)+sx*16, y = (i >> 8) & 255
				let str = `${x>>3},${y>>3},${z>>3},${dimension}`
				if (!sectionMap[str]) {
					sectionMap[str] = []
					for (let k = 0; k < 6; k++) sectionMap[str].push(new Int32Array(8*8*8).fill(-1))
					sectionTags[str] = []
					sectionTagsLength[str] = 0
				}

				sectionMap[str][0][(y & 7) << 6 | (x & 7) << 3 | z & 7] = blocks[i]
				sectionMap[str][1][(y & 7) << 6 | (z & 7) << 3 | x & 7] = blocks[i]
				sectionMap[str][2][(x & 7) << 6 | (y & 7) << 3 | z & 7] = blocks[i]
				sectionMap[str][3][(x & 7) << 6 | (z & 7) << 3 | y & 7] = blocks[i]
				sectionMap[str][4][(z & 7) << 6 | (x & 7) << 3 | y & 7] = blocks[i]
				sectionMap[str][5][(z & 7) << 6 | (y & 7) << 3 | x & 7] = blocks[i]
				if(tags[i]){
					sectionTags[str][(y & 7) << 6 | (x & 7) << 3 | z & 7] = typeof tags[i] === "number" ? tags[i] : JSON.stringify(tags[i]).substring(0,65535)
					sectionTagsLength[str]++
				}
			}
		}
		let bab = new BitArrayBuilder()
		let sections = Object.entries(sectionMap)
		let blocks = Array.from(blockSet)
		let palette = {}
		blocks.forEach((block, index) => palette[block] = index)
		let paletteBits = BitArrayBuilder.bits(blocks.length)
		bab.add(blocks.length, 32)
		for (let block of blocks) bab.add(block, 32)
		bab.add(sections.length, 32)
		for (let [coords, section] of sections) {
			let [sx, sy, sz] = coords.split(",")
			sx = +sx, sy = +sy, sz = +sz
			bab.add(sx, 1).add(sy, 8).add(sz, 1)

			// Determine the most compact orientation by checking all 6!
			let bestBAB = null
			for (let i = 0; i < 6; i++) {
				let bab = new BitArrayBuilder()

				let blocks = section[i]
				bab.add(i, 3)

				let run = null
				let runs = []
				let singles = []
				for (let i = 0; i < blocks.length; i++) {
					const block = blocks[i]
					if (block >= 0) {
						if (!run && i < blocks.length - 2 && blocks[i + 1] >= 0 && blocks[i + 2] >= 0) {
							run = [i, []]
							runs.push(run)
						}
						if (run) {
							if (run[1].length && block === run[1][run[1].length-1][1]) run[1][run[1].length-1][0]++
							else run[1].push([1, block])
						}
						else singles.push([i, blocks[i]])
					}
					else run = null
				}

				bab.add(runs.length, 8)
				bab.add(singles.length, 9)
				for (let [start, blocks] of runs) {
					// Determine the number of bits needed to store the lengths of each block type
					let maxBlocks = 0
					for (let block of blocks) maxBlocks = Math.max(maxBlocks, block[0])
					let lenBits = BitArrayBuilder.bits(maxBlocks)

					bab.add(start, 9).add(blocks.length, 9).add(lenBits, 4)
					for (let [count, block] of blocks) bab.add(count - 1, lenBits).add(palette[block], paletteBits)
				}
				for (let [index, block] of singles) {
					bab.add(index, 9).add(palette[block], paletteBits)
				}
				bab.add(sectionTagsLength[coords],9)
				if(sectionTagsLength[coords]) for(let i in sectionTags[coords]){
					let tags = sectionTags[coords][i]
					bab.add(i,9)
					if(typeof tags === "number"){
						bab.add(0,1)
						bab.add(tags,32)
					}else{
						bab.add(1,1)
						bab.addString(tags,16)
					}
				}
				if (!bestBAB || bab.bitLength < bestBAB.bitLength) {
					bestBAB = bab
				}
			}
			bab.append(bestBAB)
		}
		return bab.array
	}
	loadInv(reader,p,preBetaVersion){
		if(preBetaVersion){
			let bit = reader.bit
			try{
				this.loadInvPreBeta(reader,p)
			}catch(e){
				if(!(e instanceof RangeError)) throw e
			}
			reader.bit = bit
		}
		let {inventory} = p
		inventory.hotbarSlot = reader.read(4)
		for(let i=0;i<9;i++){
			let id = reader.read(32), amount = reader.read(7)
			inventory.hotbar[i] = amount && {id,amount}
		}
		let invLen = 27
		for(let i=0;i<invLen;i++){
			let id = reader.read(32), amount = reader.read(7)
			inventory.main[i] = amount && {id,amount}
		}
		let durability = reader.read(4), durabilityInv = reader.read(5)
		for(let i=0;i<durability;i++){
			let index = reader.read(4)
			inventory.hotbar[index].durability = reader.read(16)
		}
		for(let i=0;i<durabilityInv;i++){
			let index = reader.read(5)
			inventory.main[index].durability = reader.read(16)
		}
		let customName = reader.read(4), customNameInv = reader.read(5)
		for(let i=0;i<customName;i++){
			let index = reader.read(4)
			let name = reader.readString()
			inventory.hotbar[index].customName = name
		}
		for(let i=0;i<customNameInv;i++){
			let index = reader.read(5)
			let name = reader.readString()
			inventory.main[index].customName = name
		}
		let achievmentLen = reader.read(32)
		p.achievments.length = 0
		for(let i=0;i<achievmentLen;i++){
			p.achievments.push(reader.read(32))
		}
	}
	loadInvPreBeta(reader,p){
		let {inventory} = p
		inventory.hotbarSlot = reader.read(4)
		for(let i=0;i<9;i++){
			let id = reader.read(32), amount = reader.read(7)
			inventory.hotbar[i] = amount && {id,amount}
		}
		let invLen = 13*9
		for(let i=0;i<invLen;i++){
			let id = reader.read(32), amount = reader.read(7)
			inventory.main[i] = amount && {id,amount}
		}
		let durability = reader.read(4), durabilityInv = reader.read(5)
		for(let i=0;i<durability;i++){
			let index = reader.read(4)
			inventory.hotbar[index].durability = reader.read(16)
		}
		for(let i=0;i<durabilityInv;i++){
			let index = reader.read(5)
			inventory.main[index].durability = reader.read(16)
		}
		let customName = reader.read(4), customNameInv = reader.read(5)
		for(let i=0;i<customName;i++){
			let index = reader.read(4)
			let name = reader.readString()
			inventory.hotbar[index].customName = name
		}
		for(let i=0;i<customNameInv;i++){
			let index = reader.read(5)
			let name = reader.readString()
			inventory.main[index].customName = name
		}
		let achievmentLen = reader.read(32)
		p.achievments.length = 0
		for(let i=0;i<achievmentLen;i++){
			p.achievments.push(reader.read(32))
		}
	}
	loadOldInv(str,p){
		let arr = str.split("|")
		let inv = arr[1].split(",")
		let hotb = arr[0].split(",")
		
		for(let i=0; i<18; i+=2){
			if(hotb[i]){
				p.inventory.hotbar[i/2] = ({
					id: parseInt(hotb[i]) || 0,
					amount: parseInt(hotb[i+1]) || 0
				})
			}
		}
		for(let i=0; i<inv.length; i+=2){
			if(inv[i]){
				p.inventory.main[i/2] = ({
					id: parseInt(inv[i]) || 0,
					amount: parseInt(inv[i+1]) || 0
				})
			}
		}
		if(arr.length < 3) return
		inv = arr[3].split(",")
		hotb = arr[2].split(",")
		for(let i=0; i<len; i++){
			hotb[i] = parseInt(hotb[i]) || 0
			if(hotb[i] && inventory.hotbar[i]){
				p.inventory.hotbar[i].durability = hotb[i]
			}
		}
		for(let i=0; i<inv.length; i++){
			inv[i] = parseInt(inv[i]) || 0
			if(inv[i] && inventory.main[i]){
				p.inventory.main[i].durability = inv[i]
			}
		}
		
		if(arr.length < 5) return
		inv = arr[5].split(",")
		hotb = arr[4].split(",")
		for(let i=0; i<len; i++){
			if(hotb[i]){
				p.inventory.hotbar[i].customName = hotb[i]
			}
		}
		for(let i=0; i<inv.length; i++){
			if(inv[i]){
				p.inventory.main[i].customName = inv[i]
			}
		}
	}
	getInv(p){
		let {inventory} = p
		let bab = new BitArrayBuilder()
		bab.add(inventory.hotbarSlot,4)
		for(let i of inventory.hotbar){
			bab.add(i && i.id || 0,32)
			bab.add(i && i.amount || 0, 7)
		}
		for(let i of inventory.main){
			bab.add(i && i.id || 0,32)
			bab.add(i && i.amount || 0, 7)
		}
		
		let durability = [], durabilityInv = []
		let customName = [], customNameInv = []
		for(let i in inventory.hotbar){
			let j = inventory.hotbar[i]
			if(j){
				if(j.durability) durability.push(+i,j.durability)
				if(j.customName) customName.push(+i,j.customName)
			}
		}
		for(let i in inventory.main){
			let j = inventory.main[i]
			if(j){
				if(j.durability) durabilityInv.push(+i,j.durability)
				if(j.customName) customNameInv.push(+i,j.customName)
			}
		}
		bab.add(durability.length/2,4).add(durabilityInv.length/2,5)
		for(let i=0; i<durability.length; i+=2) bab.add(durability[i],4).add(durability[i+1],16)
		for(let i=0; i<durabilityInv.length; i+=2) bab.add(durabilityInv[i],5).add(durabilityInv[i+1],16)
		bab.add(customName.length/2,4).add(customNameInv.length/2,5)
		for(let i=0; i<customName.length; i+=2){
			bab.add(customName[i],4)
			bab.addString(customName[i+1],8)
		}
		for(let i=0; i<customNameInv.length; i+=2){
			bab.add(customNameInv[i],5)
			bab.addString(customNameInv[i+1],8)
		}
		bab.add(p.achievments.length,32)
		for(let i of p.achievments){
			bab.add(i,32)
		}
		return bab
	}

	setResourcePacks(active){
		this.activeResourcePacks.length = 0
		this.activeResourcePacks.push(...active)
		this.sendAll({type:"resourcePacks",activeResourcePacks:this.activeResourcePacks})
	}
	
	loadMod(code){
		this.mod = code
		if(this.modContainer){
			this.modContainer.contentWindow.postMessage({close:true})
			this.modContainer.remove()
		}
		//const modURL = window.URL.createObjectURL(new Blob([document.querySelector('#modPreCode').text,"const host="+(host?"true":"false")+"\n",data], { type: "text/javascript" }))
		const sandboxURL = window.URL.createObjectURL(new Blob([`
<!doctype html>
<html><head><meta charset="utf-8"></head><body><script>
let worker
addEventListener('message',e => {
	if(e.data.createWorker){
		const workerURL = window.URL.createObjectURL(new Blob(e.data.data, { type: "text/javascript" }))
		worker = new Worker(workerURL)
		worker.onmessage = e => {
			window.parent.postMessage(e.data, "*")
		}
	}else if(e.data.close){
		worker.terminate()
	}else{
		worker.postMessage(e.data)
	}
})
window.parent.postMessage({ready:true}, "*")
<\/script></body></html>
`], { type: 'text/html' }))
		let mod = this.modContainer = document.createElement("iframe")//new Worker(modURL)
		mod.src = sandboxURL
		mod.className = "hidden"
		mod.sandbox = "allow-scripts"
		doc.body.appendChild(mod)
		let world = this
		const safeFunctions = ["getBlock","setBlock","getTags","setTags","getTagByName","setTagByName"]
		const safeGlobalFunctions = {showTitle,sideMessage,customMenu,safeEval}
		mod.messageListener = addEventListener('message',e => {
			if(e.source !== mod.contentWindow) return
			if(e.data.ready){
				mod.contentWindow.postMessage({
					createWorker:true,
					data:[
						document.querySelector('#modPreCode').text.replace("SAFEFUNCTIONS",JSON.stringify(safeFunctions)).replace("SAFEGLOBALFUNCTIONS",JSON.stringify(Object.keys(safeGlobalFunctions)))+"\n",
						"const host="+(host?"true":"false")+"\n",code
					]
				},"*")
			}else{
				const {data} = e
				if(safeFunctions.includes(data.action)){
					mod.contentWindow.postMessage({id:data.id,data:world[data.action](...data.data)},"*")
				}else if(safeGlobalFunctions[data.action]){
					mod.contentWindow.postMessage({id:data.id,data:safeGlobalFunctions[data.action](...data.data)},"*")
				}
			}
		})
	}

	getSurvivStr(p){
		let bab = new BitArrayBuilder()
		//position
		bab.add(round(p.x), 20).add(round(p.y), 11).add(round(p.z), 20)
		bab.add(p.dimension === "nether" ? 1 : (p.dimension === "end" ? 2 : 0),3)
		bab.add(p.rx * 100, 11).add(p.ry * 100, 11)
		bab.add(!!p.flying, 1).add(p.gameMode==="spectator", 1)
		//survival stuff like player health
		bab.add(round(p.health),5)
		bab.add(0,28)//unused
		bab.add(p.spawnPoint.x,20).add(p.spawnPoint.y,20).add(p.spawnPoint.z,20)
		bab.add(p.food,5).add(p.foodSaturation,5).add(p.foodExhaustion,2)
		bab.add(p.oxygen,5)
		bab.add(p.gameMode==="survival"?1:(p.gameMode==="hardcore"?2:0),2).add(p.cheats?1:0,1)
		bab.add(p.freezeEffect,8)
		bab.add(p.XP*100,16).add(p.level,16)
		bab.add(p.didEndPoem?1:0,1)
		bab.add(p.lastY,11)
		let effects = Object.keys(p.effects)
		bab.add(effects.length,8)
		for(let i of effects){
			bab.addBasicString(i)
			bab.add(p.effects[i].level,8)
			bab.add(p.effects[i].time,32)
			bab.add(p.effects[i].showParticles ? 1 : 0, 1)
		}
		bab.addBasicString(p.riding||"")
		bab.add(p.doingPortal,32)
		return bab
	}
	loadSurvivStr(reader,preBetaVersion,p){
		p.x = reader.read(20, true)
		p.y = preBetaVersion ? reader.read(8) : reader.read(11,true)
		p.z = reader.read(20, true)
		let d = reader.read(3)
		p.dimension = d === 1 ? "nether" : (d === 2 ? "end" : "")
		p.world = this[p.dimension]
		p.rx = reader.read(11, true) / 100
		p.ry = reader.read(11, true) / 100
		p.flying = reader.read(1)
		let spectator = reader.read(1)

		p.health = reader.read(5)
		reader.skip(28)//unused
		p.spawnPoint.x = reader.read(20,true)
		p.spawnPoint.y = reader.read(20,true)
		p.spawnPoint.z = reader.read(20,true)
		p.food = reader.read(5)
		p.foodSaturation = reader.read(5)
		p.foodExhaustion = reader.read(2)
		p.oxygen = reader.read(5)
		let survival = reader.read(2)
		if(spectator) p.gameMode = "spectator"
		else if(survival === 0) p.gameMode = "creative"
		else if(survival === 1) p.gameMode = "survival"
		else if(survival === 2) p.gameMode = "hardcore"
		//survival = survival === 1 ? true : (survival === 2 ? "hardcore" : false)
		p.cheats = Boolean(reader.read(1))
		p.freezeEffect = reader.read(8)
		p.XP = reader.read(16)/100
		p.level = reader.read(16); p.setLevel()
		p.didEndPoem = Boolean(reader.read(1))
		p.lastY = preBetaVersion ? reader.read(8) : reader.read(11,true)
		if(!reader.canRead) return
		let effectsLen = reader.read(8)
		p.effects = {}
		for(let i=0; i<effectsLen; i++){
			p.effects[reader.readBasicString()] = {level:reader.read(8), time:reader.read(32), showParticles:reader.read(1)}
		}
		if(!reader.canRead) return
		p.riding = reader.readBasicString() || null
		if(!reader.canRead) return
		p.doingPortal = reader.read(32)
	}
	loadOldSurvivStr(str,p){
		let arr = str.split(",")
		p.health = parseInt(arr[0])
		p.witherEffect = parseInt(arr[1])
		p.itherTime = parseInt(arr[2])
		p.witherDamage = parseInt(arr[3])
		p.spawnPoint.x = parseInt(arr[4]) || 0
		p.spawnPoint.y = parseInt(arr[5]) || 0
		p.spawnPoint.z = parseInt(arr[6]) || 0
		p.food = parseInt(arr[7]); if(isNaN(p.food)) p.food = 20
		p.foodSaturation = parseFloat(arr[8]) || 0, p.foodExhaustion = parseFloat(arr[9]) || 0
		p.oxygen = parseInt(arr[10]); if(!p.oxygen) p.oxygen = 20
		this.time = parseFloat(arr[11]) || 0
		this.cheats = p.cheats = arr[12] ? arr[12] === "1" : !this.survival
		p.freezeEffect = parseInt(arr[13])
		p.XP = parseFloat(arr[14]) || 0
		p.level = parseInt(arr[15]) || 0; p.setLevel()
	}

	onpos(){
		/*let entities = this.getEntities(), arr = [], length = 0
		for(let i=0; i<entities.length; i++){
			let ent = entities[i]
			let l = ent.length
			if(length+l > 10000){
				this.sendAll({type:"entityPosAll", data: arr})
				length = 0
				arr.length = 0
			}
			length += l
			arr.push(ent)
		}
		if(length) this.sendAll({type:"entityPosAll", data: arr})*/
		this.sendAll({type:"settings", data:this.settings, time:this.time, weather:this.weather})
	}
	//c must be a connection: {send: function, onmessage, onclose, close: function}	
	/*p: {
		loadChunks: chunks that need to be sent to player,
		loadDistance
		update,
		updateingLoaded,
		updateingLoadedI
	}*/
	getPlayersInv(){
		for(let p of this.players) p.saveInv()
		return this.playersInv
	}
	serverAddPlayer(c, id, username, host = false, admin = false){
		let p = new Player()
		p.id = id
		p.host = host
		p.connection = c
		p.admin = admin
		p.loadChunks = [], p.loadDistance = 0
		p.posUpdated = {} //List of updated player positions
		for(let p2 of this.players){
			if(p2.pos && p2 !== p) p.posUpdated[p2.id] = p2.pos
		}
		p.lastSendEntities = 0
		p.updateingLoadedI = 0
		p.inventory.slotMapPlace = new Map()
		p.inventory.slotMapIdx = new Map()
		p.inventory.prevSlots = []
		p.world = this[""]//temporaryily
		this.players.push(p)
		let world = this
		function sendOthers(msg){
			for(let p2 of world.players){
				if(p2 !== p) p2.connection.send(msg)
			}
		}
		c.onmessage = async function(data){
			if(data.type === "connect"){
				username = p.username = username || data.username
				await Promise.all(world.loadPromises)
				//let saveStr = world.getSaveString()

				p.cheats = world.cheats//will be overwritten if inv exists
				p.gameMode = world.gameMode

				p.respawn()
				let inv = world.playersInv[host ? ":host" : username]
				if(inv){//older stuff
					let preBetaVersion = inv.version && verMoreThan("1.1.0",inv.version.replace(/(Alpha|Beta) /, ''))
					if(typeof inv.inv === "string"){
						if(inv.inv.includes(",")){
							this.loadOldInv(inv.inv,p), inv.inv = null
						}else{
							inv.inv = atoarr(inv.inv)
						}
					}
					if(typeof inv.survivStr === "string"){
						if(inv.survivStr.includes(",")){
							this.loadOldSurvivStr(inv.survivStr,p), inv.survivStr = null
						}else{
							inv.survivStr = atoarr(inv.survivStr)
						}
					}
					if(inv.survivStr && inv.survivStr.length){
						try{
							world.loadSurvivStr(new BitArrayReader(inv.survivStr), preBetaVersion, p)
						}catch(e){
							console.error(e)
							p.cheats = world.cheats
							p.gameMode = world.gameMode
							p.spawnPoint.x = world.spawnPoint.x
							p.spawnPoint.y = world.spawnPoint.y
							p.spawnPoint.z = world.spawnPoint.z
							p.respawn()
						}
					}
					if(inv.x !== undefined){
						p.x = inv.x, p.y = inv.y, p.z = inv.z
					}
					if(inv.inv && inv.inv.length){
						world.loadInv(new BitArrayReader(inv.inv),p,preBetaVersion)
					}
				}
				c.send({
					type:"loadSave",
					name:world.name,
					mod: world.mod,
					id: world.id,
					inv,
					//resourcePacks:world.resourcePacks,
					activeResourcePacks:world.activeResourcePacks,
					x:p.x,
					y:p.y,
					z:p.z,
					version:world.version,
					weather:world.weather,
					time:world.time,
					gameMode:p.gameMode,
					cheats:p.cheats,
					hotbarSlot:p.inventory.hotbarSlot,
					flying:p.flying,
					achievments:p.achievments
				})
				c.send({
					type:"serverCmds",
					data:world.commandNodes.map(r => ({type:r.type,name:r.name,id:r.id,next:r.next,redirect:r.redirect,info:r.info,argType:r.argType,func:Boolean(r.func||r.anonymousFunc),noCheats:r.noCheats}))
				})
				p.sendHealth()
				p.setRot(p.rx,p.ry,p.bodyRot,true)
				p.sendEffects()
				sendOthers(data)
			}else if(data.type === "pos"){
				let pos = data.data
				p.setPos(pos.x,pos.y,pos.z,pos.velx,pos.vely,pos.velz)
				p.setRot(pos.rx, pos.ry, pos.bodyRot)
				p.onGround = pos.onGround
				p.sneaking = pos.sneaking
				p.harmEffect = pos.harmEffect
				/*if(thisplayer.username !== pos.username){
					thisplayer.username = pos.username
					//thisplayer.changeBlock(abs((pos.username || "").hashCode()) % 80 + 1)
				}*/
				p.crack = pos.crack //crack number
				p.walking = pos.walking
				p.sprinting = pos.sprinting
				p.punchEffect = pos.punchEffect
				p.eating = pos.eating
				p.sleeping = pos.sleeping
				p.sitting = pos.sitting
				p.swimming = pos.swimming
				p.usingItem = pos.usingItem
				p.spectating = pos.spectating
				p.afk = data.afk
				p.scale = pos.scale
				p.riding = pos.riding
				p.flying = pos.flying
				pos.username = username
				pos.burning = p.burning
				pos.holding = p.holding
				pos.die = p.die
				pos.crackPos = p.crackPos
				pos.dimension = p.dimension
				data.FROM = p.id
				p.pos = data
				for(let p2 of world.players){
					if(p2 !== p && p2.pos) p2.posUpdated[id] = p.pos
				}
				for(let u in p.posUpdated){
					if(p.posUpdated[u]){
						c.send(p.posUpdated[u])
						p.posUpdated[u] = null
					}
				}
				let now = performance.now()
				if(now - p.lastSendEntities > 125){
					p.lastSendEntities = now
					let entities = world[p.dimension].getEntities(p), arr = [], length = 0
					for(let i=0; i<entities.length; i++){
						let ent = entities[i]
						let l = ent.length
						if(length+l > 10000){
							p.connection.send({type:"entityPosAll", data: arr})
							length = 0
							arr.length = 0
						}
						length += l
						arr.push(ent)
					}
					if(length) p.connection.send({type:"entityPosAll", data: arr})
				}
				if(p.resendHealth){
					p.sendHealth()
					p.resendHealth = false
				}
				if(p.resendEffects){
					p.sendEffects()
					p.resendEffects = false
				}
				updateContainer()
				c.send({type:"canSendPos"})
			}else if(data.type === "loadChunks"){
				p.updateingLoadedI++
				p.loadDistance = data.loadDistance
				p.loadChunks = data.data
				world.loadedUpdate = true
			}else if(data.type === "mySkin" || data.type === "particles" || data.type === "achievment" || data.type === "harmEffect" || data.type === "playSound" || data.type === "title" || data.type === "joined"){
				sendOthers(data)
			}else if(data.type === "hit"){
				if(data.isEntity){
					let ent = world.entities[world[p.dimension].getEntity(data.TO)]
					if(ent) ent.onhit(data.damage,false, data.velx,data.velz, data.id)
				}else world.sendPlayer(data,data.TO)
			}else if(data.type === "message"){
				data.fromServer = false
				data.username = username
				sendOthers(data)
			}/*else if(data.type === "setBlock"){
				let pos = data.data
				world.setBlock(pos.x, pos.y, pos.z, pos.block, false, false, true, pos.keepTags, pos.dimension)
				world.sendAllInChunk(data, pos.x>>4,pos.z>>4,pos.dimension)
			}else if(data.type === "setTags"){
				world.setTags(data.x,data.y,data.z,data.data, true, data.dimension, data.lazy)
				sendOthers(data)
			}*/else if(data.type === "serverChangeBlock"){
				try{
				world.serverChangeBlock(data.x,data.y,data.z,data.place,p,data.face,data.shift,data.blockMode,data.rotate,data.flip)
				}catch(e){e.message+"\nblock: "+JSON.stringify(p.inventory.hotbar[p.inventory.hotbarSlot]);throw e}
			}else if(data.type === "entityPos"){
				let ent = world.posEntity(new BitArrayReader(data.data, true), true)
				return world[p.dimension].deleteEntity(ent.id)
				//sendOthers(data)
			}else if(data.type === "entityDelete"){
				//world[p.dimension].deleteEntity(data.id, true)
				//sendOthers(data)
			}/*else if(data.type === "entEvent"){
				var ent = world && world.entities[world.getEntity(data.id)]
				if(!ent) return
				if(data.event === "itemAmount"){
					ent.amount = data.data
				}else if(data.event === "damageMob"){
					ent.onhit(data.data.damage,true,data.data.vx,data.data.vz,data.data.from)
				}else if(data.event === "creeperForceExplode"){
					ent.forceExplode(true)
				}else if(data.event === "sheepFur"){
					ent.fur = data.data
				}else if(data.event === "sheepEat"){
					ent.eating = 1
				}else if(data.event === "sheepColor"){
					ent.color = data.data.color
					ent.wool = data.data.wool
				}else if(data.event === "mobAttack"){
					ent.attackCooldown = ent.maxAttackCooldown
				}else if(data.event === "tame"){
					ent.tame = true
					ent.owner = data.data
				}else if(data.event === "wolfCollarColor"){
					ent.color = data.data
				}else if(data.event === "sit"){
					ent.sitting = data.data
				}else if(data.event === "tp"){
					ent.x = data.data.x
					ent.y = data.data.y
					ent.z = data.data.z
					ent.lastY = 0
					if(ent.path) ent.path = null
				}else if(data.event === "wolfTarget"){
					ent.target = data.data
				}else if(data.event === "healthAdd"){
					ent.health += data.data
				}else if(data.event === "name"){
					ent.name = data.data
				}
				sendOthers(data)
			}else if(data.type === "kill"){
				if(data.data === "@a"){
					sendOthers({type:"kill",data:data.message})
				}else{
					world.sendPlayerName({
						type:"kill",
						data:data.message
					}, data.data)
				}
			}*/else if(data.type === "remoteControl"){
				if(host || admin) world.sendPlayer(data,data.TO)
			}else if(data.type === "runCmd"){
				runCmd(data.data,p,world,false, (output,newOutputs) => {
					for(let i=0; i<newOutputs.length; i+=2) c.send({type:"message",data:newOutputs[i],fromServer:true})
				}, p.cheats)
				//runCmdFromClient(data.data,data.args,p,data.scope||{},world,data.id,p.cheats)
			}else if(data.type === "openContainer"){
				p.inventory.containerData.x = data.x
				p.inventory.containerData.y = data.y
				p.inventory.containerData.z = data.z
				p.inventory.containerData.dimension = data.dimension
				orderInvSlots(data.data)
				if(data.data === "inventory") p.addAchievment("Taking Inventory")
			}else if(data.type === "containerChange"){
				let {inventory} = p
				check:{
					if(data.data.length === 1){
						let pitem = getSlot(data.idxs[0])
						let nitem = data.data[0]//drop item is allowed
						if(pitem && (!nitem || nitem.amount < pitem.amount && nitem.id === pitem.id && (!nitem.customName && !pitem.custonName || nitem.customName === pitem.customName) && nitem.durability === pitem.durability)){
							let change = nitem ? pitem.amount-nitem.amount : pitem.amount
							let d = p.direction
							let place = inventory.slotMapPlace.get(data.idxs[0])
							if(p.survival || place !== "holding" && p.cheats) world[p.dimension].addItems(p.x, p.y, p.z, d.x/4, d.y/4, d.z/4, pitem.id, false, change,pitem.durability,pitem.customName,p.id)
							break check
						}
					}
					let nmap = new Map(), pmap = new Map()//new, previous
					for(let i=0; i<data.data.length; i++){//check for correctness
						let nitem = data.data[i]
						if(nitem && nitem.amount > blockData[nitem.id].stackSize) return updateContainer(true)
						let pitem = getSlot(data.idxs[i])
						if(nitem){
							let nname = nitem.id+"|"+(nitem.customName||"")
							nmap.set(nname,(nmap.get(nname)||0)+nitem.amount)
						}
						if(pitem){
							let pname = pitem.id+"|"+(pitem.customName||"")
							pmap.set(pname,(pmap.get(pname)||0)+pitem.amount)
						}
						let place = inventory.slotMapPlace.get(data.idxs[i])
						if((place === "craftingResult" || place === "furnaceOutput" || place === "anvilOutput") && nitem) return updateContainer(true)//cant put things in this slot
						if(place === "anvilOutput" && inventory.anvilCost>p.level && p.survival) return updateContainer(true)
					}
					if(p.survival && !compareMaps(nmap,pmap)) return updateContainer(true)
					/*for(let i=0; i<data.data.length; i++){//check for correctness
						let ritem = data.data[i]
						let item = getSlot(data.idxs[i])
						if(ritem){
							if(ritem.amount > blockData[ritem.id].stackSize || ritem.id !== first.id || ritem.customName !== first.customName) return orderInvSlots()
							reqTotal += ritem.amount
						}
						if(item){
							if(item.id !== first.id || item.customName !== first.customName) return orderInvSlots()
							toTotal += item.amount
						}
					}
					if(toTotal !== reqTotal) return orderInvSlots()*/
				}
				let craftUpdate, craftRes, anvilUpdate, anvilIn, anvilOut
				for(let i=0; i<data.data.length; i++){
					let prev = getSlot(data.idxs[i])
					setSlot(data.idxs[i], data.data[i])
					let place = inventory.slotMapPlace.get(data.idxs[i])
					if(place === "crafting2" || place === "crafting3"){
						craftUpdate = true
					}
					if(place === "craftingResult" && prev) craftRes = true
					if(place === "anvilInput" || place === "anvilMaterial" || place === "anvilOutput"){
						anvilUpdate = true
						if(place === "anvilInput") anvilIn = true
						if(place === "anvilOutput" && prev) anvilOut = prev
					}
				}
				if(craftUpdate) updateCraftingGrid()
				if(craftRes){//decrease amount
					let res = crafts[inventory.craftingName]
					let crafting = inventory.currentContainer === "crafting" ? inventory.crafting3 : inventory.crafting2
					for(let i=0; i< (inventory.currentContainer === "crafting" ? 9 : 4); i++){
						let block = crafting[i]
						if(block && block.id){
							if(res.replace && res.replace[blockData[block.id].name]){
								block.id = blockIds[res.replace[blockData[block.id].name]]
							}else{
								block.amount --
								if(block.amount <= 0) crafting[i] = null
							}
						}
					}
					let r = res.id
					if(r === blockIds.craftingTable){
						p.addAchievment("Benchmaking")
					}else if(r && blockData[r].pickaxe){
						p.addAchievment("Time to Mine!")
					}else if(r === blockIds.stonePickaxe){
						p.addAchievment("Getting an Upgrade")
					}else if(r === blockIds.bread){
						p.addAchievment("Bake Bread")
					}else if(r && blockData[r].sword){
						p.addAchievment("Time to Strike!")
					}else if(r && blockData[r].hoe){
						p.addAchievment("Time to Farm!")
					}else if(r && blockData[r].bed){
						p.addAchievment("Make a bed")
					}
					p.addDiscovery(r)
					updateCraftingGrid()
				}
				if(anvilIn){
					let item = inventory.anvilInput
					inventory.anvilRename = item ? (item.customName || blockData[item.id].Name) : ""
				}
				if(anvilOut){
					if(inventory.anvilInput && inventory.anvilInput.durability && inventory.anvilInput.durability !== anvilOut.durability){
						inventory.anvilMaterial.amount--
						if(inventory.anvilMaterial.amount <= 0) inventory.anvilMaterial = null
					}
					inventory.anvilInput = null
					if(p.survival){
						p.level -= inventory.anvilCost
						p.setLevel()
						p.resendHealth = true
					}
					world[p.dimension].playSound(p.x,p.y,p.z,"anvil.land")
					setTimeout(()=>world[p.dimension].playSound(p.x,p.y,p.z,"anvil.land"),500)
					setTimeout(()=>world[p.dimension].playSound(p.x,p.y,p.z,"anvil.land"),1000)
				}
				if(anvilUpdate) updateAnvil()
			}else if(data.type === "hotbar"){
				p.inventory.hotbarSlot = data.slot
			}else if(data.type === "containerChangeAnvil"){
				p.inventory.anvilRename = data.rename
				updateAnvil()
			}else if(data.type === "containerChangeCommandBlock"){
				let {containerData} = p.inventory
				world[containerData.dimension].setTagByName(containerData.x,containerData.y,containerData.z,"data",data.data,false)
			}else if(data.type === "containerChangeSign"){
				let {containerData} = p.inventory
				world[containerData.dimension].setTagByName(containerData.x,containerData.y,containerData.z,data.side?"text2":"text",data.data)
			}else if(data.type === "entInteract"){
				world.entInteract(data.data,data.hit,data.cooldown,p)
			}else if(data.type === "respawn"){
				if(p.die){
					if(p.gameMode === "hardcore"){
						p.gameMode = "spectator"
						p.health = 1
						c.send({type:"gameMode",gameMode:p.gameMode})
					}else p.respawn()
					p.sendHealth()
					c.send({type:"respawn"})
				}
			}else if(data.type === "gameMode"){
				if(p.cheats){
					p.gameMode = data.gameMode
					c.send({type:"gameMode",gameMode:p.gameMode})
				}
			}else if(data.type === "jump"){
				if(p.survival) p.foodExhaustion += p.sprinting ? 0.2 : 0.05
			}else if(data.type === "startBreak"){
				p.crackPos[0] = data.x
				p.crackPos[1] = data.y
				p.crackPos[2] = data.z
				p.breakStart = Date.now()
			}
		}
		c.onclose = function(){
			p.saveInv()
			let i = world.players.indexOf(p)
			if(i !== -1) world.players.splice(i,1)
			for(let p2 of world.players){
				delete p2.posUpdated[id]
			}
			world.sendAll({type:"dc",data:p.id})
		}
		p.updateLoaded = async function(){
			for(let i=0; i<9; i++){
				let item = p.inventory.hotbar[i]
				if(!item) continue
				if(blockData[item.id].durability){
					if(typeof item.durability !== "number"){
						item.durability = blockData[item.id].durability
					}else if(item.durability <= 0){
						p.inventory.hotbar[i] = 0
						world[p.dimension].playSound(p.x,p.y,p.z,"random.break")
					}
				}
			}

			if(this.updateingLoaded || p.doingPortal) return
			let id = this.updateingLoadedI
			this.updateingLoaded = true
			for(let i=0; i<p.loadChunks.length; i+=2){
				if(this.updateingLoadedI !== id) break
				let x = p.loadChunks[i], z = p.loadChunks[i+1]
				let chunk = world[p.dimension].getChunk(x*16,z*16)
				if(chunk && chunk.canSendClient){
					if(host) c.send({type:"chunkData",x,z})
					else c.send({
						type:"chunkData",
						x,z,
						data:await chunk.getData(),
						tops:chunk.tops,
						solidTops:chunk.solidTops,
						biomes:chunk.biomes,
						caveY:chunk.caveY,
						caveBiomes:chunk.caveBiomes
					})
					p.loadChunks.splice(i,2)
					i -= 2
				}
			}
			this.updateingLoaded = false
		}
		function orderInvSlots(currentContainer = p.inventory.currentContainer){
			let prev = p.inventory.currentContainer
			if(prev !== currentContainer){
				if(prev === "inventory"){//make things drop
					for(let i=0; i<4; i++) dropSlot(p.inventory.slotIds.crafting2[i])
					p.inventory.craftingResult = null
				}else if(prev === "crafting"){
					for(let i=0; i<9; i++) dropSlot(p.inventory.slotIds.crafting3[i])
					p.inventory.craftingResult = null
				}else if(prev === "anvil"){
					dropSlot(p.inventory.slotIds.anvilInput)
					dropSlot(p.inventory.slotIds.anvilMaterial)
					p.inventory.anvilOutput = null
				}
			}
			p.inventory.currentContainer = currentContainer
			let id = 0
			p.inventory.slotMapPlace.clear()
			p.inventory.slotMapIdx.clear()
			p.inventory.slotMapPlace.set(id,"holding"), p.inventory.slotIds.holding = id++
			if(currentContainer === "inventory"){
				for(let i=0; i<4; i++) p.inventory.slotMapPlace.set(id,"crafting2"), p.inventory.slotMapIdx.set(id,i), p.inventory.slotIds.crafting2[i] = id++
				p.inventory.slotMapPlace.set(id,"craftingResult"), p.inventory.slotIds.craftingResult = id++
			}else if(currentContainer === "crafting"){
				for(let i=0; i<9; i++) p.inventory.slotMapPlace.set(id,"crafting3"), p.inventory.slotMapIdx.set(id,i),  p.inventory.slotIds.crafting3[i] = id++
				p.inventory.slotMapPlace.set(id,"craftingResult"), p.inventory.slotIds.craftingResult = id++
			}else if(currentContainer === "furnace"){
				p.inventory.slotMapPlace.set(id,"furnaceInput"), p.inventory.slotIds.furnaceInput = id++
				p.inventory.slotMapPlace.set(id,"furnaceOutput"), p.inventory.slotIds.furnaceOutput = id++
				p.inventory.slotMapPlace.set(id,"furnaceFuel"), p.inventory.slotIds.furnaceFuel = id++
			}else if(currentContainer === "chest"){
				for(let i=0; i<27; i++) p.inventory.slotMapPlace.set(id,"chest"), p.inventory.slotMapIdx.set(id,i),  p.inventory.slotIds.chest[i] = id++
			}else if(currentContainer === "anvil"){
				p.inventory.slotMapPlace.set(id,"anvilInput"), p.inventory.slotIds.anvilInput = id++
				p.inventory.slotMapPlace.set(id,"anvilMaterial"), p.inventory.slotIds.anvilMaterial = id++
				p.inventory.slotMapPlace.set(id,"anvilOutput"), p.inventory.slotIds.anvilOutput = id++
			}else if(currentContainer === "dispenser"){
				for(let i=0; i<9; i++) p.inventory.slotMapPlace.set(id,"dispenser"), p.inventory.slotMapIdx.set(id,i),  p.inventory.slotIds.dispenser[i] = id++
			}else if(currentContainer === "hopper"){
				for(let i=0; i<5; i++) p.inventory.slotMapPlace.set(id,"hopper"), p.inventory.slotMapIdx.set(id,i),  p.inventory.slotIds.hopper[i] = id++
			}
			for(let i=0; i<27; i++) p.inventory.slotMapPlace.set(id,"main"), p.inventory.slotMapIdx.set(id,i), p.inventory.slotIds.main[i] = id++
			for(let i=0; i<9; i++) p.inventory.slotMapPlace.set(id,"hotbar"), p.inventory.slotMapIdx.set(id,i), p.inventory.slotIds.hotbar[i] = id++
			updateContainer(true)//c.send({type:"containerData",data:arr})
		}
		function getSlot(id){
			let containerData = p.inventory.containerData
			let place = p.inventory.slotMapPlace.get(id), idx = p.inventory.slotMapIdx.get(id)
			if(place === "hotbar" || place === "main" || place === "crafting2" || place === "crafting3"){
				return p.inventory[place][idx]
			}else if(place === "holding" || place === "craftingResult" || place === "anvilInput" || place === "anvilMaterial" || place === "anvilOutput"){
				return p.inventory[place]
			}else if(place === "furnaceInput"){
				return containerData.data.input
			}else if(place === "furnaceOutput"){
				return containerData.data.output
			}else if(place === "furnaceFuel"){
				return containerData.data.fuel
			}else if(place === "chest" || place === "dispenser" || place === "hopper"){
				return containerData.data.contents[idx]
			}
		}
		function setSlot(id,item){
			let containerData = p.inventory.containerData
			let place = p.inventory.slotMapPlace.get(id), idx = p.inventory.slotMapIdx.get(id)
			if(place === "hotbar" || place === "main" || place === "crafting2" || place === "crafting3"){
				p.inventory[place][idx] = item
			}else if(place === "holding" || place === "craftingResult" || place === "anvilInput" || place === "anvilMaterial" || place === "anvilOutput"){
				p.inventory[place] = item
			}else if(place === "furnaceInput"){
				containerData.data.input = item
				world[containerData.dimension].updateTags(containerData.x,containerData.y,containerData.z)
			}else if(place === "furnaceOutput"){
				containerData.data.output = item
				world[containerData.dimension].updateTags(containerData.x,containerData.y,containerData.z)
			}else if(place === "furnaceFuel"){
				containerData.data.fuel = item
				world[containerData.dimension].updateTags(containerData.x,containerData.y,containerData.z)
			}else if(place === "chest" || place === "dispenser" || place === "hopper"){
				containerData.data.contents[idx] = item
				world[containerData.dimension].updateTags(containerData.x,containerData.y,containerData.z)
			}
			let len = p.inventory.slotMapPlace.size
			let prevSlots = p.inventory.prevSlots
			if(item){//prevent updating
				prevSlots[id] = item.id
				prevSlots[id+len] = item.amount
				prevSlots[id+len*2] = item.customName
				prevSlots[id+len*3] = item.durability
			}else prevSlots[id] = null
		}
		function dropSlot(id){
			let item
			let place = p.inventory.slotMapPlace.get(id), idx = p.inventory.slotMapIdx.get(id)
			if(place === "crafting2" || place === "crafting3"){
				item = p.inventory[place][idx]
				p.inventory[place][idx] = null
			}
			if(place === "anvilInput" || place === "anvilMaterial" || place === "anvilOutput"){
				item = p.inventory[place]
				p.inventory[place] = null
			}
			if(item){
				let d = p.direction
				world[p.inventory.containerData.dimension].addItems(p.x, p.y, p.z, d.x/4, d.y/4, d.z/4, item.id, false, item.amount,item.durability,item.customName,p.id)
			}
		}
		let tempCraftGrid = new Array(9)
		function updateCraftingGrid(){
			let parr = (p.inventory.currentContainer === "crafting" ? p.inventory.crafting3 : p.inventory.crafting2)
			let arr = tempCraftGrid
			if(p.inventory.currentContainer === "crafting"){
				for(let i=0; i<9; i++) arr[i] = parr[i] ? parr[i].id : 0
			}else{
				arr.fill(0)
				arr[0] = parr[0] ? parr[0].id : 0
				arr[1] = parr[1] ? parr[1].id : 0
				arr[3] = parr[2] ? parr[2].id : 0
				arr[4] = parr[3] ? parr[3].id : 0
			}
			let craft = getCraft(arr)
			if(craft){
				let c = crafts[craft]
				p.inventory.craftingResult = {id:c.id,amount:c.amount}
				p.inventory.craftingName = craft
			}else{
				let shapeless = shapelessCraft(arr)
				if(shapeless){
					let c = crafts[shapeless]
					p.inventory.craftingResult = {id:c.id,amount:c.amount}
					p.inventory.craftingName = shapeless
				}else{
					p.inventory.craftingResult = null
					p.inventory.craftingName = null
				}
			}
		}
		function updateAnvil(){
			let {inventory} = p
			inventory.anvilCost = 0
			if(inventory.anvilInput){
				let {id,amount,durability} = inventory.anvilInput
				inventory.anvilOutput = {id,amount,durability}
				if(inventory.anvilRename !== blockData[id].Name){
					inventory.anvilOutput.customName = inventory.anvilRename
					inventory.anvilCost++
				}
				if(blockData[id].durability && blockData[id].material && inventory.anvilMaterial){
					let materialName = blockData[inventory.anvilMaterial.id].name
					let maxDurability = blockData[id].durability
					if(blockData[id].material === materialName){
						inventory.anvilOutput.durability += maxDurability/4
						if(inventory.anvilOutput.durability > maxDurability) inventory.anvilOutput.durability = maxDurability
						inventory.anvilCost++
					}
				}
			}else inventory.anvilOutput = 0, anvilTextbox.value = ""
			c.send({type:"containerChangeAnvil",rename:inventory.anvilRename,cost:inventory.anvilCost})
		}
		function updateContainer(redoAll){//done at differing intervals
			if(!p.inventory.currentContainer) return
			//below: for containers
			if(p.inventory.currentContainer === "furnace" || p.inventory.currentContainer === "chest" || p.inventory.currentContainer === "dispenser" || p.inventory.currentContainer === "hopper"){
				let containerData = p.inventory.containerData
				let tags = world[containerData.dimension].getTags(containerData.x,containerData.y,containerData.z)
				let block = world[containerData.dimension].getBlock(containerData.x, containerData.y, containerData.z)
				let {currentContainer} = p.inventory
				const bname = blockData[block].name
				if(currentContainer === "furnace" && bname === "furnace" || currentContainer === "chest" && (bname === "chest" || bname === "barrel") || currentContainer === "dispenser" && (bname === "dispenser" || bname === "dropper") || currentContainer === "hopper" && bname === "hopper"){
					if(!blockData[block].hasContents(tags)){
						tags = blockData[block].setContents(containerData.x,containerData.y,containerData.z,world[containerData.dimension])
					}
				}else{
					p.inventory.currentContainer = null
					c.send({type:"closeContainer"})
					return
				}
				if(p.inventory.currentContainer === "furnace"){
					c.send({type:"containerChangeFurnace",burnProgress:tags.burnProgress,progress:tags.progress})
					blockData[blockIds.furnace].update(containerData.x,containerData.y,containerData.z,world[containerData.dimension])
				}
				p.inventory.containerData.data = tags
			}else if(p.inventory.currentContainer === "commandBlock" || p.inventory.currentContainer === "sign"){
				let containerData = p.inventory.containerData
				let tags = world[containerData.dimension].getTags(containerData.x,containerData.y,containerData.z)
				let block = world[containerData.dimension].getBlock(containerData.x, containerData.y, containerData.z)
				let {currentContainer} = p.inventory
				if(currentContainer === "commandBlock" && blockData[block].commandBlock){
					if(!tags || !tags.commandBlock){
						tags = {commandBlock:true,data:"",output:""}
						world[containerData.dimension].setTags(containerData.x, containerData.y, containerData.z,tags)
					}
				}else if(currentContainer === "sign" && blockData[block].sign && tags && tags.sign){
				}else{
					p.inventory.currentContainer = null
					c.send({type:"closeContainer"})
					return
				}
				p.inventory.containerData.data = tags
			}

			let len = p.inventory.slotMapPlace.size
			let prevSlots = p.inventory.prevSlots
			if(redoAll) prevSlots.length = 0
			let changeData, changeIdx
			for(let i=0; i<len; i++){//check for changes
				let slot = getSlot(i)
				if(slot){
					if(redoAll || slot.id !== prevSlots[i] || slot.amount !== prevSlots[i+len] || slot.customName !== prevSlots[i+len*2] || slot.durability !== prevSlots[i+len*3]){
						prevSlots[i] = slot.id
						prevSlots[i+len] = slot.amount
						prevSlots[i+len*2] = slot.customName
						prevSlots[i+len*3] = slot.durability
						if(!changeData) changeData = [], changeIdx = []
						changeData.push(slot), changeIdx.push(i)
					}
				}else if(redoAll || prevSlots[i] !== null){
					prevSlots[i] = null
					if(!changeData) changeData = [], changeIdx = []
					changeData.push(slot), changeIdx.push(i)
				}
			}
			if(changeData) c.send({type:"containerChange",data:changeData,idxs:changeIdx})
		}
	}
	sendAll(msg){
		for(let p of this.players) p.connection.send(msg)
	}
	sendPlayerName(msg, to){
    for(var p of this.players){
      if(p.username === to){
        p.connection.send(msg)
      }
    }
  }
	sendPlayer(msg, to){
    for(var p of this.players){
      if(p.id === to){
        p.connection.send(msg)
      }
    }
  }
	/*requestAllInvs(){
		let promises = []
		for(let p of this.players){
			promises.push(new Promise(resolve => p.connection.onGetInv = resolve))
			p.connection.send({type:"shouldSendInv"})
		}
		return Promise.all(promises)
	}*/

	close(){
		sendAllWorkers({deleteSeed:this.worldSeed})
		for(let p of this.players) p.connection.close()
		clearInterval(this.pos)
		if(this.modContainer){
			this.modContainer.contentWindow.postMessage({close:true})
			this.modContainer.remove()
		}
	}
}
class WorldDimension{
	constructor(world,dimension) {
		this.world = world
		this.dimension = dimension

		//Initialize the world's arrays
		this.chunks = []
		this.timeoutQueue = []
		this.updateQueue = []
		this.structureData = {}//Structure data for temporary use while generating structure
	}
	sendAll(msg){
		for(let p of this.world.players){
			if(p.dimension === this.dimension) p.connection.send(msg)
		}
	}
	sendAllInChunk(msg,x,z){
		for(let p of this.world.players){
			if(p.dimension === this.dimension && maxDist(x,z,round(p.x/16),round(p.z/16)) <= p.loadDistance){
				p.connection.send(msg)
			}
		}
	}
	blockParticles(block,x,y,z,amount, type, dir, remote){
    if(!remote) this.sendAll({
      type:"particles", particleType:"blockParticles",
      x,y,z,amount,dimension:this.dimension,data:{block,thisType:type,dir}
    })
  }
	explode(x,y,z, r, type){
		/*world.setBlock(x,y,z,blockIds.air);
		for(var i=radius; i>0; i--){
			sphereoidAt(x,y,z,i,i,i, blockIds.air)
		}*/
		//ball(x,y,z,r,r,r,0)
		if(!type)this.setBlock(x,y,z, 0)
		else if(type === "original") this.setBlock(x,y,z, this.getOriginalBlock(x,y,z))
		/*let w2 = r * r
		let h2 = w2
		let d2 = w2
		for (let Y = -r; Y < r; Y++) {
			for (let X = -r; X <= r; X++) {
				for (let Z = -r; Z <= r; Z++) {
					let n = X * X / w2 + Y * Y / h2 + Z * Z / d2
					if (n < 1) {
						if(world.getBlock(X + x, Y + y, Z + z) === blockIds.tnt){
							blockData[blockIds.tnt].explode(X+x,Y+y,Z+z, "explosion")
						}
						if(Math.random() > 0.5){
							var time = Math.random()*1000
							if(time < 10){
								world.particles.push(new ExplodeParticle(X + x, Y + y, Z + z))
							}else{
								setTimeout(() => world.particles.push(new ExplodeParticle(X + x, Y + y, Z + z)), time)
							}
						}
						if(!liquid){
							var block = world.getBlock(X+x,Y+y,Z+z)
							if(blockData[block].ongetexploded){
								blockData[block].ongetexploded(x+X,y+Y,z+Z,block,world)
							}
							world.setBlock(X + x, Y + y, Z + z, 0)
						}
					}
				}
			}
		}*/
		//create rays rays coming from the center of the cube to each outer edge
		let destroyed = {}, particles = []
		for(var cx=0; cx<16; cx++){
			for(var cy=0; cy<16; cy++){
				for(var cz=0; cz<16; cz++){
					if(!(cx === 0 || cx === 15 || cy === 0 || cy === 15 || cz === 0 || cz === 15)) continue
					
					var intensity =  (0.7 + rand(0.6)) * r
					var x2 = cx / 16, y2 = cy / 16, z2 = cz / 16
					//step 0.3 blocks each time
					var d = abs(dist3(0,0,0, (x2-0.5)*2*r,(y2-0.5)*2*r,(z2-0.5)*2*r))
					var step = (0.3/d)/2 //how much to go along ray
					for(var i=0; i<1; i+=step){
						var sx = round(lerp(i, x, (x2-0.5)*2*r+x))
						var sy = round(lerp(i, y, (y2-0.5)*2*r+y))
						var sz = round(lerp(i, z, (z2-0.5)*2*r+z))
						intensity -= 0.3 * 0.75
						var block = this.getBlock(sx,sy,sz)
						var isDestroyed = destroyed[sx+","+sy+","+sz]
						//if block isn't air, reduce intensity based on blast resistance
						if(block && !isDestroyed){
							var br = blockData[block].blastResistance || 0
							intensity -= (br + 0.3) * 0.3
							if(intensity > 0) {
								destroyed[sx+","+sy+","+sz] = true
								if(!type){
									if(blockData[block].ongetexploded){
										blockData[block].ongetexploded(sx,sy,sz,block,this)
									}
									this.setBlock(sx, sy, sz, 0)
									if(round(rand(r-1)) === 0){
										this.addItems(sx, sy, sz, 0, 0, 0, block, true)
									}
								}
								if(block === blockIds.tnt){
									blockData[blockIds.tnt].explode(sx,sy,sz, "explosion",this)
								}else if(block === blockIds.untnt){
									blockData[blockIds.untnt].explode(sx,sy,sz, "explosion",this)
								}
							}/*end if(intensity > 0)*/else{
								continue
							}
						}
						if(intensity > 0 && type === "original" && !isDestroyed){
							this.setBlock(sx,sy,sz, this.getOriginalBlock(sx,sy,sz))
						}
						if(intensity > 0 && rand() > 0.995){
							let time = rand()*1000
							particles.push(sx,sy,sz,this.dimension,time)
						}
					}
				}//end for loop
			}
		}
		this.sendAll({type:"particles", particleType:"explosion", data:particles, dimension:this.dimension})
		
		//the calculation below is not from minecraft
		let nearEntities = this.getEntitiesNear(x,y,z,r)
		for(let ent of nearEntities){
			let dist = dist3(x,y,z, ent.x, ent.y, ent.z)
			if(dist <= r){
				let speed = (r-dist)
				let X = ent.x - x
				let Y = ent.y - y
				let Z = ent.z - z
				let velx = X/dist*speed, vely = Y/dist*speed, velz = Z/dist*speed
				/*
				velx = ((Math.sign(X)*r)-X)/5
				vely = ((Math.sign(Y)*r)-Y)/5
				velz = ((Math.sign(Z)*r)-Z)/5*/
				if(ent.damage){
					let damageTook = (r - dist) * 6
					ent.damage(damageTook,velx,vely,velz)
				}else{
					ent.velx += velx
					ent.vely += vely
					ent.velz += velz
				}
			}
		}
		for(let ent of this.world.players){
			if(ent.dimension !== this.dimension || ent.hidden || ent.die) continue
			let dist = dist3(x,y,z, ent.x, ent.y, ent.z)
			if(dist <= r){
				let speed = (r-dist)
				let X = ent.x - x
				let Y = ent.y - y
				let Z = ent.z - z
				let velx = X/dist*speed, vely = Y/dist*speed, velz = Z/dist*speed
				let damageTook = (r - dist) * 6
				ent.damage(damageTook,ent.username+" blew up", false,null, x,y,z, null,velx,vely,velz)
			}
		}
		explodeSound(x,y,z, r, this)
	}
	blockSound(blockID, type, x,y,z, volume){
    let block = blockData[blockID]
		if(typeof volume !== "number") volume = 1
    
    let sound, pitch = 1
    switch(type){
      case "place":
        sound = block.placeSound || block.digSound
        break;
      case "dig":
        sound = block.digSound
        break;
      case "step":
        sound = block.stepSound
        break;
			case "lowStep":
				sound = block.stepSound
				pitch = 0.5
        break;
      case "breaking":
        sound = block.stepSound
				pitch = 0.5
				volume *= 0.5
        break;
      case "land":
        sound = block.landSound || block.digSound
    }
    if(typeof sound === "function") return sound()
    if(Array.isArray(sound)){
      sound = sound[Math.floor(Math.random()*sound.length)]
    }
    if(sound){
      this.playSound(x,y,z,sound, volume, pitch)
    }
  }
	playSound(x,y,z, name, volume = 1, pitch = 1){
		this.sendAll({type:"playSound", data:name, volume, pitch, x,y,z, hasPos: (typeof x === "number")})
	}
	poof(x,y,z,amount, w,h,d, unremote){
		if(!amount) amount = w*h*d*20
    if(unremote) this.sendAll({
      type:"particles",particleType:"poof",
      x,y,z,dimension:this.dimension,amount,data:{w,h,d}
    })
  }
	glint(x,y,z,dimension,remote){
    if(!remote) this.sendAll({
      type:"particles", particleType:"glint",
      x,y,z,dimension:this.dimension
    })
  }
	updateBlock(x, y, z, lazy, noOnupdate, sx,sy,sz) {
		let chunk = this.chunks[x >> 4] && this.chunks[x >> 4][z >> 4]
		if (chunk && chunk.allGenerated) {
			chunk.updateBlock(x & 15, y, z & 15, this, lazy, noOnupdate, sx,sy,sz)
		}
	}
	getChunk(x, z) {
		return this.chunks[x >> 4] && this.chunks[x >> 4][z >> 4]
	}
	getOrNewChunk(x,z){
		const xm = x>>4, zm = z>>4
		if (!this.chunks[xm]) {
			this.chunks[xm] = []
		}
		if (!this.chunks[xm][zm]) {
			return this.chunks[xm][zm] = new Chunk(xm<<4, zm<<4,this)
		}
		return this.chunks[xm][zm]
	}
	getBlock(x, y, z) {
		if (y > maxHeight) {
			return blockIds.air
		} else if (y < minHeight) {
			return blockIds.air
		}
		if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
			return blockIds.air
		}
		return this.chunks[x >> 4][z >> 4].getBlock(x & 15, y, z & 15)
	}
	getOriginalBlock(x, y, z) {
		let chunk = this.getChunk(x,z)
		return chunk ? chunk.getOriginalBlock(x & 15, y, z & 15) : blockIds.air
	}
	setBlock(x, y, z, blockID, lazy, noOnupdate, remote, keepTags) {
		if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
			return false
		}
		if(y < minHeight) return false
		let chunk = this.chunks[x >> 4] && this.chunks[x >> 4][z >> 4]
		
		let xm = x & 15
		let zm = z & 15
		let prev = chunk.getBlock(xm,y,zm)
		if (blockID) {
			let data = blockData[blockID]
			chunk.setBlock(xm, y, zm, blockID, !lazy)
			if (!lazy && chunk.allGenerated && (!data.transparent || data.lightLevel || data.decreaseLight) && chunk.lit) {
				this.updateLight(x, y, z, true, data.lightLevel)
			}
		} else {
			let data = blockData[prev]
			chunk.deleteBlock(xm, y, zm, !lazy)
			if (!lazy && chunk.allGenerated && (!data.transparent || data.lightLevel || data.decreaseLight) && chunk.lit) {
				this.updateLight(x, y, z, false, data.lightLevel)
			}
		}
		
		if (lazy) {
			return
		}
		let prevTags = this.getTags(x,y,z)
		if(!keepTags) this.setTags(x, y, z, undefined, remote)
		for(let i = this.timeoutQueue.length-1; i>=0; i--){
			let timeout = this.timeoutQueue[i]
			if(timeout.x === x && timeout.y === y && timeout.z === z && (timeout.block === undefined || timeout.block === blockID)){
				this.timeoutQueue.splice(i,1)
				break
			}
		}
		
		let nameChanged = blockData[prev].name !== blockData[blockID || 0].name
		if(!noOnupdate && prev && blockData[prev].ondelete && nameChanged){
			blockData[prev].ondelete(x,y,z, prevTags, prev,this)
		}
		if(!noOnupdate && blockID && blockData[blockID].onset && nameChanged){
			blockData[blockID].onset(x,y,z,this)
		}
		
		if(!remote) this.sendAllInChunk({type:"setBlock", data:{x:x, y:y, z:z, block:blockID, dimension:this.dimension, keepTags:keepTags}},x>>4,z>>4)

		//Update the 6 adjacent blocks and 1 changed block
		if (xm && xm !== 15 && zm && zm !== 15) {
			chunk.updateBlock(xm - 1, y, zm, this, lazy, false, x,y,z)
			chunk.updateBlock(xm, y - 1, zm, this, lazy, false, x,y,z)
			chunk.updateBlock(xm + 1, y, zm, this, lazy, false, x,y,z)
			chunk.updateBlock(xm, y + 1, zm, this, lazy, false, x,y,z)
			chunk.updateBlock(xm, y, zm - 1, this, lazy, false, x,y,z)
			chunk.updateBlock(xm, y, zm + 1, this, lazy, false, x,y,z)
		}
		else {
			this.updateBlock(x - 1, y, z, lazy, false, x,y,z)
			this.updateBlock(x + 1, y, z, lazy, false, x,y,z)
			this.updateBlock(x, y - 1, z, lazy, false, x,y,z)
			this.updateBlock(x, y + 1, z, lazy, false, x,y,z)
			this.updateBlock(x, y, z - 1, lazy, false, x,y,z)
			this.updateBlock(x, y, z + 1, lazy, false, x,y,z)
		}

		chunk.updateBlock(xm, y, zm, this, lazy, noOnupdate, x,y,z)

		// Update the corner chunks so shadows in adjacent chunks update correctly
		if (xm | zm === 0) { this.updateBlock(x - 1, y, z - 1, lazy, true,x,y,z); }
		if (xm === 15 && zm === 0) { this.updateBlock(x + 1, y, z - 1, lazy, true,x,y,z); }
		if (xm === 0 && zm === 15) { this.updateBlock(x - 1, y, z + 1, lazy, true,x,y,z); }
		if (xm & zm === 15) { this.updateBlock(x + 1, y, z + 1, lazy, true,x,y,z); }
	}
	tagUpdate(x,y,z,t){
		var block = this.getBlock(x,y,z)
		if(block && blockData[block].ontagsupdate) blockData[block].ontagsupdate(x,y,z,t,this)
	}
	tagsChanged(x,y,z, t, remote, lazy){
		/*var str = x.toString(36)+","+y.toString(36)+","+z.toString(36)
		var editedTags = dimension === "nether" ? this.netherEditedTags : (dimension === "end" ? this.endEditedTags : this.editedTags)
		if(t){
			if(!editedTags.includes(str)) editedTags.push(str)
		}else{
			if(editedTags.includes(str)){
				editedTags.splice(editedTags.indexOf(str),1)
			}
		}*/
		if(!lazy){
			this.tagUpdate(x,y,z,t)
			this.tagUpdate(x-1,y,z,t)
			this.tagUpdate(x+1,y,z,t)
			this.tagUpdate(x,y-1,z,t)
			this.tagUpdate(x,y+1,z,t)
			this.tagUpdate(x,y,z-1,t)
			this.tagUpdate(x,y,z+1,t)
		}
		if(!remote){
			this.sendAllInChunk({type:"setTags", x, y, z, data:t, dimension:this.dimension, lazy},x>>4,z>>4)
		}
	}
	getTags(x,y,z){
		if (y > maxHeight) {
			return
		} else if (y < minHeight) {
			return
		}
		if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
			return
		}
		return this.chunks[x >> 4][z >> 4].getTags(x & 15, y, z & 15)
	}
	getTagByName(x,y,z,n){
		if (y > maxHeight) {
			return
		} else if (y < minHeight) {
			return
		}
		return this.getChunk(x, z).getTagByName(x & 15, y, z & 15, n)
	}
	setTags(x,y,z,data, remote, lazy){
		if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
			return
		}
		if(y < minHeight) return
		let chunk = this.chunks[x >> 4] && this.chunks[x >> 4][z >> 4]
		
		let xm = x & 15
		let zm = z & 15
		chunk.setTags(xm, y, zm, data)
		this.tagsChanged(x,y,z,data, remote, lazy)
	}
	setTagByName(x,y,z,n,data, remote, lazy){
		if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
			return
		}
		if(y < minHeight) return
		let chunk = this.chunks[x >> 4] && this.chunks[x >> 4][z >> 4]
		
		let xm = x & 15
		let zm = z & 15
		var t = chunk.setTagByName(xm, y, zm, n,data)
		this.tagsChanged(x,y,z,t, remote, lazy)
	}
	updateTags(x,y,z,lazy){
		var t = this.getTags(x,y,z)
		this.tagsChanged(x,y,z,t,false,lazy)
	}
	getLight(x, y, z, blockLight = 0) {
		if(y < minHeight) return 0
		let chunk = this.chunks[x >> 4] && this.chunks[x >> 4][z >> 4]
		if(chunk){
			return chunk.getLight(x & 15, y, z & 15, blockLight)
		}
		return !(blockLight&1) * 15
	}
	setLight(x, y, z, level, block) {
		let chunk = this.chunks[x >> 4] && this.chunks[x >> 4][z >> 4]
		if (chunk) {
			return chunk.setLight(x & 15, y, z & 15, level, block)
		}
	}
	updateLight(x, y, z, place, blockLight = 0) {
		let chunk = this.getChunk(x, z)
		let cx = x & 15
		let cz = z & 15
		let center = chunk.getLight(cx, y, cz, 0)
		let centerExposed = chunk.getLight(cx, y, cz, 2)
		let blight = chunk.getLight(cx, y, cz, 1)
		let up = this.getLight(x, y+1, z, 0)
		let upExposed = this.getLight(x, y+1, z, 2)
		let down = this.getLight(x, y-1, z, 0)
		let north = this.getLight(x, y, z+1, 0)
		let south = this.getLight(x, y, z-1, 0)
		let east = this.getLight(x+1, y, z, 0)
		let west = this.getLight(x-1, y, z, 0)

		let spread = []
		for (let i = 0; i <= 15; i++) spread[i] = []
		let blspread = [] // block light spread
		if (!place) { // Block was removed; increase light levels
			if (upExposed) { // Exposed to sky light
				let light = upExposed
				for (let i = y; i >= minHeight; i--) {
					let block = blockData[chunk.getBlock(cx, i, cz)]
					if (block.transparent) {
						if(block.decreaseLight){
							light = max(light - block.decreaseLight,0)
						}
						chunk.setLight(cx, i, cz, light, 2)
						if(light > chunk.getLight(cx, i, cz, 0)) chunk.setLight(cx, i, cz, light, 0)
						spread[light].push(x, i, z)
					} else {
						break
					}
				}
				for (let i = 0; i < spread.length; i++){
					if(spread[i].length) chunk.spreadLight(spread[i], i-1, true)
				}
			} else {
				center = max(up, down, north, south, east, west)
				if (center > 0) center -= 1
				this.setLight(x, y, z, center, 0)
				if (center > 1) {
					spread[center].push(x, y, z)
					chunk.spreadLight(spread[center], center - 1, true)
				}
			}

			// Block light levels
			if (!blockLight || blockLight < blight) {
				up = this.getLight(x, y+1, z, 1)
				down = this.getLight(x, y-1, z, 1)
				north = this.getLight(x, y, z+1, 1)
				south = this.getLight(x, y, z-1, 1)
				east = this.getLight(x+1, y, z, 1)
				west = this.getLight(x-1, y, z, 1)
				blight = max(up, down, north, south, east, west)
				if (blight > 0) blight -= 1
				this.setLight(x, y, z, blight, 1)
				if (blight > 1) {
					blspread.push(x, y, z)
					chunk.spreadLight(blspread, blight - 1, true, 1)
				}
			}
			if (blockLight) { // Light block was removed
				this.setLight(x, y, z, 0, 1)
				blspread.push(x, y, z)
				let respread = []
				for (let i = 0; i <= 15/*blockLight + 1*/; i++) respread[i] = []
				chunk.unSpreadLight(blspread, blockLight - 1, respread, 1)
				chunk.reSpreadLight(respread, 1)
			}
		}
		else if (place && (center !== 0 || blight !== 0)) { // Block was placed; decrease light levels
			let respread = []
			for (let i = 0; i <= 15/*center + 1*/; i++) respread[i] = []
			chunk.setLight(cx, y, cz, 0, 0)
			chunk.setLight(cx, y, cz, 0, 1)
			chunk.setLight(cx, y, cz, 0, 2)
			spread[center].push(x, y, z)

			// Sky light
			if(upExposed){
				let light = upExposed
				for (let i = y; i >= minHeight; i--) {
					let block = blockData[chunk.getBlock(cx, i, cz)]
					if (block.transparent) {
						if(block.decreaseLight){
							light = max(light - block.decreaseLight,0)
						}
						chunk.setLight(cx, i, cz, light, 2)
						let prevLight = chunk.getLight(cx, i, cz, 0)
						chunk.setLight(cx, i, cz, light, 0)
						spread[prevLight].push(x, i, z)
					} else if(i === y) {
						light = 0
					} else {
						break
					}
				}
			}
			for (let i = 0; i <= 15; i++){
				if(spread[i].length) chunk.unSpreadLight(spread[i], i - 1, respread)
			}
			//chunk.unSpreadLight(spread[0], 0, respread)
			chunk.reSpreadLight(respread)

			// Block light
			if (blight) {
				respread.length = 0
				for (let i = 0; i <= 15/*blight + 1*/; i++) respread[i] = []
				blspread.push(x, y, z)
				chunk.unSpreadLight(blspread, blight - 1, respread, 1)
				chunk.reSpreadLight(respread, 1)
			}
			if (blockLight) { // Light block was placed
				up = this.getLight(x, y+1, z, 1)
				down = this.getLight(x, y-1, z, 1)
				north = this.getLight(x, y, z+1, 1)
				south = this.getLight(x, y, z-1, 1)
				east = this.getLight(x+1, y, z, 1)
				west = this.getLight(x-1, y, z, 1)
				blight = max(max(up, down, north, south, east, west)-1, blockLight)
				this.setLight(x, y, z, blight, 1)
				this.setLight(x, y, z, blockLight, 3)
				blspread.length = 0
				blspread.push(x, y, z)
				chunk.spreadLight(blspread, blight - 1, true, 1)
			}
		}
	}
	spawnBlock(x, y, z, blockID, force) {
		//Sets a block anywhere without causing block updates around it. Only to be used in world gen.
		
		if(blockData[blockID].crossShape) blockID |= CROSS
		if(blockData[blockID].tallcrossShape) blockID |= TALLCROSS
		if(blockData[blockID].cactus) blockID |= CACTUS
		if(blockData[blockID].randomRotateOnSpawn){
			switch(round(hash3(x,y,z)*3)){
				case 0:
					blockID |= NORTH
					break
				case 1:
					blockID |= WEST
					break
				case 2:
					blockID |= SOUTH
					break
				case 3:
					blockID |= EAST
					break
			}
		}
		
		let chunkX = x >> 4
		let chunkZ = z >> 4
		if (!this.chunks[chunkX]) {
			this.chunks[chunkX] = []
		}
		let chunk = this.getOrNewChunk(x,z)
		let solid = blockData[chunk.getBlock(x & 15, y, z & 15)].solid
		if (chunk.allGenerated) {
			//Only used if spawning a block post-gen
			if(!solid) this.setBlock(x, y, z, blockID)
		} else if (force || !solid) {
			chunk.setBlock(x & 15, y, z & 15, blockID)
		}
	}
	getBiome(x,y,z){
		if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
			return
		}
		let X = x & 15
		let Z = z & 15
		let caveMinY = this.chunks[x >> 4][z >> 4].caveY[Z * 16 + X]
		let caveMaxY = this.chunks[x >> 4][z >> 4].caveY[Z * 16 + X + 256]
		return biomes[y < caveMaxY && y > caveMinY ? (this.chunks[x >> 4][z >> 4].caveBiomes[Z * 16 + X]) : (this.chunks[x >> 4][z >> 4].biomes[Z * 16 + X])]
	}
	addEntity(ent, remote){
		if(!ent.id) ent.id = generateID()
		ent.world = this
		ent.dimension = ent.chunkDimension = this.dimension, ent.world = this
		if(!remote && !ent.remote){
			//host controls entities
			this.sendEntityPos(ent)
		}
		this.world.entities.push(ent)
		//if(ent.alwaysRender) this.alwaysRenderEntities.push(ent)
		let chunk = this.getOrNewChunk(ent.chunkX<<4,ent.chunkZ<<4)
		chunk.entities.set(ent.id, ent)
	}
	deleteEntity(id, remote, i){
		i = (i || i===0) ? i : this.world.getEntity(id)
		let ent = this.world.entities[i]
		if(!ent || remote && ent.noRemoteDelete) return
		id = ent.id
		if(!remote){
			this.sendAllInChunk({type:"entityDelete", id}, ent.chunkX,ent.chunkZ)
		}
		if(i || i===0) this.world.entities.splice(i, 1)
		/*if(ent.alwaysRender){
			let i = this.alwaysRenderEntities.indexOf(ent)
			this.alwaysRenderEntities.splice(i,1)
		}*/
		const {chunkX, chunkZ} = ent
		let chunk = this.getChunk(chunkX<<4,chunkZ<<4)
		if(chunk) delete chunk.entities.delete(id)
	}
	sendEntityPos(ent){
		this.sendAllInChunk({type:"entityPos", data:this.world.getEntPos(ent,performance.now()).array}, ent.chunkX,ent.chunkZ)
	}
	
	getEntities(p){
		let x = p.x >> 4
		let z = p.z >> 4
		let {loadDistance} = p
		loadDistance--
		//if(!this.entities.length) return this.entities //its an empty array, so no problemslet minChunkX = x - d >> 4
		let minChunkX = x - loadDistance
		let maxChunkX = x + loadDistance
		let minChunkZ = z - loadDistance
		let maxChunkZ = z + loadDistance
		let arr = []
		for (x = minChunkX; x <= maxChunkX; x++) {
			for (z = minChunkZ; z <= maxChunkZ; z++) {
				if (this.chunks[x] && this.chunks[x][z]) {
					let chunk = this.chunks[x][z]
					for(let [i,ent] of chunk.entities){
						let now = performance.now()
						//if(ent.remote) return
						arr.push(this.world.getEntPos(ent,now).array)
					}
				}
			}
		}
		return arr
	}
	getEntitiesNear(x,y,z,d, ret = []){
		let minChunkX = x - d >> 4
		let maxChunkX = x + d >> 4
		let minChunkY = y - d >> 4
		let maxChunkY = y + d >> 4
		let minChunkZ = z - d >> 4
		let maxChunkZ = z + d >> 4
		let section = null
		ret.length = 0
		let i = 0
		for (x = minChunkX; x <= maxChunkX; x++) {
			for (z = minChunkZ; z <= maxChunkZ; z++) {
				if (this.chunks[x] && this.chunks[x][z]) {
					let ents = this.chunks[x][z].entities
					for(let [i,ent] of ents){
						ret.push(ent)
					}
				}
			}
		}
		return ret
	}
	addItems(x,y,z,vx,vy,vz,block,autoSetVel,amount = 1,durability,customName,from){
		if(!block) return
		var data = blockData[block]
		if(!data) throw new Error("no block: "+block)
		while(amount){
			var a = min(amount,data.stackSize)
			amount -= a
			this.addEntity(new entities[entityIds.Item](x, y, z, vx, vy, vz, block, autoSetVel, a,durability,customName,from))
		}
	}
	
	getRedstoneConnectedTo(x,y,z, level){
		let spreaded = []
		let spreadAt = []
		spreadAt.push(x,y,z,0)
		let tempblock
		while(spreadAt.length){
			let x = spreadAt[0]
			let y = spreadAt[1]
			let z = spreadAt[2]
			let i = spreadAt[3]
			if(i < level) {
				if(!xyArrayHas(spreaded,spreadAt,x+1,y,z) && blockData[this.getBlock(x+1,y,z)].carryRedstone) spreadAt.push(x+1,y,z,i+1)
				if(!xyArrayHas(spreaded,spreadAt,x-1,y,z) && blockData[this.getBlock(x-1,y,z)].carryRedstone) spreadAt.push(x-1,y,z,i+1)
				if(!xyArrayHas(spreaded,spreadAt,x,y,z+1) && blockData[this.getBlock(x,y,z+1)].carryRedstone) spreadAt.push(x,y,z+1,i+1)
				if(!xyArrayHas(spreaded,spreadAt,x,y,z-1) && blockData[this.getBlock(x,y,z-1)].carryRedstone) spreadAt.push(x,y,z-1,i+1)
				if(!xyArrayHas(spreaded,spreadAt,x,y+1,z) && blockData[this.getBlock(x,y+1,z)].carryRedstone) spreadAt.push(x,y+1,z,i+1)
				if(!xyArrayHas(spreaded,spreadAt,x,y-1,z) && blockData[this.getBlock(x,y-1,z)].carryRedstone) spreadAt.push(x,y-1,z,i+1)
				
				let tags = this.getTags(x,y,z), block = this.getBlock(x,y,z)
				if(blockData[block].name === "redstoneDust"){
					if(getTagBits(tags,"westUp",block) && !xyArrayHas(spreaded,spreadAt,x+1,y+1,z)) spreadAt.push(x+1,y+1,z,i+1)
					if(getTagBits(tags,"eastUp",block) && !xyArrayHas(spreaded,spreadAt,x-1,y+1,z)) spreadAt.push(x-1,y+1,z,i+1)
					if(getTagBits(tags,"northUp",block) && !xyArrayHas(spreaded,spreadAt,x,y+1,z+1)) spreadAt.push(x,y+1,z+1,i+1)
					if(getTagBits(tags,"southUp",block) && !xyArrayHas(spreaded,spreadAt,x,y+1,z-1)) spreadAt.push(x,y+1,z-1,i+1)
					
					if(getTagBits(tags,"westDown",block) && !xyArrayHas(spreaded,spreadAt,x+1,y-1,z)) spreadAt.push(x+1,y-1,z,i+1)
					if(getTagBits(tags,"eastDown",block) && !xyArrayHas(spreaded,spreadAt,x-1,y-1,z)) spreadAt.push(x-1,y-1,z,i+1)
					if(getTagBits(tags,"northDown",block) && !xyArrayHas(spreaded,spreadAt,x,y-1,z+1)) spreadAt.push(x,y-1,z+1,i+1)
					if(getTagBits(tags,"southDown",block) && !xyArrayHas(spreaded,spreadAt,x,y-1,z-1)) spreadAt.push(x,y-1,z-1,i+1)
				}
				if(blockData[block].rail){
					tempblock = this.getBlock(x+1,y+1,z); if(!xyArrayHas(spreaded,spreadAt,x+1,y+1,z) && blockData[tempblock].rail && blockData[tempblock].carryRedstone) spreadAt.push(x+1,y+1,z,i+1)
					tempblock = this.getBlock(x-1,y+1,z); if(!xyArrayHas(spreaded,spreadAt,x-1,y+1,z) && blockData[tempblock].rail && blockData[tempblock].carryRedstone) spreadAt.push(x-1,y+1,z,i+1)
					tempblock = this.getBlock(x,y+1,z+1); if(!xyArrayHas(spreaded,spreadAt,x,y+1,z+1) && blockData[tempblock].rail && blockData[tempblock].carryRedstone) spreadAt.push(x,y+1,z+1,i+1)
					tempblock = this.getBlock(x,y+1,z-1); if(!xyArrayHas(spreaded,spreadAt,x,y+1,z-1) && blockData[tempblock].rail && blockData[tempblock].carryRedstone) spreadAt.push(x,y+1,z-1,i+1)

					tempblock = this.getBlock(x+1,y-1,z); if(!xyArrayHas(spreaded,spreadAt,x+1,y-1,z) && blockData[tempblock].rail && blockData[tempblock].carryRedstone) spreadAt.push(x+1,y-1,z,i+1)
					tempblock = this.getBlock(x-1,y-1,z); if(!xyArrayHas(spreaded,spreadAt,x-1,y-1,z) && blockData[tempblock].rail && blockData[tempblock].carryRedstone) spreadAt.push(x-1,y-1,z,i+1)
					tempblock = this.getBlock(x,y-1,z+1); if(!xyArrayHas(spreaded,spreadAt,x,y-1,z+1) && blockData[tempblock].rail && blockData[tempblock].carryRedstone) spreadAt.push(x,y-1,z+1,i+1)
					tempblock = this.getBlock(x,y-1,z-1); if(!xyArrayHas(spreaded,spreadAt,x,y-1,z-1) && blockData[tempblock].rail && blockData[tempblock].carryRedstone) spreadAt.push(x,y-1,z-1,i+1)
				}
				spreaded.push(x,y,z,i)
			}
			spreadAt.splice(0,4)
		}

		return spreaded
	}
	spreadPower(x,y,z, level){
		if(!level) return
		var spread = this.getRedstoneConnectedTo(x,y,z,level)
		for(var i=0; i<spread.length; i+=4){
			var bx = spread[i]
			var by = spread[i+1]
			var bz = spread[i+2]
			if(bx === x && by === y && bz === z) continue
			var l = this.getRedstoneWirePower(bx,by,bz)
			if(l !== this.getPower(bx,by,bz)) this.setPower(bx,by,bz, l)
		}
	}
	unspreadPower(x,y,z, level, includeSource){
		if(!level) return
		var spread = this.getRedstoneConnectedTo(x,y,z,level)
		var toUpdate = []
		for(var n=0; n<level; n++){
			for(var i=0; i<spread.length; i+=4){
				var bx = spread[i]
				var by = spread[i+1]
				var bz = spread[i+2]
				if(!includeSource && bx === x && by === y && bz === z) continue
				var l = this.getRedstoneWirePower(bx,by,bz)
				if(l !== this.getPower(bx,by,bz)) this.setPower(bx,by,bz, l, true), toUpdate[i] = true
			}
		}
		for(var i=0; i<toUpdate.length; i+=4){
			if(toUpdate[i]){
				var x = spread[i], y = spread[i+1], z = spread[i+2]
				this.powerChangeUpdate(x,y,z, x,y,z)
				this.powerChangeUpdate(x+1,y,z, x,y,z)
				this.powerChangeUpdate(x-1,y,z, x,y,z)
				this.powerChangeUpdate(x,y,z+1, x,y,z)
				this.powerChangeUpdate(x,y,z-1, x,y,z)
				this.powerChangeUpdate(x,y+1,z, x,y,z)
				this.powerChangeUpdate(x,y-1,z, x,y,z)
				this.updateTags(x,y,z,true)
			}
		}
		/*this.powerChangeUpdate(x+1,y,z)
		this.powerChangeUpdate(x-1,y,z)
		this.powerChangeUpdate(x,y,z+1)
		this.powerChangeUpdate(x,y,z-1)*/
	}
	getPowerForWire(x,y,z,blue=0,rail=false){
		let block = this.getBlock(x,y,z)
		if(blockData[block].name === "redstoneDust" && blue !== (block & FLIP)) return 0
		if(rail && !blockData[block].rail) return 0
		return this.getPower(x,y,z)
	}
	getRedstoneWirePower(x,y,z){
		let tags = this.getTags(x,y,z), block = this.getBlock(x,y,z), blue = block & FLIP
		
		let right = this.getPowerForWire(x+1,y,z,blue)
		let left = this.getPowerForWire(x-1,y,z,blue)
		let down = this.getPowerForWire(x,y,z+1,blue)
		let up = this.getPowerForWire(x,y,z-1,blue)
		let top = this.getPowerForWire(x,y+1,z,blue)
		let bottom = this.getPowerForWire(x,y-1,z,blue)
		let westUp = 0, eastUp = 0, northUp = 0, southUp = 0, westDown = 0, eastDown = 0, northDown = 0, southDown = 0
		if(tags && blockData[block].name === "redstoneDust"){
			westUp = getTagBits(tags,"westUp",block) ? this.getPowerForWire(x+1,y+1,z,blue) : 0
			eastUp = getTagBits(tags,"eastUp",block) ? this.getPowerForWire(x-1,y+1,z,blue) : 0
			northUp = getTagBits(tags,"northUp",block) ? this.getPowerForWire(x,y+1,z+1,blue) : 0
			southUp = getTagBits(tags,"southUp",block) ? this.getPowerForWire(x,y+1,z-1,blue) : 0
			westDown = getTagBits(tags,"westDown",block) ? this.getPowerForWire(x+1,y-1,z,blue) : 0
			eastDown = getTagBits(tags,"eastDown",block) ? this.getPowerForWire(x-1,y-1,z,blue) : 0
			northDown = getTagBits(tags,"northDown",block) ? this.getPowerForWire(x,y-1,z+1,blue) : 0
			southDown = getTagBits(tags,"southDown",block) ? this.getPowerForWire(x,y-1,z-1,blue) : 0
		}
		if(blockData[block].rail){
			westUp = this.getPowerForWire(x+1,y+1,z,0,true)
			eastUp = this.getPowerForWire(x-1,y+1,z,0,true)
			northUp = this.getPowerForWire(x,y+1,z+1,0,true)
			southUp = this.getPowerForWire(x,y+1,z-1,0,true)
			westDown = this.getPowerForWire(x+1,y-1,z,0,true)
			eastDown = this.getPowerForWire(x-1,y-1,z,0,true)
			northDown = this.getPowerForWire(x,y-1,z+1,0,true)
			southDown = this.getPowerForWire(x,y-1,z-1,0,true)
		}
		let level = max(right,left,down,up, top,bottom, northUp,southUp,eastUp,westUp, northDown,southDown,eastDown,westDown,this.redstoneComponentPowering(x,y,z)+1) - 1
		if(this.getSurroundingBlockPower(x,y,z) === "strong"){
			level = 15
		}
		return level < 0 ? 0 : level
	}
	repeaterIsPowering(x,y,z,rx,ry,rz){
		var block = this.getBlock(rx,ry,rz)
		if(block && (blockData[block].name === "repeater" || blockData[block].logicGate || blockData[block].name === "comparator")){
			return blockData[block].canHavePower(rx,ry,rz,x,y,z,this)
		}
		return 0
	}
	observerIsPowering(x,y,z,rx,ry,rz){
		var block = this.getBlock(rx,ry,rz)
		if(block && blockData[block].name === "observer"){
			return blockData[block].canHavePower(rx,ry,rz,x,y,z,this)
		}
		return 0
	}
	redstoneComponentPowering(x,y,z){
		return max(
			this.repeaterIsPowering(x,y,z,x+1,y,z),
			this.repeaterIsPowering(x,y,z,x-1,y,z),
			this.repeaterIsPowering(x,y,z,x,y,z+1),
			this.repeaterIsPowering(x,y,z,x,y,z-1),

			this.observerIsPowering(x,y,z,x+1,y,z),
			this.observerIsPowering(x,y,z,x-1,y,z),
			this.observerIsPowering(x,y,z,x,y+1,z),
			this.observerIsPowering(x,y,z,x,y-1,z),
			this.observerIsPowering(x,y,z,x,y,z+1),
			this.observerIsPowering(x,y,z,x,y,z-1)
		)
	}
	getRedstonePower(x,y,z){
		var right = this.getPower(x+1,y,z)
		var left = this.getPower(x-1,y,z)
		var down = this.getPower(x,y,z+1)
		var up = this.getPower(x,y,z-1)
		var top = this.getPower(x,y+1,z)
		var bottom = this.getPower(x,y-1,z)
		var level = max(right,left,down,up,top,bottom, this.redstoneComponentPowering(x,y,z))
		return level
	}
	getRepeaterPower(x,y,z,fx,fy,fz){
		var level = max(this.getPower(fx,fy,fz), this.repeaterIsPowering(x,y,z,fx,fy,fz), this.observerIsPowering(x,y,z,fx,fy,fz))
		return level
	}
	getPower(x,y,z){
		return this.getTagByName(x,y,z,"power") || 0
	}
	setPower(x,y,z, level, lazy){
		var block = this.getBlock(x,y,z)
		if(block && blockData[block].noSetPower) return
		let tagBits = blockData[block].tagBits
		if(tagBits){
			this.setTagByName(x,y,z,"power",level,lazy,true)
		}else{
			var tags = this.getTags(x,y,z) || {}
			if(level) tags.power = level
			else delete tags.power
			this.setTags(x,y,z,tags,false,true)
		}
		this.updateBlock(x,y,z)
		
		if(lazy) return //don't update blocks if lazy
		
		this.powerChangeUpdate(x,y,z, x,y,z)
		this.powerChangeUpdate(x+1,y,z, x,y,z)
		this.powerChangeUpdate(x-1,y,z, x,y,z)
		this.powerChangeUpdate(x,y,z+1, x,y,z)
		this.powerChangeUpdate(x,y,z-1, x,y,z)
		this.powerChangeUpdate(x,y+1,z, x,y,z)
		this.powerChangeUpdate(x,y-1,z, x,y,z)
	}
	blockPowerNames = {top:"blockPowerTop",bottom:"blockPowerBottom",north:"blockPowerNorth",south:"blockPowerSouth",east:"blockPowerEast",west:"blockPowerWest"}
	setBlockPower(x,y,z, type, fromDir){
		var block = this.getBlock(x,y,z)
		if(block && blockData[block].noSetPower) return
		if(type !== null && type !== "weak" && type !== "strong") {type = null; console.error("Oh no! It can only be strong or weak or null. But it was",type)}
		let tagBits = blockData[block].tagBits
		type = !type ? 0 : (type === "strong" ? 2 : 1)
		if(tagBits){
			this.setTagByName(x,y,z,this.blockPowerNames[fromDir],type,false)
		}else{
			var tags = this.getTags(x,y,z) || {}
			if(type){
				if(!tags.blockPower) tags.blockPower = {}
				tags.blockPower[fromDir] = type
			}else if(tags.blockPower){
				delete tags.blockPower[fromDir]
				if(!tags.blockPower.top && !tags.blockPower.bottom && !tags.blockPower.north && !tags.blockPower.south && !tags.blockPower.east && !tags.blockPower.west) delete tags.blockPower
			}
			this.setTags(x,y,z,tags)
		}
		
		this.powerChangeUpdate(x,y,z, x,y,z, true)
		if(fromDir !== "west") this.powerChangeUpdate(x+1,y,z, x,y,z, true)
		if(fromDir !== "east") this.powerChangeUpdate(x-1,y,z, x,y,z, true)
		if(fromDir !== "north") this.powerChangeUpdate(x,y,z+1, x,y,z, true)
		if(fromDir !== "south") this.powerChangeUpdate(x,y,z-1, x,y,z, true)
		if(fromDir !== "top") this.powerChangeUpdate(x,y+1,z, x,y,z, true)
		if(fromDir !== "bottom") this.powerChangeUpdate(x,y-1,z, x,y,z, true)
	}
	getBlockPower(x,y,z, dir){
		var tags = this.getTags(x,y,z)
		if(!tags) return null
		let block = this.getBlock(x,y,z)
		let tagBits = blockData[block].tagBits
		let power
		if(tagBits){
			if(dir){
				power = this.getTagByName(x,y,z,this.blockPowerNames[dir])
			}else{
				power = max(
					this.getTagByName(x,y,z,this.blockPowerNames["top"]),
					this.getTagByName(x,y,z,this.blockPowerNames["bottom"]),
					this.getTagByName(x,y,z,this.blockPowerNames["north"]),
					this.getTagByName(x,y,z,this.blockPowerNames["south"]),
					this.getTagByName(x,y,z,this.blockPowerNames["east"]),
					this.getTagByName(x,y,z,this.blockPowerNames["west"]),
				)
			}
		}else{
			var blockPower = tags.blockPower
			if(!blockPower) return null
			
			if(dir){
				power = blockPower[dir]
			}else{
				power = max(blockPower.top, blockPower.bottom, blockPower.north, blockPower.south, blockPower.east, blockPower.west)
			}
		}
		return !power ? null : (power === 2 ? "strong" : "weak")
	}
	getSurroundingBlockPower(x,y,z){
		var north = this.getBlockPower(x,y,z-1)
		var south = this.getBlockPower(x,y,z+1)
		var east = this.getBlockPower(x-1,y,z)
		var west = this.getBlockPower(x+1,y,z)
		var top = this.getBlockPower(x,y+1,z)
		var bottom = this.getBlockPower(x,y-1,z)
		if(top === "strong" || bottom === "strong" || north === "strong" || south === "strong" || east === "strong" || west === "strong"){
			return "strong"
		}else if(top === "weak" || bottom === "weak" || north === "weak" || south === "weak" || east === "weak" || west === "weak"){
			return "weak"
		}
		return null
	}
	powerChangeUpdate(x,y,z,sx,sy,sz, blockPowerChanged){
		var block = this.getBlock(x,y,z)
		if(block && blockData[block].onpowerupdate){
			blockData[block].onpowerupdate(x,y,z,sx,sy,sz, blockPowerChanged,this)
		}
	}
	getBlockRotation(block){
		switch(block&ROTATION){
			case NORTH:
				return 0
			case EAST:
				return 1
			case SOUTH:
				return 2
			case WEST:
				return 3
		}
	}
	getRotationBlock(rot){
		switch(rot){
			case 0:
				return NORTH
			case 1:
				return EAST
			case 2:
				return SOUTH
			case 3:
				return WEST
		}
	}
	canStairConnect(sourceBlock,otherBlock,isBack){
		if((sourceBlock&FLIP) !== (otherBlock&FLIP)) return
		let sourceRot = this.getBlockRotation(sourceBlock)
		let otherRot = this.getBlockRotation(otherBlock)
		let rotDiff = mod(sourceRot-otherRot,4)
		if((otherBlock&isState) === STAIR){
			if(rotDiff === 1) return 1
			else if(rotDiff === 3) return -1
		}else if((otherBlock&isState) === CORNERSTAIRIN){
			if(rotDiff === 0 && isBack || rotDiff === 1 && !isBack) return 1
			else if(rotDiff === 3 && isBack || rotDiff === 2 && !isBack) return -1
		}else if((otherBlock&isState) === CORNERSTAIROUT){
			if(rotDiff === 1 && isBack || rotDiff === 0 && !isBack) return 1
			else if(rotDiff === 2 && isBack || rotDiff === 3 && !isBack) return -1
		}
	}
	setTimeout(func,time,x,y,z,block){
		let exist
		if(x || x === 0) for(let i = this.timeoutQueue.length-1; i>=0; i--){
			let timeout = this.timeoutQueue[i]
			if(timeout.x === x && timeout.y === y && timeout.z === z){
				exist = timeout
				break
			}
		}
		if(exist){
			exist.func = func
			exist.time = performance.now() + time
			exist.x = x, exist.y = y, exist.z = z
		}else this.timeoutQueue.push({
			func,
			time:performance.now() + time,
			x,y,z
		})
	}
	doBlockUpdate(x,y,z,sx,sy,sz){
		let block = this.getBlock(x,y,z)
		if(blockData[block].onupdate) blockData[block].onupdate(x,y,z,block,this,sx,sy,sz)
		else if((block & isState) === STAIR && blockData[block].shape.varients.includes(shapes.stair)){//stair corner update
			let front, back //front is lower side
			switch(block&ROTATION){
				case NORTH:
					front = this.getBlock(x,y,z-1)
					back = this.getBlock(x,y,z+1)
					break
				case SOUTH:
					front = this.getBlock(x,y,z+1)
					back = this.getBlock(x,y,z-1)
					break
				case EAST:
					front = this.getBlock(x-1,y,z)
					back = this.getBlock(x+1,y,z)
					break
				case WEST:
					front = this.getBlock(x+1,y,z)
					back = this.getBlock(x-1,y,z)
					break
			}
			let connectBack = this.canStairConnect(block,back,true)
			let connectFront = this.canStairConnect(block,front,false)
			if(connectBack || connectFront) this.setTimeout(() => {
				if(connectBack === -1 || connectFront === -1) block = block&(~ROTATION) | this.getRotationBlock(mod(this.getBlockRotation(block)+1,4))
				if(connectBack) this.setBlock(x,y,z,(block&(~isState))|CORNERSTAIROUT)
				else if(connectFront) this.setBlock(x,y,z,(block&(~isState))|CORNERSTAIRIN)
			},tickTime)
		}
	}
	getTop(x,z){
		let chunk = this.getChunk(x,z)
		return chunk && chunk.tops[(z&15) * 16 + (x&15)] || 0
	}
	getSolidTop(x,z){
		let chunk = this.getChunk(x,z)
		return chunk && chunk.solidTops[(z&15) * 16 + (x&15)] || 0
	}
}
win.ServerWorld = World

initShapes()
initBlockData()
win.initServerBlockData = function(){
	initBlockDataShapes()
}
function initServerEverything(logInitialized){
	sendAllWorkers({blockIds:generateBlockIds,biomeIds,blockStates:{CROSS,LAYER1,LAYER2,LAYER3,LAYER4,LAYER5,LAYER6,LAYER7,LAYER8,isCube}})
}
win.initServerEverything = initServerEverything
}

function webWorkerCode(){
"use strict"
let parentAndStuff, isNode = false
if(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope){
	parentAndStuff = self//webworker
}else{
	parentAndStuff = require("node:worker_threads").parentPort//nodejs worker threads
	isNode = true
}

// implementation of xxHash
const {
	seedHash,
	hash, hash3
} = (() => {
	// closure around mutable `seed`; updated via calls to `seedHash`

	let seed = Math.random() * 2100000000 | 0;

	const PRIME32_2 = 1883677709;
	const PRIME32_3 = 2034071983;
	const PRIME32_4 = 668265263;
	const PRIME32_5 = 374761393;

	const seedHash = s => {
		seed = s | 0;
	}

	const { imul } = Math;

	const hash = (x, y) => {
		let h32 = 0;

		h32 = seed + PRIME32_5 | 0;
		h32 += 8;

		h32 += imul(x, PRIME32_3);
		h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
		h32 += imul(y, PRIME32_3);
		h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);

		h32 ^= h32 >> 15;
		h32 *= PRIME32_2;
		h32 ^= h32 >> 13;
		h32 *= PRIME32_3;
		h32 ^= h32 >> 16;

		return h32 / 2147483647;
	};
	const hash3 = (x, y, z) => {
		let h32 = 0;

		h32 = seed + PRIME32_5 | 0;
		h32 += 8;

		h32 += imul(x, PRIME32_3);
		h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
		h32 += imul(y, PRIME32_3);
		h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
		h32 += imul(z, PRIME32_3);
		h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);

		h32 ^= h32 >> 15;
		h32 *= PRIME32_2;
		h32 ^= h32 >> 13;
		h32 *= PRIME32_3;
		h32 ^= h32 >> 16;

		return h32 / 2147483647;
	};

	return {
		seedHash,
		hash, hash3
	};
})();
class Marsaglia {
	// from http://www.math.uni-bielefeld.de/~sillke/ALGORITHMS/random/marsaglia-c

	nextInt() {
		const { z, w } = this;

		this.z = 36969 * (z & 65535) + (z >>> 16) & 0xFFFFFFFF;
		this.w = 18000 * (w & 65535) + (w >>> 16) & 0xFFFFFFFF;

		return ((this.z & 0xFFFF) << 16 | this.w & 0xFFFF) & 0xFFFFFFFF;
	}

	nextDouble() {
		const i = this.nextInt() / 4294967296;

		const is_less_than_zero = (i < 0) | 0; // cast to 1 or 0

		return is_less_than_zero + i;
	}

	constructor(i1, i2) { // better param names
		this.z = (i1 | 0) || 362436069;
		this.w = i2 || hash(521288629, this.z) * 2147483647 | 0;
	}
}

class PerlinNoise {
	// http://www.noisemachine.com/talk1/17b.html
	// http://mrl.nyu.edu/~perlin/noise/

	static grad3d(i, x, y, z) {
		const h = i & 15; // convert into 12 gradient directions

		const u = h < 8
			? x
			: y;

		const v = h < 4
			? y
			: h === 12 || h === 14
				? x
				: z;

		return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v)
	}

	static grad2d(i, x, y) {
		const v = (i & 1) === 0
			? x
			: y;

		return (i & 2) === 0
			? -v
			: v;
	}

	static grad1d(i, x) {
		return (i & 1) === 0
			? -x
			: x;
	}

	static lerp(t, a, b) {
		return a + t * (b - a);
	}

	// end of statics

	// permutation
	perm = new Uint8Array(0x200);

	// prototype functions:
	noise3d(x, y, z) {
		const { floor } = Math;

		const X = floor(x) & 0xff;
		const Y = floor(y) & 0xff;
		const Z = floor(z) & 0xff;

		x -= floor(x);
		y -= floor(y);
		z -= floor(z);

		const fx = (3 - 2 * x) * x * x;
		const fy = (3 - 2 * y) * y * y;
		const fz = (3 - 2 * z) * z * z;

		const { perm } = this;

		const p0 = perm[X] + Y;
		const p00 = perm[p0] + Z;
		const p01 = perm[p0 + 1] + Z;
		const p1 = perm[X + 1] + Y;
		const p10 = perm[p1] + Z;
		const p11 = perm[p1 + 1] + Z;

		const { lerp, grad3d } = PerlinNoise;

		return lerp(
			fz,
			lerp(
				fy,
				lerp(
					fx,
					grad3d(perm[p00], x, y, z),
					grad3d(perm[p10], x - 1, y, z)
				),
				lerp(
					fx,
					grad3d(perm[p01], x, y - 1, z),
					grad3d(perm[p11],x - 1, y - 1, z)
				)
			),
			lerp(
				fy,
				lerp(
					fx,
					grad3d(perm[p00 + 1], x, y, z - 1),
					grad3d(perm[p10 + 1], x - 1, y, z - 1)
				),
				lerp(
					fx,
					grad3d(perm[p01 + 1], x, y - 1, z - 1),
					grad3d(perm[p11 + 1], x - 1, y - 1, z - 1)
				)
			)
		);
	}

	noise2d(x, y) {
		const { floor } = Math;

		const X = floor(x) & 0xff;
		const Y = floor(y) & 0xff;

		x -= floor(x);
		y -= floor(y);

		const { perm } = this;
		const fx = (3 - 2 * x) * x * x;
		const fy = (3 - 2 * y) * y * y;
		const p0 = perm[X] + Y;
		const p1 = perm[X + 1] + Y;

		const { lerp, grad2d } = PerlinNoise;

		return lerp(
			fy,
			lerp(
				fx,
				grad2d(
					perm[p0],
					x,
					y
				),
				grad2d(
					perm[p1],
					x - 1,
					y
				)
			),
			lerp(
				fx,
				grad2d(
					perm[p0 + 1],
					x,
					y - 1
				),
				grad2d(
					perm[p1 + 1],
					x - 1,
					y - 1
				)
			)
		);
	}

	noise1d(x) {
		const { floor } = Math;

		const X = floor(x) & 0xff;

		x -= floor(x);

		const fx = (3 - 2 * x) * x * x;

		const { lerp, grad1d } = PerlinNoise;

		return lerp(
			fx,
			grad1d(perm[X], x),
			grad1d(perm[X + 1], x - 1)
		);
	}

	constructor(seed) {
		if (seed === undefined) {
			throw new TypeError("A value for `seed` parameter was not provided to `PerlinNoise`");
		}

		const rnd = new Marsaglia(seed);

		// generate permutation
		const { perm } = this;

		// fill 0x0..0x100
		for (let i = 0; i < 0x100; ++i) {
			perm[i] = i;
		}

		for (let i = 0; i < 0x100; ++i) {
			const j = rnd.nextInt() & 0xFF;
			const t = perm[j];
			perm[j] = perm[i];
			perm[i] = t;
		}

		// copy to avoid taking mod in perm[0]
		// copies from first half of array, into the second half
		perm.copyWithin(0x100, 0x0, 0x100);
	}
}

let noises = {}, noiseProfile, baseSimplexNoise
function newNoise(seed){
	seedHash(seed)
	const noiseProfile = {
		generator: new PerlinNoise(seed),
		octaves: 4,
		fallout: 0.5,
		offsets: []//offsets for different noise ids to make biomes vary at spawn
	};
	for(let i=0; i<8; i++){ //loop through ids
		let arr = noiseProfile.offsets[i] = []
		for(let j=0; j<18; j++){ //loop through octaves
			//every two numbers is a octave
			arr[j] = hash3(i,j,seed)*10000
		}
	}
	const baseSimplexNoise = simplexNoise()//openSimplexNoise(seed)
	if(!noises[seed]){
		noises[seed] = {noiseProfile,baseSimplexNoise,used:1}
	}else noises[seed].used++
}
function useNoise(seed){
	({noiseProfile, baseSimplexNoise} = noises[seed])
	seedHash(seed)
}
function deleteNoise(seed){
	noises[seed].used--
	if(!noises[seed].used) delete noises[seed]
}
let noise = function(x, y, z) {
	let generator = noiseProfile.generator
	let effect = 1, k = 1, sum = 0
	for(let i = 0; i < noiseProfile.octaves; ++i) {
		effect *= noiseProfile.fallout
		switch (arguments.length) {
			case 1:
				sum += effect * (1 + generator.noise1d(k*x))/2; break
			case 2:
				sum += effect * (1 + generator.noise2d(k*x, k*y))/2; break
			case 3:
				sum += effect * (1 + generator.noise3d(k*x, k*y, k*z))/2; break
		}
		k *= 2
	}
	return sum
}
function halfNegative(x){
	return x<0 ? x/2 : x
}
function quadruplePositive(x){
	return x>0 ? x*4 : x
}
function quadrupleNegative(x){
	return x>0 ? x : x*4
}
function idk4of5(x){
	return x<-0.6 ? map(x,-1,-0.6,-1,0) : map(x,-0.6,1,0,1)
}
let noise3d = function(x, y, z, add) {
	if(add>0) add *= 4
	const offsets = noiseProfile.offsets[5]
	const select = mapClamped(baseSimplexNoise(x*0.04+offsets[6], y*0.02+offsets[7], z*0.04+offsets[8]),-0.3,0.3)
	const low = select < 1 ? baseSimplexNoise(x*0.01+offsets[0], y*0.005+offsets[1], z*0.01+offsets[2]) : 0
	const high = select > 0 ? baseSimplexNoise(x*0.01+offsets[3], y*0.005+offsets[4], z*0.01+offsets[5]) : 0
	const extraDetail = baseSimplexNoise(x*0.2, y*0.02, z*0.2)*0.15
	return lerp(select,low,high) + extraDetail + add
}
let noise2d = function(x, y, octaves = noiseProfile.octaves, id = 0) {
	let generator = noiseProfile.generator
	let effect = 1, k = 1, sum = 0
	let offsets = noiseProfile.offsets[id]
	for(let i = 0, oi = 0; i < octaves; ++i, oi+=2) {
		effect *= noiseProfile.fallout
		sum += effect * (1 + generator.noise2d(k*x+offsets[oi], k*y+offsets[oi+1]))/2
		k *= 2
	}
	return sum
}
let noise2dDouble = function(x, y, octaves) {
	let effect = 1, k = 1, sum = 0
	for(let i = 0; i < octaves; ++i) {
		effect *= 0.75
		sum += effect * baseSimplexNoise(k*x, i+0.5, k*y)
		k *= 2
	}
	return sum
}
let noise3d2 = function(x, y, z, octaves = noiseProfile.octaves) {
	let generator = noiseProfile.generator
	let effect = 1, k = 1, sum = 0
	for(let i = 0; i < octaves; ++i) {
		effect *= noiseProfile.fallout
		sum += effect * (1 + generator.noise3d(k*x, k*y, k*z))/2
		k *= 2
	}
	return sum
}
let complicatedNoise = function(x,y,settings){
	const offsets = noiseProfile.offsets[settings.useOffset]
	let {amplitudes, startFrequency:freq, startAmplitude:effect, noAverage} = settings
	let sum = 0, sum2 = 0
	const inputFactor = 1.0181268882175227//why is this needed???
	for(let i=0, oi = 0; i<amplitudes.length; i++, oi += 2){
		if(amplitudes[i]){
			sum += baseSimplexNoise(freq*x+offsets[oi], 0, freq*y+offsets[oi+1]) * amplitudes[i] * effect
			sum2 += baseSimplexNoise((freq*x+offsets[oi])*inputFactor, 0, (freq*y+offsets[oi+1])*inputFactor) * amplitudes[i] * effect
		}
		freq *= 2
		effect *= 0.5
	}
	return (sum+sum2)*settings.valueFactor
}
function mapClamped(v, min, max){
	return Math.min(Math.max(((v - min) / (max - min)),0),1);
}
function mapFrom(v, min, max){
		return (v - min) / (max - min)
}
function mapTo(v, min2, max2){
		return min2 + (max2 - min2) * v;
}
function map(v, min, max, min2, max2){
		return min2 + (max2 - min2) * ((v - min) / (max - min));
}
function lerp(t, a, b) {
		return a + t * (b - a);
}
function clamp(a,b,c){
		return Math.min(Math.max(a,b),c)
}

//from https://gist.github.com/esimov/9be66c7c9d02cf6fc1cb#file-simplexnoise-js and modified
function simplexNoise() {
	// Skewing and unskewing factors for 2, 3, and 4 dimensions
	const F3 = 1.0 / 3.0;
	const G3 = 1.0 / 6.0;
	let perm = new Uint8Array(512);
	let permMod12 = new Uint8Array(512);
	let p = new Uint8Array(256);
	// Prepopulate the permutation table with values from lookup table
	// To remove the need for index wrapping, double the permutation table length
	const grad3 = new Float32Array([
			1,1,0, -1,1,0, 1,-1,0, -1,-1,0,
			1,0,1, -1,0,1, 1,0,-1, -1,0,-1,
			0,1,1, 0,-1,1, 0,1,-1, 0,-1,-1
	]);
	for (let i = 0; i < 256; i++) {
			p[i] = 256*hash(i,4789);
	}
	// To remove the need for index wrapping, double the permutation table length 
	for (let i=0; i < 512; i++) {
			perm[i] = p[i & 255];
			permMod12[i] = perm[i] % 12;
	}
	return function (xin, yin, zin) {
		xin *= 0.5, yin *= 0.5, zin *= 0.5
		// Noise contribution from the four corners
		let n0, n1, n2, n3;

		// Skew the input space to determine which simplex cell we are in
		let s = (xin+yin+zin) * F3; // Simple skew factor for 3D
		let i = Math.floor(xin + s);
		let j = Math.floor(yin + s);
		let k = Math.floor(zin + s);
		let t = (i + j + k) * G3;
		let X0 = i - t;
		let Y0 = j - t;
		let Z0 = k - t;

		// The x, y, z distances from the cell origin
		let x0 = xin - X0;
		let y0 = yin - Y0;
		let z0 = zin - Z0;

		// For the 3D case, the simplex shape is a slightly irregular tetrahedron.
		// Determine which simplex we are in.
		let i1, j1, k1,
				i2, j2, k2;

		if (x0 >= y0) {
				if (y0 >= z0) {
						i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; // XYZ order
				} else if (x0 >= z0) {
						i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; // XZY order
				} else {
						i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; // ZXY order
				}
		} else {// x0<y0
				if (y0 < z0) {
						i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; // ZYX order
				} else if (x0 < z0) {
						i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; // YZX order
				} else {
						i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; // YXZ order
				}
		}

		// A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
		// a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
		// a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
		// c = 1/6.

		let x1 = x0 - i1 + G3;
		let y1 = y0 - j1 + G3;
		let z1 = z0 - k1 + G3;

		let x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
		let y2 = y0 - j2 + 2.0 * G3;
		let z2 = z0 - k2 + 2.0 * G3;

		let x3 = x0 - 1.0 + 3.0 * G3;
		let y3 = y0 - 1.0 + 3.0 * G3;
		let z3 = z0 - 1.0 + 3.0 * G3;

		// Work out the hashed gradient indices of the four simplex corners
		let ii = i & 255;
		let jj = j & 255;
		let kk = k & 255;

		let t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
		if (t0 < 0) n0 = 0.0;
		else {
				t0 *= t0;
				let gi0 = permMod12[ii+perm[jj+perm[kk]]];
				n0 = t0 * t0 * (grad3[gi0]*x0 + grad3[gi0+1]*y0 + grad3[gi0+2]*z0);
		}
		let t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
		if (t1 < 0) n1 = 0.0;
		else {
				t1 *= t1;
				let gi1 = permMod12[ii+i1+perm[jj+j1+perm[kk+k1]]];
				n1 = t1 * t1 * (grad3[gi1]*x1 + grad3[gi1+1]*y1 + grad3[gi1+2]*z1);
		}
		let t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
		if (t2 < 0) n2 = 0.0;
		else {
				t2 *= t2;
				let gi2 = permMod12[ii+i2+perm[jj+j2+perm[kk+k2]]];
				n2 = t2 * t2 * (grad3[gi2]*x2 + grad3[gi2+1]*y2 + grad3[gi2+2]*z2);
		}
		let t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
		if (t3 < 0) n3 = 0.0;
		else {
				t3 *= t3;
				let gi3 = permMod12[ii+1+perm[jj+1+perm[kk+1]]];
				n3 = t3 * t3 * (grad3[gi3]*x3 + grad3[gi3+1]*y3 + grad3[gi3+2]*z3);
		}

		// Add contributions from each corner to get the final noise value.
		// The result is scaled to stay just inside [-1,1]
		return 32.0 * (n0 + n1 + n2 + n3)
	}
}
//Note: simplex noise is not the same as opensimplex noise

// Copied and modified from https://github.com/blindman67/SimplexNoiseJS
function openSimplexNoise(clientSeed) {
	const {floor} = Math
	const SQ4 = 2
	const toNums = function(s) { return s.split(",").map(function(s) { return new Uint8Array(s.split("").map(function(v) { return Number(v) })) }) }
	const decode = function(m, r, s) { return new Int8Array(s.split("").map(function(v) { return parseInt(v, r) + m })) }
	const toNumsB32 = function(s) { return s.split(",").map(function(s) { return parseInt(s, 32) }) }
	const NORM_3D = 1.0 / 206.0
	const SQUISH_3D = 1 / 3
	const STRETCH_3D = -1 / 6
	var base3D = toNums("0000110010101001,2110210120113111,110010101001211021012011")
	const gradients3D = decode(-11, 23, "0ff7mf7fmmfffmfffm07f70f77mm7ff0ff7m0f77m77f0mf7fm7ff0077707770m77f07f70")
	var lookupPairs3D = function() { return new Uint16Array(toNumsB32("0,2,1,1,2,2,5,1,6,0,7,0,10,2,12,2,41,1,45,1,50,5,51,5,g6,0,g7,0,h2,4,h6,4,k5,3,k7,3,l0,5,l1,5,l2,4,l5,3,l6,4,l7,3,l8,d,l9,d,la,c,ld,e,le,c,lf,e,m8,k,ma,i,p9,l,pd,n,q8,k,q9,l,15e,j,15f,m,16a,i,16e,j,19d,n,19f,m,1a8,f,1a9,h,1aa,f,1ad,h,1ae,g,1af,g,1ag,b,1ah,a,1ai,b,1al,a,1am,9,1an,9,1bg,b,1bi,b,1eh,a,1el,a,1fg,8,1fh,8,1qm,9,1qn,9,1ri,7,1rm,7,1ul,6,1un,6,1vg,8,1vh,8,1vi,7,1vl,6,1vm,7,1vn,6")) }
	var p3D = decode(-1, 5, "112011210110211120110121102132212220132122202131222022243214231243124213241324123222113311221213131221123113311112202311112022311112220342223113342223311342223131322023113322023311320223113320223131322203311322203131")
	const setOf = function(count) { var a = [],i = 0; while (i < count) { a.push(i++) } return a }
	const doFor = function(count, cb) { var i = 0; while (i < count && cb(i++) !== true) {} }

	function shuffleSeed(seed,count){
		seed = seed * 1664525 + 1013904223 | 0
		count -= 1
		return count > 0 ? shuffleSeed(seed, count) : seed
	}
	const types = {
		_3D : {
			base : base3D,
			squish : SQUISH_3D,
			dimensions : 3,
			pD : p3D,
			lookup : lookupPairs3D,
		}
	}

	function createContribution(type, baseSet, index) {
		var i = 0
		const multiplier = baseSet[index ++]
		const c = { next : undefined }
		while(i < type.dimensions) {
			const axis = ("xyzw")[i]
			c[axis + "sb"] = baseSet[index + i]
			c["d" + axis] = - baseSet[index + i++] - multiplier * type.squish
		}
		return c
	}

	function createLookupPairs(lookupArray, contributions){
		var i
		const a = lookupArray()
		const res = new Map()
		for (i = 0; i < a.length; i += 2) { res.set(a[i], contributions[a[i + 1]]); }
		return res
	}

	function createContributionArray(type) {
		const conts = []
		const d = type.dimensions
		const baseStep = d * d
		var k, i = 0
		while (i < type.pD.length) {
			const baseSet = type.base[type.pD[i]]
			let previous, current
			k = 0
			do {
				current = createContribution(type, baseSet, k)
				if (!previous) { conts[i / baseStep] = current; }
				else { previous.next = current; }
				previous = current
				k += d + 1
			} while(k < baseSet.length)

			current.next = createContribution(type, type.pD, i + 1)
			if (d >= 3) { current.next.next = createContribution(type, type.pD, i + d + 2) }
			if (d === 4) { current.next.next.next = createContribution(type, type.pD, i + 11) }
			i += baseStep
		}
		const result = [conts, createLookupPairs(type.lookup, conts)]
		type.base = undefined
		type.lookup = undefined
		return result
	}

	let temp = createContributionArray(types._3D)
	const contributions3D = temp[0], lookup3D = temp[1]
	const perm = new Uint8Array(256)
	const perm3D = new Uint8Array(256)
	const source = new Uint8Array(setOf(256))
	var seed = shuffleSeed(clientSeed, 3)
	doFor(256, function(i) {
		i = 255 - i
		seed = shuffleSeed(seed, 1)
		var r = (seed + 31) % (i + 1)
		r += r < 0 ? i + 1 : 0
		perm[i] = source[r]
		perm3D[i] = (perm[i] % 24) * 3
		source[r] = source[i]
	})
	base3D = undefined
	lookupPairs3D = undefined
	p3D = undefined

	return function(x, y, z) {
		const pD = perm3D
		const p = perm
		const g = gradients3D
		const stretchOffset = (x + y + z) * STRETCH_3D
		const xs = x + stretchOffset, ys = y + stretchOffset, zs = z + stretchOffset
		const xsb = floor(xs), ysb = floor(ys), zsb = floor(zs)
		const squishOffset	= (xsb + ysb + zsb) * SQUISH_3D
		const dx0 = x - (xsb + squishOffset), dy0 = y - (ysb + squishOffset), dz0 = z - (zsb + squishOffset)
		const xins = xs - xsb, yins = ys - ysb, zins = zs - zsb
		const inSum = xins + yins + zins
		var c = lookup3D.get(
			(yins - zins + 1) |
			((xins - yins + 1) << 1) |
			((xins - zins + 1) << 2) |
			(inSum << 3) |
			((inSum + zins) << 5) |
			((inSum + yins) << 7) |
			((inSum + xins) << 9)
		)
		var i, value = 0
		while (c !== undefined) {
			const dx = dx0 + c.dx, dy = dy0 + c.dy, dz = dz0 + c.dz
			let attn = 2 - dx * dx - dy * dy - dz * dz
			if (attn > 0) {
				i = pD[(((p[(xsb + c.xsb) & 0xFF] + (ysb + c.ysb)) & 0xFF) + (zsb + c.zsb)) & 0xFF]
				attn *= attn
				value += attn * attn * (g[i++] * dx + g[i++] * dy + g[i] * dz)
			}
			c = c.next
		}
		return value * NORM_3D + 0.5
	}
}

function caveNoise2(x, y, z, id, id2){
	const offsets = noiseProfile.offsets[id]
	return baseSimplexNoise(x+offsets[id2], y+offsets[id2+1], z+offsets[id2+2])*0.5+0.5
}
function caveNoise(x, y, z, id, id2){
	const offsets = noiseProfile.offsets[id]
	return baseSimplexNoise(x+offsets[id2], y+offsets[id2+1], z+offsets[id2+2])
}
function caveNoiseWeirdScale(input, x, y, z, id, id2){
	const offsets = noiseProfile.offsets[id]
	return(
		baseSimplexNoise(x+offsets[id2], y+offsets[id2+1], z+offsets[id2+2])*(1-input)
		+baseSimplexNoise(x+offsets[id2]*2, y+offsets[id2+1]*2, z+offsets[id2+2]*2)*input
	)
}

function approxCbrt(x){
	if(x<0.001)x=map(x,0,0.001,0,0.1)
	else if(x<0.005)x=map(x,0.001,0.005,0.1,0.17)
	else if(x<0.01)x=map(x,0.005,0.01,0.17,0.22)
	else if(x<0.03)x=map(x,0.01,0.03,0.22,0.31)
	else if(x<0.0625)x=map(x,0.03,0.0625,0.31,0.4)
	else if(x<0.125)x=map(x,0.0625,0.125,0.4,0.5)
	else if(x<0.25)x=map(x,0.125,0.25,0.5,0.63)
	else if(x<0.5)x=map(x,0.25,0.5,0.63,0.8)
	else if(x<0.75)x=map(x,0.5,0.75,0.8,0.9)
	else x=map(x,0.75,1,0.9,1)
	return x
}
function approx8rt(x){
	if(x<0.0001)x=map(x,0,0.0001,0,0.316)
	else if(x<0.0002)x=map(x,0.0001,0.0002,0.316,0.36)
	else if(x<0.001)x=map(x,0.0002,0.001,0.36,0.42)
	else if(x<0.005)x=map(x,0.001,0.005,0.42,0.52)
	else if(x<0.02)x=map(x,0.005,0.02,0.52,0.61)
	else if(x<0.1)x=map(x,0.02,0.1,0.61,0.75)
	else if(x<0.2)x=map(x,0.1,0.2,0.75,0.82)
	else if(x<0.2)x=map(x,0.1,0.2,0.75,0.82)
	else if(x<0.4)x=map(x,0.2,0.4,0.82,0.89)
	else if(x<0.7)x=map(x,0.4,0.7,0.89,0.96)
	else x=map(x,0.7,1,0.96,1)
	return x
}

function xyArrayHas(arr,x,y){
	for(let i=0; i<arr.length; i+=2){
		if(arr[i] === x && arr[i+1] === y){
			return true
		}
	}
}

let generateRiverChunk, riverHeights = new Float32Array(256), riverLoweredHeight = new Float32Array(256), riverFinalDists = new Float32Array(256), riverFinalNormalDists = new Float32Array(256)
{//------- River Generator
//Warning: very messy!!!!!

const center = 5, lwidth = center*2+1
function getHeightmap(cx,cz,heightmaps,rcx,rcz,scale,riverLowers,empty){
		heightmaps[(cx+center)*lwidth+(cz+center)] = null
    /*let grid = empty ? null : []
    if(!empty) for(let x=0; x<16; x++){
        for(let z=0; z<16; z++){
            grid[z*16+x] = getBottomHeight((x+rcx*16)*scale,(z+rcz*16)*scale,scale)
            //extraGrid[z*16+x] = (noise2d((x+rcx*16)*0.4,(rcz*16+z)*0.4, 2)-0.25)*0.1
        }
    }
    if(!empty && riverLowers){
        for(let x=0; x<16; x++){
            for(let z=0; z<16; z++){
                grid[z*16+x] *= 1-(getRiver(x+cx*16,z+cz*16,riverLowers)||0)*0.5
            }
        }
    }
    heightmaps[(cx+center)*lwidth+(cz+center)] = grid;*/
}
function getHeight(x,z,heightmaps,extra,top=0){
	/*
		extra = true: extraHeightmap
		top = 1: top height
		other (extra = riverLowers): bottom height
	*/
    let chunk = heightmaps[((x>>4)+center)*lwidth+((z>>4)+center)];
    if(!chunk) chunk = heightmaps[((x>>4)+center)*lwidth+((z>>4)+center)] = []
    if(chunk[(z&15)*16+(x&15)] === undefined){
			let scale = getHeight.scale
			if(extra === true) chunk[(z&15)*16+(x&15)] = 0//(noise2d((x+getHeight.offsetX)*0.4,(z+getHeight.offsetZ)*0.4, 2)-0.25)*0.04*iteration
			else{
				chunk[(z&15)*16+(x&15)] = getBottomHeight((x+getHeight.offsetX)*scale,(z+getHeight.offsetZ)*scale,scale) * (1-getRiver(x,z,extra)*0.5)
				chunk[(z&15)*16+(x&15)+256] = getBottomHeight.topHeight
				chunk[(z&15)*16+(x&15)+512] = getBottomHeight.cantSpawnRiver
			}
		}
		return chunk[(z&15)*16+(x&15) + top*256]
}
/*Chunk format: 11 by 11 grid

`````
`|||`
`|m|`
`|||`
`````

`  only heightmaps
|  heightmaps + generate rivers
m  heightmaps + generate rivers + include neighbour chunk rivers
*/
function setRiver(x,z,rivers,value){
	let cx = x>>4, cz = z>>4
	let grid = rivers[(cx+center)*lwidth+(cz+center)] || (rivers[(cx+center)*lwidth+(cz+center)] = new Uint16Array(256))
	grid[(z&15)*16+(x&15)] = value
}
function setGridFloat(x,z,rivers,value=1){
	let cx = x>>4, cz = z>>4
	let grid = rivers[(cx+center)*lwidth+(cz+center)] || (rivers[(cx+center)*lwidth+(cz+center)] = new Float32Array(256))
	grid[(z&15)*16+(x&15)] = value
}
function getRiver(x,z,rivers){
    let cx = x>>4, cz = z>>4
    let grid = rivers[(cx+center)*lwidth+(cz+center)]
    if(!grid) return 0
    return grid[(z&15)*16+(x&15)]
}
function maxLower(x,z,rivers,value){
    let cx = x>>4, cz = z>>4
    let grid = rivers[(cx+center)*lwidth+(cz+center)] || (rivers[(cx+center)*lwidth+(cz+center)] = new Float32Array(256))
    grid[(z&15)*16+(x&15)] = Math.max(value,(grid[(z&15)*16+(x&15)]||0))
}
function addGridXZ(x,z,rivers,value,xOrZ=0){//if xOrZ=0, x    if xOrZ=1, z
	let cx = x>>4, cz = z>>4
	let grid = rivers[(cx+center)*lwidth+(cz+center)] || (rivers[(cx+center)*lwidth+(cz+center)] = new Float32Array(512))
	grid[(z&15)*32+(x&15)*2+xOrZ] += value
}
function setGridXZ(x,z,rivers,value,xOrZ=0){//if xOrZ=0, x    if xOrZ=1, z
	let cx = x>>4, cz = z>>4
	let grid = rivers[(cx+center)*lwidth+(cz+center)] || (rivers[(cx+center)*lwidth+(cz+center)] = new Float32Array(512))
	grid[(z&15)*32+(x&15)*2+xOrZ] = value
}
function getGridXZ(x,z,rivers,xOrZ=0){
	let cx = x>>4, cz = z>>4
	let grid = rivers[(cx+center)*lwidth+(cz+center)]
	if(!grid) return 0
	return grid[(z&15)*32+(x&15)*2+xOrZ]
}
function copyGridFloat(cx,cz,rivers,arr){
	let idx = (cx+center)*lwidth+(cz+center)
	let grid = rivers[idx] || (rivers[idx] = new Float32Array(512))
	if(arr[idx]) grid.set(arr[idx])
	else grid.fill(0)
}
function dirToInt(x){return x===1?1:(x===-1?2:0)}
function intToDir(i){return i===1?1:(i===2?-1:0)}

const diagonalMult = 1, diagonal2Mult = 0.8
let tempRiverArr = []
function generateBaseRivers(cx,cz,rcx,rcz,rivers,heightmaps,prevRivers,iteration,riverLowers,scale,riverDists,prevRiverDists){
	let river = tempRiverArr
	let random = new Marsaglia(hash3(rcx,rcz,iteration))
	getHeight.scale = scale
	getHeight.iteration = iteration
	getHeight.offsetX = (rcx-cx)*16
	getHeight.offsetZ = (rcz-cz)*16
	const tries = iteration===1 ? 16 : 8//Math.round(2/iteration + random.nextDouble()*0.5)
	//const scaleHigher = 1-(1-scale)**2
	const minDist = 4*4/iteration
	main:for(let i=0; i<tries; i++){
			let ox = random.nextDouble(), oz = random.nextDouble()
			if(iteration===1){
				//for more even distribution
				ox = ((i&3)+ox)*0.25
				oz = ((i>>2)+oz)*0.25
			}
			ox = Math.floor(ox*16)+cx*16;
			oz = Math.floor(oz*16)+cz*16;
			//getTemperatureAndRainfall((getHeight.offsetX+ox)*scale/generateRiverChunk.riverScale,(getHeight.offsetZ+oz)*scale/generateRiverChunk.riverScale,true)
			//if(random.nextDouble()*(4-rainfallHere)>iteration*0.25+0.75) continue//dryer places have less big rivers
			let height = getHeight(ox,oz,heightmaps,riverLowers)
			if(height<0 || getHeight(ox,oz,heightmaps,riverLowers,2)) continue
			let x = ox, z = oz
			let thisheight, heightdiff
			river.length = 0
			let topHeight = getHeight(x,z,heightmaps,riverLowers,1)
			let maxUpHeight, upMode = false, pdx, pdz, pdouble2, pnx, pnz, upModeDownEnd
			//upMode happens when river stuck and makes them keep going in the same direction until it can go down
			while(topHeight>0 && !getRiver(x,z,prevRivers)){
					let nx, nz//next position
					let dx = 0, dz = 0, double2 //position for diagonal if diagonal
					let maxHeightDiff = 0
					
					if(upMode){
						nx = pnx, nz = pnz, dx = pdx, dz = pdz, double2 = pdouble2
						if(nx === undefined) continue main
						let thisheight = getHeight(x+nx,z+nz,heightmaps,riverLowers)
						if(thisheight > maxUpHeight) continue main//it can't go up that much
						if(thisheight < height){
							if(upModeDownEnd === undefined) upModeDownEnd = height-0.025//it has to go down a certain amount to count
							if(thisheight < upModeDownEnd){
								upMode = false//going down place found
								upModeDownEnd = undefined
							}
						}else upModeDownEnd = undefined
						height = thisheight
					}else{
						//4 basic directions
						thisheight = getHeight(x+1,z,heightmaps,riverLowers), heightdiff = height-thisheight//+getHeight(x+1,z,extraNoisemaps,1)
						if(heightdiff>maxHeightDiff) maxHeightDiff = heightdiff, height = thisheight, nx = 1, nz = 0
						thisheight = getHeight(x-1,z,heightmaps,riverLowers), heightdiff = height-thisheight//+getHeight(x-1,z,extraNoisemaps,1)
						if(heightdiff>maxHeightDiff) maxHeightDiff = heightdiff, height = thisheight, nx = -1, nz = 0
						thisheight = getHeight(x,z+1,heightmaps,riverLowers), heightdiff = height-thisheight//+getHeight(x,z+1,extraNoisemaps,1)
						if(heightdiff>maxHeightDiff) maxHeightDiff = heightdiff, height = thisheight, nx = 0, nz = 1
						thisheight = getHeight(x,z-1,heightmaps,riverLowers), heightdiff = height-thisheight//+getHeight(x,z-1,extraNoisemaps,1)
						if(heightdiff>maxHeightDiff) maxHeightDiff = heightdiff, height = thisheight, nx = 0, nz = -1
						
						//between directions
						thisheight = getHeight(x+1,z+1,heightmaps,riverLowers), heightdiff = (height-thisheight/*+getHeight(x+1,z+1,extraNoisemaps,1)*/)*diagonalMult
						if(heightdiff>maxHeightDiff) maxHeightDiff = heightdiff, height = thisheight, nx = 1, nz = 1, dx = 1, dz = 0
						thisheight = getHeight(x+1,z-1,heightmaps,riverLowers), heightdiff = (height-thisheight/*+getHeight(x+1,z-1,extraNoisemaps,1)*/)*diagonalMult
						if(heightdiff>maxHeightDiff) maxHeightDiff = heightdiff, height = thisheight, nx = 1, nz = -1, dx = 0, dz = -1
						thisheight = getHeight(x-1,z+1,heightmaps,riverLowers), heightdiff = (height-thisheight/*+getHeight(x-1,z+1,extraNoisemaps,1)*/)*diagonalMult
						if(heightdiff>maxHeightDiff) maxHeightDiff = heightdiff, height = thisheight, nx = -1, nz = 1, dx = 0, dz = 1
						thisheight = getHeight(x-1,z-1,heightmaps,riverLowers), heightdiff = (height-thisheight/*+getHeight(x-1,z-1,extraNoisemaps,1)*/)*diagonalMult
						if(heightdiff>maxHeightDiff) maxHeightDiff = heightdiff, height = thisheight, nx = -1, nz = -1, dx = -1, dz = 0
						
						//between between directions
						//thisheight = getHeight(x-1,z+2,heightmaps,riverLowers), heightdiff = (height-thisheight/*+getHeight(x-1,z+2,extraNoisemaps,1)*/)*diagonal2Mult
						//if(heightdiff>maxHeightDiff) maxHeightDiff = heightdiff, height = thisheight, nx = -1, nz = 2, dx = 0, dz = 1, double2 = true
						//thisheight = getHeight(x+1,z+2,heightmaps,riverLowers), heightdiff = (height-thisheight/*+getHeight(x+1,z+2,extraNoisemaps,1)*/)*diagonal2Mult
						//if(heightdiff>maxHeightDiff) maxHeightDiff = heightdiff, height = thisheight, nx = 1, nz = 2, dx = 0, dz = 1, double2 = true
						//thisheight = getHeight(x+2,z+1,heightmaps,riverLowers), heightdiff = (height-thisheight/*+getHeight(x+2,z+1,extraNoisemaps,1)*/)*diagonal2Mult
						//if(heightdiff>maxHeightDiff) maxHeightDiff = heightdiff, height = thisheight, nx = 2, nz = 1, dx = 1, dz = 0, double2 = true
						//thisheight = getHeight(x+2,z-1,heightmaps,riverLowers), heightdiff = (height-thisheight/*+getHeight(x+2,z-1,extraNoisemaps,1)*/)*diagonal2Mult
						//if(heightdiff>maxHeightDiff) maxHeightDiff = heightdiff, height = thisheight, nx = 2, nz = -1, dx = 1, dz = 0, double2 = true
						//thisheight = getHeight(x+1,z-2,heightmaps,riverLowers), heightdiff = (height-thisheight/*+getHeight(x+1,z-2,extraNoisemaps,1)*/)*diagonal2Mult
						//if(heightdiff>maxHeightDiff) maxHeightDiff = heightdiff, height = thisheight, nx = 1, nz = -2, dx = 0, dz = -1, double2 = true
						//thisheight = getHeight(x-1,z-2,heightmaps,riverLowers), heightdiff = (height-thisheight/*+getHeight(x-1,z-2,extraNoisemaps,1)*/)*diagonal2Mult
						//if(heightdiff>maxHeightDiff) maxHeightDiff = heightdiff, height = thisheight, nx = -1, nz = -2, dx = 0, dz = -1, double2 = true
						//thisheight = getHeight(x-2,z-1,heightmaps,riverLowers), heightdiff = (height-thisheight/*+getHeight(x-2,z-1,extraNoisemaps,1)*/)*diagonal2Mult
						//if(heightdiff>maxHeightDiff) maxHeightDiff = heightdiff, height = thisheight, nx = -2, nz = -1, dx = -1, dz = 0, double2 = true
						//thisheight = getHeight(x-2,z+1,heightmaps,riverLowers), heightdiff = (height-thisheight/*+getHeight(x-2,z+1,extraNoisemaps,1)*/)*diagonal2Mult
						//if(heightdiff>maxHeightDiff) maxHeightDiff = heightdiff, height = thisheight, nx = -2, nz = 1, dx = -1, dz = 0, double2 = true

						if(nx === undefined || xyArrayHas(river,x+nx,z+nz)) {
							upMode = true //river is stuck
							maxUpHeight = height+0.025
							continue
						}
					}
					/*if(dx || dz){
							river.push(x+dx,z+dz)
							if(double2) river.push(x+nx-dx,z+nz-dz)
					}*/
					x += nx, z += nz
					river.push(x,z)
					pnx = nx, pnz = nz, pdx = dx, pdz = dz, pdouble2 = double2
					topHeight = getHeight(x,z,heightmaps,riverLowers,1)
					if(river.length>1600 || Math.max(Math.abs(x-ox),Math.abs(z-oz)) > 32 || getHeight(x,z,heightmaps,riverLowers,2)) continue main
					if((dx || dz) && (getRiver(x+dx,z,prevRivers)||getRiver(x,z+dz,prevRivers))) break//prevent diagonal going through another diagonal
			}
			if((x-ox)**2+(z-oz)**2<minDist) continue main//too short
			//startt if(topHeight > 0 && random.nextDouble() < getRiver(x,z,prevRiverStartDists)) continue main //if not connecting to start, it is rarer
			//if(topHeight <= 0 && iteration>3 && random.nextDouble()*iteration>3) continue main //prevent small rivers going into ocean to much
			for(let j=0, f=0; j<river.length; j+=2, f++){
				if(j<river.length-2){
					let riverWidth = (maxZoom-iteration+1)*384//1 to 4096
					let prevRiverWidth = getRiver(river[j],river[j+1],rivers)>>>4
					if(prevRiverWidth) riverWidth = riverWidth+prevRiverWidth
					setRiver(river[j],river[j+1],rivers, (riverWidth-1)<<4 | dirToInt(river[j+2]-river[j])<<2 | dirToInt(river[j+3]-river[j+1]))
				}
				for(let x=-1;x<=1;x++){
						for(let z=-1;z<=1;z++){
								const d = Math.abs(x/1)+Math.abs(z/1)//(x/16)**2+(z/16)**2
								if(d>=1) continue
								const lower = 1-d //1-approxCbrt(d*d) //Math.max((d-riverFlatDist),0)*riverFlatMult
								maxLower(river[j]+x,river[j+1]+z,riverDists,lower)
						}
				}
				//startt let startDist = scaleHigher*Math.min(f*0.125,1)*0.25
				//maxLower(river[j],river[j+1],riverStartDists,startDist)//start of river has lower value, other parts are higher
				//maxLower(river[j]+1,river[j+1],riverStartDists,startDist)
				//maxLower(river[j]-1,river[j+1],riverStartDists,startDist)
				//maxLower(river[j],river[j+1]+1,riverStartDists,startDist)
				//maxLower(river[j],river[j+1]-1,riverStartDists,startDist)
			}
			//if(rivlog<1)console.log("river at",(ox+(rcx-cx)*16)*scale/generateRiverChunk.riverScale,(oz+(rcz-cz)*16)*scale/generateRiverChunk.riverScale),rivlog++
	}
	getHeight.scale = null
}
//let rivlog=0,aaa={stuck:0,nom:0,short:0,total:0}
const riverFlatDist = (1/8)**2, riverFlatMult = 1/(1-riverFlatDist)
function interpolateRivers(cx,cz,scaleBy,prevRivers,newRivers,newPrevRivers,offsetX,offsetZ,prevRiverLowers,newRiverLowers,prevRiverDists,prevPrevRiverDists,newPrevRiverDists,scale,riverNormalDists,prevRiverNormalDists,prevRiverTwists,newRiverTwists){
    //let pcx = Math.round(rcx*scaleBy), pcz = Math.round(rcz*scaleBy)
    //let offsetX = cx*scaleBy - pcx + cx, offsetZ = cz*scaleBy - pcz + cz
    offsetX *= 16, offsetZ *= 16
		let lowerAmount = scale//1-(1-scale)**2
    for(let x=0;x<16;x++){
        for(let z=0;z<16;z++){
            let rx = Math.floor(x*scaleBy+offsetX), rz = Math.floor(z*scaleBy+offsetZ)
            let ix = x*scaleBy+offsetX-rx, iz = z*scaleBy+offsetZ-rz
						let newX = x+cx*16, newZ = z+cz*16

						if(!ix && !iz){
							let river = getRiver(rx,rz,prevRivers)
							//make rivers in previous scale longer in new scale
							if(river){
								let dirX = intToDir((river>>>2)&3), dirZ = intToDir(river&3)
								for(let i=0, rx=0, rz=0; i<1; i+=scaleBy, rx+=dirX, rz+=dirZ){
									setRiver(newX+rx,newZ+rz,newRivers,river)
									setRiver(newX+rx,newZ+rz,newPrevRivers,river)
								}
							}
						}
            let lower = lerp(ix,
                lerp(iz,
                    getRiver(rx,rz,prevRiverLowers),
                    getRiver(rx,rz+1,prevRiverLowers)
                ),
                lerp(iz,
                    getRiver(rx+1,rz,prevRiverLowers),
                    getRiver(rx+1,rz+1,prevRiverLowers)
                )
            )
						let prevDist = lerp(ix, //prevPrevRiverDists is from before the previous ones set
							lerp(iz,
								getRiver(rx,rz,prevPrevRiverDists),
								getRiver(rx,rz+1,prevPrevRiverDists)
							),
							lerp(iz,
								getRiver(rx+1,rz,prevPrevRiverDists),
								getRiver(rx+1,rz+1,prevPrevRiverDists)
							)
						)
						let newDist = lerp(ix, //prevRiverDists is the newly set ones
							lerp(iz,
								getRiver(rx,rz,prevRiverDists),
								getRiver(rx,rz+1,prevRiverDists)
							),
							lerp(iz,
								getRiver(rx+1,rz,prevRiverDists),
								getRiver(rx+1,rz+1,prevRiverDists)
							)
						)
						let prevRiverNormalDist = lerp(ix,
							lerp(iz,
									getRiver(rx,rz,riverNormalDists),
									getRiver(rx,rz+1,riverNormalDists)
							),
							lerp(iz,
									getRiver(rx+1,rz,riverNormalDists),
									getRiver(rx+1,rz+1,riverNormalDists)
							)
						)
						let twistX = lerp(ix,
							lerp(iz,
								getGridXZ(rx,rz,prevRiverTwists),
								getGridXZ(rx,rz+1,prevRiverTwists)
							),
							lerp(iz,
								getGridXZ(rx+1,rz,prevRiverTwists),
								getGridXZ(rx+1,rz+1,prevRiverTwists)
							)
						)
						let twistZ = lerp(ix,
							lerp(iz,
								getGridXZ(rx,rz,prevRiverTwists,1),
								getGridXZ(rx,rz+1,prevRiverTwists,1)
							),
							lerp(iz,
								getGridXZ(rx+1,rz,prevRiverTwists,1),
								getGridXZ(rx+1,rz+1,prevRiverTwists,1)
							)
						)
						lower = lerp(prevDist,lowerAmount*newDist/*scale controls deepness*/,lower)
            setGridFloat(newX,newZ,newRiverLowers,lower)
            setGridFloat(newX,newZ,newPrevRiverDists,Math.max(newDist,prevDist))
						setGridFloat(newX,newZ,prevRiverNormalDists, Math.max((newDist*2)-1,(prevRiverNormalDist/scaleBy)-(1/scaleBy-1),0))
            setGridXZ(newX,newZ,newRiverTwists,twistX/scaleBy)
            setGridXZ(newX,newZ,newRiverTwists,twistZ/scaleBy,1)
        }
    }
}
const blocksPerFinalChunk = 2
let maxZoom = 2//5
let zoomScaleBy = 0.5
const twistIterations = 2, twistAmount = zoomScaleBy**(maxZoom-1)*0.45/*will be scaled up in interpolate*/
function twistRivers(cx,cz,prevRiverTwists,rivers,scale,riverTwists,maxDist){
	maxDist *= 16
	copyGridFloat(cx,cz,riverTwists,prevRiverTwists)
	for(let x=0;x<16;x++){
		for(let z=0;z<16;z++){
			let newX = x+cx*16, newZ = z+cz*16
			let river = getRiver(newX,newZ,rivers)
			if(river){
				let dirX = intToDir((river>>>2)&3), dirZ = intToDir(river&3)
				let strength = twistAmount/scale/twistIterations
				let pullX = dirX ? strength*(getGridXZ(newX+dirX,newZ+dirZ,prevRiverTwists)+dirX-getGridXZ(newX,newZ,prevRiverTwists)) : 0
				let pullZ = dirZ ? strength*(getGridXZ(newX+dirX,newZ+dirZ,prevRiverTwists,1)+dirZ-getGridXZ(newX,newZ,prevRiverTwists,1)) : 0
				addGridXZ(newX,newZ,riverTwists, pullX)//pull this one closer to other
				addGridXZ(newX,newZ,riverTwists, pullZ, 1)//pull this one closer to other
				if(getRiver(newX+dirX,newZ+dirZ,rivers) && newX+dirX<maxDist+16 && newX+dirX>=-maxDist && newZ+dirZ<maxDist+16 && newZ+dirZ>=-maxDist){
					addGridXZ(newX+dirX,newZ+dirZ,riverTwists, -pullX)//pull other one closer to this
					addGridXZ(newX+dirX,newZ+dirZ,riverTwists, -pullZ, 1)//pull other one closer to this
				}
			}else{//keep space between nodes equal
				setGridXZ(newX,newZ,riverTwists, (getGridXZ(newX+1,newZ,prevRiverTwists)+getGridXZ(newX-1,newZ,prevRiverTwists)+getGridXZ(newX,newZ+1,prevRiverTwists)+getGridXZ(newX,newZ-1,prevRiverTwists))*0.25)
				setGridXZ(newX,newZ,riverTwists, (getGridXZ(newX,newZ+1,prevRiverTwists,1)+getGridXZ(newX,newZ-1,prevRiverTwists,1)+getGridXZ(newX+1,newZ,prevRiverTwists,1)+getGridXZ(newX-1,newZ,prevRiverTwists,1))*0.25, 1)
			}
			/*if(dirZ){
				addGridXZ(newX,newZ+dirZ,riverTwists, -dirZ*strength,1)//pull other one closer to this
				addGridXZ(newX,newZ,riverTwists, dirZ*strength,1)//pull this one closer to other
			}*/
		}
	}
}
function limitTwistRivers(cx,cz,riverTwists){
	for(let x=0;x<16;x++){
		for(let z=0;z<16;z++){
			let newX = x+cx*16, newZ = z+cz*16
			let twistX = getGridXZ(newX,newZ,riverTwists), twistZ = getGridXZ(newX,newZ,riverTwists,1)
			let changed
			if(twistX<-0.45) twistX = -0.45, twistZ *= -0.45/twistX, changed = true
			else if(twistX>0.45) twistX = 0.45, twistZ *= 0.45/twistX, changed = true
			if(twistZ<-0.45) twistZ = -0.45, twistX *= -0.45/twistZ, changed = true
			else if(twistZ>0.45) twistZ = 0.45, twistX *= 0.45/twistZ, changed = true
			if(changed){
				setGridXZ(newX,newZ,riverTwists,twistX)
				setGridXZ(newX,newZ,riverTwists,twistZ,1)
			}
		}
	}
}
//One chunk is 1 unit
//code to convert chunk idx to position: a=60; ((a%lwidth)-center)+","+Math.floor(a/lwidth-center)
let rivers = [], prevRivers = [], newRivers = [], temp, riverLowers = [], newRiverLowers = [], riverDists = [], prevRiverDists = [], newPrevRiverDists = [], riverNormalDists = [], prevRiverNormalDists = [], riverTwists = [], newRiverTwists = []
let isRiverWithWidth = new Float32Array(256)
function generateChunk(x,z,seed){
    x*=generateChunk.riverScale, z*=generateChunk.riverScale
    let heightmaps = []
    let Scale = 1, prevScale;
    
		for(let i of rivers){
			if(i) i.fill(0)
		}
		for(let i of prevRivers){
			if(i) i.fill(0)
		}
		for(let i of riverLowers){
			if(i) i.fill(0)
		}
		for(let i of riverDists){
			if(i) i.fill(0)
		}
		for(let i of prevRiverDists){
			if(i) i.fill(0)
		}
		for(let i of riverNormalDists){
			if(i) i.fill(0)
		}
		for(let i of prevRiverNormalDists){
			if(i) i.fill(0)
		}
		for(let i of riverTwists){
			if(i) i.fill(0)
		}
    for(let zoom=0; zoom<maxZoom; zoom++){
        if(zoom){
            //Zoom in and generate smaller rivers connecting to the previous rivers
						for(let i of newRivers){
								if(i) i.fill(0)
						}
						for(let i of prevRivers){
								if(i) i.fill(0)
						}
						for(let i of newRiverLowers){
								if(i) i.fill(0)
						}
            prevScale = Scale;
            let scaleBy = zoomScaleBy;
            Scale *= scaleBy;
            for(let cx=-3; cx<=3; cx++){
                for(let cz=-3; cz<=3; cz++){
                    let offsetX = Math.floor(x/Scale)*scaleBy - Math.floor(x/prevScale)+cx*scaleBy
                    let offsetZ = Math.floor(z/Scale)*scaleBy - Math.floor(z/prevScale)+cz*scaleBy
                    interpolateRivers(cx,cz,scaleBy,rivers,newRivers,prevRivers,offsetX,offsetZ,riverLowers,newRiverLowers,riverDists,prevRiverDists,newPrevRiverDists,Scale,riverNormalDists,prevRiverNormalDists,riverTwists,newRiverTwists)
                }
            }
						temp = rivers
            rivers = newRivers
						newRivers = temp
						temp = riverLowers
            riverLowers = newRiverLowers
						newRiverLowers = temp
						for(let i of riverDists){
							if(i) i.fill(0)
						}
						temp = prevRiverDists
						prevRiverDists = newPrevRiverDists
						newPrevRiverDists = temp
						temp = prevRiverNormalDists
						prevRiverNormalDists = riverNormalDists
						riverNormalDists = temp
						temp = riverTwists
						riverTwists = newRiverTwists
						newRiverTwists = temp
        }
        
        //Create a heightmap for the rivers to flow down
				//done only if needed
        for(let cx=-5; cx<=5; cx++){
            for(let cz=-5; cz<=5; cz++){
                getHeightmap(cx,cz,heightmaps,(Math.floor(x/Scale)+cx),(Math.floor(z/Scale)+cz),Scale,riverLowers,true);
            }
        }
       	for(let cx=-3; cx<=3; cx++){
            for(let cz=-3; cz<=3; cz++){
                generateBaseRivers(cx,cz,Math.floor(x/Scale)+cx,Math.floor(z/Scale)+cz,rivers,heightmaps,prevRivers,zoom+1,riverLowers,Scale,riverDists,prevRiverDists)
            }
        }
				for(let i=0; i<twistIterations; i++){
					for(let cx=-1; cx<=1; cx++){
						for(let cz=-1; cz<=1; cz++){
							twistRivers(cx,cz,riverTwists,rivers,Scale,newRiverTwists,1)
						}
					}
					for(let cx=-1; cx<=1; cx++){
						for(let cz=-1; cz<=1; cz++){
							limitTwistRivers(cx,cz,newRiverTwists)
						}
					}
					let temp = riverTwists
					riverTwists = newRiverTwists
					newRiverTwists = temp
				}
				/*let riverThreshold = 5-(zoom/2)
				for(let cx=-3; cx<=3; cx++){
					for(let cz=-3; cz<=3; cz++){
						let w = wetness[(cx+center)*lwidth+cz+center]
						if(w) for(let i=0; i<w.length; i++){
							if(w[i] > riverThreshold){
								setRiver(cx+(i&15),cz+(i>>4),rivers)
								let rx = i&15, rz = i>>4
								for(let bx=-16;bx<=16;bx++){
									for(let bz=-16;bz<=16;bz++){
										const d = Math.abs(bx/16)+Math.abs(bz/16)//(x/16)**2+(z/16)**2
										if(d>=1) continue
										const lower = 1-approxCbrt(d/*Math.max((d-riverFlatDist),0)*riverFlatMult*-/)
										maxLower(rx+bx,rz+bz,riverDists,lower)
									}
								}
							}
						}
					}
				}*/
    }
    
		//getHeightmap(0,0,heightmaps,Math.floor(x/Scale),Math.floor(z/Scale),Scale,riverLowers);//Create a heightmap for the result
		let scaleBy = blocksPerFinalChunk/16
		prevScale = Scale, Scale *= scaleBy
		let offsetX = (Math.floor(x/Scale)*scaleBy - Math.floor(x/prevScale))*16
		let offsetZ = (Math.floor(z/Scale)*scaleBy - Math.floor(z/prevScale))*16
		let drawRivers = []
		for(let bx=offsetX-3; bx<offsetX+blocksPerFinalChunk+3; bx++){
			for(let bz=offsetZ-3; bz<offsetZ+blocksPerFinalChunk+3; bz++){
				let river = getRiver(bx,bz,rivers)
				if(!river) continue
				let pointingX = intToDir((river>>>2)&3), pointingZ = intToDir(river&3)
				let riverWidth = ((river>>>4)+1)/4096*16/blocksPerFinalChunk //1.5**(maxZoom-(river>>>4))-0.5
				let riverPrevWidth = riverWidth*blocksPerFinalChunk/16
				let twistX = getGridXZ(bx,bz,riverTwists), twistZ = getGridXZ(bx,bz,riverTwists,1)
				let twistPointingX = getGridXZ(bx+pointingX,bz+pointingZ,riverTwists), twistPointingZ = getGridXZ(bx+pointingX,bz+pointingZ,riverTwists,1)
				if(
					(bx+pointingX+twistPointingX+riverPrevWidth<offsetX || bx+pointingX+twistPointingX-riverPrevWidth>offsetX+blocksPerFinalChunk || bz+pointingZ+twistPointingZ+riverPrevWidth<offsetZ || bz+pointingZ+twistPointingZ-riverPrevWidth>offsetZ+blocksPerFinalChunk) &&
					(bx+twistX+riverPrevWidth<offsetX || bx+twistX-riverPrevWidth>offsetX+blocksPerFinalChunk || bz+twistZ+riverPrevWidth<offsetZ || bz+twistZ-riverPrevWidth>offsetZ+blocksPerFinalChunk)
				) continue
				let fcs = 16/blocksPerFinalChunk
				drawRivers.push((bx-offsetX+twistX)*fcs,(bz-offsetZ+twistZ)*fcs,(bx-offsetX+twistPointingX+pointingX)*fcs,(bz-offsetZ+twistPointingZ+pointingZ)*fcs, riverWidth)
			}
		}
		/*for(let cx=-1; cx<=1; cx++){
			for(let cz=-1; cz<=1; cz++){
				for(let bx=0;bx<16;bx++){
					for(let bz=0;bz<16;bz++){
						let bx2 = bx+cx*16, bz2 = bz+cz*16
						let river = getRiver(bx2,bz2,rivers)
						if(river){
							let riverWidth = 1.5**(maxZoom-(river>>>4))-0.75
							let deepness = 1-(river>>>4)/maxZoom
							if(bx2<-riverWidth || bx2>riverWidth+16 || bz2<-riverWidth || bz2>riverWidth+16) continue
							for(let rx=Math.round(Math.min(Math.max(bx2-riverWidth,0),15)); rx<=Math.round(Math.min(Math.max(bx2+riverWidth,0),15)); rx++){//this clamps so it only sets in current chunk
								for(let rz=Math.round(Math.min(Math.max(bz2-riverWidth,0),15)); rz<=Math.round(Math.min(Math.max(bz2+riverWidth,0),15)); rz++){
									let dist = (rx-bx2)*(rx-bx2)/riverWidth + (rz-bz2)*(rz-bz2)/riverWidth
									if(dist<1) isRiverWithWidth[rx*16+rz] = Math.max(isRiverWithWidth[rx*16+rz], (1-dist)*deepness)
								}
							}
						}
					}
				}
			}
		}*/
    for(let bx=0;bx<16;bx++){
        for(let bz=0;bz<16;bz++){
						//let finalHeight = getHeight(bx,bz,heightmaps)
						let river = 0//isRiverWithWidth[bx*16+bz]
						let riverSize = 0
						for(let di=0; di<drawRivers.length; di+=5){
							let thisriver = 1-lineToPointSq(bx,bz, drawRivers[di],drawRivers[di+1],drawRivers[di+2],drawRivers[di+3])/drawRivers[di+4]
							river = Math.max(river, thisriver)
							if(thisriver>0) riverSize = Math.max(riverSize, drawRivers[di+4]*thisriver)
						}
						//isRiverWithWidth[bx*16+bz] = 0
						//rivers[center*lwidth+center/*middle*/]&&rivers[center*lwidth+center/*middle*/][bz*16+bx]||0
						let btx, btz, btlax, btlaz//before twist, before twist lerp amount
						btloop:for(btx=offsetX-2; btx<offsetX+blocksPerFinalChunk+2; btx++){
							for(btz=offsetZ-2; btz<offsetZ+blocksPerFinalChunk+2; btz++){
								let x1 = btx+getGridXZ(btx,btz,riverTwists), z1 = btz+getGridXZ(btx,btz,riverTwists,1)
								let x2 = btx+1+getGridXZ(btx+1,btz,riverTwists), z2 = btz+getGridXZ(btx+1,btz,riverTwists,1)
								let x3 = btx+1+getGridXZ(btx+1,btz+1,riverTwists), z3 = btz+1+getGridXZ(btx+1,btz+1,riverTwists,1)
								let x4 = btx+getGridXZ(btx,btz+1,riverTwists), z4 = btz+1+getGridXZ(btx,btz+1,riverTwists,1)
								if(pointInQuad(x1,z1,x2,z2,x3,z3,x4,z4, bx*scaleBy+offsetX, bz*scaleBy+offsetZ)){
									transformQuadri(x1,z1,x2,z2,x3,z3,x4,z4, bx*scaleBy+offsetX, bz*scaleBy+offsetZ)
									btlax = transformQuadri.xc
									btlaz = transformQuadri.yc
									break btloop
								}
							}
						}
						//if(isNaN(btlax)) throw new Error("river twisted grid node not found")
						//let lower = getRiver(bx,bz,riverLowers)||0, dist = Math.max(getRiver(bx,bz,riverDists)||0,getRiver(bx,bz,prevRiverDists)||0)
						/*if(river){
							riverHeight = river//mapFrom(getRiver(bx,bz,riverScales)||0, Scale*0.8,1)//mapFrom(r,0.4,1)*255
							//finalHeight = Math.max(finalHeight,0)-0.025
						}*/
						//if(dist>0.8) finalHeight -= map(dist,0.8,1,0,0.01)
						getHeight.scale = prevScale
						getHeight.offsetX = Math.floor(x/prevScale)*16
						getHeight.offsetZ = Math.floor(z/prevScale)*16
						riverHeights[bz*16+bx] = riverSize/2
						/*riverFinalLowers[bz*16+bx] = lerp(btlax,
							lerp(btlaz,
								getRiver(btx,btz,riverLowers),
								getRiver(btx,btz+1,riverLowers)
							),
							lerp(btlaz,
								getRiver(btx+1,btz,riverLowers),
								getRiver(btx+1,btz+1,riverLowers)
							)
						)*/
						riverLoweredHeight[bz*16+bx] = lerp(btlax,
							lerp(btlaz,
								getHeight(btx,btz,heightmaps,riverLowers),
								getHeight(btx,btz+1,heightmaps,riverLowers)
							),
							lerp(btlaz,
								getHeight(btx+1,btz,heightmaps,riverLowers),
								getHeight(btx+1,btz+1,heightmaps,riverLowers)
							)
						)
						riverFinalDists[bz*16+bx] = lerp(btlax,
							lerp(btlaz,
								Math.max(getRiver(btx,btz,riverDists),getRiver(btx,btz,prevRiverDists)),
								Math.max(getRiver(btx,btz+1,riverDists),getRiver(btx,btz+1,prevRiverDists))
							),
							lerp(btlaz,
								Math.max(getRiver(btx+1,btz,riverDists),getRiver(btx+1,btz,prevRiverDists)),
								Math.max(getRiver(btx+1,btz+1,riverDists),getRiver(btx+1,btz+1,prevRiverDists))
							)
						)
						riverFinalNormalDists[bz*16+bx] = lerp(btlax,
							lerp(btlaz,
								getRiver(btx,btz,riverNormalDists),
								getRiver(btx,btz+1,riverNormalDists)
							),
							lerp(btlaz,
								getRiver(btx+1,btz,riverNormalDists),
								getRiver(btx+1,btz+1,riverNormalDists)
							)
						)
						//if(btlax<0.1 || btlax>0.9 || btlaz<0.1||btlaz>0.9)finalHeight=-1
						//if(btlax!==undefined)riverLoweredHeight[bz*16+bx]=-hash(btx,btz)
        }
    }
}
generateChunk.riverScale = blocksPerFinalChunk/16 * zoomScaleBy**(maxZoom-1)
generateRiverChunk = generateChunk
}
//below function from https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment  and modified
function lineToPointSq(x, y, x1, y1, x2, y2) {
  var A = x - x1;
  var B = y - y1;
  var C = x2 - x1;
  var D = y2 - y1;

  var dot = A * C + B * D;
  var len_sq = C * C + D * D;
  var param = -1;
  if (len_sq !== 0){ //in case of 0 length line
      param = dot / len_sq;
  }

  var xx, yy;

  if (param < 0) {
    xx = x1;
    yy = y1;
  }
  else if (param > 1) {
    xx = x2;
    yy = y2;
  }
  else {
    xx = x1 + param * C;
    yy = y1 + param * D;
  }

  var dx = x - xx;
  var dy = y - yy;
  lineToPointSq.xx = xx;
  lineToPointSq.yy = yy;
  return dx * dx + dy * dy;
}

function transformQuadri(x1,y1,x2,y2,x3,y3,x4,y4, x, y) {
	//from https://gitlab.com/gaelysam/mapgen_rivers/-/blob/master/geometry.lua and modified
	// To index points in an irregular quadrilateral, giving x and y between 0 (one edge) and 1 (opposite edge)
	// X, Y 4-vectors giving the coordinates of the 4 vertices
	// x, y position to index.
	// Compare distance to 2 opposite edges, they give the X coordinate
	//more effecient & accurate to use cross product than distance to segment
	var d23 = (x3 - x2)*(y - y2) - (y3 - y2)*(x - x2)
	var d41 = (x1 - x4)*(y - y4) - (y1 - y4)*(x - x4)
	var xc = d41 / (d23+d41);
	// Same for the 2 other edges, they give the Y coordinate
	var d12 = (x2 - x1)*(y - y1) - (y2 - y1)*(x - x1)
	var d34 = (x4 - x3)*(y - y3) - (y4 - y3)*(x - x3)
	var yc = d12 / (d12+d34);
	transformQuadri.xc = xc
	transformQuadri.yc = yc
}
function pointInQuad(x1,y1,x2,y2,x3,y3,x4,y4, x, y){
	return (
		(x2 - x1)*(y - y1) - (y2 - y1)*(x - x1) >= 0 &&
		(x3 - x2)*(y - y2) - (y3 - y2)*(x - x2) >= 0 &&
		(x4 - x3)*(y - y3) - (y4 - y3)*(x - x3) >= 0 &&
		(x1 - x4)*(y - y4) - (y1 - y4)*(x - x4) >= 0 )
}
		
const splineData = {
	"offset":{"coordinate":"continents","points":[
		{"location":-1.1,"value":0.044,"derivative":0},
		{"location":-1.02,"value":-0.2222,"derivative":0},
		{"location":-0.51,"value":-0.2222,"derivative":0},
		{"location":-0.44,"value":-0.12,"derivative":0},
		{"location":-0.2,"value":-0.12,"derivative":0},
		{"location":-0.16,"value":{"coordinate":"erosion","points":[
			{"location":-0.85,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.08880186,"derivative":0.38940096},{"location":1,"value":0.69000006,"derivative":0.38940096}]},"derivative":0},
			{"location":-0.7,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.115760356,"derivative":0.37788022},{"location":1,"value":0.6400001,"derivative":0.37788022}]},"derivative":0},
			{"location":-0.4,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.2222,"derivative":0},{"location":-0.75,"value":-0.2222,"derivative":0},{"location":-0.65,"value":0,"derivative":0},{"location":0.5954547,"value":2.9802322e-8,"derivative":0},{"location":0.6054547,"value":2.9802322e-8,"derivative":0.2534563},{"location":1,"value":0.05,"derivative":0.2534563}]},"derivative":0},
			{"location":-0.35,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.3,"derivative":0.5},{"location":-0.4,"value":0.025,"derivative":0},{"location":0,"value":0.025,"derivative":0},{"location":0.4,"value":0.025,"derivative":0},{"location":1,"value":0.03,"derivative":0.007000001}]},"derivative":0},
			{"location":-0.1,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.15,"derivative":0.5},{"location":-0.4,"value":0,"derivative":0},{"location":0,"value":0,"derivative":0},{"location":0.4,"value":0.025,"derivative":0.1},{"location":1,"value":0.03,"derivative":0.007000001}]},"derivative":0},
			{"location":0.2,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.15,"derivative":0.5},{"location":-0.4,"value":0,"derivative":0},{"location":0,"value":0,"derivative":0},{"location":0.4,"value":0,"derivative":0},{"location":1,"value":0,"derivative":0}]},"derivative":0},
			{"location":0.7,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.02,"derivative":0},{"location":-0.4,"value":-0.03,"derivative":0},{"location":0,"value":-0.03,"derivative":0},{"location":0.4,"value":0,"derivative":0.06},{"location":1,"value":0,"derivative":0}]},"derivative":0}
		]},"derivative":0},
		{"location":-0.125,"value":{"coordinate":"erosion","points":[
			{"location":-0.85,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.08880186,"derivative":0.38940096},{"location":1,"value":0.69000006,"derivative":0.38940096}]},"derivative":0},
			{"location":-0.7,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.115760356,"derivative":0.37788022},{"location":1,"value":0.6400001,"derivative":0.37788022}]},"derivative":0},
			{"location":-0.4,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.2222,"derivative":0},{"location":-0.75,"value":-0.2222,"derivative":0},{"location":-0.65,"value":0,"derivative":0},{"location":0.5954547,"value":2.9802322e-8,"derivative":0},{"location":0.6054547,"value":2.9802322e-8,"derivative":0.2534563},{"location":1,"value":0.05,"derivative":0.2534563}]},"derivative":0},
			{"location":-0.35,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.3,"derivative":0.5},{"location":-0.4,"value":0.025,"derivative":0},{"location":0,"value":0.025,"derivative":0},{"location":0.4,"value":0.025,"derivative":0},{"location":1,"value":0.03,"derivative":0.007000001}]},"derivative":0},
			{"location":-0.1,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.15,"derivative":0.5},{"location":-0.4,"value":0,"derivative":0},{"location":0,"value":0,"derivative":0},{"location":0.4,"value":0.025,"derivative":0.1},{"location":1,"value":0.03,"derivative":0.007000001}]},"derivative":0},
			{"location":0.2,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.15,"derivative":0.5},{"location":-0.4,"value":0,"derivative":0},{"location":0,"value":0,"derivative":0},{"location":0.4,"value":0,"derivative":0},{"location":1,"value":0,"derivative":0}]},"derivative":0},
			{"location":0.7,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.02,"derivative":0},{"location":-0.4,"value":-0.03,"derivative":0},{"location":0,"value":-0.03,"derivative":0},{"location":0.4,"value":0,"derivative":0.06},{"location":1,"value":0,"derivative":0}]},"derivative":0}
		]},"derivative":0},
		{"location":-0.1,"value":{"coordinate":"erosion","points":[
			{"location":-0.85,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.08880186,"derivative":0.38940096},{"location":1,"value":0.69000006,"derivative":0.38940096}]},"derivative":0},
			{"location":-0.7,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.115760356,"derivative":0.37788022},{"location":1,"value":0.6400001,"derivative":0.37788022}]},"derivative":0},
			{"location":-0.4,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.2222,"derivative":0},{"location":-0.75,"value":-0.2222,"derivative":0},{"location":-0.65,"value":0,"derivative":0},{"location":0.5954547,"value":2.9802322e-8,"derivative":0},{"location":0.6054547,"value":2.9802322e-8,"derivative":0.2534563},{"location":1,"value":0.100000024,"derivative":0.2534563}]},"derivative":0},
			{"location":-0.35,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.25,"derivative":0.5},{"location":-0.4,"value":0.05,"derivative":0},{"location":0,"value":0.05,"derivative":0},{"location":0.4,"value":0.05,"derivative":0},{"location":1,"value":0.060000002,"derivative":0.007000001}]},"derivative":0},
			{"location":-0.1,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.1,"derivative":0.5},{"location":-0.4,"value":0.001,"derivative":0.01},{"location":0,"value":0.003,"derivative":0.01},{"location":0.4,"value":0.05,"derivative":0.094000004},{"location":1,"value":0.060000002,"derivative":0.007000001}]},"derivative":0},
			{"location":0.2,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.1,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},
			{"location":0.7,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.02,"derivative":0},{"location":-0.4,"value":-0.03,"derivative":0},{"location":0,"value":-0.03,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.12},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0}
		]},"derivative":0},
		{"location":0.25,"value":{"coordinate":"erosion","points":[
			{"location":-0.85,"value":{"coordinate":"ridgesBig","points":[{"location":-1,"value":0.20235021,"derivative":0},{"location":0,"value":0.5,"derivative":0.5138249},{"location":1,"value":0.8,"derivative":0.5138249}]},"derivative":0},
			{"location":-0.7,"value":{"coordinate":"ridgesBig","points":[{"location":-1,"value":0.2,"derivative":0},{"location":0,"value":0.44682026,"derivative":0.43317974},{"location":1,"value":0.78,"derivative":0.43317974}]},"derivative":0},
			{"location":-0.4,"value":{"coordinate":"ridgesBig","points":[{"location":-1,"value":0.2,"derivative":0},{"location":0,"value":0.30829495,"derivative":0.3917051},{"location":1,"value":0.70000005,"derivative":0.3917051}]},"derivative":0},
			{"location":-0.35,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.25,"derivative":0.5},{"location":-0.4,"value":0.35,"derivative":0},{"location":0,"value":0.35,"derivative":0},{"location":0.4,"value":0.35,"derivative":0},{"location":1,"value":0.42000002,"derivative":0.049000014}]},"derivative":0},
			{"location":-0.1,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.1,"derivative":0.5},{"location":-0.4,"value":0.0069999998,"derivative":0.07},{"location":0,"value":0.021,"derivative":0.07},{"location":0.4,"value":0.35,"derivative":0.658},{"location":1,"value":0.42000002,"derivative":0.049000014}]},"derivative":0},
			{"location":0.2,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.1,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},
			{"location":0.4,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.1,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},
			{"location":0.45,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.1,"derivative":0},{"location":-0.4,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.1,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},{"location":0,"value":0.17,"derivative":0}]},"derivative":0},
			{"location":0.55,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.1,"derivative":0},{"location":-0.4,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.1,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},{"location":0,"value":0.17,"derivative":0}]},"derivative":0},
			{"location":0.58,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.1,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},
			{"location":0.7,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.02,"derivative":0},{"location":-0.4,"value":-0.03,"derivative":0},{"location":0,"value":-0.03,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.12},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0}
		]},"derivative":0},
		{"location":1,"value":{"coordinate":"erosion","points":[
			{"location":-0.85,"value":{"coordinate":"ridgesBig","points":[{"location":-1,"value":0.34792626,"derivative":0},{"location":0,"value":0.5,"derivative":0.5760369},{"location":1,"value":1,"derivative":0.5760369}]},"derivative":0},
			{"location":-0.7,"value":{"coordinate":"ridgesBig","points":[{"location":-1,"value":0.2,"derivative":0},{"location":0,"value":0.45,"derivative":0.4608295},{"location":1,"value":0.8,"derivative":0.4608295}]},"derivative":0},
			{"location":-0.4,"value":{"coordinate":"ridgesBig","points":[{"location":-1,"value":0.2,"derivative":0},{"location":0,"value":0.45,"derivative":0.4608295},{"location":1,"value":0.8,"derivative":0.4608295}]},"derivative":0},
			{"location":-0.35,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.2,"derivative":0.5},{"location":-0.4,"value":0.5,"derivative":0},{"location":0,"value":0.5,"derivative":0},{"location":0.4,"value":0.5,"derivative":0},{"location":1,"value":0.6,"derivative":0.070000015}]},"derivative":0},
			{"location":-0.1,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.05,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0.099999994},{"location":0,"value":0.03,"derivative":0.099999994},{"location":0.4,"value":0.5,"derivative":0.94},{"location":1,"value":0.6,"derivative":0.070000015}]},"derivative":0},
			{"location":0.2,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.05,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},
			{"location":0.4,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.05,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},
			{"location":0.45,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.05,"derivative":0},{"location":-0.4,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.05,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},{"location":0,"value":0.17,"derivative":0}]},"derivative":0},
			{"location":0.55,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.05,"derivative":0},{"location":-0.4,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.05,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},{"location":0,"value":0.17,"derivative":0}]},"derivative":0},
			{"location":0.58,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.05,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},
			{"location":0.7,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.02,"derivative":0.015},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0}
		]},"derivative":0}
	]},
	"factor":{"coordinate":"continents","points":[
		{"location":-0.2,"value":3.95,"derivative":0},
		{"location":-0.16,"value":{"coordinate":"erosion","points":[
			{"location":-0.6,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":6.25,"derivative":0}]},"derivative":0},
			{"location":-0.5,"value":{"coordinate":"weirdness","points":[{"location":-0.05,"value":6.3,"derivative":0},{"location":0.05,"value":2.67,"derivative":0}]},"derivative":0},
			{"location":-0.35,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":8.3,"derivative":0},{"location":0.2,"value":8.25,"derivative":0}]},"derivative":0},
			{"location":-0.25,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":8.3,"derivative":0},{"location":0.2,"value":8.25,"derivative":0}]},"derivative":0},
			{"location":-0.1,"value":{"coordinate":"weirdness","points":[{"location":-0.05,"value":4.67,"derivative":0},{"location":0.05,"value":8.3,"derivative":0}]},"derivative":0},
			{"location":0.03,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":8.3,"derivative":0},{"location":0.2,"value":8.25,"derivative":0}]},"derivative":0},
			{"location":0.35,"value":8.25,"derivative":0},
			{"location":0.45,"value":{"coordinate":"ridges","points":[{"location":-0.9,"value":8.25,"derivative":0},{"location":-0.69,"value":{"coordinate":"weirdness","points":[{"location":0,"value":8.25,"derivative":0},{"location":0.1,"value":0.625,"derivative":0}]},"derivative":0}]},"derivative":0},
			{"location":0.55,"value":{"coordinate":"ridges","points":[{"location":-0.9,"value":8.25,"derivative":0},{"location":-0.69,"value":{"coordinate":"weirdness","points":[{"location":0,"value":8.25,"derivative":0},{"location":0.1,"value":0.625,"derivative":0}]},"derivative":0}]},"derivative":0},
			{"location":0.62,"value":8.25,"derivative":0}
		]},"derivative":0},
		{"location":-0.1,"value":{"coordinate":"erosion","points":[
			{"location":-0.6,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":5.47,"derivative":0}]},"derivative":0},
			{"location":-0.5,"value":{"coordinate":"weirdness","points":[{"location":-0.05,"value":6.3,"derivative":0},{"location":0.05,"value":2.67,"derivative":0}]},"derivative":0},
			{"location":-0.35,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":8.3,"derivative":0},{"location":0.2,"value":7.47,"derivative":0}]},"derivative":0},
			{"location":-0.25,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":8.3,"derivative":0},{"location":0.2,"value":7.47,"derivative":0}]},"derivative":0},
			{"location":-0.1,"value":{"coordinate":"weirdness","points":[{"location":-0.05,"value":4.67,"derivative":0},{"location":0.05,"value":8.3,"derivative":0}]},"derivative":0},
			{"location":0.03,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":8.3,"derivative":0},{"location":0.2,"value":7.47,"derivative":0}]},"derivative":0},
			{"location":0.35,"value":5.47,"derivative":0},
			{"location":0.45,"value":{"coordinate":"ridges","points":[{"location":-0.9,"value":7.47,"derivative":0},{"location":-0.69,"value":{"coordinate":"weirdness","points":[{"location":0,"value":7.47,"derivative":0},{"location":0.1,"value":0.625,"derivative":0}]},"derivative":0}]},"derivative":0},
			{"location":0.55,"value":{"coordinate":"ridges","points":[{"location":-0.9,"value":7.47,"derivative":0},{"location":-0.69,"value":{"coordinate":"weirdness","points":[{"location":0,"value":7.47,"derivative":0},{"location":0.1,"value":0.625,"derivative":0}]},"derivative":0}]},"derivative":0},
			{"location":0.62,"value":7.47,"derivative":0}
		]},"derivative":0},
		{"location":0.03,"value":{"coordinate":"erosion","points":[
			{"location":-0.6,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":5.08,"derivative":0}]},"derivative":0},
			{"location":-0.5,"value":{"coordinate":"weirdness","points":[{"location":-0.05,"value":6.3,"derivative":0},{"location":0.05,"value":2.67,"derivative":0}]},"derivative":0},
			{"location":-0.35,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":5.08,"derivative":0}]},"derivative":0},
			{"location":-0.25,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":5.08,"derivative":0}]},"derivative":0},
			{"location":-0.1,"value":{"coordinate":"weirdness","points":[{"location":-0.05,"value":2.67,"derivative":0},{"location":0.05,"value":6.3,"derivative":0}]},"derivative":0},
			{"location":0.03,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":5.08,"derivative":0}]},"derivative":0},
			{"location":0.35,"value":5.08,"derivative":0},
			{"location":0.45,"value":{"coordinate":"ridges","points":[{"location":-0.9,"value":5.08,"derivative":0},{"location":-0.69,"value":{"coordinate":"weirdness","points":[{"location":0,"value":5.08,"derivative":0},{"location":0.1,"value":0.625,"derivative":0}]},"derivative":0}]},"derivative":0},
			{"location":0.55,"value":{"coordinate":"ridges","points":[{"location":-0.9,"value":5.08,"derivative":0},{"location":-0.69,"value":{"coordinate":"weirdness","points":[{"location":0,"value":5.08,"derivative":0},{"location":0.1,"value":0.625,"derivative":0}]},"derivative":0}]},"derivative":0},
			{"location":0.62,"value":5.08,"derivative":0}
		]},"derivative":0},
		{"location":0.06,"value":{"coordinate":"erosion","points":[
			{"location":-0.6,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":4.69,"derivative":0}]},"derivative":0},
			{"location":-0.5,"value":{"coordinate":"weirdness","points":[{"location":-0.05,"value":6.3,"derivative":0},{"location":0.05,"value":2.67,"derivative":0}]},"derivative":0},
			{"location":-0.35,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":4.69,"derivative":0}]},"derivative":0},
			{"location":-0.25,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":4.69,"derivative":0}]},"derivative":0},
			{"location":-0.1,"value":{"coordinate":"weirdness","points":[{"location":-0.05,"value":2.67,"derivative":0},{"location":0.05,"value":6.3,"derivative":0}]},"derivative":0},
			{"location":0.03,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":4.69,"derivative":0}]},"derivative":0},
			{"location":0.05,"value":{"coordinate":"ridges","points":[{"location":0.45,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":4.69,"derivative":0}]},"derivative":0},{"location":0.7,"value":1.56,"derivative":0}]},"derivative":0},
			{"location":0.4,"value":{"coordinate":"ridges","points":[{"location":0.45,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":4.69,"derivative":0}]},"derivative":0},{"location":0.7,"value":1.56,"derivative":0}]},"derivative":0},
			{"location":0.45,"value":{"coordinate":"ridges","points":[{"location":-0.7,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":4.69,"derivative":0}]},"derivative":0},{"location":-0.15,"value":1.37,"derivative":0}]},"derivative":0},
			{"location":0.55,"value":{"coordinate":"ridges","points":[{"location":-0.7,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":4.69,"derivative":0}]},"derivative":0},{"location":-0.15,"value":1.37,"derivative":0}]},"derivative":0},
			{"location":0.58,"value":4.69,"derivative":0}
		]},"derivative":0}
	]},
	"jaggedness":{"coordinate":"continents","points":[
		{"location":-0.11,"value":0,"derivative":0},
		{"location":0.03,"value":{"coordinate":"erosion","points":[
			{"location":-1,"value":{"coordinate":"ridges","points":[{"location":-0.9,"value":0,"derivative":0},{"location":1,"value":{"coordinate":"weirdness","points":[{"location":-0.1,"value":0.5,"derivative":0},{"location":0.1,"value":0.25,"derivative":0}]},"derivative":0.2}]},"derivative":0},
			{"location":-0.78,"value":{"coordinate":"ridges","points":[{"location":-0.9,"value":0,"derivative":0},{"location":1,"value":{"coordinate":"weirdness","points":[{"location":-0.1,"value":0.4,"derivative":0},{"location":0.1,"value":0.2,"derivative":0}]},"derivative":0.2}]},"derivative":0},
			{"location":-0.5775,"value":{"coordinate":"ridges","points":[{"location":-0.9,"value":0,"derivative":0},{"location":1,"value":{"coordinate":"weirdness","points":[{"location":-0.01,"value":0.4,"derivative":0},{"location":0.01,"value":0.2,"derivative":0}]},"derivative":0.2}]},"derivative":0},
			{"location":-0.375,"value":0,"derivative":0}
		]},"derivative":0},
		{"location":0.65,"value":{"coordinate":"erosion","points":[
			{"location":-1,"value":{"coordinate":"ridgesBig","points":[{"location":-0.9,"value":0,"derivative":0},{"location":1,"value":{"coordinate":"weirdness","points":[{"location":-0.1,"value":1,"derivative":0},{"location":0.1,"value":0.5,"derivative":0}]},"derivative":0.3}]},"derivative":0},
			{"location":-0.78,"value":{"coordinate":"ridgesBig","points":[{"location":-0.9,"value":0,"derivative":0},{"location":1,"value":{"coordinate":"weirdness","points":[{"location":-0.1,"value":1,"derivative":0},{"location":0.1,"value":0.5,"derivative":0}]},"derivative":0.3}]},"derivative":0},
			{"location":-0.5775,"value":{"coordinate":"ridgesBig","points":[{"location":-0.9,"value":0,"derivative":0},{"location":1,"value":{"coordinate":"weirdness","points":[{"location":-0.1,"value":1,"derivative":0},{"location":0.1,"value":0.5,"derivative":0}]},"derivative":0.3}]},"derivative":0},
			{"location":-0.375,"value":0,"derivative":0}
		]},"derivative":0}
	]}
}
/*attempt at better mountains below
{
	"offset":{"coordinate":"continents","points":[
		{"location":-1.1,"value":0.044,"derivative":0},
		{"location":-1.02,"value":-0.2222,"derivative":0},
		{"location":-0.51,"value":-0.2222,"derivative":0},
		{"location":-0.44,"value":-0.12,"derivative":0},
		{"location":-0.2,"value":-0.12,"derivative":0},
		{"location":-0.16,"value":{"coordinate":"erosion","points":[
			{"location":-0.85,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.08880186,"derivative":0.38940096},{"location":1,"value":0.19,"derivative":0}]},"derivative":0},
			{"location":-0.7,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.115760356,"derivative":0.37788022},{"location":1,"value":0.17,"derivative":0}]},"derivative":0},
			{"location":-0.4,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.2222,"derivative":0},{"location":-0.75,"value":-0.2222,"derivative":0},{"location":-0.65,"value":0,"derivative":0},{"location":0.5954547,"value":2.9802322e-8,"derivative":0},{"location":0.6054547,"value":2.9802322e-8,"derivative":0.2534563},{"location":1,"value":0.05,"derivative":0.2534563}]},"derivative":0},
			{"location":-0.35,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.3,"derivative":0.5},{"location":-0.4,"value":0.025,"derivative":0},{"location":0,"value":0.025,"derivative":0},{"location":0.4,"value":0.025,"derivative":0},{"location":1,"value":0.03,"derivative":0.007000001}]},"derivative":0},
			{"location":-0.1,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.15,"derivative":0.5},{"location":-0.4,"value":0,"derivative":0},{"location":0,"value":0,"derivative":0},{"location":0.4,"value":0.025,"derivative":0.1},{"location":1,"value":0.03,"derivative":0.007000001}]},"derivative":0},
			{"location":0.2,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.15,"derivative":0.5},{"location":-0.4,"value":0,"derivative":0},{"location":0,"value":0,"derivative":0},{"location":0.4,"value":0,"derivative":0},{"location":1,"value":0,"derivative":0}]},"derivative":0},
			{"location":0.7,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.02,"derivative":0},{"location":-0.4,"value":-0.03,"derivative":0},{"location":0,"value":-0.03,"derivative":0},{"location":0.4,"value":0,"derivative":0.06},{"location":1,"value":0,"derivative":0}]},"derivative":0}
		]},"derivative":0},
		{"location":-0.125,"value":{"coordinate":"erosion","points":[
			{"location":-0.85,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.08880186,"derivative":0.38940096},{"location":1,"value":0.2,"derivative":0}]},"derivative":0},
			{"location":-0.7,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.115760356,"derivative":0.37788022},{"location":1,"value":0.19,"derivative":0}]},"derivative":0},
			{"location":-0.4,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.2222,"derivative":0},{"location":-0.75,"value":-0.2222,"derivative":0},{"location":-0.65,"value":0,"derivative":0},{"location":0.5954547,"value":2.9802322e-8,"derivative":0},{"location":0.6054547,"value":2.9802322e-8,"derivative":0.2534563},{"location":1,"value":0.05,"derivative":0.2534563}]},"derivative":0},
			{"location":-0.35,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.3,"derivative":0.5},{"location":-0.4,"value":0.025,"derivative":0},{"location":0,"value":0.025,"derivative":0},{"location":0.4,"value":0.025,"derivative":0},{"location":1,"value":0.03,"derivative":0.007000001}]},"derivative":0},
			{"location":-0.1,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.15,"derivative":0.5},{"location":-0.4,"value":0,"derivative":0},{"location":0,"value":0,"derivative":0},{"location":0.4,"value":0.025,"derivative":0.1},{"location":1,"value":0.03,"derivative":0.007000001}]},"derivative":0},
			{"location":0.2,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.15,"derivative":0.5},{"location":-0.4,"value":0,"derivative":0},{"location":0,"value":0,"derivative":0},{"location":0.4,"value":0,"derivative":0},{"location":1,"value":0,"derivative":0}]},"derivative":0},
			{"location":0.7,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.02,"derivative":0},{"location":-0.4,"value":-0.03,"derivative":0},{"location":0,"value":-0.03,"derivative":0},{"location":0.4,"value":0,"derivative":0.06},{"location":1,"value":0,"derivative":0}]},"derivative":0}
		]},"derivative":0},
		{"location":-0.1,"value":{"coordinate":"erosion","points":[
			{"location":-0.85,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.08880186,"derivative":0.38940096},{"location":1,"value":0.3,"derivative":0}]},"derivative":0},
			{"location":-0.7,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.115760356,"derivative":0.37788022},{"location":1,"value":0.25,"derivative":0}]},"derivative":0},
			{"location":-0.4,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.2222,"derivative":0},{"location":-0.75,"value":-0.2222,"derivative":0},{"location":-0.65,"value":0,"derivative":0},{"location":0.5954547,"value":2.9802322e-8,"derivative":0},{"location":0.6054547,"value":2.9802322e-8,"derivative":0.2534563},{"location":1,"value":0.100000024,"derivative":0.2534563}]},"derivative":0},
			{"location":-0.35,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.25,"derivative":0.5},{"location":-0.4,"value":0.05,"derivative":0},{"location":0,"value":0.05,"derivative":0},{"location":0.4,"value":0.05,"derivative":0},{"location":1,"value":0.060000002,"derivative":0.007000001}]},"derivative":0},
			{"location":-0.1,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.1,"derivative":0.5},{"location":-0.4,"value":0.001,"derivative":0.01},{"location":0,"value":0.003,"derivative":0.01},{"location":0.4,"value":0.05,"derivative":0.094000004},{"location":1,"value":0.060000002,"derivative":0.007000001}]},"derivative":0},
			{"location":0.2,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.1,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},
			{"location":0.7,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.02,"derivative":0},{"location":-0.4,"value":-0.03,"derivative":0},{"location":0,"value":-0.03,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.12},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0}
		]},"derivative":0},
		{"location":0.25,"value":{"coordinate":"erosion","points":[
			{"location":-0.85,"value":{"coordinate":"ridgesBig","points":[{"location":-1,"value":0.2,"derivative":0},{"location":0,"value":0.28,"derivative":0},{"location":1,"value":0.425,"derivative":0}]},"derivative":0},
			{"location":-0.7,"value":{"coordinate":"ridgesBig","points":[{"location":-1,"value":0.19,"derivative":0},{"location":0,"value":0.27,"derivative":0},{"location":1,"value":0.425,"derivative":0}]},"derivative":0},
			{"location":-0.4,"value":{"coordinate":"ridgesBig","points":[{"location":-1,"value":0.1,"derivative":0},{"location":0,"value":0.2,"derivative":0},{"location":1,"value":0.3,"derivative":0}]},"derivative":0},
			{"location":-0.25,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.25,"derivative":0.5},{"location":-0.4,"value":0.1,"derivative":0},{"location":0,"value":0.1,"derivative":0},{"location":0.4,"value":0.1,"derivative":0},{"location":1,"value":0.2,"derivative":0.049000014}]},"derivative":0},
			{"location":-0.1,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.1,"derivative":0.5},{"location":-0.4,"value":0.0069999998,"derivative":0.07},{"location":0,"value":0.021,"derivative":0.07},{"location":0.4,"value":0.1,"derivative":0.658},{"location":1,"value":0.2,"derivative":0.049000014}]},"derivative":0},
			{"location":0.2,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.1,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},
			{"location":0.4,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.1,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},
			{"location":0.45,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.1,"derivative":0},{"location":-0.4,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.1,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},{"location":0,"value":0.17,"derivative":0}]},"derivative":0},
			{"location":0.55,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.1,"derivative":0},{"location":-0.4,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.1,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},{"location":0,"value":0.17,"derivative":0}]},"derivative":0},
			{"location":0.58,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.1,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},
			{"location":0.7,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.02,"derivative":0},{"location":-0.4,"value":-0.03,"derivative":0},{"location":0,"value":-0.03,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.12},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0}
		]},"derivative":0},
		{"location":1,"value":{"coordinate":"erosion","points":[
			{"location":-0.85,"value":{"coordinate":"ridgesBig","points":[{"location":-1,"value":0.2,"derivative":0},{"location":0,"value":0.3,"derivative":0.1},{"location":1,"value":0.45,"derivative":0}]},"derivative":0},
			{"location":-0.7,"value":{"coordinate":"ridgesBig","points":[{"location":-1,"value":0.19,"derivative":0},{"location":0,"value":0.29,"derivative":0.1},{"location":1,"value":0.45,"derivative":0}]},"derivative":0},
			{"location":-0.4,"value":{"coordinate":"ridgesBig","points":[{"location":-1,"value":0.1,"derivative":0},{"location":0,"value":0.2,"derivative":0.3},{"location":1,"value":0.4,"derivative":0}]},"derivative":0},
			{"location":-0.25,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.2,"derivative":0.5},{"location":-0.4,"value":0.15,"derivative":0},{"location":0,"value":0.15,"derivative":0},{"location":0.4,"value":0.15,"derivative":0},{"location":1,"value":0.25,"derivative":0.070000015}]},"derivative":0},
			{"location":-0.1,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.05,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0.099999994},{"location":0,"value":0.03,"derivative":0.099999994},{"location":0.4,"value":0.15,"derivative":0.94},{"location":1,"value":0.25,"derivative":0.070000015}]},"derivative":0},
			{"location":0.2,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.05,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},
			{"location":0.4,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.05,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},
			{"location":0.45,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.05,"derivative":0},{"location":-0.4,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.05,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},{"location":0,"value":0.17,"derivative":0}]},"derivative":0},
			{"location":0.55,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.05,"derivative":0},{"location":-0.4,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.05,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},{"location":0,"value":0.17,"derivative":0}]},"derivative":0},
			{"location":0.58,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.05,"derivative":0.5},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0},
			{"location":0.7,"value":{"coordinate":"ridges","points":[{"location":-1,"value":-0.02,"derivative":0.015},{"location":-0.4,"value":0.01,"derivative":0},{"location":0,"value":0.01,"derivative":0},{"location":0.4,"value":0.03,"derivative":0.04},{"location":1,"value":0.1,"derivative":0.049}]},"derivative":0}
		]},"derivative":0}
	]},
	"factor":{"coordinate":"continents","points":[
		{"location":-0.2,"value":3.95,"derivative":0},
		{"location":-0.16,"value":{"coordinate":"erosion","points":[
			{"location":-0.6,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":6.25,"derivative":0}]},"derivative":0},
			{"location":-0.5,"value":{"coordinate":"weirdness","points":[{"location":-0.05,"value":6.3,"derivative":0},{"location":0.05,"value":2.67,"derivative":0}]},"derivative":0},
			{"location":-0.35,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":8.3,"derivative":0},{"location":0.2,"value":8.25,"derivative":0}]},"derivative":0},
			{"location":-0.25,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":8.3,"derivative":0},{"location":0.2,"value":8.25,"derivative":0}]},"derivative":0},
			{"location":-0.1,"value":{"coordinate":"weirdness","points":[{"location":-0.05,"value":4.67,"derivative":0},{"location":0.05,"value":8.3,"derivative":0}]},"derivative":0},
			{"location":0.03,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":8.3,"derivative":0},{"location":0.2,"value":8.25,"derivative":0}]},"derivative":0},
			{"location":0.35,"value":8.25,"derivative":0},
			{"location":0.45,"value":{"coordinate":"ridges","points":[{"location":-0.9,"value":8.25,"derivative":0},{"location":-0.69,"value":{"coordinate":"weirdness","points":[{"location":0,"value":8.25,"derivative":0},{"location":0.1,"value":0.625,"derivative":0}]},"derivative":0}]},"derivative":0},
			{"location":0.55,"value":{"coordinate":"ridges","points":[{"location":-0.9,"value":8.25,"derivative":0},{"location":-0.69,"value":{"coordinate":"weirdness","points":[{"location":0,"value":8.25,"derivative":0},{"location":0.1,"value":0.625,"derivative":0}]},"derivative":0}]},"derivative":0},
			{"location":0.62,"value":8.25,"derivative":0}
		]},"derivative":0},
		{"location":-0.1,"value":{"coordinate":"erosion","points":[
			{"location":-0.6,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":5.47,"derivative":0}]},"derivative":0},
			{"location":-0.5,"value":{"coordinate":"weirdness","points":[{"location":-0.05,"value":6.3,"derivative":0},{"location":0.05,"value":2.67,"derivative":0}]},"derivative":0},
			{"location":-0.35,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":8.3,"derivative":0},{"location":0.2,"value":7.47,"derivative":0}]},"derivative":0},
			{"location":-0.25,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":8.3,"derivative":0},{"location":0.2,"value":7.47,"derivative":0}]},"derivative":0},
			{"location":-0.1,"value":{"coordinate":"weirdness","points":[{"location":-0.05,"value":4.67,"derivative":0},{"location":0.05,"value":8.3,"derivative":0}]},"derivative":0},
			{"location":0.03,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":8.3,"derivative":0},{"location":0.2,"value":7.47,"derivative":0}]},"derivative":0},
			{"location":0.35,"value":5.47,"derivative":0},
			{"location":0.45,"value":{"coordinate":"ridges","points":[{"location":-0.9,"value":7.47,"derivative":0},{"location":-0.69,"value":{"coordinate":"weirdness","points":[{"location":0,"value":7.47,"derivative":0},{"location":0.1,"value":0.625,"derivative":0}]},"derivative":0}]},"derivative":0},
			{"location":0.55,"value":{"coordinate":"ridges","points":[{"location":-0.9,"value":7.47,"derivative":0},{"location":-0.69,"value":{"coordinate":"weirdness","points":[{"location":0,"value":7.47,"derivative":0},{"location":0.1,"value":0.625,"derivative":0}]},"derivative":0}]},"derivative":0},
			{"location":0.62,"value":7.47,"derivative":0}
		]},"derivative":0},
		{"location":0.03,"value":{"coordinate":"erosion","points":[
			{"location":-0.6,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":5.08,"derivative":0}]},"derivative":0},
			{"location":-0.5,"value":{"coordinate":"weirdness","points":[{"location":-0.05,"value":6.3,"derivative":0},{"location":0.05,"value":2.67,"derivative":0}]},"derivative":0},
			{"location":-0.35,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":5.08,"derivative":0}]},"derivative":0},
			{"location":-0.25,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":5.08,"derivative":0}]},"derivative":0},
			{"location":-0.1,"value":{"coordinate":"weirdness","points":[{"location":-0.05,"value":2.67,"derivative":0},{"location":0.05,"value":6.3,"derivative":0}]},"derivative":0},
			{"location":0.03,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":5.08,"derivative":0}]},"derivative":0},
			{"location":0.35,"value":5.08,"derivative":0},
			{"location":0.45,"value":{"coordinate":"ridges","points":[{"location":-0.9,"value":5.08,"derivative":0},{"location":-0.69,"value":{"coordinate":"weirdness","points":[{"location":0,"value":5.08,"derivative":0},{"location":0.1,"value":0.625,"derivative":0}]},"derivative":0}]},"derivative":0},
			{"location":0.55,"value":{"coordinate":"ridges","points":[{"location":-0.9,"value":5.08,"derivative":0},{"location":-0.69,"value":{"coordinate":"weirdness","points":[{"location":0,"value":5.08,"derivative":0},{"location":0.1,"value":0.625,"derivative":0}]},"derivative":0}]},"derivative":0},
			{"location":0.62,"value":5.08,"derivative":0}
		]},"derivative":0},
		{"location":0.06,"value":{"coordinate":"erosion","points":[
			{"location":-0.6,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":4.69,"derivative":0}]},"derivative":0},
			{"location":-0.5,"value":{"coordinate":"weirdness","points":[{"location":-0.05,"value":6.3,"derivative":0},{"location":0.05,"value":2.67,"derivative":0}]},"derivative":0},
			{"location":-0.35,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":4.69,"derivative":0}]},"derivative":0},
			{"location":-0.25,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":4.69,"derivative":0}]},"derivative":0},
			{"location":-0.1,"value":{"coordinate":"weirdness","points":[{"location":-0.05,"value":2.67,"derivative":0},{"location":0.05,"value":6.3,"derivative":0}]},"derivative":0},
			{"location":0.03,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":4.69,"derivative":0}]},"derivative":0},
			{"location":0.05,"value":{"coordinate":"ridges","points":[{"location":0.45,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":4.69,"derivative":0}]},"derivative":0},{"location":0.7,"value":1.56,"derivative":0}]},"derivative":0},
			{"location":0.4,"value":{"coordinate":"ridges","points":[{"location":0.45,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":4.69,"derivative":0}]},"derivative":0},{"location":0.7,"value":1.56,"derivative":0}]},"derivative":0},
			{"location":0.45,"value":{"coordinate":"ridges","points":[{"location":-0.7,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":4.69,"derivative":0}]},"derivative":0},{"location":-0.15,"value":1.37,"derivative":0}]},"derivative":0},
			{"location":0.55,"value":{"coordinate":"ridges","points":[{"location":-0.7,"value":{"coordinate":"weirdness","points":[{"location":-0.2,"value":6.3,"derivative":0},{"location":0.2,"value":4.69,"derivative":0}]},"derivative":0},{"location":-0.15,"value":1.37,"derivative":0}]},"derivative":0},
			{"location":0.58,"value":4.69,"derivative":0}
		]},"derivative":0}
	]},
	"jaggedness":{"coordinate":"continents","points":[
		{"location":-0.11,"value":0,"derivative":0},
		{"location":0.1,"value":{"coordinate":"erosion","points":[
			{"location":-1,"value":{"coordinate":"ridges","points":[{"location":-0.9,"value":0,"derivative":0},{"location":1,"value":{"coordinate":"weirdness","points":[{"location":-0.1,"value":0.5,"derivative":0},{"location":0.1,"value":0.25,"derivative":0}]},"derivative":0.2}]},"derivative":0},
			{"location":-0.78,"value":{"coordinate":"ridges","points":[{"location":-0.9,"value":0,"derivative":0},{"location":1,"value":{"coordinate":"weirdness","points":[{"location":-0.1,"value":0.4,"derivative":0},{"location":0.1,"value":0.2,"derivative":0}]},"derivative":0.2}]},"derivative":0},
			{"location":-0.5775,"value":{"coordinate":"ridges","points":[{"location":-0.9,"value":0,"derivative":0},{"location":1,"value":{"coordinate":"weirdness","points":[{"location":-0.01,"value":0.4,"derivative":0},{"location":0.01,"value":0.2,"derivative":0}]},"derivative":0.2}]},"derivative":0},
			{"location":-0.375,"value":0,"derivative":0}
		]},"derivative":0},
		{"location":0.6,"value":{"coordinate":"erosion","points":[
			{"location":-1,"value":{"coordinate":"ridgesBig","points":[{"location":-0.9,"value":0,"derivative":0},{"location":1,"value":{"coordinate":"weirdness","points":[{"location":-0.1,"value":1,"derivative":0},{"location":0.1,"value":0.5,"derivative":0}]},"derivative":0.3}]},"derivative":0},
			{"location":-0.78,"value":{"coordinate":"ridgesBig","points":[{"location":-0.9,"value":0,"derivative":0},{"location":1,"value":{"coordinate":"weirdness","points":[{"location":-0.1,"value":1,"derivative":0},{"location":0.1,"value":0.5,"derivative":0}]},"derivative":0.3}]},"derivative":0},
			{"location":-0.5775,"value":{"coordinate":"ridgesBig","points":[{"location":-0.9,"value":0,"derivative":0},{"location":1,"value":{"coordinate":"weirdness","points":[{"location":-0.1,"value":1,"derivative":0},{"location":0.1,"value":0.5,"derivative":0}]},"derivative":0.3}]},"derivative":0},
			{"location":-0.375,"value":0,"derivative":0}
		]},"derivative":0}
	]}
}*/
function sortSplineLayer(o){
		o.points.sort(function(a,b){return a.location-b.location;});
		for(let j=0; j<o.points.length; j++){
				const point = o.points[j];
				if(typeof point.value === "object"){
						sortSplineLayer(point.value);
				}
		}
}
for(let i in splineData){
		sortSplineLayer(splineData[i]);
}
function getSplineLayer(o,continents,erosion,ridges,weirdness,ridgesBig){
	if(typeof o === "number"){return o;}
	let x;
	switch(o.coordinate){
			case "continents": x = continents; break;
			case "erosion": x = erosion; break;
			case "ridges": x = ridges; break;
			case "weirdness": x = weirdness; break;
			case "ridgesBig": x = ridgesBig; break;
	}
	const points = o.points;
	
	//binary search
	let n2 = points.length, n = 0;
	let n3 = n2;
	while (n3 > 0) {
		const n4 = Math.floor(n3 / 2);
		const n5 = n + n4;
		if (x < points[n5].location) {
			n3 = n4;
			continue;
		}
		n = n5 + 1;
		n3 -= n4 + 1;
	}
	
	//end binary search
	let idx = n-1;
		
	if(idx === points.length-1){
			const n = points.length-1;
			return getSplineLayer(points[n].value,continents,erosion,ridges,weirdness,ridgesBig) + points[n].derivative * (x - points[n].location);
	}
	if(idx<0){
			return getSplineLayer(points[0].value,continents,erosion,ridges,weirdness,ridgesBig) + points[0].derivative * (x - points[0].location);
	}
	
	const loc0 = points[idx].location;
	const loc1 = points[idx+1].location;
	const der0 = points[idx].derivative;
	const der1 = points[idx + 1].derivative;
	const f = (x - loc0) / (loc1 - loc0);

	const val0 = getSplineLayer(points[idx].value,continents,erosion,ridges,weirdness,ridgesBig);
	const val1 = getSplineLayer(points[idx+1].value,continents,erosion,ridges,weirdness,ridgesBig);
	const f8 = der0 * (loc1 - loc0) - (val1 - val0);
	const f9 = -der1 * (loc1 - loc0) + (val1 - val0);
	const f10 = lerp(f, val0, val1) + f * (1.0 - f) * lerp(f, f8, f9);
	return f10;
}

const noiseSettings = {
	"erosion": {
		"firstOctave": -9,
		"amplitudes": [
				1.0,
				1.0,
				0.0,
				1.0,
				1.0
		],
		"useOffset":0
	},
	"weirdness": {
		"firstOctave": -7,
		"amplitudes": [
				1.0,
				2.0,
				1.0,
				0.0,
				0.0,
				0.0
		],
		"useOffset":1
	},
	"weirdnessBig": {
		"firstOctave": -7,
		"amplitudes": [
				1,
				2,
				1,
				1,
				1,
				1
		],
		"useOffset":1
	},
	"temperature": {
		"firstOctave": -10,
		"amplitudes": [
				1.5,
				0.0,
				1.0,
				0.0,
				0.0,
				0.0
		],
		"useOffset":2
	},
	"humidity": {
		"firstOctave": -8,
		"amplitudes": [
				1.0,
				1.0,
				0.0,
				0.0,
				0.0,
				0.0
		],
		"useOffset":3
	},
	"continentalness": {
		"firstOctave": -9,
		"amplitudes": [
				1.0,
				1.0,
				2.0,
				2.0,
				2.0,
				1.0,
				1.0,
				1.0,
				1.0
		],
		"useOffset":4
	},
	"surface":{
		"firstOctave":-6,
		"amplitudes":[1,1,1],
		"useOffset":0
	}
}
for(let j in noiseSettings){
	let n = noiseSettings[j]  //;n.firstOctave+=4
	//code in loop from https://github.com/misode/deepslate/blob/main/src/math/noise
	n.startAmplitude = Math.pow(2, (n.amplitudes.length - 1)) / (Math.pow(2, n.amplitudes.length) - 1)
	n.startFrequency = 2**n.firstOctave

	let min = +Infinity
	let max = -Infinity
	for (let i = 0; i < n.amplitudes.length; i += 1) {
		if (n.amplitudes[i] !== 0) {
			min = Math.min(min, i)
			max = Math.max(max, i)
		}
	}
	const expectedDeviation = 0.1 * (1 + 1 / (max - min + 1))
	n.valueFactor = (1/6) / expectedDeviation
}
let badlandInterpolate, badlandInterpolateEroded
const biomeGenerator = {
	middleBiome(temperature,rainfall,weirdness,rainfallFloat,temperatureFloat){
			switch(temperature){
					case 0:
							switch(rainfall){
									case 0:
											return weirdness>0?"iceSpikes":"snowyPlains"
									case 1:
									case 2:
											return"snowyPlains"
									case 3:
											return "snowyTaiga"
									case 4:
											return "taiga"
							}
							break
					case 1:
						switch(rainfall){
							case 0:
								return weirdness>0?"rockyPlains":"plains"
							case 1:
								return weirdness>0?"shrubland":"plains"
							case 2:
								return "taiga"
							case 3:
							case 4:
								return weirdness>0?"oldPineTaiga":"oldSpruceTaiga"
						}
					case 2:
						switch(rainfall){
							case 0:
									return weirdness>0?"flowerForest":"sunflowerPlains"
							case 1:
									return "plains"
							case 2:
									return weirdness>0?"sparseForest":"forest"
							case 3:
									return weirdness>0?"oldBirchForest":"birchForest"
							case 4:
									return "darkForest"
						}
					case 3:
						switch(rainfall){
							case 0:
								return "rockyPlains"
							case 1:
								return weirdness > 0 ? "grassySavanna" : "savanna"
							case 2:
								return "forest"//weirdness>0?"basicForest":"forest"
							case 3:
								return weirdness>0?"jungle":"sparseJungle"
							case 4:
								return weirdness>0?"bambooJungle":"jungle"
						}
					case 4:
						switch(rainfall){
							case 0:
							case 1:
								return "desert"
							case 2:
								return temperatureFloat < 3.55 ? "plains" : "desert"
							case 3:
							case 4:
								return temperatureFloat < 3.55 ? "plains" : "dryShrubland"
						}
			}
	},
	beachBiome(temperature){
			switch(temperature){
					case 0:
							return "snowyBeach"
					case 4:
							return "dryShrubland"
					default:
							return "beach"
			}
	},
	peakBiome(temperature,rainfall,weirdness,ridges,erosion,jaggedness){
			switch(temperature){
					case 0:
					case 1:
					case 2:
							return weirdness < -0.45 && jaggedness > 0.5 ? "jaggedPeaks" : "frozenPeaks"
					case 3:
					case 4:
							return "stonePeaks"
			}
			
	},
	shatterdBiome(temperature,rainfall,weirdness,rainfallFloat,temperatureFloat){
			switch(temperature){
					case 0:
						switch(rainfall){
							case 0:
							case 1:
								return "windsweptGravellyHills"
							case 2:
								return "windsweptHills"
							case 3:
							case 4:
								return "alpineHills"
						}
					case 1:
						switch(rainfall){
							case 0:
							case 1:
								return "windsweptGravellyHills"
							case 2:
								return "windsweptHills"
							case 3:
							case 4:
								return "windsweptForest"
						}
					case 2:
							switch(rainfall){
									case 0:
									case 1:
									case 2:
											return "windsweptHills"
									case 3:
									case 4:
											return "windsweptForest"
							}
					case 3:
					case 4:
							return this.middleBiome(temperature,rainfall,weirdness,rainfallFloat,temperatureFloat)
			}
	},
	plateauBiome(temperature,rainfall,weirdness,rainfallFloat,temperatureFloat){
		switch(temperature){
			case 0:
				return this.middleBiome(temperature,rainfall,weirdness,rainfallFloat,temperatureFloat)
			case 1:
				switch(rainfall){
					case 0:
						return weirdness>0 ? "cherryGrove" : "meadow"
					case 1:
						return "meadow"
					case 2:
						return weirdness>0 ? "meadow" : "alpineHills"
					case 3:
						return weirdness>0 ? "meadow" : this.middleBiome(temperature,rainfall,weirdness,rainfallFloat,temperatureFloat)
					case 4:
						return this.middleBiome(temperature,rainfall,weirdness,rainfallFloat,temperatureFloat)
				}
			case 2:
				switch(rainfall){
					case 0:
					case 1:
							return weirdness>0 ? "cherryGrove" : "meadow"
					case 2:
							return "meadow"
					case 3:
					case 4:
							return weirdness>0 ? "bambooForest" : this.middleBiome(temperature,rainfall,weirdness,rainfallFloat,temperatureFloat)
				}
			case 3:
				switch(rainfall){
					case 0:
					case 1:
							return "savannaPlateau"
					case 2:
					case 3:
					case 4:
							return this.middleBiome(temperature,rainfall,weirdness,rainfallFloat,temperatureFloat)
				}
			case 4:
				return this.badlandsBiome(rainfall,weirdness)
		}
	},
	badlandsBiome(rainfall,weirdness){
		switch(rainfall){
			case 0:
			case 1:
					badlandInterpolateEroded = mapClamped(weirdness,-0.05,0.05)
					return weirdness>0 ? "erodedBadlands" : "badlands"
			case 2:
					return "badlands"
			case 3:
			case 4:
					return "woodedBadlands"
		}
	},
	riverBiome(temperature,rainfall,continentalness,erosion){
		if(temperature===0) return "frozenRiver"
		else if(erosion > 0 && erosion < 0.4 && continentalness > 0.4) return "rockyRiver"
		else if(temperature === 3 && rainfall<2 || temperature === 4) return "dryRiver"
		else return "river"
	},
	oceanBiome(temperature,continentalness){
		switch(temperature){
			case 0:
				return continentalness < -0.45 ? "deepFrozenOcean" : "frozenOcean"
				break
			case 1:
				return continentalness < -0.45 ? "deepColdOcean" : "coldOcean"
				break
			case 2:
				return continentalness < -0.45 ? "deepOcean" : "ocean"
				break
			case 3:
				return continentalness < -0.45 ? "deepLukewarmOcean" : "lukewarmOcean"
				break
			case 4:
				return "warmOcean"
				break
		}
	},
	waterBiome(temperature,rainfall,continentalness,ridges,prevBiome,erosion){
			return ridges<-0.5 && continentalness > 0 ? this.riverBiome(temperature,rainfall,continentalness,erosion) : (continentalness<-0.1 ? this.oceanBiome(temperature,continentalness) : prevBiome)
	},
	get(temperature,rainfall,weirdness,ridges,continentalness,erosion,height,jaggedness,bottom,rainfallFloat,temperatureFloat,jagged,ridgesBig){
		//*rett*/return "swamp"
		badlandInterpolate = badlandInterpolateEroded = 0
		if(continentalness < -1){
			return "mushroomFields"
		}else if(continentalness<-0.2){
			return this.oceanBiome(temperature,continentalness)
		}else if((jaggedness > 0.3 || jagged > 30) && continentalness<-0.4){
			return this.peakBiome(temperature,rainfall,weirdness,ridges,erosion,jaggedness)
		}else if((erosion < -0.6 && temperature<3 || erosion < -0.375 && temperature === 0) && weirdness<0 && ridgesBig>0 && continentalness>-0.12){
			return rainfall > 1 ? (temperature > 2 ? "alpineHills" : "grove") : "snowySlopes"
		}else if(erosion > 0.42 && erosion < 0.56 && ridges > -0.5 && continentalness <= 0.2 && weirdness>0 && temperature >= 2 && rainfall < 4){
			return "windsweptSavanna"
		}else if(ridges < 0.2 && erosion > 0.6 && continentalness > 0.1 && temperature>0){
			return temperature>3 || temperature===3&&weirdness>0 ? "mangroveSwamp" : (temperature < 2 ? "marsh" : "swamp")
		}else if(erosion > 0.42 && erosion < 0.56 && ridges > -0.2 && continentalness > 0.2){
			return this.shatterdBiome(temperature,rainfall,weirdness,rainfallFloat,temperatureFloat)
		}else if(continentalness > 0.03 && erosion < 0 && ridges > -0.2){
			return this.plateauBiome(temperature,rainfall,weirdness,rainfallFloat,temperatureFloat)
		}else if(continentalness > 0.25 && temperature === 4 && ((ridges*0.5+0.5)+0.25)*0.5-(erosion*0.5+0.5)>0){
			badlandInterpolate = mapClamped(((ridges*0.5+0.5)+0.25)*0.5-(erosion*0.5+0.5), 0,0.1)*mapClamped(continentalness,0.25,0.3)
			return this.badlandsBiome(rainfall,weirdness)
		}else if(continentalness<-0.12){
			if(erosion>-0.2 || ridges < 0.3) return this.beachBiome(temperature)
			else return "stonyShore"
		}/*else if(weirdness > 0.25 && weirdness < 0.35 && continentalness > 0 && factor>4 && !jaggedness && height < 100 && temperature > 2){
			return "trashland"
		}*/else return this.middleBiome(temperature,rainfall,weirdness,rainfallFloat,temperatureFloat)
	},
	caveBiome(continentalness,temperature,rainfall){
		if(continentalness > 0.2 && rainfall > 2){
			return temperature > 2 ? "lushCaves" : "dripstoneCaves"
		}
	}
}
function interpolateHash(x,y){
	return lerp(y-Math.floor(y),hash(x,Math.floor(y)),hash(x,Math.floor(y)+1))
}
function badlandsBase(x,y,z){
	const offsets = noiseProfile.offsets[7]
	if(y<64) return blockIds.stone
	else if(y<80) return blockIds.redSandstone
	let shift = Math.round(noiseProfile.generator.noise3d(x*0.00001,y*0.0004,z*0.00001)*40)
	let base = Math.round(interpolateHash(shift,y*0.25)*4+hash(shift,y)) //Math.abs(Math.round(noiseProfile.generator.noise3d(x*0.00001,y*0.1,z*0.00001)*140))%7
	base = base-Math.floor(base/5)*5
	if(y>140 && base>2) base = base%3
	switch(base){
		case 0: return blockIds.terracotta
		case 1: return blockIds.lightGrayTerracotta
		case 2: return blockIds.whiteTerracotta
		case 3: return blockIds.yellowTerracotta
		case 4: return blockIds.orangeTerracotta
	}
}
function stoneLayersBase(x,y,z){
	let shift = Math.round(noiseProfile.generator.noise3d(x*0.00001,y*0.0004,z*0.00001)*40)
	let base = hash(shift,y*0.25)*0.75+hash(shift,y)*0.25
	return base>0.65 ? (base>0.8 ? blockIds.calcite : blockIds.limestone) : blockIds.stone
}
let currentBlocks = [], tops, biomes, maxY, minY, waterTops, caveY, caveBiomes
const minHeight = -64
function setBlock(x,y,z,id){
	let py = y
	y -= minHeight
	if(!currentBlocks[y>>4]){
		while (!currentBlocks[y>>4]){
			currentBlocks.push(new Int32Array(4096))
		}
	}
	currentBlocks[y >> 4][x<<8 | (y & 15)<<4 | z] = id
	maxY = Math.max(maxY,py)
	minY = Math.max(minY,py)
}
function setBlockSolid(x,y,z,id){
	if(id !== undefined) setBlock(x,y,z,id)
}
function fillChunk(y,id){
	let py = y
	y -= minHeight
	if(!currentBlocks[y>>4]){
		while (!currentBlocks[y>>4]){
			currentBlocks.push(new Int32Array(4096))
		}
	}
	currentBlocks[y >> 4].fill(id)
	maxY = Math.max(maxY,((py>>4)<<4)+16)
	minY = Math.max(minY,(py>>4)<<4)
}
function spawnBlock(x,y,z,id){
	if(!getBlock(x,y,z)) setBlock(x,y,z,id)
}
function getBlock(x,y,z){
	y -= minHeight
	if(!currentBlocks[y>>4]) return 0
	return currentBlocks[y >> 4][x<<8 | (y & 15)<<4 | z]
}
const waterHeight = 62
let blockIds,biomeIds,blockStates,biomeNames

let groundType
function getGroundType(x,z,s){
	groundType = mapClamped(
		noise2d(x*s, z*s, 2)
	,0.25,0.5)// Used to generate patches of different ground blocks
}
function getBase(biome){
	if(biome === "erodedBadlands" || biome === "badlands" || biome === "woodedBadlands") return "badlands"
	else if(biome === "snowyBeach" || biome === "beach" || biome === "desert" || biome === "dryShrubland") return "sandstone"
	else if(biome === "stonePeaks" || biome === "stonyShore") return "stoneLayers"
}
function getSurfaceBlocks(biome,x,y,z,surfaceThick){
	let groundBlock = blockIds.grass, underBlock = blockIds.dirt
	//steepness calculated in populate
	if(biome === "snowySlopes" || biome === "grove") getGroundType(x,z,0.01), groundBlock = underBlock = groundType > 0.45 && groundType < 0.5 ? blockIds.powderSnow : blockIds.snowBlock
	else if(biome === "snowyBeach") groundBlock = underBlock = blockIds.sand
	else if(biome === "jaggedPeaks") groundBlock = blockIds.snowBlock, underBlock = blockIds.stone
	else if(biome === "frozenPeaks") getGroundType(x,z,0.01), groundBlock = underBlock = groundType > 0.45 && groundType < 0.5 ? blockIds.packedIce : blockIds.snowBlock
	else if(biome === "iceSpikes") getGroundType(x,z,0.2), groundBlock = groundType > 0.8 ? blockIds.packedIce : blockIds.snowBlock
	else if(biome === "desert" || biome === "beach") groundBlock = underBlock = blockIds.sand
	else if(biome === "stonePeaks") getGroundType(x,z,0.01), groundBlock = underBlock = groundType > 0.45 && groundType < 0.5 ? blockIds.calcite : undefined
	else if(biome === "stonyShore") getGroundType(x,z,0.01), groundBlock = underBlock = groundType > 0.45 && groundType < 0.5 ? blockIds.gravel : undefined
	else if(biome === "windsweptGravellyHills") groundBlock = surfaceThick>5 ? (surfaceThick>5.1 ? blockIds.gravel : blockIds.stone) : (surfaceThick<1 ? blockIds.limestone : blockIds.grass), underBlock = surfaceThick>5 ? (surfaceThick>5.1 ? blockIds.gravel : blockIds.stone) : (surfaceThick<1 ? blockIds.limestone : blockIds.dirt)
	else if(biome === "erodedBadlands" || biome === "badlands") groundBlock = underBlock = y > 80 ? undefined : blockIds.redSand
	else if(biome === "woodedBadlands") groundBlock = y > 97 ? (surfaceThick>3.5 ? blockIds.coarseDirt : blockIds.grass) : undefined, underBlock = undefined
	else if(biome === "bambooJungle") getGroundType(x,z,0.1), groundBlock = groundType>0.5 ? blockIds.podzol : blockIds.grass
	else if(biome === "windsweptHills") groundBlock = surfaceThick>5 ? blockIds.stone : (surfaceThick<1 ? blockIds.limestone : blockIds.grass), underBlock = surfaceThick>5 ? blockIds.stone : (surfaceThick<1 ? blockIds.limestone : blockIds.dirt)
	else if(biome === "oldSpruceTaiga" || biome === "oldPineTaiga") getGroundType(x,z,0.1), groundBlock = groundType > 0.75 ? (surfaceThick>3.5 ? blockIds.grass : blockIds.rootedDirt) : blockIds.podzol
	else if(biome === "mushroomFields") groundBlock = blockIds.mycelium
	else if(biome === "forest" || biome === "birchForest") getGroundType(x,z,0.1), groundBlock = groundType < 0.35 ? blockIds.podzol : (groundType < 0.55 ? blockIds.grass : (groundType < 0.7 ? blockIds.rootedDirt : blockIds.coarseDirt))
	else if(biome === "alpineHills") groundBlock = surfaceThick>4.5 ? blockIds.coarseDirt : blockIds.grass
	else if(biome === "rockyPlains") groundBlock = surfaceThick>5.5 ? blockIds.stone : blockIds.grass, underBlock = surfaceThick>5.5 ? blockIds.stone : blockIds.dirt
	else if(biome === "windsweptSavanna") groundBlock = surfaceThick>4.5 ? (surfaceThick > 6 ? blockIds.stone : blockIds.coarseDirt) : blockIds.grass
	else if(biome === "sparseForest" || biome === "oldBirchForest") getGroundType(x,z,0.1), groundBlock = groundType > 0.25 ? (groundType > 0.5 ? blockIds.coarseDirt : blockIds.rootedDirt) : blockIds.grass
	else if(biome === "dryShrubland") getGroundType(x,z,0.1), groundBlock = underBlock = blockIds.sand
	else if(biome === "bambooForest") getGroundType(x,z,0.1), groundBlock = groundType > 0.5 ? (surfaceThick>3.5 ? blockIds.grass : blockIds.rootedDirt) : blockIds.podzol
	//else if(biome === "taiga") getGroundType(x,z,0.1), groundBlock = groundType < 0.25 ? blockIds.podzol : (groundType < 0.75 ? blockIds.grass : blockIds.rootedDirt)
	else if(biome === "marsh") getGroundType(x,z,0.4), groundBlock = groundType > 0.85 ? blockIds.sand : blockIds.grass
	else if(biome === "shrubland") getGroundType(x,z,0.6), groundBlock = groundType > 0.35 ? blockIds.grass : blockIds.coarseDirt
	return [groundBlock,underBlock]
}
function getBottomHeight(x,z,scale){ //used for river generator
	x /= generateRiverChunk.riverScale, z /= generateRiverChunk.riverScale
	scale /= generateRiverChunk.riverScale
	//let useLowQuality = scale > 0//8//allows more rivers to generate
	const baseWeirdness = complicatedNoise(x*0.25,z*0.25, noiseSettings.weirdness)
	const ridges = (Math.abs(Math.abs(baseWeirdness)-0.666666667)-0.333333333)*-3
	const ridgesBig = (1-Math.abs(complicatedNoise(x*0.25,z*0.25, noiseSettings.weirdnessBig)))*2-1
	const continentalness = complicatedNoise(x*0.25,z*0.25, /*useLowQuality ? noiseSettings.continentalnessLowQuality : */noiseSettings.continentalness)
	const erosion = complicatedNoise(x*0.25,z*0.25, /*useLowQuality ? noiseSettings.erosionLowQuality : */noiseSettings.erosion)
	const offsetValue = getSplineLayer(splineData.offset,continentalness,erosion,ridges,baseWeirdness,ridgesBig)
	const factorValue = getSplineLayer(splineData.factor,continentalness,erosion,ridges,baseWeirdness,ridgesBig)
	const jaggedness = getSplineLayer(splineData.jaggedness,continentalness,erosion,ridges,baseWeirdness,ridgesBig)
	getBottomHeight.topHeight = offsetValue + (1/factorValue)/2.5
	getBottomHeight.cantSpawnRiver = jaggedness > 0.25 || factorValue<2
	return offsetValue// - (1/factorValue)/8
}
let temperatureHere, rainfallHere
function getTemperatureAndRainfall(x,z,noTemp){
	if(!noTemp) temperatureHere = (
		mapClamped(complicatedNoise(x*0.25, z*0.25, noiseSettings.temperature),-1,1)*4
		+map(noise2d(x*0.33, z*0.33, 2),0.25,0.5,-1,1)*0.01
	)//Temperature and Rainfall for biome generation
	rainfallHere = (
		mapClamped(complicatedNoise(z*0.25, x*0.25, noiseSettings.humidity),-1,1)*4
		+map(noise2d(z*0.33, x*0.33, 2),0.25,0.5,-1,1)*0.01
	)
}
function generate(trueX,trueZ,seed,fancyRivers,caves){
	useNoise(seed)
	tops = new Int16Array(256)
	waterTops = new Int16Array(256)//for river
	currentBlocks.length = 0
	biomes = new Uint8Array(256)
	maxY = -Infinity, minY = Infinity
	fillChunk(-64,blockIds.deepslate)
	fillChunk(-48,blockIds.deepslate)
	fillChunk(-32,blockIds.deepslate)
	fillChunk(-16,blockIds.deepslate)
	if(fancyRivers) generateRiverChunk(trueX/16,trueZ/16,seed)
	caveY = new Int16Array(512)
	caveBiomes = new Uint8Array(256)
	for (let i = 0; i < 16; i++) {
		for (let k = 0; k < 16; k++) {
			const erosion = complicatedNoise((trueX + i)*0.25, (trueZ + k)*0.25, noiseSettings.erosion)
			const continentalness = complicatedNoise((trueX+i)*0.25,(trueZ+k)*0.25,noiseSettings.continentalness)
			const baseWeirdness = complicatedNoise((trueX + i)*0.25, (trueZ + k)*0.25, noiseSettings.weirdness)
			const ridges = (Math.abs(Math.abs(baseWeirdness)-0.666666667)-0.333333333)*-3
			const ridgesBig = (1-Math.abs(complicatedNoise((trueX + i)*0.25,(trueZ + k)*0.25, noiseSettings.weirdnessBig)))*2-1
			getTemperatureAndRainfall(trueX + i, trueZ + k)
			const temperatureFloat = temperatureHere, temperature = Math.round(temperatureFloat)//Temperature and Rainfall for biome generation
			const rainfallFloat = rainfallHere, rainfall = Math.round(rainfallFloat)
			let surfaceThick = complicatedNoise(trueX + i, trueZ + k, noiseSettings.surface)*2.75+3+hash(trueX+i,trueZ+k)*0.25
			/*mapClamped(
				noise2d((trueX + i) * 0.1, (trueZ + k) * 0.1, 4, 1)
			,0.25,0.7)*6*/// Determines thickness of surface blocks

			let riverHeight = fancyRivers ? riverHeights[k*16+i] : 0
			const riverLowerHeight = fancyRivers ? riverLoweredHeight[k*16+i] : 0
			//const riverLower = fancyRivers ? riverFinalLowers[k*16+i] : 0
			const riverDist = fancyRivers ? riverFinalDists[k*16+i] : 0, riverNormalDist = fancyRivers ? riverFinalNormalDists[k*16+i] : 0
			//if(riverLowerHeight<0)setBlock(i,80+Math.round(riverLowerHeight*10),k,blockIds.orangeConcrete),setBlock(i,91,k,blockIds.glass)

			const offsetValue = lerp(riverDist,getSplineLayer(splineData.offset,continentalness,erosion,ridges,baseWeirdness,ridgesBig),riverLowerHeight)
			const factorValue = 1/lerp(riverNormalDist,1/getSplineLayer(splineData.factor,continentalness,erosion,ridges,baseWeirdness,ridgesBig),0.015625)
			const jaggedness = getSplineLayer(splineData.jaggedness,continentalness,erosion,ridges,baseWeirdness,ridgesBig)
			const addFactor = (1/factorValue)*64
			const adjOffset = offsetValue*128+64
			let jagged = (jaggedness ? 128*(noise2dDouble((trueX + i) * 0.01, (trueZ + k) * 0.01, 4)*0.5+0.5)*jaggedness : 0)
			let noiseBottom = Math.max(adjOffset - addFactor*0.25/*because of quadruplePositive*/ + jagged,0)
			let noiseTop = Math.max(adjOffset + addFactor + jagged,0)
			let noiseMiddle = Math.max(adjOffset+jagged,0)
			let biome = biomeGenerator.get(temperature,rainfall,baseWeirdness,ridges,continentalness,erosion,noiseTop,jaggedness,noiseBottom,rainfallFloat,temperatureFloat,jagged,ridgesBig)
			const badlandInterpolateCache = badlandInterpolate*badlandInterpolateEroded
			let addErodedBadland = (Math.max(baseSimplexNoise((trueZ + k) * 0.1, 0, (trueX + i) * 0.1),0)*2)**2*badlandInterpolateCache*80
			if(addErodedBadland > 32) addErodedBadland -= 16
			else if(addErodedBadland > 16) addErodedBadland = 16
			if(addErodedBadland > 64) addErodedBadland = 64
			jagged += addErodedBadland
			//const noiseSize = lerp(mapClamped(continentalness,0.65,0.75), mapClamped(factorValue,2.6,6), 1)
			//const hillNoise = noiseSize<1 ? idk4of5(noise2dDouble((trueX + i) * 0.02, (trueZ + k) * 0.02, 2))*(1-noiseSize) : 0
			noiseBottom += Math.floor(addErodedBadland), noiseTop += Math.ceil(addErodedBadland)

			let top = 0
			let solid = true
			let bedrockAdd = Math.round(noise2d((trueX + i) * 0.5, (trueZ + k) * 0.5, 1)*2*6)
			setBlock(i, -64, k, blockIds.bedrock) //There is always at least 1 layer of bedrock
			for(let j=0; j<bedrockAdd; j++){
				setBlock(i, j, k, blockIds.deepslate)
				setBlock(i, j-63, k, blockIds.bedrock)
			}
			const base = getBase(biome)
			const sandstoneDeepness = Math.max(Math.round(adjOffset-30),10)
			/*if(base === "badlands"){
				for(let j=bedrockAdd; j<64; j++){
					setBlock(i, j, k, blockIds.stone)
				}
				for(let j=64; j<Math.floor(noiseBottom); j++){
					setBlock(i, j, k, badlandsBase(i,j,k))
				}
			}else if(base === "sandstone"){
				for(let j=bedrockAdd; j<sandstoneDeepness; j++){
					setBlock(i, j, k, blockIds.stone)
				}
				for(let j=sandstoneDeepness; j<Math.floor(noiseBottom); j++){
					setBlock(i, j, k, blockIds.sandstone)
				}
			}else if(base === "stoneLayers"){
				for(let j=bedrockAdd; j<Math.floor(noiseBottom); j++){
					setBlock(i, j, k, stoneLayersBase(i,j,k))
				}
			}else{
				for(let j=bedrockAdd; j<Math.floor(noiseBottom); j++){//This part is always stone
					setBlock(i, j, k, blockIds.stone)
				}
			}*/
			//if(badlandInterpolate)setBlock(i,100+badlandInterpolate*16,k,blockIds.glass)

			//for caves
			let caveBiome = biomeGenerator.caveBiome(continentalness,temperature,rainfall)
			let grass = noiseBottom - 8
			let caveMax = minHeight, caveMin = minHeight
			const riverClosenessHere = 1-(1-Math.max((riverNormalDist-0.8)*10,0))**2 //1-(1-riverCloseness[k*16+i])**2
			let density, caveDense, wx = trueX+i, wz = trueZ+k
			let prevNoodle = 0, nextNoodle = 0
			let caveDepth, caveWaterSurfaceness
			let cavePrevDense = 1, caveNextDense = 1, caveNextDenseY = minHeight+8

			for (let j = minHeight+bedrockAdd; j < Math.max(noiseTop+1,waterHeight+1); j++) {
				if(j<noiseBottom) density = 1
				else if(j>noiseTop+1) density = 0 //ocean above, not solid
				else{
					density = Math.min( noise3d((trueX + i), j, (trueZ + k), (adjOffset-j + jagged)/64*factorValue), 1)
				}
				caveWaterSurfaceness = Math.max(1-density, Math.min((8-(noiseBottom-j))*0.125,1),0) * Math.min(Math.max((waterHeight+8-j)*0.125,0,riverClosenessHere)*2,1)
				const caveDenseAdd = -((1-density)**2*0.1)*(1-caveWaterSurfaceness) + caveWaterSurfaceness
				if(j<=noiseTop+1 && caves){//for caves
					if(j === caveNextDenseY){
						caveDepth = Math.max(Math.min((noiseMiddle-j)/30,1),0) //- (1-Math.min((j-(minHeight+4))/20,1))
						const noodleness = mapClamped(caveNoise(wx*0.00390625,j*0.00390625,wz*0.00390625, 1, 0),-0.2,0)
						const noodleThick = noodleness && caveNoise(wx*0.00390625,j*0.00390625,wz*0.00390625, 1, 3)
						const noodleA = noodleness && caveNoise(wx*0.03125,j*0.03125,wz*0.03125, 0, 0)
						const noodleB = noodleness && (noodleA+noodleThick*-0.025-0.1)*noodleness<0/*before: if noodleA is too big, it won't generate anyway*/ && caveNoise(wx*0.03125,j*0.03125,wz*0.03125, 0, 3)
						const spaghettiRarity = caveNoise2(wx*0.0009765625,j*0.00048828125,wz*0.0009765625, 1, 6)
						const spaghettiThick = caveNoise2(wx*0.00390625,j*0.00390625,wz*0.00390625, 1, 9)
						const spaghettiA = caveNoiseWeirdScale(spaghettiRarity, wx*0.015625,j*0.015625,wz*0.015625, 0, 6)
						const spaghettiB = caveNoiseWeirdScale(spaghettiRarity, wx*0.015625,j*0.015625,wz*0.015625, 0, 9)
						let spaghetti = (Math.sqrt((Math.abs(spaghettiA)*8)**2+(Math.abs(spaghettiB)*8)**2)-1)*0.125 + spaghettiThick*0.083
						//if(spaghetti>0) spaghetti = (Math.sqrt(spaghetti+1)-1)/8
						const caveLayer = caveNoise(wx*0.004,j*0.008,wz*0.004, 2,0)**2*4
						const cheese = caveNoise(wx*0.005,j*0.003,wz*0.005, 0, 12)*0.5+0.27+caveLayer+(1-caveDepth)*0.5//depth makes them appear less on surface
						cavePrevDense = caveDense = caveNextDense
						caveNextDense = Math.min(spaghetti,cheese) //density + Math.min(spaghetti, cheese) + caveWaterSurfaceness
						if(caveNextDense < 0) caveNextDense += Math.max(caveNoise(wx*0.1,j*0.0015,wz*0.1, 0,15),0)**2*lerp(caveNoise2(wx*0.04,j*0.0015,wz*0.04, 1,15),0.1,0.75)//pillar
						caveNextDenseY += 4
						prevNoodle = nextNoodle
						nextNoodle = (Math.max(Math.abs(noodleA),Math.abs(noodleB)) + noodleThick*-0.025-0.1)*noodleness + (1-caveDepth)*0.02
					}else caveDense = lerp((caveNextDenseY-j)*0.25, caveNextDense, cavePrevDense)
				}
				if (density > 0) {
					if(caves && caveDense+caveDenseAdd < 0){
						if(j < bedrockAdd) setBlock(i,j,k,0)
						if(solid){
							if(j>grass){
								let [groundBlock,underBlock] = getSurfaceBlocks(biome,trueX+i,top,trueZ+k,surfaceThick)
								if(surfaceThick>0 && groundBlock) setBlock(i, top, k, groundBlock)
								if(underBlock){//IF you CHANGE this, change one in normal TERRAIN
									for(let t=1; t<surfaceThick && getBlock(i, top-t, k); t++) setBlock(i, top-t, k, underBlock)
								}
							}else caveMin = j-1
							solid = false
						}
					}else if(caves && lerp((caveNextDenseY-j)*0.25, nextNoodle, prevNoodle) + caveWaterSurfaceness < 0){
						if(j < bedrockAdd) setBlock(i,j,k,0)
						if(solid){
							if(j>grass){
								let [groundBlock,underBlock] = getSurfaceBlocks(biome,trueX+i,top,trueZ+k,surfaceThick)
								if(surfaceThick>0 && groundBlock) setBlock(i, top, k, groundBlock)
								if(underBlock){//IF you CHANGE this, change one in normal TERRAIN
									for(let t=1; t<surfaceThick && getBlock(i, top-t, k); t++) setBlock(i, top-t, k, underBlock)
								}
							}
							solid = false
						}
					}else{
						if(j>=bedrockAdd){
							setBlock(i, j, k, base === "badlands" ? badlandsBase(i,j,k) : (base === "sandstone" && j>=sandstoneDeepness ? blockIds.sandstone : (base === "stoneLayers" ? stoneLayersBase(i,j,k) : blockIds.stone)))
						}
						if(!solid && j<grass) caveMax = j-1
						solid = true
						top = j
					}
				} else {
					if(solid && j>=noiseBottom){
						if (top >= waterHeight && !riverHeight) {
							let [groundBlock,underBlock] = getSurfaceBlocks(biome,trueX+i,top,trueZ+k,surfaceThick)
							if(surfaceThick>0 && groundBlock) setBlock(i, top, k, groundBlock)
							if(underBlock){//IF you CHANGE this, change one in caves
								for(let t=1; t<surfaceThick && getBlock(i, top-t, k); t++) setBlock(i, top-t, k, underBlock)
							}
						}else{
							biome = biomeGenerator.waterBiome(temperature,rainfall,continentalness,ridges,biome,erosion)
							let oceanSurfaceBlock = blockIds.dirt
							if(biome === "warmOcean") oceanSurfaceBlock = blockIds.sand
							else if(biome.endsWith("Ocean") || biome === "ocean") oceanSurfaceBlock = blockIds.gravel
							else if(biome === "marsh") oceanSurfaceBlock = blockIds.mud
							setBlock(i,top,k,oceanSurfaceBlock)
							setBlock(i,top-1,k,oceanSurfaceBlock)
							setBlock(i,top-2,k,oceanSurfaceBlock)
							setBlock(i,top-3,k,oceanSurfaceBlock)
							setBlock(i,top-4,k,oceanSurfaceBlock)
							setBlock(i,top-5,k,oceanSurfaceBlock)
						}
					}
					solid = false
					if(j <= waterHeight){
						setBlock(i, j, k, blockIds.Water)
					}
				}
			}
			if(riverHeight){
				if(top-1 > waterHeight){
					setBlock(i,top,k,0)
					waterTops[k*16+i] = top-1
					let bottom = Math.round(top-1-riverHeight)
					for(let y=top-1; y>=Math.max(bottom,waterHeight); y--){
						setBlock(i,y,k,0)
					}
					//setBlock(i,top+3,k,blockIds.orangeConcrete)
					//top = bottom-1
				}else if(top >= waterHeight){
					setBlock(i,waterHeight+1,k,0)
					setBlock(i,waterHeight,k,0)
					waterTops[k*16+i] = waterHeight
					//top--
				}
			}
			tops[k*16+i] = top
			biomes[k * 16 + i] = biomeIds[biome]
			if(caves && caveBiome && caveMax !== minHeight && caveMin !== minHeight && caveMin < noiseBottom && caveMin < caveMax){
				caveBiomes[k*16+i] = biomeIds[caveBiome]
				caveY[k*16+i] = caveMin
				caveY[k*16+i+256] = caveMax
			}
		}
	}
}
function isLand(x,z){
	const trueX = x*16+8, trueZ = z*16+8
	const baseWeirdness = complicatedNoise(trueX*0.25, trueZ*0.25, noiseSettings.weirdness)
	const ridges = (Math.abs(Math.abs(baseWeirdness)-0.666666667)-0.333333333)*-3
	const ridgesBig = (1-Math.abs(complicatedNoise(x*0.25,z*0.25, noiseSettings.weirdnessBig)))*2-1
	const continentalness = complicatedNoise(trueX*0.25,trueZ*0.25,noiseSettings.continentalness)
	const erosion = complicatedNoise(trueX*0.25, trueZ*0.25, noiseSettings.erosion)
	const offsetValue = getSplineLayer(splineData.offset,continentalness,erosion,ridges,baseWeirdness,ridgesBig)
	const factorValue = getSplineLayer(splineData.factor,continentalness,erosion,ridges,baseWeirdness,ridgesBig)
	const jaggedness = getSplineLayer(splineData.jaggedness,continentalness,erosion,ridges,baseWeirdness,ridgesBig)
	const adjOffset = offsetValue*128+64
	const addFactor = (1/factorValue)*64
	const jagged = jaggedness ? 128*(noise2dDouble(trueX * 0.006, trueZ * 0.006, 4)*0.5+0.5)*jaggedness : 0
	const noiseBottom = Math.max(adjOffset - addFactor*0.25/*because of quadruplePositive*/ + jagged,0)
	const noiseTop = Math.max(adjOffset + addFactor + jagged,0)
	/*getTemperatureAndRainfall(trueX, trueZ)
	const temperatureFloat = temperatureHere, temperature = Math.round(temperatureFloat)//Temperature and Rainfall for biome generation
	const rainfallFloat = rainfallHere, rainfall = Math.round(rainfallFloat)
	let biome = biomeGenerator.get(temperature,rainfall,baseWeirdness,ridges,continentalness,erosion,noiseTop,jaggedness,noiseBottom,rainfallFloat,temperatureFloat)*/
	if(noiseTop<waterHeight) return false
	let solid = false
	for (let j = Math.max(Math.floor(noiseBottom),waterHeight); j < noiseTop; j++) {
		let n = noise3d(trueX, j, trueZ, (adjOffset-j + jagged)/64*factorValue)
		if(n>=0) solid = true
		if(n<0 && solid) return j-1
	}
	return false
}
function findLand(seed){
	useNoise(seed)
	let lastProg = Date.now()
	let i=-1
	while(i<100){
		i++
		for(let x2=0;x2<i*2+1;x2++){
			let x = ((x2%2)?-(x2+1)/2:x2/2)
			let z = i-Math.abs(x)
			let land = isLand(x,z)
			if(land !== false) return {x:x*16+8,z:z*16+8,y:land}
			land = isLand(x,-z)
			if(land !== false) return {x:x*16+8,z:-z*16+8,y:land}
		}
		let now = Date.now()
		if(now - lastProg > 1000){
			lastProg = now
			parentAndStuff.postMessage({progress: i/50})
		}
	}
	return {x:8,z:8,y:128,fail:true}
}
parentAndStuff.onmessage = function(e) {
	let msg = e.data
	if(msg.generate){
		if(!noises[msg.seed]) {
			parentAndStuff.postMessage("")
			return
		}
		generate(msg.trueX,msg.trueZ,msg.seed,msg.fancyRivers,msg.caves)
		parentAndStuff.postMessage({
			blocks:currentBlocks,
			tops,biomes,minY,maxY,
			waterTops,
			caveBiomes, caveY
		}, [
			...currentBlocks.map(r=>r.buffer),
			tops.buffer,biomes.buffer,
			waterTops.buffer,
			caveBiomes.buffer, caveY.buffer
		])
	}else if(msg.findLand){
		parentAndStuff.postMessage(findLand(msg.seed))
	}else if ("newSeed" in msg) {
		newNoise(msg.newSeed)
		parentAndStuff.postMessage("")
	}else if ("deleteSeed" in msg) {
		deleteNoise(msg.deleteSeed)
		parentAndStuff.postMessage("")
	}else if(msg.blockIds){
		({blockIds,biomeIds,blockStates} = msg)
		biomeNames = Object.keys(biomeIds).reduce((ret, key) => {
			ret[biomeIds[key]] = key;
			return ret;
		}, {});
		parentAndStuff.postMessage("")
	}
}
parentAndStuff.postMessage("started")
}