<!DOCTYPE html>
<style>
	#res > div{
		border:1px solid black;
		padding: 16px;
		margin:16px;
	}
</style>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
This tool may not get all worlds but it should get most of them<br>
<br>
Open zip with indexed db: <input type="file" onchange="doit(this)"><br>
Big endian: <input type="checkbox" id="bigEndian" checked> Change if time or something looks wrong<br>
<br>
<div id="status"></div>
<!--You can see the server side code used <a href="open-indexed-db.js">here</a><br>-->
<div id="res"></div>
<script>
let allData
async function doit(input){
	res.innerHTML = "<button onclick='saveit()'>Save to minekhan on this website</button>"
	bigEndian = document.querySelector("#bigEndian").checked
	allData = []
	let zipData = await input.files[0].arrayBuffer()
	let zip = await JSZip.loadAsync(zipData)
	zip.forEach((path, file) => {
		console.log(path,file)
		if(path.includes(".blob/") && !path.endsWith("/")){
			file.async("arraybuffer").then(r => {
				try{
					addRes(new reader(r).result, "from .blob")
				}catch(e){
					res.insertAdjacentHTML("beforeend", "<div>unable to read: "+sanitize(e)+"</div>")
					reportError(e)
				}
			})
		}else if(path.includes(".leveldb/") && !path.endsWith("/")){
			/*let ws = new WebSocket(location.origin+"/open-indexed-db")
			ws.onopen = function(){
				ws.send(path)
				ws.send(zipData)
			}
			let lastKey
			ws.onmessage = function(e){
				if(typeof e.data === "string") lastKey = e.data
				else{
					console.log(lastKey,e.data)
				}
			}*/
			file.async("arraybuffer").then(r => {
				let arr = new Uint8Array(r)
				let i = 0
				while((i = arr.indexOf(255,i)) !== -1){ //find pattern
					let oi = i
					while(arr[i]&0b10000000) i++
					i++
					if(arr[i++] !== 255) continue
					try{
						addRes(new reader(arr.subarray(oi)).result, "from .leveldb")
					}catch(e){
						res.insertAdjacentHTML("beforeend", "<div>unable to read: "+sanitize(e.message)+" <br> found at "+i+"</div>")
						reportError(e)
					}
				}
			})
		}
	})
}
const sanitizer = document.createElement('div')
function sanitize(text) {
  sanitizer.textContent = text
  return sanitizer.innerHTML
}
let res = document.querySelector("#res")
function addRes(r, info){
	r = r.data
	res.insertAdjacentHTML("beforeend", `
		<div>
			<img src="${r.thumbnail}"><br>
			${r.name}<br>
			${(new Date(r.edited)).toLocaleString()}<br>
			${r.code.length||r.code.byteLength} bytes<br>
			${info}
		</div>
	`)
	allData.push(r)
}
const status=document.querySelector("#status")
async function saveit(){
	async function createDatabase() {
		return await new Promise(async (resolve, reject) => {
			let request = window.indexedDB.open("MineKhan")

			request.onsuccess = function(e) {
				resolve(request.result)
			}

			request.onerror = function(e) {
				reject(request.error || new Error("indexed db open error"))
			}
		})
	}
	async function loadFromDB(id, storeName = "worlds") {
		return await new Promise(async (resolve, reject) => {
			let db = await createDatabase()
			let trans = db.transaction(storeName, "readwrite")
			let store = trans.objectStore(storeName)
			let req = id ? store.get(id) : store.getAll()
			req.onsuccess = function(e) {
				resolve(req.result)
				db.close()
			}
			req.onerror = function(e) { 
				resolve(null)
				db.close()
			}
		})
	}
	async function saveToDB(id, data, storeName = "worlds") {
		return new Promise(async (resolve, reject) => {
			let db = await createDatabase()
			let trans = db.transaction(storeName, "readwrite")
			let store = trans.objectStore(storeName)
			let req = store.put({ id: id, data: data })
			req.onsuccess = function() {
				resolve(req.result)
			}
			req.onerror = function(e) {
				reject(req.error)
			}
		})
	}

	status.textContent = "saving..."
	let a=0, i=0
	for(let r of allData){
		try{
			if(!await loadFromDB(r.id)) {
				await saveToDB(r.id, r)
				a++
			}
		}catch(e){alert(e)}
		status.textContent = i+" / "+allData.length
		i++
	}
	status.innerHTML = "saved "+a+" out of "+allData.length+" worlds. they should show up in <a href='/minekhan/'>minekhan</a>"
}



let bigEndian = false
const utf8 = new TextDecoder(), ascii = new TextDecoder("ascii"), utf16 = new TextDecoder(bigEndian?"utf-16be":"utf-16")
class reader{
	constructor(data){
		this.data = new DataView(data.buffer||data, data.byteOffset,data.byteLength)
		this.dataU8 = new Uint8Array(data.buffer||data, data.byteOffset,data.byteLength)
		this.idx = 0

		while(this.peek === 0xff) this.varint()
		this.result = this.read()
		console.log(this.result)
	}
	get peek(){return this.data.getUint8(this.idx)}
	next(){return this.data.getUint8(this.idx++)}
	get peekU32(){return this.data.getUint32(this.idx)}
	nextU32(){return this.data.getUint32(this.idx++)}
	read(){
		while(this.peek === 0) this.next()
		let tag = this.next()
		switch(tag){
			case "o".charCodeAt(0):
				let o = {}
				let k = 0n
				while(this.peek !== 0x7b){
					o[this.read()] = this.read()
					k++
				}
				this.next() //end tag
				if(this.varint() !== k) throw new Error("incorrect number of keys")
				return o
			case '"'.charCodeAt(0):{
				let len = Number(this.varint())
				return ascii.decode(this.dataU8.slice(this.idx,this.idx+=len))
			}
			case 'c'.charCodeAt(0):{
				let len = Number(this.varint())
				return utf16.decode(this.dataU8.slice(this.idx,this.idx+=len))
			}
			case 'S'.charCodeAt(0):{
				let len = Number(this.varint())
				return utf8.decode(this.dataU8.slice(this.idx,this.idx+=len))
			}
			case '_'.charCodeAt(0): return undefined
			case '0'.charCodeAt(0): return null
			case 'T'.charCodeAt(0): return true
			case 'F'.charCodeAt(0): return false
			case 'U'.charCodeAt(0): return Number(this.varint())
			case 'I'.charCodeAt(0):{
				let n = this.varint()
				return Number(((n+1n)>>1n) * ((n&1n) ? -1n : 1n))
			}
			case 'N'.charCodeAt(0): return this.data.getFloat64((this.idx+=8)-8, !bigEndian)
			case 'B'.charCodeAt(0):{ //array buffer view
				let type = this.varint(), offset = this.varint(), len = this.varint()
				let buffer = this.read() // should be "V"
				switch(type){
					case "B".charCodeAt(0): return new Uint8Array(buffer,offset,len)
				}
			}
			case 'V'.charCodeAt(0):{ //array buffer
				let len = this.varint()
				return this.data.buffer.slice(this.idx,this.idx+=len)
			}
			case 'a'.charCodeAt(0):{
				let len = this.varint()
				let arr = []
				let k = 0n
				while(this.peek !== 0x40){
					arr[this.read()] = this.read()
					k++
				}
				this.next() //end tag
				if(this.varint() !== k) throw new Error("incorrect number of keys")
				if(this.varint() !== len) throw new Error("incorrect length")
				return arr
			}
			case 'A'.charCodeAt(0):{
				let len = this.varint()
				let arr = []
				for(let i=0; i<len; i++){
					arr.push(this.read())
				}
				let k = 0n
				while(this.peek !== 0x24){
					arr[this.read()] = this.read()
					k++
				}
				this.next() //end tag
				if(this.varint() !== k) throw new Error("incorrect number of keys")
				if(this.varint() !== len) throw new Error("incorrect length")
				return arr
			}
			default:
				throw new Error("unknown tag "+tag)
		}
	}
	varint(){
		let r = 0n, sh = 0n
		while(this.peek&0b10000000){
			r = r | BigInt(this.next()&0b01111111)<<sh
			sh += 7n
		}
		return r | BigInt(this.next()&0b01111111)<<sh
	}
}
</script>